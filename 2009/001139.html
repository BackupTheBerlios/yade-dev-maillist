<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [deprecated list] [Yade-dev] [svn] r1841 - in trunk: . gui gui/py	lib lib/py	pkg/common pkg/common/Engine/StandAloneEngine	pkg/dem	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor py	py/miniWm3Wrap py/yadeWrapper scripts/test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-dev/2009/index.html" >
   <LINK REL="made" HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1841%20-%20in%20trunk%3A%20.%20gui%20gui/py%0A%09lib%20lib/py%09pkg/common%20pkg/common/Engine/StandAloneEngine%0A%09pkg/dem%09pkg/dem/DataClass/InteractionGeometry%09pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%09pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%20py%09py/miniWm3Wrap%20py/yadeWrapper%20scripts/test&In-Reply-To=%3C200907071154.n67BsHaH009939%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001138.html">
   <LINK REL="Next"  HREF="001140.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[deprecated list] [Yade-dev] [svn] r1841 - in trunk: . gui gui/py	lib lib/py	pkg/common pkg/common/Engine/StandAloneEngine	pkg/dem	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor py	py/miniWm3Wrap py/yadeWrapper scripts/test</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1841%20-%20in%20trunk%3A%20.%20gui%20gui/py%0A%09lib%20lib/py%09pkg/common%20pkg/common/Engine/StandAloneEngine%0A%09pkg/dem%09pkg/dem/DataClass/InteractionGeometry%09pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%09pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%20py%09py/miniWm3Wrap%20py/yadeWrapper%20scripts/test&In-Reply-To=%3C200907071154.n67BsHaH009939%40sheep.berlios.de%3E"
       TITLE="[deprecated list] [Yade-dev] [svn] r1841 - in trunk: . gui gui/py	lib lib/py	pkg/common pkg/common/Engine/StandAloneEngine	pkg/dem	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor py	py/miniWm3Wrap py/yadeWrapper scripts/test">eudoxos at mail.berlios.de
       </A><BR>
    <I>Tue Jul  7 13:54:17 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001138.html">[deprecated list] [Yade-dev] WARNING: file %s skipped while	scanning for headers (no	module)
</A></li>
        <LI>Next message: <A HREF="001140.html">[deprecated list] [Yade-dev] [svn] r1843 - trunk/core
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1139">[ date ]</a>
              <a href="thread.html#1139">[ thread ]</a>
              <a href="subject.html#1139">[ subject ]</a>
              <a href="author.html#1139">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2009-07-07 13:54:14 +0200 (Tue, 07 Jul 2009)
New Revision: 1841

Added:
   trunk/gui/py/pyAttrUtils.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.cpp
   trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.hpp
   trunk/py/
   trunk/py/_eudoxos.cpp
   trunk/py/_packPredicates.cpp
   trunk/py/_packSpheres.cpp
   trunk/py/_utils.cpp
   trunk/py/euclid.py
   trunk/py/eudoxos.py
   trunk/py/linterpolation.py
   trunk/py/log.cpp
   trunk/py/miniWm3Wrap/
   trunk/py/miniWm3Wrap/README
   trunk/py/miniWm3Wrap/__call_policies.pypp.hpp
   trunk/py/miniWm3Wrap/__convenience.pypp.hpp
   trunk/py/miniWm3Wrap/miniWm3Wrap-funcs.ipp
   trunk/py/miniWm3Wrap/miniWm3Wrap-generate.py
   trunk/py/miniWm3Wrap/miniWm3Wrap-toExpose.hpp
   trunk/py/miniWm3Wrap/miniWm3Wrap.cpp
   trunk/py/pack.py
   trunk/py/plot.py
   trunk/py/timing.py
   trunk/py/utils.py
   trunk/py/yadeWrapper/
   trunk/py/yadeWrapper/yadeWrapper.cpp
   trunk/scripts/test/wm3-wrap.py
Removed:
   trunk/gui/py/PeriodicPythonRunner.cpp
   trunk/gui/py/PeriodicPythonRunner.hpp
   trunk/gui/py/pyAttrUtils.hpp
   trunk/gui/py/yadeControl.cpp
   trunk/lib/miniWm3Wrap-generate.py
   trunk/lib/miniWm3Wrap-toExpose.hpp
   trunk/lib/py/_eudoxos.cpp
   trunk/lib/py/_packPredicates.cpp
   trunk/lib/py/_packSpheres.cpp
   trunk/lib/py/_utils.cpp
   trunk/lib/py/euclid.py
   trunk/lib/py/eudoxos.py
   trunk/lib/py/linterpolation.py
   trunk/lib/py/log.cpp
   trunk/lib/py/pack.py
   trunk/lib/py/plot.py
   trunk/lib/py/timing.py
   trunk/lib/py/utils.py
Modified:
   trunk/SConstruct
   trunk/gui/SConscript
   trunk/gui/py/PythonUI_rc.py
   trunk/lib/SConscript
   trunk/pkg/common/SConscript
   trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.hpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.hpp
   trunk/pkg/dem/SConscript
   trunk/scripts/test/gts-triax-pack.py
   trunk/scripts/test/shear.py
   trunk/scripts/test/triax-identical-results.py
Log:
1. Shuffling stuff around, moving most python things to py/
2. Wrapping Vector3r, Quaternionr and Vector2r in python directly, see scripts/wm3-wrap.py
3. Change the way utils.box, utils.sphere and utils.facet works: arguments to physical parameters are passed as keywords, not as dictionary now (update your old code by passing **dict instead of dict as the last argument)
4. Fix a bug with useShear, now getting almost identical results for triaxial again.
5. Preliminary Triaxial::facetWalls, to be able to used Dem3DofGeom with Triaxial. (not fully functional yet)
6. TriaxialStressController::thickness is -1 by default now (get thickness from box width), as 0 is real value for Facets. Doesn't change beahvior in any way.

Please report any regressions, I tried to make sure there are none.



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/SConstruct	2009-07-07 11:54:14 UTC (rev 1841)
@@ -383,7 +383,7 @@
 env['PREFIX']=os.path.abspath(env['PREFIX'])
 
 # paths to in-tree SConscript files
-libDirs=['lib','pkg/common','pkg/dem','pkg/fem','pkg/lattice','pkg/mass-spring','pkg/realtime-rigidbody','pkg/snow','extra','gui']
+libDirs=['lib','pkg/common','pkg/dem','pkg/fem','pkg/lattice','pkg/mass-spring','pkg/realtime-rigidbody','pkg/snow','extra','gui','py']
 #libDirs = libDirs + ['pkg/gram'] 
 # BUT: exclude stuff that should be excluded
 libDirs=[x for x in libDirs if not re.match('^.*/('+'|'.join(env['exclude'])+')$',x)]

Modified: trunk/gui/SConscript
===================================================================
--- trunk/gui/SConscript	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/gui/SConscript	2009-07-07 11:54:14 UTC (rev 1841)
@@ -45,7 +45,6 @@
 if 'EMBED_PYTHON' in env['CPPDEFINES']:
 	env.Install('$PREFIX/lib/yade$SUFFIX/gui',[
 		env.SharedLibrary('PythonUI',['py/PythonUI.cpp']),
-		env.SharedLibrary('PeriodicPythonRunner',['py/PeriodicPythonRunner.cpp']),
 		env.File('PythonUI_rc.py','py'),
 	])
 	if 'qt3' not in env['exclude']:
@@ -53,41 +52,15 @@
 			env.SharedLibrary('_qt',['qt3/QtGUI-python.cpp'],SHLIBPREFIX='',LIBS=env['LIBS']+['QtGUI'],CPPPATH=env['CPPPATH']+[env['buildDir']+'/gui/qt3']), # CPPPATH is for files generated by moc which are indirectly included
 			env.File('qt.py','qt3'),
 		])
-
 	env.InstallAs('$PREFIX/bin/yade$SUFFIX-multi',env.File('yade-multi','py'))
 
-	# python modules are one level deeper so that you can say: from yade.wrapper import *
+	# these modules will not be imported directly (probably)
+	# the rest was moved to py/ directory
 	env.Install('$PREFIX/lib/yade$SUFFIX/py/yade',[
-		env.SharedLibrary('wrapper',['py/yadeControl.cpp'],SHLIBPREFIX='',
-			LIBS=env['LIBS']+['XMLFormatManager','yade-factory','yade-serialization','Shop',
-				'BoundingVolumeMetaEngine',
-				'GeometricalModelMetaEngine',
-				'InteractingGeometryMetaEngine',
-				'InteractionGeometryMetaEngine',
-				'InteractionPhysicsMetaEngine',
-				'PhysicalParametersMetaEngine',
-				'ConstitutiveLawDispatcher',
-				'InteractionDispatchers',
-				'STLImporter',
-				'ParallelEngine',
-				'Clump'
-			],
-			),
-		#env.SharedLibrary('_utils',['py/_utils.cpp'],SHLIBPREFIX='',LIBS=env['LIBS']+['Shop','ConcretePM']),
-		#env.SharedLibrary('_packPredicates',['py/_packPredicates.cpp'],SHLIBPREFIX='',
-		#	# if we compile with GTS, link to the python module, as inGtsSurface uses some of its symbols.
-		#	# because the module doesn't have the lib- suffix, we put it directly to SHLINKFLAGS
-		#	# using the -l: syntax (see man ld) and declare the dependency below
-		#	SHLINKFLAGS=env['SHLINKFLAGS']+(['-l:$PREFIX/lib/yade$SUFFIX/py/gts/_gts.so'] if 'GTS' in env['features'] else [])),
-		#env.SharedLibrary('_eudoxos',['py/_eudoxos.cpp'],SHLIBPREFIX='',CXXFLAGS=env['CXXFLAGS']+([] if not os.path.exists('../../brefcom-mm.hh') else ['-include','../brefcom-mm.hh']),LIBS=env['LIBS']+['Shop','ConcretePM']),
-		#env.SharedLibrary('log',['py/log.cpp'],SHLIBPREFIX=''),
 		env.File('__init__.py','py'),
 		env.File('runtime.py','py'),
 		env.File('ipython.py','py'),
 		env.File('PythonTCPServer.py','py'),
 	])
-	#if os.path.exists('../../brefcom-mm.hh'): Depends('py/_eudoxos.cpp','../../brefcom-mm.hh')
-	# see comments for _packPredicates above
-	#if 'GTS' in env['features']: env.Depends('_packPredicates.so','$PREFIX/lib/yade$SUFFIX/py/gts/_gts.so')
 
 

Deleted: trunk/gui/py/PeriodicPythonRunner.cpp
===================================================================
--- trunk/gui/py/PeriodicPythonRunner.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/gui/py/PeriodicPythonRunner.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,2 +0,0 @@
-#include&lt;yade/gui-py/PeriodicPythonRunner.hpp&gt;
-YADE_PLUGIN();

Deleted: trunk/gui/py/PeriodicPythonRunner.hpp
===================================================================
--- trunk/gui/py/PeriodicPythonRunner.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/gui/py/PeriodicPythonRunner.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,32 +0,0 @@
-// 2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
-#pragma once
-#include&lt;yade/core/StandAloneEngine.hpp&gt;
-#include&lt;yade/core/MetaBody.hpp&gt;
-#include&lt;yade/pkg-common/PeriodicEngines.hpp&gt;
-/* Execute a python command (in addPlotDataCall) periodically, with defined (and adjustable) periodicity.
- *
- * Period constraints are iterInterval and timeInterval. When either of them is exceeded, the addPlotDataCall is run.
- *
- * Thie engine is primarily conceived for collecting data for yade.plot plots during simulations, hence the name.
- */
-class PeriodicPythonRunner: public StretchPeriodicEngine {
-	private:
-		string command;
-	public :
-		PeriodicPythonRunner(): command(&quot;pass&quot;){};
-		/* virtual bool isActivated: not overridden, StretchPeriodicEngine handles that */
-		virtual void action(MetaBody* b){
-			PyGILState_STATE gstate;
-				gstate = PyGILState_Ensure();
-				PyRun_SimpleString(command.c_str()); // this is suboptimal, since it has to be parsed at every execution; critical?
-			PyGILState_Release(gstate);
-		}
-		virtual void registerAttributes(){ StretchPeriodicEngine::registerAttributes(); REGISTER_ATTRIBUTE(command); }
-	protected :
-		virtual void postProcessAttributes(bool deserializing){}
-	REGISTER_CLASS_NAME(PeriodicPythonRunner);
-	REGISTER_BASE_CLASS_NAME(StretchPeriodicEngine);
-};
-
-REGISTER_SERIALIZABLE(PeriodicPythonRunner);
-

Modified: trunk/gui/py/PythonUI_rc.py
===================================================================
--- trunk/gui/py/PythonUI_rc.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/gui/py/PythonUI_rc.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -8,6 +8,7 @@
 # sys.path.insert(0,runtime.prefix+'/lib/yade'+runtime.suffix+'/extra')
 
 from math import *
+from miniWm3Wrap import *
 from yade.wrapper import *
 from yade import runtime
 from yade import utils

Deleted: trunk/gui/py/pyAttrUtils.hpp
===================================================================
--- trunk/gui/py/pyAttrUtils.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/gui/py/pyAttrUtils.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,223 +0,0 @@
-// 2007,2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
-#include&lt;sstream&gt;
-#include&lt;boost/any.hpp&gt;
-#include&lt;map&gt;
-#include&lt;vector&gt;
-#include&lt;yade/lib-serialization/Archive.hpp&gt;
-#include&lt;yade/lib-serialization-xml/XMLFormatManager.hpp&gt;
-#include&lt;boost/python.hpp&gt;
-#include&lt;yade/extra/boost_python_len.hpp&gt;
-
-#include&lt;boost/foreach.hpp&gt;
-#ifndef FOREACH
-	#define FOREACH BOOST_FOREACH
-#endif
-
-using namespace std;
-using namespace boost;
-
-/*! Define inline proxy functions that access attributes of some object associated with this class.
- * \param accessor is an shared_ptr&lt;AttrAccess&gt; (or AttrAccess*), properly initialized and associated with the object of your choice
- * \param ensureFunc is member function called before every attribute access. It typically would check whether acessor is not NULL, otherwise instantiate it.
- */
-#define ATTR_ACCESS_CXX(accessor,ensureFunc) \
-	boost::python::object wrappedPyGet(std::string key){ensureFunc();return accessor-&gt;pyGet(key);} \
-	void wrappedPySet(std::string key,python::object val){ensureFunc(); accessor-&gt;pySet(key,val);} \
-	string wrappedGetAttrStr(std::string key){ensureFunc();vector&lt;string&gt; a=accessor-&gt;getAttrStr(key); string ret(&quot;[&quot;); FOREACH(string s, a) ret+=s+&quot; &quot;; return ret+&quot;]&quot;;} \
-	void wrappedSetAttrStr(std::string key, std::string val){ensureFunc();return accessor-&gt;setAttrStr(key,val);} \
-	boost::python::list wrappedPyKeys(){ensureFunc(); return accessor-&gt;pyKeys();} \
-	boost::python::dict wrappedPyDict(){ensureFunc(); return accessor-&gt;pyDict();} \
-	bool wrappedPyHasKey(std::string key){ensureFunc(); return accessor-&gt;descriptors.find(key)!=accessor-&gt;descriptors.end();} \
-	
-	
-	//boost::python::object wrappedPyGet_throw(std::string key){ensureFunc(); if(wrappedPyHasKey(key)) return accessor-&gt;pyGet(key); PyErr_SetString(PyExc_AttributeError, &quot;No such attribute.&quot;); boost::python::throw_error_already_set(); /* make compiler happy*/ return boost::python::object(); }
-
-
-/*! Python special functions complementing proxies defined by ATTR_ACCESS_CXX, to be used with boost::python::class_&lt;&gt;.
- *
- * They define python special functions that support dictionary operations on this object and calls proxies for them. */
-#define ATTR_ACCESS_PY(cxxClass) \
-	def(&quot;__getitem__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setitem__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;keys&quot;,&amp;cxxClass::wrappedPyKeys).def(&quot;has_key&quot;,&amp;cxxClass::wrappedPyHasKey).def(&quot;dict&quot;,&amp;cxxClass::wrappedPyDict) \
-	.def(&quot;getRaw&quot;,&amp;cxxClass::wrappedGetAttrStr).def(&quot;setRaw&quot;,&amp;cxxClass::wrappedSetAttrStr)
-	//def(&quot;__getattr__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setattr__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;attrs&quot;,&amp;cxxClass::wrappedPyKeys)
-
-	//.def(&quot;__getattribute__&quot;,&amp;cxxClass::wrappedPyGet_throw)
-
-#define BASIC_PY_PROXY_HEAD(pyClass,yadeClass) \
-class pyClass{shared_ptr&lt;AttrAccess&gt; accessor; \
-	private: void init(string clss){ proxee=dynamic_pointer_cast&lt;yadeClass&gt;(ClassFactory::instance().createShared(clss.empty()? #yadeClass : clss)); if(!proxee) throw runtime_error(&quot;Invalid class `&quot;+clss+&quot;': either nonexistent, or unable to cast to `&quot;+#yadeClass+&quot;'&quot;); } \
-	public: shared_ptr&lt;yadeClass&gt; proxee; \
-		void ensureAcc(void){ if(!proxee) throw runtime_error(string(&quot;No proxied `&quot;)+#yadeClass+&quot;'.&quot;); if(!accessor) accessor=shared_ptr&lt;AttrAccess&gt;(new AttrAccess(proxee));} \
-		pyClass(string clss=&quot;&quot;, python::dict attrs=python::dict()){ init(clss); python::list l=attrs.items(); int len=PySequence_Size(l.ptr()); for(int i=0; i&lt;len; i++){ python::extract&lt;python::tuple&gt; t(l[i]); python::extract&lt;string&gt; keyEx(t()[0]); if(!keyEx.check()) throw invalid_argument(&quot;Attribute keys must be strings.&quot;); wrappedPySet(keyEx(),t()[1]); } } \
-		pyClass(const shared_ptr&lt;yadeClass&gt;&amp; _proxee): proxee(_proxee) {} \
-		std::string pyStr(void){ ensureAcc(); return string(proxee-&gt;getClassName()==#yadeClass ? &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot;&gt;&quot; : &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot; &quot;+ #yadeClass +&quot;&gt;&quot;); } \
-		string className(void){ ensureAcc(); return proxee-&gt;getClassName(); } \
-		void postProcessAttributes(void){ensureAcc(); static_pointer_cast&lt;Serializable&gt;(proxee)-&gt;/*<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">__HACK__D at _N</A>@T_ABUSE_*/postProcessAttributes(/*deserializing*/ true); } \
-		ATTR_ACCESS_CXX(accessor,ensureAcc);
-
-#define BASIC_PY_PROXY_TAIL };
-/*! Basic implementation of python proxy class that provides:
- * 1. constructor with (optional) class name and (optional) dictionary of attributes
- * 2. copy constructor from another proxy class
- * 3. className() returning proxy class name as string 
- * 4. ensureAcc() that makes sure we have proxy _and_ attribute access things ready
- */
-#define BASIC_PY_PROXY(pyClass,yadeClass) BASIC_PY_PROXY_HEAD(pyClass,yadeClass) BASIC_PY_PROXY_TAIL
-
-/* Read-write access to some attribute that is not basic-serializable, i.e. must be exported as instance.attribute (not instance['attribute']. That attribute is wrapped in given python class before it is returned. */
-#define NONPOD_ATTRIBUTE_ACCESS(pyName,pyClass,yadeName) \
-	python::object pyName##_get(void){ensureAcc(); return proxee-&gt;yadeName ? python::object(pyClass(proxee-&gt;yadeName)) : python::object(); } \
-	void pyName##_set(pyClass proxy){ensureAcc(); proxee-&gt;yadeName=proxy.proxee; }
-/*! Boost.python's definition of python object corresponding to BASIC_PY_PROXY */
-#define BASIC_PY_PROXY_WRAPPER(pyClass,pyName)  \
-	boost::python::class_&lt;pyClass&gt;(pyName,python::init&lt;python::optional&lt;string,python::dict&gt; &gt;()) \
-	.ATTR_ACCESS_PY(pyClass) \
-	.def(&quot;__str__&quot;,&amp;pyClass::pyStr).def(&quot;__repr__&quot;,&amp;pyClass::pyStr) \
-	.add_property(&quot;name&quot;,&amp;pyClass::className) \
-	.def(&quot;postProcessAttributes&quot;,&amp;pyClass::postProcessAttributes)
-
-
-
-/*! Helper class for accessing registered attributes through the serialization interface.
- *
- * 4 possible types of attributes are supported: bool, string, number and arrays (homogeneous) of any of them.
- * This class exposes pySet, pyGet and pyKeys methods to python so that associated object supports python syntax for dictionary member access.
- */
-class AttrAccess{
-	struct AttrDesc{int type; shared_ptr&lt;Archive&gt; archive;};
-	private:
-		const shared_ptr&lt;Serializable&gt; ser;
-		Serializable::Archives archives;
-	public:
-		DECLARE_LOGGER;
-		typedef map&lt;string,AttrDesc&gt; DescriptorMap;
-		//! maps attribute name to its archive and vector of its types (given as ints, from the following enum)
-		DescriptorMap descriptors;
-		//! allowed types
-		enum {BOOL,STRING,FLOAT,INTEGER,SEQ_FLOAT, SEQ_STRING, VEC_VEC }; // allowed types
-		
-		AttrAccess(Serializable* _ser): ser(shared_ptr&lt;Serializable&gt;(_ser)){init();}
-		AttrAccess(shared_ptr&lt;Serializable&gt; _ser):ser(_ser){init();}
-
-		//! create archives and descriptors, always called from the constructor
-		void init(){
-			//cerr&lt;&lt;typeid(std::vector&lt;Wm3::Vector3&lt;double&gt; &gt;*).name()&lt;&lt;endl;
-			if(ser-&gt;getArchives().empty()) ser-&gt;registerSerializableAttributes(false);
-			archives=ser-&gt;getArchives();
-			for(Serializable::Archives::iterator ai=archives.begin();ai!=archives.end();++ai){
-				if((*ai)-&gt;isFundamental() &amp;&amp; (*ai)-&gt;getName()!=&quot;serializationDynlib&quot;){
-					AttrDesc desc; 
-					desc.archive=*ai;
-					any instance=(*ai)-&gt;getAddress(); // gets pointer to the stored value
-					//cerr&lt;&lt;&quot;[&quot;&lt;&lt;(*ai)-&gt;getName()&lt;&lt;&quot;,&quot;&lt;&lt;instance.type().name()&lt;&lt;&quot;]&quot;;
-					// 3 possibilities: one BOOL, one or more STRINGS, one or more FLOATs (fallback if none matches)
-					if      (any_cast&lt;string*&gt;(&amp;instance)) { desc.type=AttrAccess::STRING; goto found; }
-					else if (any_cast&lt;bool*&gt;(&amp;instance)) { desc.type=AttrAccess::BOOL; goto found; }
-					else if (any_cast&lt;Real*&gt;(&amp;instance) || any_cast&lt;long double*&gt;(&amp;instance) || any_cast&lt;double*&gt;(&amp;instance) || any_cast&lt;float*&gt;(&amp;instance)) { desc.type=AttrAccess::FLOAT; goto found;}
-					else if (any_cast&lt;int*&gt;(&amp;instance) || any_cast&lt;unsigned int*&gt;(&amp;instance) || any_cast&lt;long*&gt;(&amp;instance) || any_cast&lt;unsigned long*&gt;(&amp;instance) || any_cast&lt;long long*&gt;(&amp;instance) || any_cast&lt;unsigned long long*&gt;(&amp;instance)) {desc.type=AttrAccess::INTEGER; goto found; }
-					else if (any_cast&lt;vector&lt;string&gt;*&gt;(&amp;instance)) { desc.type=AttrAccess::SEQ_STRING; goto found; }
-				#if 0
-					else if (any_cast&lt;vector&lt;Vector3r&gt;*&gt;(&amp;instance)) { cerr&lt;&lt;&quot;WWWWWWWWWWWWW&quot;&lt;&lt;endl;}
-					//else if (any_cast&lt;vector&lt;Vector3r&gt;*&gt;(&amp;&amp;instance)) { cerr&lt;&quot;QQQQQQQQQQQQQQ&quot;&lt;&lt;endl;}
-					#define GET_TYPE_DIRECT(_type,ATTR_ACCESS_TYPE) try{ cerr&lt;&lt;&quot;Try &quot;&lt;&lt;instance.type().name()&lt;&lt;&quot; to &quot;&lt;&lt;typeid(_type).name()&lt;&lt;endl; any_cast&lt;_type &gt;(instance); desc.type=ATTR_ACCESS_TYPE; cerr&lt;&lt;&quot;OK!!!&quot;&lt;&lt;endl; goto found; } catch(boost::bad_any_cast&amp; e){}
-					GET_TYPE_DIRECT(std::vector&lt;Wm3::Vector3r&gt;*,AttrAccess::VEC_VEC);
-					else if (any_cast&lt;vector&lt;Wm3::Vector3&lt;double&gt; &gt;*&gt;(&amp;instance)) {
-						desc.type=AttrAccess::VEC_VEC;
-						cerr&lt;&lt;&quot;Attribute &quot;&lt;&lt;(*ai)-&gt;getName()&lt;&lt;&quot; is a vector&lt;Vector3r&gt;&quot;;
-					//else if (any_cast&lt;vector&lt;Real&gt;*&gt;(&amp;instance)) desc.type=AttrAccess::SEQ_FLOAT;
-					}
-				#endif
-					desc.type=AttrAccess::SEQ_FLOAT;
-					found:
-						descriptors[(*ai)-&gt;getName()]=desc;
-				}
-			}
-			//cerr&lt;&lt;dumpAttrs();
-		}
-		
-		//! Return serialized attribute by its name, as vector of strings
-		vector&lt;string&gt; getAttrStr(string name){
-			vector&lt;string&gt; ret;
-			shared_ptr&lt;Archive&gt; arch=descriptors[name].archive;
-			stringstream stream;
-			arch-&gt;serialize(stream,*arch,0);
-			IOFormatManager::parseFundamental(stream.str(),ret);
-			return ret;
-		}
-		//! name, values and types of given attribute, on one line as string
-		string dumpAttr(string name){
-			string vals,types; AttrDesc desc=descriptors[name]; vector&lt;string&gt; values=getAttrStr(name);
-			for(size_t i=0; i&lt;values.size(); i++) vals+=(i&gt;0?&quot; &quot;:&quot;&quot;)+values[i];
-			string typeDesc(desc.type==BOOL?&quot;BOOL&quot;:(desc.type==STRING?&quot;STRING&quot;:(desc.type==FLOAT?&quot;FLOAT&quot;:(desc.type==INTEGER?&quot;INTEGER&quot;:(desc.type==SEQ_FLOAT?&quot;SEQ_FLOAT&quot;:(desc.type==SEQ_STRING?&quot;SEQ_STRING&quot;:(desc.type==VEC_VEC?&quot;VEC_VEC&quot;:&quot;&lt;unknown&gt;&quot;)))))));
-			return name+&quot; =\t&quot;+vals+&quot;\t (&quot;+typeDesc+&quot;)&quot;;
-		}
-		//! call dumpAttr for all attributes (used for debugging)
-		string dumpAttrs(){ string ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++) ret+=dumpAttr(I-&gt;first)+&quot;\n&quot;; return ret;}
-		//! set attribute by name from its serialized value
-		void setAttrStr(string name, string value){
-			LOG_DEBUG(&quot;Will set `&quot;&lt;&lt;name&lt;&lt;&quot;' to `&quot;&lt;&lt;value&lt;&lt;&quot;'.&quot;);
-			stringstream voidStream;
-			descriptors[name].archive-&gt;deserialize(voidStream,*(descriptors[name].archive),value);
-		}
-
-		//! return dictionary of attributes and their python values (debugging mosly)
-		boost::python::dict pyDict(){boost::python::dict ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret[I-&gt;first]=pyGet(I-&gt;first); return ret; }
-		//! return python list of keys (attribute names)
-		boost::python::list pyKeys(){boost::python::list ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret.append(I-&gt;first); return ret;}
-
-
-		//! return attribute value as python object
-		boost::python::object pyGet(std::string key){
-			DescriptorMap::iterator I=descriptors.find(key);
-			if(I==descriptors.end()) throw std::invalid_argument(string(&quot;Invalid key: `&quot;)+key+&quot;'.&quot;);
-			vector&lt;string&gt; raw=getAttrStr(key);
-			LOG_DEBUG(&quot;Got raw attribute `&quot;&lt;&lt;key&lt;&lt;&quot;'&quot;);
-			switch(descriptors[key].type){
-				case BOOL: return python::object(lexical_cast&lt;bool&gt;(raw[0]));
-				case FLOAT: return python::object(lexical_cast_maybeNanInf&lt;double&gt;(raw[0]));
-				case INTEGER: return python::object(lexical_cast_maybeNanInf&lt;long&gt;(raw[0]));
-				case STRING: return python::object(raw[0]);
-				case SEQ_STRING: {python::list ret; for(size_t i=0; i&lt;raw.size(); i++) ret.append(python::object(raw[i])); return ret;}
-				case SEQ_FLOAT: {python::list ret; for(size_t i=0; i&lt;raw.size(); i++){ ret.append(python::object(lexical_cast_maybeNanInf&lt;double&gt;(raw[i]))); LOG_TRACE(&quot;Appended &quot;&lt;&lt;raw[i]);} return ret; }
-				case VEC_VEC: {
-					python::list ret; for(size_t i=0; i&lt;raw.size(); i++){
-						/* raw[i] has the form &quot;{number number number}&quot; */
-						vector&lt;string&gt; s; boost::algorithm::split(s,raw[i],algorithm::is_any_of(&quot;{} &quot;),algorithm::token_compress_on);
-						python::list subList; FOREACH(string ss, s) subList.append(python::object(lexical_cast_maybeNanInf&lt;double&gt;(ss)));
-						ret.append(subList);
-					}
-				}
-				default: throw runtime_error(&quot;Unhandled attribute type!&quot;);
-			}
-		}
-		//! set attribute value from python object
-		void pySet(std::string key, python::object val){
-			DescriptorMap::iterator I=descriptors.find(key);
-			if(I==descriptors.end()) throw std::invalid_argument(string(&quot;Invalid key: `&quot;)+key+&quot;'.&quot;);
-			#define SAFE_EXTRACT(from,to,type) python::extract&lt;type&gt; to(from); if(!to.check()) throw invalid_argument(string(&quot;Could not extract type &quot;)+#type);
-			switch(descriptors[key].type){
-				case BOOL: {SAFE_EXTRACT(val.ptr(),extr,bool); setAttrStr(key,extr()?&quot;1&quot;:&quot;0&quot;); break;}
-				case FLOAT: {SAFE_EXTRACT(val.ptr(),extr,double); setAttrStr(key,lexical_cast&lt;string&gt;(extr())); break; }
-				case INTEGER: {SAFE_EXTRACT(val.ptr(),extr,long); setAttrStr(key,lexical_cast&lt;string&gt;(extr())); break; }
-				case STRING: {SAFE_EXTRACT(val.ptr(),extr,string); setAttrStr(key,extr()); break;}
-				case SEQ_STRING:{
-					if(!PySequence_Check(val.ptr())) throw invalid_argument(&quot;String sequence argument required.&quot;);
-					string strVal(&quot;[&quot;);
-					for(int i=0; i&lt;PySequence_Size(val.ptr()); i++){SAFE_EXTRACT(PySequence_GetItem(val.ptr(),i),extr,string); strVal+=extr()+&quot; &quot;;}
-					setAttrStr(key,strVal+&quot;]&quot;);
-				} 
-				break;
-				case SEQ_FLOAT:{
-					if(!PySequence_Check(val.ptr())) throw invalid_argument(&quot;Number sequence argument required.&quot;);
-					string strVal(&quot;{&quot;);
-					for(int i=0; i&lt;PySequence_Size(val.ptr()); i++){SAFE_EXTRACT(PySequence_GetItem(val.ptr(),i),extr,double); strVal+=lexical_cast&lt;string&gt;(extr())+&quot; &quot;;}
-					setAttrStr(key,strVal+&quot;}&quot;);
-				}
-				break;
-				default: throw runtime_error(&quot;Invalid argument types!!&quot;);
-			}
-		}
-};
-
-CREATE_LOGGER(AttrAccess);
-

Added: trunk/gui/py/pyAttrUtils.hpp
===================================================================
--- trunk/gui/py/pyAttrUtils.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/gui/py/pyAttrUtils.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,223 @@
+// 2007,2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
+#include&lt;sstream&gt;
+#include&lt;boost/any.hpp&gt;
+#include&lt;map&gt;
+#include&lt;vector&gt;
+#include&lt;yade/lib-serialization/Archive.hpp&gt;
+#include&lt;yade/lib-serialization-xml/XMLFormatManager.hpp&gt;
+#include&lt;boost/python.hpp&gt;
+#include&lt;yade/extra/boost_python_len.hpp&gt;
+
+#include&lt;boost/foreach.hpp&gt;
+#ifndef FOREACH
+	#define FOREACH BOOST_FOREACH
+#endif
+
+using namespace std;
+using namespace boost;
+
+/*! Define inline proxy functions that access attributes of some object associated with this class.
+ * \param accessor is an shared_ptr&lt;AttrAccess&gt; (or AttrAccess*), properly initialized and associated with the object of your choice
+ * \param ensureFunc is member function called before every attribute access. It typically would check whether acessor is not NULL, otherwise instantiate it.
+ */
+#define ATTR_ACCESS_CXX(accessor,ensureFunc) \
+	boost::python::object wrappedPyGet(std::string key){ensureFunc();return accessor-&gt;pyGet(key);} \
+	void wrappedPySet(std::string key,python::object val){ensureFunc(); accessor-&gt;pySet(key,val);} \
+	string wrappedGetAttrStr(std::string key){ensureFunc();vector&lt;string&gt; a=accessor-&gt;getAttrStr(key); string ret(&quot;[&quot;); FOREACH(string s, a) ret+=s+&quot; &quot;; return ret+&quot;]&quot;;} \
+	void wrappedSetAttrStr(std::string key, std::string val){ensureFunc();return accessor-&gt;setAttrStr(key,val);} \
+	boost::python::list wrappedPyKeys(){ensureFunc(); return accessor-&gt;pyKeys();} \
+	boost::python::dict wrappedPyDict(){ensureFunc(); return accessor-&gt;pyDict();} \
+	bool wrappedPyHasKey(std::string key){ensureFunc(); return accessor-&gt;descriptors.find(key)!=accessor-&gt;descriptors.end();} \
+	
+	
+	//boost::python::object wrappedPyGet_throw(std::string key){ensureFunc(); if(wrappedPyHasKey(key)) return accessor-&gt;pyGet(key); PyErr_SetString(PyExc_AttributeError, &quot;No such attribute.&quot;); boost::python::throw_error_already_set(); /* make compiler happy*/ return boost::python::object(); }
+
+
+/*! Python special functions complementing proxies defined by ATTR_ACCESS_CXX, to be used with boost::python::class_&lt;&gt;.
+ *
+ * They define python special functions that support dictionary operations on this object and calls proxies for them. */
+#define ATTR_ACCESS_PY(cxxClass) \
+	def(&quot;__getitem__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setitem__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;keys&quot;,&amp;cxxClass::wrappedPyKeys).def(&quot;has_key&quot;,&amp;cxxClass::wrappedPyHasKey).def(&quot;dict&quot;,&amp;cxxClass::wrappedPyDict) \
+	.def(&quot;getRaw&quot;,&amp;cxxClass::wrappedGetAttrStr).def(&quot;setRaw&quot;,&amp;cxxClass::wrappedSetAttrStr)
+	//def(&quot;__getattr__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setattr__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;attrs&quot;,&amp;cxxClass::wrappedPyKeys)
+
+	//.def(&quot;__getattribute__&quot;,&amp;cxxClass::wrappedPyGet_throw)
+
+#define BASIC_PY_PROXY_HEAD(pyClass,yadeClass) \
+class pyClass{shared_ptr&lt;AttrAccess&gt; accessor; \
+	private: void init(string clss){ proxee=dynamic_pointer_cast&lt;yadeClass&gt;(ClassFactory::instance().createShared(clss.empty()? #yadeClass : clss)); if(!proxee) throw runtime_error(&quot;Invalid class `&quot;+clss+&quot;': either nonexistent, or unable to cast to `&quot;+#yadeClass+&quot;'&quot;); } \
+	public: shared_ptr&lt;yadeClass&gt; proxee; \
+		void ensureAcc(void){ if(!proxee) throw runtime_error(string(&quot;No proxied `&quot;)+#yadeClass+&quot;'.&quot;); if(!accessor) accessor=shared_ptr&lt;AttrAccess&gt;(new AttrAccess(proxee));} \
+		pyClass(string clss=&quot;&quot;, python::dict attrs=python::dict()){ init(clss); python::list l=attrs.items(); int len=PySequence_Size(l.ptr()); for(int i=0; i&lt;len; i++){ python::extract&lt;python::tuple&gt; t(l[i]); python::extract&lt;string&gt; keyEx(t()[0]); if(!keyEx.check()) throw invalid_argument(&quot;Attribute keys must be strings.&quot;); wrappedPySet(keyEx(),t()[1]); } } \
+		pyClass(const shared_ptr&lt;yadeClass&gt;&amp; _proxee): proxee(_proxee) {} \
+		std::string pyStr(void){ ensureAcc(); return string(proxee-&gt;getClassName()==#yadeClass ? &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot;&gt;&quot; : &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot; &quot;+ #yadeClass +&quot;&gt;&quot;); } \
+		string className(void){ ensureAcc(); return proxee-&gt;getClassName(); } \
+		void postProcessAttributes(void){ensureAcc(); static_pointer_cast&lt;Serializable&gt;(proxee)-&gt;/*<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">__HACK__D at _N</A>@T_ABUSE_*/postProcessAttributes(/*deserializing*/ true); } \
+		ATTR_ACCESS_CXX(accessor,ensureAcc);
+
+#define BASIC_PY_PROXY_TAIL };
+/*! Basic implementation of python proxy class that provides:
+ * 1. constructor with (optional) class name and (optional) dictionary of attributes
+ * 2. copy constructor from another proxy class
+ * 3. className() returning proxy class name as string 
+ * 4. ensureAcc() that makes sure we have proxy _and_ attribute access things ready
+ */
+#define BASIC_PY_PROXY(pyClass,yadeClass) BASIC_PY_PROXY_HEAD(pyClass,yadeClass) BASIC_PY_PROXY_TAIL
+
+/* Read-write access to some attribute that is not basic-serializable, i.e. must be exported as instance.attribute (not instance['attribute']. That attribute is wrapped in given python class before it is returned. */
+#define NONPOD_ATTRIBUTE_ACCESS(pyName,pyClass,yadeName) \
+	python::object pyName##_get(void){ensureAcc(); return proxee-&gt;yadeName ? python::object(pyClass(proxee-&gt;yadeName)) : python::object(); } \
+	void pyName##_set(pyClass proxy){ensureAcc(); proxee-&gt;yadeName=proxy.proxee; }
+/*! Boost.python's definition of python object corresponding to BASIC_PY_PROXY */
+#define BASIC_PY_PROXY_WRAPPER(pyClass,pyName)  \
+	boost::python::class_&lt;pyClass&gt;(pyName,python::init&lt;python::optional&lt;string,python::dict&gt; &gt;()) \
+	.ATTR_ACCESS_PY(pyClass) \
+	.def(&quot;__str__&quot;,&amp;pyClass::pyStr).def(&quot;__repr__&quot;,&amp;pyClass::pyStr) \
+	.add_property(&quot;name&quot;,&amp;pyClass::className) \
+	.def(&quot;postProcessAttributes&quot;,&amp;pyClass::postProcessAttributes)
+
+
+
+/*! Helper class for accessing registered attributes through the serialization interface.
+ *
+ * 4 possible types of attributes are supported: bool, string, number and arrays (homogeneous) of any of them.
+ * This class exposes pySet, pyGet and pyKeys methods to python so that associated object supports python syntax for dictionary member access.
+ */
+class AttrAccess{
+	struct AttrDesc{int type; shared_ptr&lt;Archive&gt; archive;};
+	private:
+		const shared_ptr&lt;Serializable&gt; ser;
+		Serializable::Archives archives;
+	public:
+		DECLARE_LOGGER;
+		typedef map&lt;string,AttrDesc&gt; DescriptorMap;
+		//! maps attribute name to its archive and vector of its types (given as ints, from the following enum)
+		DescriptorMap descriptors;
+		//! allowed types
+		enum {BOOL,STRING,FLOAT,INTEGER,SEQ_FLOAT, SEQ_STRING, VEC_VEC }; // allowed types
+		
+		AttrAccess(Serializable* _ser): ser(shared_ptr&lt;Serializable&gt;(_ser)){init();}
+		AttrAccess(shared_ptr&lt;Serializable&gt; _ser):ser(_ser){init();}
+
+		//! create archives and descriptors, always called from the constructor
+		void init(){
+			//cerr&lt;&lt;typeid(std::vector&lt;Wm3::Vector3&lt;double&gt; &gt;*).name()&lt;&lt;endl;
+			if(ser-&gt;getArchives().empty()) ser-&gt;registerSerializableAttributes(false);
+			archives=ser-&gt;getArchives();
+			for(Serializable::Archives::iterator ai=archives.begin();ai!=archives.end();++ai){
+				if((*ai)-&gt;isFundamental() &amp;&amp; (*ai)-&gt;getName()!=&quot;serializationDynlib&quot;){
+					AttrDesc desc; 
+					desc.archive=*ai;
+					any instance=(*ai)-&gt;getAddress(); // gets pointer to the stored value
+					//cerr&lt;&lt;&quot;[&quot;&lt;&lt;(*ai)-&gt;getName()&lt;&lt;&quot;,&quot;&lt;&lt;instance.type().name()&lt;&lt;&quot;]&quot;;
+					// 3 possibilities: one BOOL, one or more STRINGS, one or more FLOATs (fallback if none matches)
+					if      (any_cast&lt;string*&gt;(&amp;instance)) { desc.type=AttrAccess::STRING; goto found; }
+					else if (any_cast&lt;bool*&gt;(&amp;instance)) { desc.type=AttrAccess::BOOL; goto found; }
+					else if (any_cast&lt;Real*&gt;(&amp;instance) || any_cast&lt;long double*&gt;(&amp;instance) || any_cast&lt;double*&gt;(&amp;instance) || any_cast&lt;float*&gt;(&amp;instance)) { desc.type=AttrAccess::FLOAT; goto found;}
+					else if (any_cast&lt;int*&gt;(&amp;instance) || any_cast&lt;unsigned int*&gt;(&amp;instance) || any_cast&lt;long*&gt;(&amp;instance) || any_cast&lt;unsigned long*&gt;(&amp;instance) || any_cast&lt;long long*&gt;(&amp;instance) || any_cast&lt;unsigned long long*&gt;(&amp;instance)) {desc.type=AttrAccess::INTEGER; goto found; }
+					else if (any_cast&lt;vector&lt;string&gt;*&gt;(&amp;instance)) { desc.type=AttrAccess::SEQ_STRING; goto found; }
+				#if 0
+					else if (any_cast&lt;vector&lt;Vector3r&gt;*&gt;(&amp;instance)) { cerr&lt;&lt;&quot;WWWWWWWWWWWWW&quot;&lt;&lt;endl;}
+					//else if (any_cast&lt;vector&lt;Vector3r&gt;*&gt;(&amp;&amp;instance)) { cerr&lt;&quot;QQQQQQQQQQQQQQ&quot;&lt;&lt;endl;}
+					#define GET_TYPE_DIRECT(_type,ATTR_ACCESS_TYPE) try{ cerr&lt;&lt;&quot;Try &quot;&lt;&lt;instance.type().name()&lt;&lt;&quot; to &quot;&lt;&lt;typeid(_type).name()&lt;&lt;endl; any_cast&lt;_type &gt;(instance); desc.type=ATTR_ACCESS_TYPE; cerr&lt;&lt;&quot;OK!!!&quot;&lt;&lt;endl; goto found; } catch(boost::bad_any_cast&amp; e){}
+					GET_TYPE_DIRECT(std::vector&lt;Wm3::Vector3r&gt;*,AttrAccess::VEC_VEC);
+					else if (any_cast&lt;vector&lt;Wm3::Vector3&lt;double&gt; &gt;*&gt;(&amp;instance)) {
+						desc.type=AttrAccess::VEC_VEC;
+						cerr&lt;&lt;&quot;Attribute &quot;&lt;&lt;(*ai)-&gt;getName()&lt;&lt;&quot; is a vector&lt;Vector3r&gt;&quot;;
+					//else if (any_cast&lt;vector&lt;Real&gt;*&gt;(&amp;instance)) desc.type=AttrAccess::SEQ_FLOAT;
+					}
+				#endif
+					desc.type=AttrAccess::SEQ_FLOAT;
+					found:
+						descriptors[(*ai)-&gt;getName()]=desc;
+				}
+			}
+			//cerr&lt;&lt;dumpAttrs();
+		}
+		
+		//! Return serialized attribute by its name, as vector of strings
+		vector&lt;string&gt; getAttrStr(string name){
+			vector&lt;string&gt; ret;
+			shared_ptr&lt;Archive&gt; arch=descriptors[name].archive;
+			stringstream stream;
+			arch-&gt;serialize(stream,*arch,0);
+			IOFormatManager::parseFundamental(stream.str(),ret);
+			return ret;
+		}
+		//! name, values and types of given attribute, on one line as string
+		string dumpAttr(string name){
+			string vals,types; AttrDesc desc=descriptors[name]; vector&lt;string&gt; values=getAttrStr(name);
+			for(size_t i=0; i&lt;values.size(); i++) vals+=(i&gt;0?&quot; &quot;:&quot;&quot;)+values[i];
+			string typeDesc(desc.type==BOOL?&quot;BOOL&quot;:(desc.type==STRING?&quot;STRING&quot;:(desc.type==FLOAT?&quot;FLOAT&quot;:(desc.type==INTEGER?&quot;INTEGER&quot;:(desc.type==SEQ_FLOAT?&quot;SEQ_FLOAT&quot;:(desc.type==SEQ_STRING?&quot;SEQ_STRING&quot;:(desc.type==VEC_VEC?&quot;VEC_VEC&quot;:&quot;&lt;unknown&gt;&quot;)))))));
+			return name+&quot; =\t&quot;+vals+&quot;\t (&quot;+typeDesc+&quot;)&quot;;
+		}
+		//! call dumpAttr for all attributes (used for debugging)
+		string dumpAttrs(){ string ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++) ret+=dumpAttr(I-&gt;first)+&quot;\n&quot;; return ret;}
+		//! set attribute by name from its serialized value
+		void setAttrStr(string name, string value){
+			LOG_DEBUG(&quot;Will set `&quot;&lt;&lt;name&lt;&lt;&quot;' to `&quot;&lt;&lt;value&lt;&lt;&quot;'.&quot;);
+			stringstream voidStream;
+			descriptors[name].archive-&gt;deserialize(voidStream,*(descriptors[name].archive),value);
+		}
+
+		//! return dictionary of attributes and their python values (debugging mosly)
+		boost::python::dict pyDict(){boost::python::dict ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret[I-&gt;first]=pyGet(I-&gt;first); return ret; }
+		//! return python list of keys (attribute names)
+		boost::python::list pyKeys(){boost::python::list ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret.append(I-&gt;first); return ret;}
+
+
+		//! return attribute value as python object
+		boost::python::object pyGet(std::string key){
+			DescriptorMap::iterator I=descriptors.find(key);
+			if(I==descriptors.end()) throw std::invalid_argument(string(&quot;Invalid key: `&quot;)+key+&quot;'.&quot;);
+			vector&lt;string&gt; raw=getAttrStr(key);
+			LOG_DEBUG(&quot;Got raw attribute `&quot;&lt;&lt;key&lt;&lt;&quot;'&quot;);
+			switch(descriptors[key].type){
+				case BOOL: return python::object(lexical_cast&lt;bool&gt;(raw[0]));
+				case FLOAT: return python::object(lexical_cast_maybeNanInf&lt;double&gt;(raw[0]));
+				case INTEGER: return python::object(lexical_cast_maybeNanInf&lt;long&gt;(raw[0]));
+				case STRING: return python::object(raw[0]);
+				case SEQ_STRING: {python::list ret; for(size_t i=0; i&lt;raw.size(); i++) ret.append(python::object(raw[i])); return ret;}
+				case SEQ_FLOAT: {python::list ret; for(size_t i=0; i&lt;raw.size(); i++){ ret.append(python::object(lexical_cast_maybeNanInf&lt;double&gt;(raw[i]))); LOG_TRACE(&quot;Appended &quot;&lt;&lt;raw[i]);} return ret; }
+				case VEC_VEC: {
+					python::list ret; for(size_t i=0; i&lt;raw.size(); i++){
+						/* raw[i] has the form &quot;{number number number}&quot; */
+						vector&lt;string&gt; s; boost::algorithm::split(s,raw[i],algorithm::is_any_of(&quot;{} &quot;),algorithm::token_compress_on);
+						python::list subList; FOREACH(string ss, s) subList.append(python::object(lexical_cast_maybeNanInf&lt;double&gt;(ss)));
+						ret.append(subList);
+					}
+				}
+				default: throw runtime_error(&quot;Unhandled attribute type!&quot;);
+			}
+		}
+		//! set attribute value from python object
+		void pySet(std::string key, python::object val){
+			DescriptorMap::iterator I=descriptors.find(key);
+			if(I==descriptors.end()) throw std::invalid_argument(string(&quot;Invalid key: `&quot;)+key+&quot;'.&quot;);
+			#define SAFE_EXTRACT(from,to,type) python::extract&lt;type&gt; to(from); if(!to.check()) throw invalid_argument(string(&quot;Could not extract type &quot;)+#type);
+			switch(descriptors[key].type){
+				case BOOL: {SAFE_EXTRACT(val.ptr(),extr,bool); setAttrStr(key,extr()?&quot;1&quot;:&quot;0&quot;); break;}
+				case FLOAT: {SAFE_EXTRACT(val.ptr(),extr,double); setAttrStr(key,lexical_cast&lt;string&gt;(extr())); break; }
+				case INTEGER: {SAFE_EXTRACT(val.ptr(),extr,long); setAttrStr(key,lexical_cast&lt;string&gt;(extr())); break; }
+				case STRING: {SAFE_EXTRACT(val.ptr(),extr,string); setAttrStr(key,extr()); break;}
+				case SEQ_STRING:{
+					if(!PySequence_Check(val.ptr())) throw invalid_argument(&quot;String sequence argument required.&quot;);
+					string strVal(&quot;[&quot;);
+					for(int i=0; i&lt;PySequence_Size(val.ptr()); i++){SAFE_EXTRACT(PySequence_GetItem(val.ptr(),i),extr,string); strVal+=extr()+&quot; &quot;;}
+					setAttrStr(key,strVal+&quot;]&quot;);
+				} 
+				break;
+				case SEQ_FLOAT:{
+					if(!PySequence_Check(val.ptr())) throw invalid_argument(&quot;Number sequence argument required.&quot;);
+					string strVal(&quot;{&quot;);
+					for(int i=0; i&lt;PySequence_Size(val.ptr()); i++){SAFE_EXTRACT(PySequence_GetItem(val.ptr(),i),extr,double); strVal+=lexical_cast&lt;string&gt;(extr())+&quot; &quot;;}
+					setAttrStr(key,strVal+&quot;}&quot;);
+				}
+				break;
+				default: throw runtime_error(&quot;Invalid argument types!!&quot;);
+			}
+		}
+};
+
+CREATE_LOGGER(AttrAccess);
+


Property changes on: trunk/gui/py/pyAttrUtils.hpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/gui/py/yadeControl.cpp
===================================================================
--- trunk/gui/py/yadeControl.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/gui/py/yadeControl.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,849 +0,0 @@
-// 2007,2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
-
-#include&lt;sstream&gt;
-#include&lt;map&gt;
-#include&lt;vector&gt;
-#include&lt;unistd.h&gt;
-#include&lt;list&gt;
-
-
-#include&lt;boost/python.hpp&gt;
-#include&lt;boost/python/suite/indexing/vector_indexing_suite.hpp&gt;
-#include&lt;boost/bind.hpp&gt;
-#include&lt;boost/thread/thread.hpp&gt;
-#include&lt;boost/filesystem/operations.hpp&gt;
-#include&lt;boost/date_time/posix_time/posix_time.hpp&gt;
-#include&lt;boost/any.hpp&gt;
-#include&lt;boost/python.hpp&gt;
-#include&lt;boost/foreach.hpp&gt;
-#include&lt;boost/algorithm/string.hpp&gt;
-
-// [boost1.34] #include&lt;boost/python/stl_iterator.hpp&gt;
-
-#include&lt;yade/lib-base/Logging.hpp&gt;
-#include&lt;yade/lib-serialization-xml/XMLFormatManager.hpp&gt;
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/core/FileGenerator.hpp&gt;
-
-#include&lt;yade/lib-import/STLImporter.hpp&gt;
-
-#include&lt;yade/core/MetaEngine.hpp&gt;
-#include&lt;yade/core/MetaEngine1D.hpp&gt;
-#include&lt;yade/core/MetaEngine2D.hpp&gt;
-#include&lt;yade/core/StandAloneEngine.hpp&gt;
-#include&lt;yade/core/DeusExMachina.hpp&gt;
-#include&lt;yade/core/EngineUnit.hpp&gt;
-#include&lt;yade/pkg-common/ParallelEngine.hpp&gt;
-#include&lt;yade/core/EngineUnit1D.hpp&gt;
-#include&lt;yade/core/EngineUnit2D.hpp&gt;
-
-#include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/GeometricalModelMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/InteractingGeometryMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/InteractionGeometryMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/InteractionPhysicsMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/ConstitutiveLawDispatcher.hpp&gt;
-#include&lt;yade/pkg-common/InteractionDispatchers.hpp&gt;
-#include&lt;yade/pkg-common/PhysicalActionDamper.hpp&gt;
-#include&lt;yade/pkg-common/PhysicalActionApplier.hpp&gt;
-#include&lt;yade/pkg-common/MetaInteractingGeometry.hpp&gt;
-#include&lt;yade/pkg-common/AABB.hpp&gt;
-#include&lt;yade/pkg-common/ParticleParameters.hpp&gt;
-
-#include&lt;yade/pkg-common/BoundingVolumeEngineUnit.hpp&gt;
-#include&lt;yade/pkg-common/GeometricalModelEngineUnit.hpp&gt;
-#include&lt;yade/pkg-common/InteractingGeometryEngineUnit.hpp&gt;
-#include&lt;yade/pkg-common/InteractionGeometryEngineUnit.hpp&gt;
-#include&lt;yade/pkg-common/InteractionPhysicsEngineUnit.hpp&gt;
-#include&lt;yade/pkg-common/PhysicalParametersEngineUnit.hpp&gt;
-#include&lt;yade/pkg-common/PhysicalActionDamperUnit.hpp&gt;
-#include&lt;yade/pkg-common/PhysicalActionApplierUnit.hpp&gt;
-#include&lt;yade/pkg-common/ConstitutiveLaw.hpp&gt;
-
-#include&lt;yade/extra/Shop.hpp&gt;
-#include&lt;yade/pkg-dem/Clump.hpp&gt;
-
-using namespace boost;
-using namespace std;
-
-#include&quot;pyAttrUtils.hpp&quot;
-#include&lt;yade/extra/boost_python_len.hpp&gt;
-
-class RenderingEngine;
-
-/*!
-	
-	A regular class (not Omega) is instantiated like this:
-
-		RootClass('optional class name as quoted string',{optional dictionary of attributes})
-		
-	if class name is not given, the RootClass itself is instantiated
-
-		p=PhysicalParameters() # p is now instance of PhysicalParameters
-		p=PhysicalParameters('RigidBodyParameters') # p is now instance of RigidBodyParameters, which has PhysicalParameters as the &quot;root&quot; class
-		p=PhysicalParameters('RigidBodyParameters',{'mass':100,'se3':[1,1,2,1,0,0,0]}) # convenience constructor
-
-	The last statement is equivalent to:
-
-		p=PhysicalParameters('RigidBodyParameters')
-		p['mass']=100; 
-		p['se3']=[1,1,2,1,0,0,0]
-
-	Class attributes are those that are registered as serializable, are accessed using the [] operator and are always read-write (be careful)
-
-		p['se3'] # this will show you the se3 attribute inside p
-		p['se3']=[1,2,3,1,0,0,0] # this sets se3 of p
-
-	Those attributes that are not fundamental types (strings, numbers, booleans, se3, vectors, quaternions, arrays of numbers, arrays of strings) can be accessed only through explicit python data members, for example:
-		
-		b=Body()
-		b.mold=InteractingGeometry(&quot;InteractingSphere&quot;,{'radius':1})
-		b.shape=GeometricalModel(&quot;Sphere&quot;,{'radius':1})
-		b.mold # will give you the interactingGeometry of body
-	
-	Instances can be queried about attributes and data members they have:
-
-		b.keys() # serializable attributes, accessible via b['attribute']
-		dir(b) # python data members, accessible via b.attribute; the __something__ attributes are python internal attributes/metods -- methods are just callable members
-
-	MetaEngine class has special constructor (for convenience):
-
-		m=MetaEngine('class name as string',[list of engine units])
-
-	and it is equivalent to
-
-		m=MetaEntine('class name as string')
-		m.functors=[list of engine units]
-
-	It is your responsibility to pass the right engineUnits, otherwise crash will results. There is currently no way I know of to prevent that. 
-
-*/
-
-/*
-TODO:
-	1. PhysicalActionContainer (constructor with actionName) with iteration
-	2. from yadeControl import Omega as _Omega, inherit from that and add other convenience functions
-*/
-
-#ifdef LOG4CXX
-	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.python&quot;);
-#endif
-
-BASIC_PY_PROXY(pyGeneric,Serializable);
-
-BASIC_PY_PROXY(pyInteractionGeometry,InteractionGeometry);
-BASIC_PY_PROXY(pyInteractionPhysics,InteractionPhysics);
-
-BASIC_PY_PROXY(pyGeometricalModel,GeometricalModel);
-BASIC_PY_PROXY_HEAD(pyPhysicalParameters,PhysicalParameters)
-	python::list blockedDOFs_get(){
-		python::list ret;
-		#define _SET_DOF(DOF_ANY,str) if((proxee-&gt;blockedDOFs &amp; PhysicalParameters::DOF_ANY)!=0) ret.append(str);
-		_SET_DOF(DOF_X,&quot;x&quot;); _SET_DOF(DOF_Y,&quot;y&quot;); _SET_DOF(DOF_Z,&quot;z&quot;); _SET_DOF(DOF_RX,&quot;rx&quot;); _SET_DOF(DOF_RY,&quot;ry&quot;); _SET_DOF(DOF_RZ,&quot;rz&quot;);
-		#undef _SET_DOF
-		return ret;
-	}
-	void blockedDOFs_set(python::list l){
-		proxee-&gt;blockedDOFs=PhysicalParameters::DOF_NONE;
-		int len=python::len(l);
-		for(int i=0; i&lt;len; i++){
-			string s=python::extract&lt;string&gt;(l[i])();
-			#define _GET_DOF(DOF_ANY,str) if(s==str) { proxee-&gt;blockedDOFs|=PhysicalParameters::DOF_ANY; continue; }
-			_GET_DOF(DOF_X,&quot;x&quot;); _GET_DOF(DOF_Y,&quot;y&quot;); _GET_DOF(DOF_Z,&quot;z&quot;); _GET_DOF(DOF_RX,&quot;rx&quot;); _GET_DOF(DOF_RY,&quot;ry&quot;); _GET_DOF(DOF_RZ,&quot;rz&quot;);
-			#undef _GET_DOF
-			throw std::invalid_argument(&quot;Invalid  DOF specification `&quot;+s+&quot;', must be &#8712;{x,y,z,rx,ry,rz}.&quot;);
-		}
-	}
-	Vector3r displ_get(){return proxee-&gt;se3.position-proxee-&gt;refSe3.position;}
-	python::tuple rot_get(){Quaternionr relRot=proxee-&gt;refSe3.orientation.Conjugate()*proxee-&gt;se3.orientation; Vector3r axis; Real angle; relRot.ToAxisAngle(axis,angle); axis*=angle; return python::make_tuple(axis[0],axis[1],axis[2]); }
-	Vector3r pos_get(){return proxee-&gt;se3.position;}
-	Vector3r refPos_get(){return proxee-&gt;refSe3.position;}
-	python::tuple ori_get(){Vector3r axis; Real angle; proxee-&gt;se3.orientation.ToAxisAngle(axis,angle); return python::make_tuple(axis[0],axis[1],axis[2],angle);}
-	void pos_set(const Vector3r&amp; p){ proxee-&gt;se3.position=p; }
-	void refPos_set(const Vector3r&amp; p){ proxee-&gt;refSe3.position=p;}
-	void ori_set(python::list l){if(python::len(l)!=4) throw invalid_argument(&quot;Wrong number of quaternion elements &quot;+lexical_cast&lt;string&gt;(python::len(l))+&quot;, should be 4&quot;); proxee-&gt;se3.orientation=Quaternionr(Vector3r(python::extract&lt;double&gt;(l[0])(),python::extract&lt;double&gt;(l[1])(),python::extract&lt;double&gt;(l[2])()),python::extract&lt;double&gt;(l[3])());}
-BASIC_PY_PROXY_TAIL;
-
-BASIC_PY_PROXY(pyBoundingVolume,BoundingVolume);
-BASIC_PY_PROXY(pyInteractingGeometry,InteractingGeometry);
-
-struct pyTimingDeltas{
-	shared_ptr&lt;TimingDeltas&gt; proxee;
-	pyTimingDeltas(shared_ptr&lt;TimingDeltas&gt; td){proxee=td;}
-	python::list data_get(){
-		python::list ret;
-		for(size_t i=0; i&lt;proxee-&gt;data.size(); i++){
-			ret.append(python::make_tuple(proxee-&gt;labels[i],proxee-&gt;data[i].nsec,proxee-&gt;data[i].nExec));
-		}
-		return ret;
-	}
-	void reset(){proxee-&gt;data.clear(); proxee-&gt;labels.clear();}
-};
-
-#define PY_PROXY_TIMING \
-	TimingInfo::delta execTime_get(void){return proxee-&gt;timingInfo.nsec;} void execTime_set(TimingInfo::delta t){proxee-&gt;timingInfo.nsec=t;} \
-	long execCount_get(void){return proxee-&gt;timingInfo.nExec;} void execCount_set(long n){proxee-&gt;timingInfo.nExec=n;} \
-	python::object timingDeltas_get(void){return proxee-&gt;timingDeltas?python::object(pyTimingDeltas(proxee-&gt;timingDeltas)):python::object();}
-
-
-BASIC_PY_PROXY_HEAD(pyDeusExMachina,DeusExMachina)
-	PY_PROXY_TIMING
-BASIC_PY_PROXY_TAIL;
-
-BASIC_PY_PROXY_HEAD(pyStandAloneEngine,StandAloneEngine)
-	PY_PROXY_TIMING
-BASIC_PY_PROXY_TAIL;
-	
-
-python::list anyEngines_get(const vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp;);
-void anyEngines_set(vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp;, python::object);
-
-BASIC_PY_PROXY_HEAD(pyParallelEngine,ParallelEngine)
-	pyParallelEngine(python::list slaves){init(&quot;ParallelEngine&quot;); slaves_set(slaves);}
-	void slaves_set(python::list slaves){
-		ensureAcc(); shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
-		int len=python::len(slaves);
-		me-&gt;slaves=ParallelEngine::slaveContainer(); // empty the container
-		for(int i=0; i&lt;len; i++){
-			python::extract&lt;python::list&gt; grpMaybe(slaves[i]);
-			python::list grpList;
-			if(grpMaybe.check()){ grpList=grpMaybe(); }
-			else{ /* we got a standalone thing; let's wrap it in list */ grpList.append(slaves[i]); }
-			vector&lt;shared_ptr&lt;Engine&gt; &gt; grpVec;
-			anyEngines_set(grpVec,grpList);
-			me-&gt;slaves.push_back(grpVec);
-		}
-	}
-	python::list slaves_get(void){	
-		ensureAcc(); shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
-		python::list ret;
-		FOREACH(vector&lt;shared_ptr&lt;Engine &gt; &gt;&amp; grp, me-&gt;slaves){
-			python::list rret=anyEngines_get(grp);
-			if(python::len(rret)==1){ ret.append(rret[0]); } else ret.append(rret);
-		}
-		return ret;
-	}
-BASIC_PY_PROXY_TAIL;
-
-
-BASIC_PY_PROXY_HEAD(pyEngineUnit,EngineUnit)
-	python::list bases_get(void){ python::list ret; vector&lt;string&gt; t=proxee-&gt;getFunctorTypes(); for(size_t i=0; i&lt;t.size(); i++) ret.append(t[i]); return ret; }
-	python::object timingDeltas_get(){return proxee-&gt;timingDeltas?python::object(pyTimingDeltas(proxee-&gt;timingDeltas)):python::object();}
-BASIC_PY_PROXY_TAIL;
-
-BASIC_PY_PROXY_HEAD(pyMetaEngine,MetaEngine)
-		// additional constructor
-		pyMetaEngine(string clss, python::list functors){init(clss); functors_set(functors);}
-		python::list functors_get(void){
-			ensureAcc(); shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine (?!)&quot;); python::list ret;
-			/* garbage design: functorArguments are instances of EngineUnits, but they may not be present; therefore, only use them if they exist; our pyMetaEngine, however, will always have both names and EnguneUnit objects in the same count */
-			for(size_t i=0; i&lt;me-&gt;functorNames.size(); i++){
-				shared_ptr&lt;EngineUnit&gt; eu;
-				string functorName(*(me-&gt;functorNames[i].rbegin()));
-				if(i&lt;=me-&gt;functorArguments.size()){ /* count i-th list member */ size_t j=0;
-					for(list&lt;shared_ptr&lt;EngineUnit&gt; &gt;::iterator I=me-&gt;functorArguments.begin(); I!=me-&gt;functorArguments.end(); I++, j++) { if(j==i) { eu=(*I); break;}}
-				}
-				if(!eu) /* either list was shorter or empty pointer in the functorArguments list */ { eu=dynamic_pointer_cast&lt;EngineUnit&gt;(ClassFactory::instance().createShared(functorName)); if(!eu) throw runtime_error(&quot;Unable to construct `&quot;+string(*(me-&gt;functorNames[i].rbegin()))+&quot;' EngineUnit&quot;); }
-				assert(eu);
-				ret.append(pyEngineUnit(eu));
-			}
-			return ret;
-		}
-		void functors_set(python::list ftrs){
-			ensureAcc(); shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine. (?!)&quot;);
-			me-&gt;clear(); int len=python::len(ftrs);
-			for(int i=0; i&lt;len; i++){
-				python::extract&lt;pyEngineUnit&gt; euEx(ftrs[i]); if(!euEx.check()) throw invalid_argument(&quot;Unable to extract type EngineUnit from sequence.&quot;);
-				bool ok=false;
-				/* FIXME: casting engine unit to the right type via dynamic_cast doesn't work (always unusuccessful),
-				 * do static_cast and if the EngineUnit is of wrong type, it will crash badly immediately. */
-				#define TRY_ADD_FUNCTOR(P,Q) {shared_ptr&lt;P&gt; p(dynamic_pointer_cast&lt;P&gt;(me)); shared_ptr&lt;EngineUnit&gt; eu(euEx().proxee); if(p&amp;&amp;eu){p-&gt;add(static_pointer_cast&lt;Q&gt;(eu)); ok=true; }}
-				// shared_ptr&lt;Q&gt; q(dynamic_pointer_cast&lt;Q&gt;(eu)); cerr&lt;&lt;#P&lt;&lt;&quot; &quot;&lt;&lt;#Q&lt;&lt;&quot;:&quot;&lt;&lt;(bool)p&lt;&lt;&quot; &quot;&lt;&lt;(bool)q&lt;&lt;endl;
-				TRY_ADD_FUNCTOR(BoundingVolumeMetaEngine,BoundingVolumeEngineUnit);
-				TRY_ADD_FUNCTOR(GeometricalModelMetaEngine,GeometricalModelEngineUnit);
-				TRY_ADD_FUNCTOR(InteractingGeometryMetaEngine,InteractingGeometryEngineUnit);
-				TRY_ADD_FUNCTOR(InteractionGeometryMetaEngine,InteractionGeometryEngineUnit);
-				TRY_ADD_FUNCTOR(InteractionPhysicsMetaEngine,InteractionPhysicsEngineUnit);
-				TRY_ADD_FUNCTOR(PhysicalParametersMetaEngine,PhysicalParametersEngineUnit);
-				TRY_ADD_FUNCTOR(PhysicalActionDamper,PhysicalActionDamperUnit);
-				TRY_ADD_FUNCTOR(PhysicalActionApplier,PhysicalActionApplierUnit);
-				TRY_ADD_FUNCTOR(ConstitutiveLawDispatcher,ConstitutiveLaw);
-				if(!ok) throw runtime_error(string(&quot;Unable to cast to suitable MetaEngine type when adding functor (MetaEngine: &quot;)+me-&gt;getClassName()+&quot;, functor: &quot;+euEx().proxee-&gt;getClassName()+&quot;)&quot;);
-				#undef TRY_ADD_FUNCTOR
-			}
-		}
-	PY_PROXY_TIMING
-BASIC_PY_PROXY_TAIL;
-
-BASIC_PY_PROXY_HEAD(pyInteractionDispatchers,InteractionDispatchers)
-	pyInteractionDispatchers(python::list geomFunctors, python::list physFunctors, python::list constLawFunctors){
-		init(&quot;InteractionDispatchers&quot;);
-		pyMetaEngine(proxee-&gt;geomDispatcher).functors_set(geomFunctors);
-		pyMetaEngine(proxee-&gt;physDispatcher).functors_set(physFunctors);
-		pyMetaEngine(proxee-&gt;constLawDispatcher).functors_set(constLawFunctors);
-	}
-	pyMetaEngine geomDispatcher_get(void){ return pyMetaEngine(proxee-&gt;geomDispatcher);}
-	pyMetaEngine physDispatcher_get(void){ return pyMetaEngine(proxee-&gt;physDispatcher);}
-	pyMetaEngine constLawDispatcher_get(void){ return pyMetaEngine(proxee-&gt;constLawDispatcher);}
-	PY_PROXY_TIMING
-BASIC_PY_PROXY_TAIL;
-
-python::list anyEngines_get(const vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp; engContainer){
-	python::list ret; 
-	FOREACH(const shared_ptr&lt;Engine&gt;&amp; eng, engContainer){
-		#define APPEND_ENGINE_IF_POSSIBLE(engineType,pyEngineType) { shared_ptr&lt;engineType&gt; e=dynamic_pointer_cast&lt;engineType&gt;(eng); if(e) { ret.append(pyEngineType(e)); continue; } }
-		APPEND_ENGINE_IF_POSSIBLE(InteractionDispatchers,pyInteractionDispatchers); APPEND_ENGINE_IF_POSSIBLE(MetaEngine,pyMetaEngine); APPEND_ENGINE_IF_POSSIBLE(StandAloneEngine,pyStandAloneEngine); APPEND_ENGINE_IF_POSSIBLE(DeusExMachina,pyDeusExMachina); APPEND_ENGINE_IF_POSSIBLE(ParallelEngine,pyParallelEngine); 
-		throw std::runtime_error(&quot;Unknown engine type: `&quot;+eng-&gt;getClassName()+&quot;' (only MetaEngine, StandAloneEngine, DeusExMachina and ParallelEngine are supported)&quot;);
-	}
-	return ret;
-}
-
-void anyEngines_set(vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp; engContainer, python::object egs){
-	int len=python::len(egs);
-	//const shared_ptr&lt;MetaBody&gt;&amp; rootBody=OMEGA.getRootBody(); rootBody-&gt;engines.clear();
-	engContainer.clear();
-	for(int i=0; i&lt;len; i++){
-		#define PUSH_BACK_ENGINE_IF_POSSIBLE(pyEngineType) if(python::extract&lt;pyEngineType&gt;(PySequence_GetItem(egs.ptr(),i)).check()){ pyEngineType e=python::extract&lt;pyEngineType&gt;(PySequence_GetItem(egs.ptr(),i)); engContainer.push_back(e.proxee); /* cerr&lt;&lt;&quot;added &quot;&lt;&lt;e.pyStr()&lt;&lt;&quot;, a &quot;&lt;&lt;#pyEngineType&lt;&lt;endl; */ continue; }
-		PUSH_BACK_ENGINE_IF_POSSIBLE(pyStandAloneEngine); PUSH_BACK_ENGINE_IF_POSSIBLE(pyMetaEngine); PUSH_BACK_ENGINE_IF_POSSIBLE(pyDeusExMachina); PUSH_BACK_ENGINE_IF_POSSIBLE(pyParallelEngine); PUSH_BACK_ENGINE_IF_POSSIBLE(pyInteractionDispatchers);
-		throw std::runtime_error(&quot;Encountered unknown engine type (unable to extract from python object)&quot;);
-	}
-}
-
-
-
-BASIC_PY_PROXY_HEAD(pyInteraction,Interaction)
-	NONPOD_ATTRIBUTE_ACCESS(geom,pyInteractionGeometry,interactionGeometry);
-	NONPOD_ATTRIBUTE_ACCESS(phys,pyInteractionPhysics,interactionPhysics);
-	/* shorthands */ unsigned id1_get(void){ensureAcc(); return proxee-&gt;getId1();} unsigned id2_get(void){ensureAcc(); return proxee-&gt;getId2();}
-	bool isReal_get(void){ensureAcc(); return proxee-&gt;isReal(); }
-BASIC_PY_PROXY_TAIL;
-
-BASIC_PY_PROXY_HEAD(pyBody,Body)
-	NONPOD_ATTRIBUTE_ACCESS(shape,pyGeometricalModel,geometricalModel);
-	NONPOD_ATTRIBUTE_ACCESS(mold,pyInteractingGeometry,interactingGeometry);
-	NONPOD_ATTRIBUTE_ACCESS(bound,pyBoundingVolume,boundingVolume);
-	NONPOD_ATTRIBUTE_ACCESS(phys,pyPhysicalParameters,physicalParameters);
-	unsigned id_get(){ensureAcc(); return proxee-&gt;getId();}
-	int mask_get(){ensureAcc(); return proxee-&gt;groupMask;}
-	void mask_set(int m){ensureAcc(); proxee-&gt;groupMask=m;}
-	bool dynamic_get(){ensureAcc(); return proxee-&gt;isDynamic;} void dynamic_set(bool dyn){ensureAcc(); proxee-&gt;isDynamic=dyn;}
-	bool isStandalone(){ensureAcc(); return proxee-&gt;isStandalone();} bool isClumpMember(){ensureAcc(); return proxee-&gt;isClumpMember();} bool isClump(){ensureAcc(); return proxee-&gt;isClump();}
-BASIC_PY_PROXY_TAIL;
-
-class pyBodyContainer{
-	public:
-	const shared_ptr&lt;BodyContainer&gt; proxee;
-	pyBodyContainer(const shared_ptr&lt;BodyContainer&gt;&amp; _proxee): proxee(_proxee){}
-	pyBody pyGetitem(unsigned id){
-		if(id&gt;=proxee-&gt;size()){ PyErr_SetString(PyExc_IndexError, &quot;Body id out of range.&quot;); python::throw_error_already_set(); /* make compiler happy; never reached */ return pyBody(); }
-		else return pyBody(proxee-&gt;operator[](id));
-	}
-	body_id_t insert(pyBody b){return proxee-&gt;insert(b.proxee);}
-	python::list insertList(python::list bb){python::list ret; for(int i=0; i&lt;len(bb); i++){ret.append(insert(python::extract&lt;pyBody&gt;(bb[i])()));} return ret;}
-		python::tuple insertClump(python::list bb){/*clump: first add constitutents, then add clump, then add constitutents to the clump, then update clump props*/
-		python::list ids=insertList(bb);
-		shared_ptr&lt;Clump&gt; clump=shared_ptr&lt;Clump&gt;(new Clump());
-		shared_ptr&lt;Body&gt; clumpAsBody=static_pointer_cast&lt;Body&gt;(clump);
-		clump-&gt;isDynamic=true;
-		proxee-&gt;insert(clumpAsBody);
-		for(int i=0; i&lt;len(ids); i++){clump-&gt;add(python::extract&lt;body_id_t&gt;(ids[i])());}
-		clump-&gt;updateProperties(false);
-		return python::make_tuple(clump-&gt;getId(),ids);
-	}
-	python::list replace(python::list bb){proxee-&gt;clear(); return insertList(bb);}
-	long length(){return proxee-&gt;size();}
-	void clear(){proxee-&gt;clear();}
-};
-
-
-class pyTags{
-	public:
-		pyTags(const shared_ptr&lt;MetaBody&gt; _mb): mb(_mb){}
-		const shared_ptr&lt;MetaBody&gt; mb;
-		bool hasKey(string key){ FOREACH(string val, mb-&gt;tags){ if(algorithm::starts_with(val,key+&quot;=&quot;)){ return true;} } return false; }
-		string getItem(string key){
-			FOREACH(string&amp; val, mb-&gt;tags){
-				if(algorithm::starts_with(val,key+&quot;=&quot;)){ string val1(val); algorithm::erase_head(val1,key.size()+1); algorithm::replace_all(val1,&quot;~&quot;,&quot; &quot;); return val1;}
-			}
-			PyErr_SetString(PyExc_KeyError, &quot;Invalid key.&quot;);
-			python::throw_error_already_set(); /* make compiler happy; never reached */ return string();
-		}
-		void setItem(string key,string newVal){
-			string item=algorithm::replace_all_copy(key+&quot;=&quot;+newVal,&quot; &quot;,&quot;~&quot;);
-			FOREACH(string&amp; val, mb-&gt;tags){if(algorithm::starts_with(val,key+&quot;=&quot;)){ val=item; return; } }
-			mb-&gt;tags.push_back(item);
-			}
-		python::list keys(){
-			python::list ret;
-			FOREACH(string val, mb-&gt;tags){
-				size_t i=val.find(&quot;=&quot;);
-				if(i==string::npos) throw runtime_error(&quot;Tags must be in the key=value format&quot;);
-				algorithm::erase_tail(val,val.size()-i); ret.append(val);
-			}
-			return ret;
-		}
-};
-
-class pyInteractionIterator{
-	InteractionContainer::iterator I, Iend;
-	public:
-	pyInteractionIterator(const shared_ptr&lt;InteractionContainer&gt;&amp; ic){ I=ic-&gt;begin(); Iend=ic-&gt;end(); }
-	pyInteractionIterator pyIter(){return *this;}
-	pyInteraction pyNext(){ if(!(I!=Iend)){ PyErr_SetNone(PyExc_StopIteration); python::throw_error_already_set(); }
-		InteractionContainer::iterator ret=I; ++I; return pyInteraction(*ret); }
-};
-
-class pyInteractionContainer{
-	public:
-		const shared_ptr&lt;InteractionContainer&gt; proxee;
-		pyInteractionContainer(const shared_ptr&lt;InteractionContainer&gt;&amp; _proxee): proxee(_proxee){}
-		pyInteractionIterator pyIter(){return pyInteractionIterator(proxee);}
-		pyInteraction pyGetitem(python::object id12){
-			if(!PySequence_Check(id12.ptr())) throw invalid_argument(&quot;Key must be a tuple&quot;);
-			if(python::len(id12)!=2) throw invalid_argument(&quot;Key must be a 2-tuple: id1,id2.&quot;);
-			python::extract&lt;body_id_t&gt; id1_(PySequence_GetItem(id12.ptr(),0)), id2_(PySequence_GetItem(id12.ptr(),1));
-			if(!id1_.check()) throw invalid_argument(&quot;Could not extract id1&quot;);
-			if(!id2_.check()) throw invalid_argument(&quot;Could not extract id2&quot;);
-			shared_ptr&lt;Interaction&gt; i=proxee-&gt;find(id1_(),id2_());
-			if(i) return pyInteraction(i); else throw invalid_argument(&quot;No such interaction.&quot;);
-		}
-		/* return nth _real_ iteration from the container (0-based index); this is to facilitate picking random interaction */
-		pyInteraction pyNth(long n){
-			long i=0; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(!I-&gt;isReal()) continue; if(i++==n) return pyInteraction(I); }
-			throw invalid_argument(string(&quot;Interaction number out of range (&quot;)+lexical_cast&lt;string&gt;(n)+&quot;&gt;=&quot;+lexical_cast&lt;string&gt;(i)+&quot;).&quot;);
-		}
-		long len(){return proxee-&gt;size();}
-		void clear(){proxee-&gt;clear();}
-		python::list withBody(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;isReal() &amp;&amp; (I-&gt;getId1()==id || I-&gt;getId2()==id)) ret.append(pyInteraction(I));} return ret;}
-		python::list withBodyAll(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;getId1()==id || I-&gt;getId2()==id) ret.append(pyInteraction(I));} return ret; }
-};
-
-Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
-
-class pyBexContainer{
-	public:
-		pyBexContainer(){}
-		python::tuple force_get(long id){  MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r f=rb-&gt;bex.getForce(id); return python::make_tuple(f[0],f[1],f[2]); }
-		python::tuple torque_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getTorque(id); return python::make_tuple(m[0],m[1],m[2]);}
-		python::tuple move_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getMove(id); return python::make_tuple(m[0],m[1],m[2]);}
-		python::tuple rot_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getRot(id); return python::make_tuple(m[0],m[1],m[2]);}
-		void force_add(long id, const Vector3r&amp; f){  MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addForce (id,f); }
-		void torque_add(long id, const Vector3r&amp; t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addTorque(id,t);}
-		void move_add(long id, const Vector3r&amp; t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addMove(id,t);}
-		void rot_add(long id, const Vector3r&amp; t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addRot(id,t);}
-};
-
-class pyOmega{
-	private:
-		// can be safely removed now, since pyOmega makes an empty rootBody in the constructor, if there is none
-		void assertRootBody(){if(!OMEGA.getRootBody()) throw std::runtime_error(&quot;No root body.&quot;); }
-		Omega&amp; OMEGA;
-	public:
-	pyOmega(): OMEGA(Omega::instance()){
-		shared_ptr&lt;MetaBody&gt; rb=OMEGA.getRootBody();
-		assert(rb);
-		if(!rb-&gt;physicalParameters){rb-&gt;physicalParameters=shared_ptr&lt;PhysicalParameters&gt;(new ParticleParameters);} /* PhysicalParameters crashes PhysicalParametersMetaEngine... why? */
-		if(!rb-&gt;boundingVolume){rb-&gt;boundingVolume=shared_ptr&lt;AABB&gt;(new AABB);}
-		// initialized in constructor now: rb-&gt;boundingVolume-&gt;diffuseColor=Vector3r(1,1,1); 
-		if(!rb-&gt;interactingGeometry){rb-&gt;interactingGeometry=shared_ptr&lt;MetaInteractingGeometry&gt;(new MetaInteractingGeometry);}
-		//if(!OMEGA.getRootBody()){shared_ptr&lt;MetaBody&gt; mb=Shop::rootBody(); OMEGA.setRootBody(mb);}
-		/* this is not true if another instance of Omega is created; flag should be stored inside the Omega singleton for clean solution. */
-		if(!OMEGA.hasSimulationLoop()){
-			OMEGA.createSimulationLoop();
-		}
-	};
-	/* Create variables in python's __builtin__ namespace that correspond to labeled objects. At this moment, only engines can be labeled. */
-	void mapLabeledEntitiesToVariables(){
-		FOREACH(const shared_ptr&lt;Engine&gt;&amp; e, OMEGA.getRootBody()-&gt;engines){
-			if(!e-&gt;label.empty()){
-				PyGILState_STATE gstate; gstate = PyGILState_Ensure();
-				PyRun_SimpleString((&quot;__builtins__.&quot;+e-&gt;label+&quot;=Omega().labeledEngine('&quot;+e-&gt;label+&quot;')&quot;).c_str());
-				PyGILState_Release(gstate);
-			}
-			if(isChildClassOf(e-&gt;getClassName(),&quot;MetaEngine&quot;)){
-				shared_ptr&lt;MetaEngine&gt; ee=dynamic_pointer_cast&lt;MetaEngine&gt;(e);
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; f, ee-&gt;functorArguments){
-					if(!f-&gt;label.empty()){
-						PyGILState_STATE gstate; gstate = PyGILState_Ensure(); PyRun_SimpleString((&quot;__builtins__.&quot;+f-&gt;label+&quot;=Omega().labeledEngine('&quot;+f-&gt;label+&quot;')&quot;).c_str()); PyGILState_Release(gstate);
-					}
-				}
-			}
-			if(e-&gt;getClassName()==&quot;InteractionDispatchers&quot;){
-				shared_ptr&lt;InteractionDispatchers&gt; ee=dynamic_pointer_cast&lt;InteractionDispatchers&gt;(e);
-				list&lt;shared_ptr&lt;EngineUnit&gt; &gt; eus;
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;geomDispatcher-&gt;functorArguments) eus.push_back(eu);
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;physDispatcher-&gt;functorArguments) eus.push_back(eu);
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;constLawDispatcher-&gt;functorArguments) eus.push_back(eu);
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,eus){
-					if(!eu-&gt;label.empty()){
-						PyGILState_STATE gstate; gstate = PyGILState_Ensure(); PyRun_SimpleString((&quot;__builtins__.&quot;+eu-&gt;label+&quot;=Omega().labeledEngine('&quot;+eu-&gt;label+&quot;')&quot;).c_str()); PyGILState_Release(gstate);
-					}
-				}
-			}
-		}
-	}
-
-	long iter(){ return OMEGA.getCurrentIteration();}
-	double simulationTime(){return OMEGA.getSimulationTime();}
-	double realTime(){ return OMEGA.getComputationTime(); }
-	// long realTime(){return OMEGA(get...);}
-	double dt_get(){return OMEGA.getTimeStep();}
-	void dt_set(double dt){OMEGA.skipTimeStepper(true); OMEGA.setTimeStep(dt);}
-
-	long stopAtIter_get(){return OMEGA.getRootBody()-&gt;stopAtIteration; }
-	void stopAtIter_set(long s){OMEGA.getRootBody()-&gt;stopAtIteration=s; }
-
-	bool usesTimeStepper_get(){return OMEGA.timeStepperActive();}
-	void usesTimeStepper_set(bool use){OMEGA.skipTimeStepper(!use);}
-
-	bool timingEnabled_get(){return TimingInfo::enabled;}
-	void timingEnabled_set(bool enabled){TimingInfo::enabled=enabled;}
-	unsigned long bexSyncCount_get(){ return OMEGA.getRootBody()-&gt;bex.syncCount;}
-	void bexSyncCount_set(unsigned long count){ OMEGA.getRootBody()-&gt;bex.syncCount=count;}
-
-	void run(long int numIter=-1,bool doWait=false){
-		if(numIter&gt;0) OMEGA.getRootBody()-&gt;stopAtIteration=OMEGA.getCurrentIteration()+numIter;
-		OMEGA.startSimulationLoop();
-		LOG_DEBUG(&quot;RUN&quot;&lt;&lt;((OMEGA.getRootBody()-&gt;stopAtIteration-OMEGA.getCurrentIteration())&gt;0?string(&quot; (&quot;+lexical_cast&lt;string&gt;(OMEGA.getRootBody()-&gt;stopAtIteration-OMEGA.getCurrentIteration())+&quot; to go)&quot;):string(&quot;&quot;))&lt;&lt;&quot;!&quot;);
-		if(doWait) wait();
-	}
-	void pause(){Py_BEGIN_ALLOW_THREADS; OMEGA.stopSimulationLoop(); Py_END_ALLOW_THREADS; LOG_DEBUG(&quot;PAUSE!&quot;);}
-	void step() { LOG_DEBUG(&quot;STEP!&quot;); run(1); wait();  }
-	void wait(){ if(OMEGA.isRunning()){LOG_DEBUG(&quot;WAIT!&quot;);} else return; timespec t1,t2; t1.tv_sec=0; t1.tv_nsec=40000000; /* 40 ms */ Py_BEGIN_ALLOW_THREADS; while(OMEGA.isRunning()) nanosleep(&amp;t1,&amp;t2); Py_END_ALLOW_THREADS; }
-
-	void load(std::string fileName) {
-		Py_BEGIN_ALLOW_THREADS; OMEGA.joinSimulationLoop(); Py_END_ALLOW_THREADS; 
-		OMEGA.setSimulationFileName(fileName);
-		OMEGA.loadSimulation();
-		OMEGA.createSimulationLoop();
-		mapLabeledEntitiesToVariables();
-		LOG_DEBUG(&quot;LOAD!&quot;);
-	}
-	void reload(){	load(OMEGA.getSimulationFileName());}
-	void saveTmp(string mark=&quot;&quot;){ save(&quot;:memory:&quot;+mark);}
-	void loadTmp(string mark=&quot;&quot;){ load(&quot;:memory:&quot;+mark);}
-	void tmpToFile(string mark, string filename){
-		if(OMEGA.memSavedSimulations.count(&quot;:memory:&quot;+mark)==0) throw runtime_error(&quot;No memory-saved simulation named &quot;+mark);
-		iostreams::filtering_ostream out;
-		if(boost::algorithm::ends_with(filename,&quot;.bz2&quot;)) out.push(iostreams::bzip2_compressor());
-		out.push(iostreams::file_sink(filename));
-		if(!out.good()) throw runtime_error(&quot;Error while opening file `&quot;+filename+&quot;' for writing.&quot;);
-		LOG_INFO(&quot;Saving :memory:&quot;&lt;&lt;mark&lt;&lt;&quot; to &quot;&lt;&lt;filename);
-		out&lt;&lt;OMEGA.memSavedSimulations[&quot;:memory:&quot;+mark];
-	}
-
-
-
-	void reset(){Py_BEGIN_ALLOW_THREADS; OMEGA.reset(); Py_END_ALLOW_THREADS; }
-	void resetTime(){ OMEGA.getRootBody()-&gt;currentIteration=0; OMEGA.getRootBody()-&gt;simulationTime=0; OMEGA.timeInit(); }
-	void switchWorld(){ std::swap(OMEGA.rootBody,OMEGA.rootBodyAnother); }
-
-	void save(std::string fileName){
-		assertRootBody();
-		OMEGA.saveSimulation(fileName);
-		OMEGA.setSimulationFileName(fileName);
-		LOG_DEBUG(&quot;SAVE!&quot;);
-	}
-
-	void saveSpheres(std::string fileName){ Shop::saveSpheresToFile(fileName); }
-
-	python::list miscParams_get(){
-		python::list ret;
-		FOREACH(shared_ptr&lt;Serializable&gt;&amp; s, OMEGA.getRootBody()-&gt;miscParams){
-			ret.append(pyGeneric(s));
-		}
-		return ret;
-	}
-
-	void miscParams_set(python::list l){
-		int len=python::len(l);
-		vector&lt;shared_ptr&lt;Serializable&gt; &gt;&amp; miscParams=OMEGA.getRootBody()-&gt;miscParams;
-		miscParams.clear();
-		for(int i=0; i&lt;len; i++){
-			if(python::extract&lt;pyGeneric&gt;(PySequence_GetItem(l.ptr(),i)).check()){ pyGeneric g=python::extract&lt;pyGeneric&gt;(PySequence_GetItem(l.ptr(),i)); miscParams.push_back(g.proxee); }
-			else throw std::invalid_argument(&quot;Unable to extract `Generic' from item #&quot;+lexical_cast&lt;string&gt;(i)+&quot;.&quot;);
-		}
-	}
-
-	python::list engines_get(void){assertRootBody(); return anyEngines_get(OMEGA.getRootBody()-&gt;engines);}
-	void engines_set(python::object egs){assertRootBody(); anyEngines_set(OMEGA.getRootBody()-&gt;engines,egs); mapLabeledEntitiesToVariables(); }
-	python::list initializers_get(void){assertRootBody(); return anyEngines_get(OMEGA.getRootBody()-&gt;initializers);}
-	void initializers_set(python::object egs){assertRootBody(); anyEngines_set(OMEGA.getRootBody()-&gt;initializers,egs); OMEGA.getRootBody()-&gt;needsInitializers=true; }
-
-	python::object labeled_engine_get(string label){
-		FOREACH(const shared_ptr&lt;Engine&gt;&amp; eng, OMEGA.getRootBody()-&gt;engines){
-			if(eng-&gt;label==label){
-				#define RETURN_ENGINE_IF_POSSIBLE(engineType,pyEngineType) { shared_ptr&lt;engineType&gt; e=dynamic_pointer_cast&lt;engineType&gt;(eng); if(e) return python::object(pyEngineType(e)); }
-				RETURN_ENGINE_IF_POSSIBLE(MetaEngine,pyMetaEngine);
-				RETURN_ENGINE_IF_POSSIBLE(StandAloneEngine,pyStandAloneEngine);
-				RETURN_ENGINE_IF_POSSIBLE(DeusExMachina,pyDeusExMachina);
-				RETURN_ENGINE_IF_POSSIBLE(ParallelEngine,pyParallelEngine);
-				throw std::runtime_error(&quot;Unable to cast engine to MetaEngine, StandAloneEngine, DeusExMachina or ParallelEngine? ??&quot;);
-			}
-			shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(eng);
-			if(me){
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu, me-&gt;functorArguments){
-					if(eu-&gt;label==label) return python::object(pyEngineUnit(eu));
-				}
-			}
-			shared_ptr&lt;InteractionDispatchers&gt; ee=dynamic_pointer_cast&lt;InteractionDispatchers&gt;(eng);
-			if(ee){
-				list&lt;shared_ptr&lt;EngineUnit&gt; &gt; eus;
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;geomDispatcher-&gt;functorArguments) eus.push_back(eu);
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;physDispatcher-&gt;functorArguments) eus.push_back(eu);
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;constLawDispatcher-&gt;functorArguments) eus.push_back(eu);
-				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,eus){
-					if(eu-&gt;label==label) return python::object(pyEngineUnit(eu));
-				}
-			}
-		}
-		throw std::invalid_argument(string(&quot;No engine labeled `&quot;)+label+&quot;'&quot;);
-	}
-	
-	pyBodyContainer bodies_get(void){assertRootBody(); return pyBodyContainer(OMEGA.getRootBody()-&gt;bodies); }
-	pyInteractionContainer interactions_get(void){assertRootBody(); return pyInteractionContainer(OMEGA.getRootBody()-&gt;interactions); }
-	
-	pyBexContainer bex_get(void){return pyBexContainer();}
-	
-
-	boost::python::list listChildClasses(const string&amp; base){
-		boost::python::list ret;
-		for(map&lt;string,DynlibDescriptor&gt;::const_iterator di=Omega::instance().getDynlibsDescriptor().begin();di!=Omega::instance().getDynlibsDescriptor().end();++di) if (Omega::instance().isInheritingFrom((*di).first,base)) ret.append(di-&gt;first);
-		return ret;
-	}
-
-	bool isChildClassOf(const string&amp; child, const string&amp; base){
-		return (Omega::instance().isInheritingFrom(child,base));
-	}
-
-	boost::python::list plugins_get(){
-		const map&lt;string,DynlibDescriptor&gt;&amp; plugins=Omega::instance().getDynlibsDescriptor();
-		std::pair&lt;string,DynlibDescriptor&gt; p; boost::python::list ret;
-		FOREACH(p, plugins) ret.append(p.first);
-		return ret;
-	}
-
-	pyTags tags_get(void){assertRootBody(); return pyTags(OMEGA.getRootBody());}
-
-	void interactionContainer_set(string clss){
-		MetaBody* rb=OMEGA.getRootBody().get();
-		if(rb-&gt;interactions-&gt;size()&gt;0) throw std::runtime_error(&quot;Interaction container not empty, will not change its class.&quot;);
-		shared_ptr&lt;InteractionContainer&gt; ic=dynamic_pointer_cast&lt;InteractionContainer&gt;(ClassFactory::instance().createShared(clss));
-		rb-&gt;interactions=ic;
-	}
-	string interactionContainer_get(string clss){ return OMEGA.getRootBody()-&gt;interactions-&gt;getClassName(); }
-
-	void bodyContainer_set(string clss){
-		MetaBody* rb=OMEGA.getRootBody().get();
-		if(rb-&gt;bodies-&gt;size()&gt;0) throw std::runtime_error(&quot;Body container not empty, will not change its class.&quot;);
-		shared_ptr&lt;BodyContainer&gt; bc=dynamic_pointer_cast&lt;BodyContainer&gt;(ClassFactory::instance().createShared(clss));
-		rb-&gt;bodies=bc;
-	}
-	string bodyContainer_get(string clss){ return OMEGA.getRootBody()-&gt;bodies-&gt;getClassName(); }
-	#ifdef YADE_OPENMP
-		int numThreads_get(){ return omp_get_max_threads();}
-		void numThreads_set(int n){ int bcn=OMEGA.getRootBody()-&gt;bex.getNumAllocatedThreads(); if(bcn&lt;n) LOG_WARN(&quot;BexContainer has only &quot;&lt;&lt;bcn&lt;&lt;&quot; threads allocated. Changing thread number to on &quot;&lt;&lt;bcn&lt;&lt;&quot; instead of &quot;&lt;&lt;n&lt;&lt;&quot; requested.&quot;); omp_set_num_threads(min(n,bcn)); LOG_WARN(&quot;BUG: Omega().numThreads=n doesn't work as expected (number of threads is not changed globally). Set env var OMP_NUM_THREADS instead.&quot;); }
-	#else
-		int numThreads_get(){return 1;}
-		void numThreads_set(int n){ LOG_WARN(&quot;Yade was compiled without openMP support, changing number of threads will have no effect.&quot;); }
-	#endif
-
-};
-BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_run_overloads,run,0,2);
-BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_saveTmp_overloads,saveTmp,0,1);
-BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_loadTmp_overloads,loadTmp,0,1);
-
-BASIC_PY_PROXY_HEAD(pyFileGenerator,FileGenerator)
-	void generate(string outFile){ensureAcc(); proxee-&gt;setFileName(outFile); proxee-&gt;setSerializationLibrary(&quot;XMLFormatManager&quot;); bool ret=proxee-&gt;generateAndSave(); LOG_INFO((ret?&quot;SUCCESS:\n&quot;:&quot;FAILURE:\n&quot;)&lt;&lt;proxee-&gt;message); if(ret==false) throw runtime_error(&quot;Generator reported error: &quot;+proxee-&gt;message); };
-	void load(){ ensureAcc(); char tmpnam_str [L_tmpnam]; char* result=tmpnam(tmpnam_str); if(result!=tmpnam_str) throw runtime_error(__FILE__ &quot;: tmpnam(char*) failed!&quot;);  string xml(tmpnam_str+string(&quot;.xml.bz2&quot;)); LOG_DEBUG(&quot;Using temp file &quot;&lt;&lt;xml); this-&gt;generate(xml); pyOmega().load(xml); }
-BASIC_PY_PROXY_TAIL;
-
-class pySTLImporter : public STLImporter {
-    public:
-	void py_import(pyBodyContainer bc, unsigned int begin=0, bool noInteractingGeometry=false) { import(bc.proxee,begin,noInteractingGeometry); }
-};
-BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(STLImporter_import_overloads,py_import,1,3);
-
-
-// automatic conversion of Vector3r and 3-tuple
-// this doesn't create any new class in python
-struct custom_Vector3r_to_tuple{
-	static PyObject* convert(Vector3r const&amp; v){
-		return python::incref(python::make_tuple(v[0],v[1],v[2]).ptr());
-	}
-};
-struct custom_Vector3r_from_tuple{
-	custom_Vector3r_from_tuple(){
-		python::converter::registry::push_back(&amp;convertible,&amp;construct,python::type_id&lt;Vector3r&gt;());
-	}
-	static void* convertible(PyObject* obj_ptr){
-		if(!PySequence_Check(obj_ptr) || PySequence_Size(obj_ptr)!=3) return 0;
-		return obj_ptr;
-	}
-	static void construct(PyObject* obj_ptr, python::converter::rvalue_from_python_stage1_data* data){
-		void* storage=((python::converter::rvalue_from_python_storage&lt;Vector3r&gt;*)(data))-&gt;storage.bytes;
-		new (storage) Vector3r(python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,0)),python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,1)),python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,2)));
-		data-&gt;convertible=storage;
-	}
-};
-
-
-BOOST_PYTHON_MODULE(wrapper)
-{
-
-	python::to_python_converter&lt;Vector3r,custom_Vector3r_to_tuple&gt;();
-	custom_Vector3r_from_tuple();
-
-	boost::python::class_&lt;pyOmega&gt;(&quot;Omega&quot;)
-		.add_property(&quot;iter&quot;,&amp;pyOmega::iter)
-		.add_property(&quot;stopAtIter&quot;,&amp;pyOmega::stopAtIter_get,&amp;pyOmega::stopAtIter_set)
-		.add_property(&quot;time&quot;,&amp;pyOmega::simulationTime)
-		.add_property(&quot;realtime&quot;,&amp;pyOmega::realTime)
-		.add_property(&quot;dt&quot;,&amp;pyOmega::dt_get,&amp;pyOmega::dt_set)
-		.add_property(&quot;usesTimeStepper&quot;,&amp;pyOmega::usesTimeStepper_get,&amp;pyOmega::usesTimeStepper_set)
-		.def(&quot;load&quot;,&amp;pyOmega::load)
-		.def(&quot;reload&quot;,&amp;pyOmega::reload)
-		.def(&quot;save&quot;,&amp;pyOmega::save)
-		.def(&quot;loadTmp&quot;,&amp;pyOmega::loadTmp,omega_loadTmp_overloads(python::args(&quot;mark&quot;)))
-		.def(&quot;saveTmp&quot;,&amp;pyOmega::saveTmp,omega_saveTmp_overloads(python::args(&quot;mark&quot;)))
-		.def(&quot;tmpToFile&quot;,&amp;pyOmega::tmpToFile)
-		.def(&quot;saveSpheres&quot;,&amp;pyOmega::saveSpheres)
-		.def(&quot;run&quot;,&amp;pyOmega::run,omega_run_overloads())
-		.def(&quot;pause&quot;,&amp;pyOmega::pause)
-		.def(&quot;step&quot;,&amp;pyOmega::step)
-		.def(&quot;wait&quot;,&amp;pyOmega::wait)
-		.def(&quot;reset&quot;,&amp;pyOmega::reset)
-		.def(&quot;switchWorld&quot;,&amp;pyOmega::switchWorld)
-		.def(&quot;labeledEngine&quot;,&amp;pyOmega::labeled_engine_get)
-		.def(&quot;resetTime&quot;,&amp;pyOmega::resetTime)
-		.def(&quot;plugins&quot;,&amp;pyOmega::plugins_get)
-		.add_property(&quot;engines&quot;,&amp;pyOmega::engines_get,&amp;pyOmega::engines_set)
-		.add_property(&quot;miscParams&quot;,&amp;pyOmega::miscParams_get,&amp;pyOmega::miscParams_set)
-		.add_property(&quot;initializers&quot;,&amp;pyOmega::initializers_get,&amp;pyOmega::initializers_set)
-		.add_property(&quot;bodies&quot;,&amp;pyOmega::bodies_get)
-		.add_property(&quot;interactions&quot;,&amp;pyOmega::interactions_get)
-		.add_property(&quot;actions&quot;,&amp;pyOmega::bex_get)
-		.add_property(&quot;bex&quot;,&amp;pyOmega::bex_get)
-		.add_property(&quot;tags&quot;,&amp;pyOmega::tags_get)
-		.def(&quot;childClasses&quot;,&amp;pyOmega::listChildClasses)
-		.def(&quot;isChildClassOf&quot;,&amp;pyOmega::isChildClassOf)
-		.add_property(&quot;bodyContainer&quot;,&amp;pyOmega::bodyContainer_get,&amp;pyOmega::bodyContainer_set)
-		.add_property(&quot;interactionContainer&quot;,&amp;pyOmega::interactionContainer_get,&amp;pyOmega::interactionContainer_set)
-		.add_property(&quot;timingEnabled&quot;,&amp;pyOmega::timingEnabled_get,&amp;pyOmega::timingEnabled_set)
-		.add_property(&quot;bexSyncCount&quot;,&amp;pyOmega::bexSyncCount_get,&amp;pyOmega::bexSyncCount_set)
-		.add_property(&quot;numThreads&quot;,&amp;pyOmega::numThreads_get,&amp;pyOmega::numThreads_set)
-		;
-	boost::python::class_&lt;pyTags&gt;(&quot;TagsWrapper&quot;,python::init&lt;pyTags&amp;&gt;())
-		.def(&quot;__getitem__&quot;,&amp;pyTags::getItem)
-		.def(&quot;__setitem__&quot;,&amp;pyTags::setItem)
-		.def(&quot;keys&quot;,&amp;pyTags::keys);
-	
-	boost::python::class_&lt;pyBodyContainer&gt;(&quot;BodyContainer&quot;,python::init&lt;pyBodyContainer&amp;&gt;())
-		.def(&quot;__getitem__&quot;,&amp;pyBodyContainer::pyGetitem)
-		.def(&quot;__len__&quot;,&amp;pyBodyContainer::length)
-		.def(&quot;append&quot;,&amp;pyBodyContainer::insert)
-		.def(&quot;append&quot;,&amp;pyBodyContainer::insertList)
-		.def(&quot;appendClumped&quot;,&amp;pyBodyContainer::insertClump)
-		.def(&quot;clear&quot;, &amp;pyBodyContainer::clear)
-		.def(&quot;replace&quot;,&amp;pyBodyContainer::replace);
-	boost::python::class_&lt;pyInteractionContainer&gt;(&quot;InteractionContainer&quot;,python::init&lt;pyInteractionContainer&amp;&gt;())
-		.def(&quot;__iter__&quot;,&amp;pyInteractionContainer::pyIter)
-		.def(&quot;__getitem__&quot;,&amp;pyInteractionContainer::pyGetitem)
-		.def(&quot;__len__&quot;,&amp;pyInteractionContainer::len)
-		.def(&quot;nth&quot;,&amp;pyInteractionContainer::pyNth)
-		.def(&quot;withBody&quot;,&amp;pyInteractionContainer::withBody)
-		.def(&quot;withBodyAll&quot;,&amp;pyInteractionContainer::withBodyAll)
-		.def(&quot;nth&quot;,&amp;pyInteractionContainer::pyNth)
-		.def(&quot;clear&quot;,&amp;pyInteractionContainer::clear);
-	boost::python::class_&lt;pyInteractionIterator&gt;(&quot;InteractionIterator&quot;,python::init&lt;pyInteractionIterator&amp;&gt;())
-		.def(&quot;__iter__&quot;,&amp;pyInteractionIterator::pyIter)
-		.def(&quot;next&quot;,&amp;pyInteractionIterator::pyNext);
-
-	boost::python::class_&lt;pyBexContainer&gt;(&quot;BexContainer&quot;,python::init&lt;pyBexContainer&amp;&gt;())
-		.def(&quot;f&quot;,&amp;pyBexContainer::force_get)
-		.def(&quot;t&quot;,&amp;pyBexContainer::torque_get)
-		.def(&quot;m&quot;,&amp;pyBexContainer::torque_get) // for compatibility with ActionContainer
-		.def(&quot;move&quot;,&amp;pyBexContainer::move_get)
-		.def(&quot;rot&quot;,&amp;pyBexContainer::rot_get)
-		.def(&quot;addF&quot;,&amp;pyBexContainer::force_add)
-		.def(&quot;addT&quot;,&amp;pyBexContainer::torque_add)
-		.def(&quot;addMove&quot;,&amp;pyBexContainer::move_add)
-		.def(&quot;addRot&quot;,&amp;pyBexContainer::rot_add);
-
-	boost::python::class_&lt;pyTimingDeltas&gt;(&quot;TimingDeltas&quot;,python::init&lt;pyTimingDeltas&amp;&gt;())
-		.def(&quot;reset&quot;,&amp;pyTimingDeltas::reset)
-		.add_property(&quot;data&quot;,&amp;pyTimingDeltas::data_get);
-
-	#define TIMING_PROPS(class) .add_property(&quot;execTime&quot;,&amp;class::execTime_get,&amp;class::execTime_set).add_property(&quot;execCount&quot;,&amp;class::execCount_get,&amp;class::execCount_set).add_property(&quot;timingDeltas&quot;,&amp;class::timingDeltas_get)
-
-	BASIC_PY_PROXY_WRAPPER(pyStandAloneEngine,&quot;StandAloneEngine&quot;)
-		TIMING_PROPS(pyStandAloneEngine);
-	BASIC_PY_PROXY_WRAPPER(pyMetaEngine,&quot;MetaEngine&quot;)
-		.add_property(&quot;functors&quot;,&amp;pyMetaEngine::functors_get,&amp;pyMetaEngine::functors_set)
-		TIMING_PROPS(pyMetaEngine)
-		.def(python::init&lt;string,python::list&gt;());
-	BASIC_PY_PROXY_WRAPPER(pyParallelEngine,&quot;ParallelEngine&quot;)
-		.add_property(&quot;slaves&quot;,&amp;pyParallelEngine::slaves_get,&amp;pyParallelEngine::slaves_set)
-		.def(python::init&lt;python::list&gt;());
-	BASIC_PY_PROXY_WRAPPER(pyDeusExMachina,&quot;DeusExMachina&quot;)
-		TIMING_PROPS(pyDeusExMachina);
-	BASIC_PY_PROXY_WRAPPER(pyInteractionDispatchers,&quot;InteractionDispatchers&quot;)
-		.def(python::init&lt;python::list,python::list,python::list&gt;())
-		.add_property(&quot;geomDispatcher&quot;,&amp;pyInteractionDispatchers::geomDispatcher_get)
-		.add_property(&quot;physDispatcher&quot;,&amp;pyInteractionDispatchers::physDispatcher_get)
-		.add_property(&quot;constLawDispatcher&quot;,&amp;pyInteractionDispatchers::constLawDispatcher_get)
-		TIMING_PROPS(pyInteractionDispatchers);
-	BASIC_PY_PROXY_WRAPPER(pyEngineUnit,&quot;EngineUnit&quot;)
-		.add_property(&quot;timingDeltas&quot;,&amp;pyEngineUnit::timingDeltas_get)
-		.add_property(&quot;bases&quot;,&amp;pyEngineUnit::bases_get);
-
-	#undef TIMING_PROPS
-
-	BASIC_PY_PROXY_WRAPPER(pyGeometricalModel,&quot;GeometricalModel&quot;);
-	BASIC_PY_PROXY_WRAPPER(pyInteractingGeometry,&quot;InteractingGeometry&quot;);
-	BASIC_PY_PROXY_WRAPPER(pyPhysicalParameters,&quot;PhysicalParameters&quot;)	
-		.add_property(&quot;blockedDOFs&quot;,&amp;pyPhysicalParameters::blockedDOFs_get,&amp;pyPhysicalParameters::blockedDOFs_set)
-		.add_property(&quot;pos&quot;,&amp;pyPhysicalParameters::pos_get,&amp;pyPhysicalParameters::pos_set)
-		.add_property(&quot;ori&quot;,&amp;pyPhysicalParameters::ori_get,&amp;pyPhysicalParameters::ori_set)
-		.add_property(&quot;refPos&quot;,&amp;pyPhysicalParameters::refPos_get,&amp;pyPhysicalParameters::refPos_set)
-		.add_property(&quot;displ&quot;,&amp;pyPhysicalParameters::displ_get)
-		.add_property(&quot;rot&quot;,&amp;pyPhysicalParameters::rot_get)
-		;
-	BASIC_PY_PROXY_WRAPPER(pyBoundingVolume,&quot;BoundingVolume&quot;);
-	BASIC_PY_PROXY_WRAPPER(pyInteractionGeometry,&quot;InteractionGeometry&quot;);
-	BASIC_PY_PROXY_WRAPPER(pyInteractionPhysics,&quot;InteractionPhysics&quot;);
-
-	BASIC_PY_PROXY_WRAPPER(pyGeneric,&quot;Generic&quot;);
-
-	BASIC_PY_PROXY_WRAPPER(pyBody,&quot;Body&quot;)
-		.add_property(&quot;shape&quot;,&amp;pyBody::shape_get,&amp;pyBody::shape_set)
-		.add_property(&quot;mold&quot;,&amp;pyBody::mold_get,&amp;pyBody::mold_set)
-		.add_property(&quot;bound&quot;,&amp;pyBody::bound_get,&amp;pyBody::bound_set)
-		.add_property(&quot;phys&quot;,&amp;pyBody::phys_get,&amp;pyBody::phys_set)
-		.add_property(&quot;dynamic&quot;,&amp;pyBody::dynamic_get,&amp;pyBody::dynamic_set)
-		.add_property(&quot;id&quot;,&amp;pyBody::id_get)
-		.add_property(&quot;mask&quot;,&amp;pyBody::mask_get,&amp;pyBody::mask_set)
-		.add_property(&quot;isStandalone&quot;,&amp;pyBody::isStandalone)
-		.add_property(&quot;isClumpMember&quot;,&amp;pyBody::isClumpMember)
-		.add_property(&quot;isClump&quot;,&amp;pyBody::isClump);
-
-	BASIC_PY_PROXY_WRAPPER(pyInteraction,&quot;Interaction&quot;)
-		.add_property(&quot;phys&quot;,&amp;pyInteraction::phys_get,&amp;pyInteraction::phys_set)
-		.add_property(&quot;geom&quot;,&amp;pyInteraction::geom_get,&amp;pyInteraction::geom_set)
-		.add_property(&quot;id1&quot;,&amp;pyInteraction::id1_get)
-		.add_property(&quot;id2&quot;,&amp;pyInteraction::id2_get)
-		.add_property(&quot;isReal&quot;,&amp;pyInteraction::isReal_get);
-
-	BASIC_PY_PROXY_WRAPPER(pyFileGenerator,&quot;Preprocessor&quot;)
-		.def(&quot;generate&quot;,&amp;pyFileGenerator::generate)
-		.def(&quot;load&quot;,&amp;pyFileGenerator::load);
-
-	boost::python::class_&lt;pySTLImporter&gt;(&quot;STLImporter&quot;)
-	    .def(&quot;open&quot;,&amp;pySTLImporter::open)
-	    .add_property(&quot;number_of_facets&quot;,&amp;pySTLImporter::number_of_facets)
-	    .def_readwrite(&quot;wire&quot;,&amp;pySTLImporter::wire)
-	    .def(&quot;import_geometry&quot;,&amp;pySTLImporter::py_import,STLImporter_import_overloads());
-	
-}
-

Modified: trunk/lib/SConscript
===================================================================
--- trunk/lib/SConscript	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/SConscript	2009-07-07 11:54:14 UTC (rev 1841)
@@ -6,36 +6,9 @@
 	env.Install('$PREFIX/lib/yade$SUFFIX/py/yade',[
 		env.SharedLibrary('WeightedAverage2d',['smoothing/WeightedAverage2d.cpp'],SHLIBPREFIX='',
 			LIBS=env['LIBS']+['yade-base']),
-		env.SharedLibrary('_eudoxos',['py/_eudoxos.cpp'],SHLIBPREFIX='',CXXFLAGS=env['CXXFLAGS']+([] if not os.path.exists('../../brefcom-mm.hh') else ['-include','../brefcom-mm.hh']),LIBS=env['LIBS']+['Shop','ConcretePM']),
-		env.SharedLibrary('log',['py/log.cpp'],SHLIBPREFIX=''),
-		env.SharedLibrary('_utils',['py/_utils.cpp'],SHLIBPREFIX='',LIBS=env['LIBS']+['Shop','ConcretePM']),
-		env.SharedLibrary('_packPredicates',['py/_packPredicates.cpp'],SHLIBPREFIX='',
-			# if we compile with GTS, link to the python module, as inGtsSurface uses some of its symbols.
-			# because the module doesn't have the lib- suffix, we put it directly to SHLINKFLAGS
-			# using the -l: syntax (see man ld) and declare the dependency below
-			SHLINKFLAGS=env['SHLINKFLAGS']+(['-l:$PREFIX/lib/yade$SUFFIX/py/gts/_gts.so'] if 'GTS' in env['features'] else [])),
-		env.SharedLibrary('_packSpheres',['py/_packSpheres.cpp'],SHLIBPREFIX='',LIBS=env['LIBS']+['Shop']),
-		env.File('utils.py','py'),
-		env.File('eudoxos.py','py'),
-		env.File('plot.py','py'),
-		env.File('linterpolation.py','py'),
-		env.File('timing.py','py'),
-		env.File('pack.py','py'),
-
 	])
-	# 3rd party modules:
-	# ==================
-	# do not install them under yade but to the top-level module path
-	# say e.g. 'import euclid' (not 'import  yade.euclid')
-	env.Install('$PREFIX/lib/yade$SUFFIX/py',[
-		env.File('euclid.py','py'),
-		# skip this for now
-		#env.SharedLibrary('miniWm3Wrap',['miniWm3Wrap.cpp'],SHLIBPREFIX='',CPPPATH=env['CPPPATH']+['.'])
-	])
 
 
-
-
 if 'qt3' not in env['exclude']:
 	env.Install('$PREFIX/lib/yade$SUFFIX/lib',[
 		env.SharedLibrary('yade-serialization-qt',

Deleted: trunk/lib/miniWm3Wrap-generate.py
===================================================================
--- trunk/lib/miniWm3Wrap-generate.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/miniWm3Wrap-generate.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,26 +0,0 @@
-import os, os.path
-from pyplusplus import module_builder
-from pyplusplus.decl_wrappers import *
-from pyplusplus.module_builder import call_policies
-
-
-#Creating an instance of class that will help you to expose your declarations
-mb = module_builder.module_builder_t( [os.path.abspath(&quot;miniWm3Wrap-toExpose.hpp&quot;)]
-                                      , working_directory=r&quot;.&quot;
-                                      , include_paths=['miniWm3','.']
-                                      , define_symbols=['USE_MINIWM3'] )
-# we don't need system things from wm3
-mb.decls(lambda decl: 'System' in decl.name).exclude() 
-#mb.decls(lambda decl: 'noexpose' in decl.name).exclude() 
-# exclude casting operators
-mb.decls(lambda decl: 'operator double' in decl.name).exclude()
-mb.member_functions(return_type='double &amp;').exclude()
-# we would have to do some magic here
-mb.member_functions(lambda decl: decl.name in ['ToAxisAngle','ToRotationMatrix']).exclude()
-mb.member_functions(lambda decl: decl.name in ['FromRotationMatrix','FromAxisAngle','Slerp','SlerpExtraSpins','Intermediate','Squad','Align']).exclude()
-#mb.member_function(meth).call_policies=call_policies.return_value_policy(call_policies.return_internal_reference)
-
-#mb.print_declarations()
-mb.build_code_creator(module_name='miniWm3Wrap')
-mb.write_module('miniWm3Wrap.cpp')
-

Deleted: trunk/lib/miniWm3Wrap-toExpose.hpp
===================================================================
--- trunk/lib/miniWm3Wrap-toExpose.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/miniWm3Wrap-toExpose.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,16 +0,0 @@
-//#include&lt;Wm3Vector3.h&gt;
-#include&lt;base/yadeWm3.hpp&gt;
-#include&lt;base/yadeWm3Extra.hpp&gt;
-// instantiate those types so that they are exposed
-// but name them noexpose_*, as we ask for exclusion of such things in the wrapper script
-
-//int i=sizeof(Vector3r);
-//int j=sizeof(Vector2r);
-//int k=sizeof(Quaternionr);
-
-Vector3r noexpose_v3r;
-Vector2r noexpose_v2r;
-Quaternionr noexpose_q;
-//Matrix3r m3r;
-
-

Deleted: trunk/lib/py/_eudoxos.cpp
===================================================================
--- trunk/lib/py/_eudoxos.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/_eudoxos.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,91 +0,0 @@
-#include&lt;yade/pkg-dem/ConcretePM.hpp&gt;
-#include&lt;boost/python.hpp&gt;
-#include&lt;yade/extra/boost_python_len.hpp&gt;
-using namespace boost::python;
-using namespace std;
-#ifdef LOG4CXX
-	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.eudoxos&quot;);
-#endif
-
-# if 0
-Real elasticEnergyDensityInAABB(python::tuple AABB){
-	Vector3r bbMin=tuple2vec(python::extract&lt;python::tuple&gt;(AABB[0])()), bbMax=tuple2vec(python::extract&lt;python::tuple&gt;(AABB[1])()); Vector3r box=bbMax-bbMin;
-	shared_ptr&lt;MetaBody&gt; rb=Omega::instance().getRootBody();
-	Real E=0;
-	FOREACH(const shared_ptr&lt;Interaction&gt;&amp;i, *rb-&gt;transientInteractions){
-		if(!i-&gt;interactionPhysics) continue;
-		shared_ptr&lt;CpmPhys&gt; bc=dynamic_pointer_cast&lt;CpmPhys&gt;(i-&gt;interactionPhysics); if(!bc) continue;
-		const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(i-&gt;getId1(),rb), b2=Body::byId(i-&gt;getId2(),rb);
-		bool isIn1=isInBB(b1-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax), isIn2=isInBB(b2-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax);
-		if(!isIn1 &amp;&amp; !isIn2) continue;
-		Real weight=1.;
-		if((!isIn1 &amp;&amp; isIn2) || (isIn1 &amp;&amp; !isIn2)){
-			//shared_ptr&lt;Body&gt; bIn=isIn1?b1:b2, bOut=isIn2?b2:b1;
-			Vector3r vIn=(isIn1?b1:b2)-&gt;physicalParameters-&gt;se3.position, vOut=(isIn2?b1:b2)-&gt;physicalParameters-&gt;se3.position;
-			#define _WEIGHT_COMPONENT(axis) if(vOut[axis]&lt;bbMin[axis]) weight=min(weight,abs((vOut[axis]-bbMin[axis])/(vOut[axis]-vIn[axis]))); else if(vOut[axis]&gt;bbMax[axis]) weight=min(weight,abs((vOut[axis]-bbMax[axis])/(vOut[axis]-vIn[axis])));
-			_WEIGHT_COMPONENT(0); _WEIGHT_COMPONENT(1); _WEIGHT_COMPONENT(2);
-			assert(weight&gt;=0 &amp;&amp; weight&lt;=1);
-		}
-		E+=.5*bc-&gt;E*bc-&gt;crossSection*pow(bc-&gt;epsN,2)+.5*bc-&gt;G*bc-&gt;crossSection*pow(bc-&gt;epsT.Length(),2);
-	}
-	return E/(box[0]*box[1]*box[2]);
-}
-#endif
-
-/* yield surface for the CPM model; this is used only to make yield surface plot from python, for debugging */
-Real yieldSigmaTMagnitude(Real sigmaN, int yieldSurfType=0){
-	#ifdef CPM_YIELD_SIGMA_T_MAGNITUDE
-		/* find first suitable interaction */
-		MetaBody* rootBody=Omega::instance().getRootBody().get();
-		shared_ptr&lt;Interaction&gt; I;
-		FOREACH(I, *rootBody-&gt;transientInteractions){
-			if(I-&gt;isReal()) break;
-		}
-		Real nan=std::numeric_limits&lt;Real&gt;::quiet_NaN();
-		if(!I-&gt;isReal()) {LOG_ERROR(&quot;No real interaction found, returning NaN!&quot;); return nan; }
-		CpmPhys* BC=dynamic_cast&lt;CpmPhys*&gt;(I-&gt;interactionPhysics.get());
-		if(!BC) {LOG_ERROR(&quot;Interaction physics is not CpmPhys instance, returning NaN!&quot;); return nan;}
-		const Real &amp;omega(BC-&gt;omega); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; tanFrictionAngle(BC-&gt;tanFrictionAngle);
-		const Real&amp; yieldLogSpeed(Law2_Dem3DofGeom_CpmPhys_Cpm::yieldLogSpeed); // const int&amp; yieldSurfType(Law2_Dem3DofGeom_CpmPhys_Cpm::yieldSurfType);
-		const Real&amp; yieldEllipseShift(Law2_Dem3DofGeom_CpmPhys_Cpm::yieldEllipseShift);
-		return CPM_YIELD_SIGMA_T_MAGNITUDE(sigmaN);
-	#else
-		LOG_FATAL(&quot;CPM model not available in this build.&quot;);
-		throw;
-	#endif
-}
-
-
-// copied from _utils.cpp
-Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(extract&lt;double&gt;(t[0])(),extract&lt;double&gt;(t[1])(),extract&lt;double&gt;(t[2])());}
-
-/*! Set velocity of all dynamic particles so that if their motion were unconstrained,
- * axis given by axisPoint and axisDirection would be reached in timeToAxis
- * (or, point at distance subtractDist from axis would be reached).
- *
- * The code is analogous to AxialGravityEngine and is intended to give initial motion
- * to particles subject to axial compaction to speed up the process. */
-void velocityTowardsAxis(const Vector3r&amp; axisPoint, const Vector3r&amp; axisDirection, Real timeToAxis, Real subtractDist=0., Real perturbation=0.1){
-	FOREACH(const shared_ptr&lt;Body&gt;&amp;b, *(Omega::instance().getRootBody()-&gt;bodies)){
-		if(!b-&gt;isDynamic) continue;
-		ParticleParameters* pp=YADE_CAST&lt;ParticleParameters*&gt;(b-&gt;physicalParameters.get());
-		const Vector3r&amp; x0=pp-&gt;se3.position;
-		const Vector3r&amp; x1=axisPoint;
-		const Vector3r x2=axisPoint+axisDirection;
-		Vector3r closestAxisPoint=(x2-x1) * /* t */ (-(x1-x0).Dot(x2-x1))/((x2-x1).SquaredLength());
-		Vector3r toAxis=closestAxisPoint-x0;
-		if(subtractDist&gt;0) toAxis*=(toAxis.Length()-subtractDist)/toAxis.Length();
-		pp-&gt;velocity=toAxis/timeToAxis;
-		Vector3r ppDiff=perturbation*(1./sqrt(3.))*Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom())*pp-&gt;velocity.Length();
-		pp-&gt;velocity+=ppDiff;
-	}
-}
-BOOST_PYTHON_FUNCTION_OVERLOADS(velocityTowardsAxis_overloads,velocityTowardsAxis,3,5);
-
-
-
-BOOST_PYTHON_MODULE(_eudoxos){
-	def(&quot;velocityTowardsAxis&quot;,velocityTowardsAxis,velocityTowardsAxis_overloads(args(&quot;axisPoint&quot;,&quot;axisDirection&quot;,&quot;timeToAxis&quot;,&quot;subtractDist&quot;,&quot;perturbation&quot;)));
-	def(&quot;yieldSigmaTMagnitude&quot;,yieldSigmaTMagnitude);
-}
-

Deleted: trunk/lib/py/_packPredicates.cpp
===================================================================
--- trunk/lib/py/_packPredicates.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/_packPredicates.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,348 +0,0 @@
-// 2009 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
-#include&lt;boost/python.hpp&gt;
-#include&lt;yade/extra/boost_python_len.hpp&gt;
-#include&lt;yade/lib-base/Logging.hpp&gt;
-#include&lt;yade/lib-base/yadeWm3.hpp&gt;
-#include&lt;yade/lib-base/yadeWm3Extra.hpp&gt;
-// #include&lt;yade/gui-py/_utils.hpp&gt; // will be: yade/lib-py/_utils.hpp&gt; at some point
-#include&lt;Wm3Vector3.h&gt;
-
-using namespace boost;
-using namespace std;
-#ifdef LOG4CXX
-	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.pack.predicates&quot;);
-#endif
-
-/*
-This file contains various predicates that say whether a given point is within the solid,
-or, not closer than &quot;pad&quot; to its boundary, if pad is nonzero
-Besides the (point,pad) operator, each predicate defines aabb() method that returns
-(min,max) tuple defining minimum and maximum point of axis-aligned bounding box 
-for the predicate.
-
-These classes are primarily used for yade.pack.* functions creating packings.
-See scripts/test/regular-sphere-pack.py for an example.
-
-*/
-
-// aux functions
-python::tuple vec2tuple(const Vector3r&amp; v){return boost::python::make_tuple(v[0],v[1],v[2]);}
-python::tuple vec2tuple(const Vector2r&amp; v){return boost::python::make_tuple(v[0],v[1]);}
-Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
-Vector2r tuple2vec2d(const python::tuple&amp; t){return Vector2r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])());}
-//void ttuple2vvec(const python::tuple&amp; t, Vector3r&amp; v1, Vector3r&amp; v2){ v1=tuple2vec(python::extract&lt;python::tuple&gt;(t[0])()); v2=tuple2vec(python::extract&lt;python::tuple&gt;(t[1])()); }
-void ttuple2vvec(const python::tuple&amp; t, Vector3r&amp; v1, Vector3r&amp; v2){ v1=python::extract&lt;Vector3r&gt;(t[0])(); v2=python::extract&lt;Vector3r&gt;(t[1])(); }
-python::tuple vvec2ttuple(const Vector3r&amp;v1, const Vector3r&amp;v2){ return python::make_tuple(v1,v2); }
-
-struct Predicate{
-	public:
-		virtual bool operator() (const Vector3r&amp; pt,Real pad=0.) const = 0;
-		virtual python::tuple aabb() const = 0;
-		Vector3r dim() const { Vector3r mn,mx; ttuple2vvec(aabb(),mn,mx); return mx-mn; }
-		Vector3r center() const { Vector3r mn,mx; ttuple2vvec(aabb(),mn,mx); return .5*(mn+mx); }
-};
-// make the pad parameter optional
-BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(PredicateCall_overloads,operator(),1,2);
-
-/* Since we want to make Predicate::operator() and Predicate::aabb() callable from c++ on python::object
-with the right virtual method resolution, we have to wrap the class in the following way. See 
-<A HREF="http://www.boost.org/doc/libs/1_38_0/libs/python/doc/tutorial/doc/html/python/exposing.html">http://www.boost.org/doc/libs/1_38_0/libs/python/doc/tutorial/doc/html/python/exposing.html</A> for documentation
-on exposing virtual methods.
-
-This makes it possible to derive a python class from Predicate, override its aabb() method, for instance,
-and use it in PredicateUnion, which will call the python implementation of aabb() as it should. This
-approach is used in the inGtsSurface class defined in pack.py.
-
-See scripts/test/gts-operators.py for an example.
-
-NOTE: you still have to call base class ctor in your class' ctor derived in python, e.g.
-super(inGtsSurface,self).__init__() so that virtual methods work as expected.
-*/
-struct PredicateWrap: Predicate, python::wrapper&lt;Predicate&gt;{
-	bool operator()(const Vector3r&amp; pt, Real pad=0.) const { return this-&gt;get_override(&quot;__call__&quot;)(pt,pad);}
-	python::tuple aabb() const { return this-&gt;get_override(&quot;aabb&quot;)(); }
-};
-// make the pad parameter optional
-BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(PredicateWrapCall_overloads,operator(),1,2);
-
-/*********************************************************************************
-****************** Boolean operations on predicates ******************************
-*********************************************************************************/
-
-const Predicate&amp; obj2pred(python::object obj){ return python::extract&lt;const Predicate&amp;&gt;(obj)();}
-
-class PredicateBoolean: public Predicate{
-	protected:
-		const python::object A,B;
-	public:
-		PredicateBoolean(const python::object _A, const python::object _B): A(_A), B(_B){}
-		const python::object getA(){ return A;}
-		const python::object getB(){ return B;}
-};
-
-// <A HREF="http://www.linuxtopia.org/online_books/programming_books/python_programming/python_ch16s03.html">http://www.linuxtopia.org/online_books/programming_books/python_programming/python_ch16s03.html</A>
-class PredicateUnion: public PredicateBoolean{
-	public:
-		PredicateUnion(const python::object _A, const python::object _B): PredicateBoolean(_A,_B){}
-		virtual bool operator()(const Vector3r&amp; pt,Real pad) const {return obj2pred(A)(pt,pad)||obj2pred(B)(pt,pad);}
-		virtual python::tuple aabb() const { Vector3r minA,maxA,minB,maxB; ttuple2vvec(obj2pred(A).aabb(),minA,maxA); ttuple2vvec(obj2pred(B).aabb(),minB,maxB); return vvec2ttuple(componentMinVector(minA,minB),componentMaxVector(maxA,maxB));}
-};
-PredicateUnion makeUnion(const python::object&amp; A, const python::object&amp; B){ return PredicateUnion(A,B);}
-
-class PredicateIntersection: public PredicateBoolean{
-	public:
-		PredicateIntersection(const python::object _A, const python::object _B): PredicateBoolean(_A,_B){}
-		virtual bool operator()(const Vector3r&amp; pt,Real pad) const {return obj2pred(A)(pt,pad) &amp;&amp; obj2pred(B)(pt,pad);}
-		virtual python::tuple aabb() const { Vector3r minA,maxA,minB,maxB; ttuple2vvec(obj2pred(A).aabb(),minA,maxA); ttuple2vvec(obj2pred(B).aabb(),minB,maxB); return vvec2ttuple(componentMaxVector(minA,minB),componentMinVector(maxA,maxB));}
-};
-PredicateIntersection makeIntersection(const python::object&amp; A, const python::object&amp; B){ return PredicateIntersection(A,B);}
-
-class PredicateDifference: public PredicateBoolean{
-	public:
-		PredicateDifference(const python::object _A, const python::object _B): PredicateBoolean(_A,_B){}
-		virtual bool operator()(const Vector3r&amp; pt,Real pad) const {return obj2pred(A)(pt,pad) &amp;&amp; !obj2pred(B)(pt,-pad);}
-		virtual python::tuple aabb() const { return obj2pred(A).aabb(); }
-};
-PredicateDifference makeDifference(const python::object&amp; A, const python::object&amp; B){ return PredicateDifference(A,B);}
-
-class PredicateSymmetricDifference: public PredicateBoolean{
-	public:
-		PredicateSymmetricDifference(const python::object _A, const python::object _B): PredicateBoolean(_A,_B){}
-		virtual bool operator()(const Vector3r&amp; pt,Real pad) const {bool inA=obj2pred(A)(pt,pad), inB=obj2pred(B)(pt,pad); return (inA &amp;&amp; !inB) || (!inA &amp;&amp; inB);}
-		virtual python::tuple aabb() const { Vector3r minA,maxA,minB,maxB; ttuple2vvec(obj2pred(A).aabb(),minA,maxA); ttuple2vvec(obj2pred(B).aabb(),minB,maxB); return vvec2ttuple(componentMinVector(minA,minB),componentMaxVector(maxA,maxB));}
-};
-PredicateSymmetricDifference makeSymmetricDifference(const python::object&amp; A, const python::object&amp; B){ return PredicateSymmetricDifference(A,B);}
-
-/*********************************************************************************
-****************************** Primitive predicates ******************************
-*********************************************************************************/
-
-
-/*! Sphere predicate */
-class inSphere: public Predicate {
-	Vector3r center; Real radius;
-public:
-	inSphere(const Vector3r&amp; _center, Real _radius){center=_center; radius=_radius;}
-	virtual bool operator()(const Vector3r&amp; pt, Real pad=0.) const { return ((pt-center).Length()-pad&lt;=radius-pad); }
-	virtual python::tuple aabb() const {return vvec2ttuple(Vector3r(center[0]-radius,center[1]-radius,center[2]-radius),Vector3r(center[0]+radius,center[1]+radius,center[2]+radius));}
-};
-
-/*! Axis-aligned box predicate */
-class inAlignedBox: public Predicate{
-	Vector3r mn, mx;
-public:
-	inAlignedBox(const Vector3r&amp; _mn, const Vector3r&amp; _mx): mn(_mn), mx(_mx) {}
-	virtual bool operator()(const Vector3r&amp; pt, Real pad=0.) const {
-		return
-			mn[0]+pad&lt;=pt[0] &amp;&amp; mx[0]-pad&gt;=pt[0] &amp;&amp;
-			mn[1]+pad&lt;=pt[1] &amp;&amp; mx[1]-pad&gt;=pt[1] &amp;&amp;
-			mn[2]+pad&lt;=pt[2] &amp;&amp; mx[2]-pad&gt;=pt[2];
-	}
-	virtual python::tuple aabb() const { return vvec2ttuple(mn,mx); }
-};
-
-/*! Arbitrarily oriented cylinder predicate */
-class inCylinder: public Predicate{
-	Vector3r c1,c2,c12; Real radius,ht;
-public:
-	inCylinder(const Vector3r&amp; _c1, const Vector3r&amp; _c2, Real _radius){c1=_c1; c2=_c2; c12=c2-c1; radius=_radius; ht=c12.Length(); }
-	bool operator()(const Vector3r&amp; pt, Real pad=0.) const {
-		Real u=(pt.Dot(c12)-c1.Dot(c12))/(ht*ht); // normalized coordinate along the c1--c2 axis
-		if((u*ht&lt;0+pad) || (u*ht&gt;ht-pad)) return false; // out of cylinder along the axis
-		Real axisDist=((pt-c1).Cross(pt-c2)).Length()/ht;
-		if(axisDist&gt;radius-pad) return false;
-		return true;
-	}
-	python::tuple aabb() const {
-		// see <A HREF="http://www.gamedev.net/community/forums/topic.asp?topic_id=338522&amp;forum_id=20&amp;gforum_id=0">http://www.gamedev.net/community/forums/topic.asp?topic_id=338522&amp;forum_id=20&amp;gforum_id=0</A> for the algorithm
-		const Vector3r&amp; A(c1); const Vector3r&amp; B(c2); 
-		Vector3r k(
-			sqrt((pow(A[1]-B[1],2)+pow(A[2]-B[2],2)))/ht,
-			sqrt((pow(A[0]-B[0],2)+pow(A[2]-B[2],2)))/ht,
-			sqrt((pow(A[0]-B[0],2)+pow(A[1]-B[1],2)))/ht);
-		Vector3r mn=componentMinVector(A,B), mx=componentMaxVector(A,B);
-		return vvec2ttuple(mn-radius*k,mx+radius*k);
-	}
-};
-
-/*! Oriented hyperboloid predicate (cylinder as special case).
-
-See <A HREF="http://mathworld.wolfram.com/Hyperboloid.html">http://mathworld.wolfram.com/Hyperboloid.html</A> for the parametrization and meaning of symbols
-*/
-class inHyperboloid: public Predicate{
-	Vector3r c1,c2,c12; Real R,a,ht,c;
-public:
-	inHyperboloid(const Vector3r&amp; _c1, const Vector3r&amp; _c2, Real _R, Real _r){
-		c1=_c1; c2=_c2; R=_R; a=_r;
-		c12=c2-c1; ht=c12.Length();
-		Real uMax=sqrt(pow(R/a,2)-1); c=ht/(2*uMax);
-	}
-	// WARN: this is not accurate, since padding is taken as perpendicular to the axis, not the the surface
-	bool operator()(const Vector3r&amp; pt, Real pad=0.) const {
-		Real v=(pt.Dot(c12)-c1.Dot(c12))/(ht*ht); // normalized coordinate along the c1--c2 axis
-		if((v*ht&lt;0+pad) || (v*ht&gt;ht-pad)) return false; // out of cylinder along the axis
-		Real u=(v-.5)*ht/c; // u from the wolfram parametrization; u is 0 in the center
-		Real rHere=a*sqrt(1+u*u); // pad is taken perpendicular to the axis, not to the surface (inaccurate)
-		Real axisDist=((pt-c1).Cross(pt-c2)).Length()/ht;
-		if(axisDist&gt;rHere-pad) return false;
-		return true;
-	}
-	python::tuple aabb() const {
-		// the lazy way
-		return inCylinder(c1,c2,R).aabb();
-	}
-};
-
-/*! Axis-aligned ellipsoid predicate */
-class inEllipsoid: public Predicate{
-	Vector3r c, abc;
-public:
-	inEllipsoid(const Vector3r&amp; _c, const Vector3r&amp; _abc) {c=_c; abc=_abc;}
-	bool operator()(const Vector3r&amp; pt, Real pad=0.) const {
-		//Define the ellipsoid X-coordinate of given Y and Z
-		Real x = sqrt((1-pow((pt[1]-c[1]),2)/((abc[1]-pad)*(abc[1]-pad))-pow((pt[2]-c[2]),2)/((abc[2]-pad)*(abc[2]-pad)))*((abc[0]-pad)*(abc[0]-pad)))+c[0]; 
-		Vector3r edgeEllipsoid(x,pt[1],pt[2]); // create a vector of these 3 coordinates
-		//check whether given coordinates lie inside ellipsoid or not
-		if ((pt-c).Length()&lt;=(edgeEllipsoid-c).Length()) return true;
-		else return false;
-	}
-	python::tuple aabb() const {
-		const Vector3r&amp; center(c); const Vector3r&amp; ABC(abc);
-		return vvec2ttuple(Vector3r(center[0]-ABC[0],center[1]-ABC[1],center[2]-ABC[2]),Vector3r(center[0]+ABC[0],center[1]+ABC[1],center[2]+ABC[2]));
-	}
-};
-
-/*! Negative notch predicate.
-
-Use intersection (&amp; operator) of another predicate with notInNotch to create notched solid.
-
-
-		
-		geometry explanation:
-		
-			c: the center
-			normalHalfHt (in constructor): A-C
-			inside: perpendicular to notch edge, points inside the notch (unit vector)
-			normal: perpendicular to inside, perpendicular to both notch planes
-			edge: unit vector in the direction of the edge
-
-		          &#8593; distUp        A
-		-------------------------
-		                        | C
-		         inside(unit) &#8592; * &#8594; distInPlane
-		                        |
-		-------------------------
-		          &#8595; distDown      B
-
-*/
-class notInNotch: public Predicate{
-	Vector3r c, edge, normal, inside; Real aperture;
-public:
-	notInNotch(const Vector3r&amp; _c, const Vector3r&amp; _edge, const Vector3r&amp; _normal, Real _aperture){
-		c=_c;
-		edge=_edge; edge.Normalize();
-		normal=_normal; normal-=edge*edge.Dot(normal); normal.Normalize();
-		inside=edge.Cross(normal);
-		aperture=_aperture;
-		// LOG_DEBUG(&quot;edge=&quot;&lt;&lt;edge&lt;&lt;&quot;, normal=&quot;&lt;&lt;normal&lt;&lt;&quot;, inside=&quot;&lt;&lt;inside&lt;&lt;&quot;, aperture=&quot;&lt;&lt;aperture);
-	}
-	bool operator()(const Vector3r&amp; pt, Real pad=0.) const {
-		Real distUp=normal.Dot(pt-c)-aperture/2, distDown=-normal.Dot(pt-c)-aperture/2, distInPlane=-inside.Dot(pt-c);
-		// LOG_DEBUG(&quot;pt=&quot;&lt;&lt;pt&lt;&lt;&quot;, distUp=&quot;&lt;&lt;distUp&lt;&lt;&quot;, distDown=&quot;&lt;&lt;distDown&lt;&lt;&quot;, distInPlane=&quot;&lt;&lt;distInPlane);
-		if(distInPlane&gt;=pad) return true;
-		if(distUp     &gt;=pad) return true;
-		if(distDown   &gt;=pad) return true;
-		if(distInPlane&lt;0) return false;
-		if(distUp  &gt;0) return sqrt(pow(distInPlane,2)+pow(distUp,2))&gt;=pad;
-		if(distDown&gt;0) return sqrt(pow(distInPlane,2)+pow(distUp,2))&gt;=pad;
-		// between both notch planes, closer to the edge than pad (distInPlane&lt;pad)
-		return false;
-	}
-	// This predicate is not bounded, return infinities
-	python::tuple aabb() const {
-		Real inf=std::numeric_limits&lt;Real&gt;::infinity();
-		return vvec2ttuple(Vector3r(-inf,-inf,-inf),Vector3r(inf,inf,inf));
-	}
-};
-
-#ifdef YADE_GTS
-extern &quot;C&quot; {
-#include&lt;yade/lib-py/pygts.h&gt;
-}
-/* Helper function for inGtsSurface::aabb() */
-static void vertex_aabb(GtsVertex *vertex, pair&lt;Vector3r,Vector3r&gt; *bb)
-{
-	GtsPoint *_p=GTS_POINT(vertex);
-	Vector3r p(_p-&gt;x,_p-&gt;y,_p-&gt;z);
-	bb-&gt;first=componentMinVector(bb-&gt;first,p);
-	bb-&gt;second=componentMaxVector(bb-&gt;second,p);
-}
-
-/*
-This class plays tricks getting aroung pyGTS to get GTS objects and cache bb tree to speed
-up point inclusion tests. For this reason, we have to link with _gts.so (see corresponding
-SConscript file), which is at the same time the python module.
-*/
-class inGtsSurface: public Predicate{
-	python::object pySurf; // to hold the reference so that surf is valid
-	GtsSurface *surf;
-	bool is_open, noPad, noPadWarned;
-	GNode* tree;
-public:
-	inGtsSurface(python::object _surf, bool _noPad=false): pySurf(_surf), noPad(_noPad), noPadWarned(false) {
-		if(!pygts_surface_check(_surf.ptr())) throw invalid_argument(&quot;Ctor must receive a gts.Surface() instance.&quot;); 
-		surf=PYGTS_SURFACE_AS_GTS_SURFACE(PYGTS_SURFACE(_surf.ptr()));
-	 	if(!gts_surface_is_closed(surf)) throw invalid_argument(&quot;Surface is not closed.&quot;);
-		is_open=gts_surface_volume(surf)&lt;0.;
-		if((tree=gts_bb_tree_surface(surf))==NULL) throw runtime_error(&quot;Could not create GTree.&quot;);
-	}
-	~inGtsSurface(){g_node_destroy(tree);}
-	python::tuple aabb() const {
-		Real inf=std::numeric_limits&lt;Real&gt;::infinity();
-		pair&lt;Vector3r,Vector3r&gt; bb; bb.first=Vector3r(inf,inf,inf); bb.second=Vector3r(-inf,-inf,-inf);
-		gts_surface_foreach_vertex(surf,(GtsFunc)vertex_aabb,&amp;bb);
-		return vvec2ttuple(bb.first,bb.second);
-	}
-	bool ptCheck(const Vector3r&amp; pt) const{
-		GtsPoint gp; gp.x=pt[0]; gp.y=pt[1]; gp.z=pt[2];
-		return (bool)gts_point_is_inside_surface(&amp;gp,tree,is_open);
-	}
-	bool operator()(const Vector3r&amp; pt, Real pad=0.) const {
-		if(noPad){
-			if(pad!=0. &amp;&amp; noPadWarned) LOG_WARN(&quot;inGtsSurface constructed with noPad; requested non-zero pad set to zero.&quot;);
-			return ptCheck(pt);
-		}
-		return ptCheck(pt) &amp;&amp; ptCheck(pt-Vector3r(pad,0,0)) &amp;&amp; ptCheck(pt+Vector3r(pad,0,0)) &amp;&amp; ptCheck(pt-Vector3r(0,pad,0))&amp;&amp; ptCheck(pt+Vector3r(0,pad,0)) &amp;&amp; ptCheck(pt-Vector3r(0,0,pad))&amp;&amp; ptCheck(pt+Vector3r(0,0,pad));
-	}
-};
-
-#endif
-
-BOOST_PYTHON_MODULE(_packPredicates){
-
-	// base predicate class
-	python::class_&lt;PredicateWrap,/* necessary, as methods are pure virtual*/ boost::noncopyable&gt;(&quot;Predicate&quot;)
-		.def(&quot;__call__&quot;,python::pure_virtual(&amp;Predicate::operator()))
-		.def(&quot;aabb&quot;,python::pure_virtual(&amp;Predicate::aabb))
-		.def(&quot;dim&quot;,&amp;Predicate::dim)
-		.def(&quot;center&quot;,&amp;Predicate::center)
-		.def(&quot;__or__&quot;,makeUnion).def(&quot;__and__&quot;,makeIntersection).def(&quot;__sub__&quot;,makeDifference).def(&quot;__xor__&quot;,makeSymmetricDifference);
-	// boolean operations
-	python::class_&lt;PredicateBoolean,python::bases&lt;Predicate&gt;,boost::noncopyable&gt;(&quot;PredicateBoolean&quot;,&quot;Boolean operation on 2 predicates (abstract class)&quot;,python::no_init)
-		.add_property(&quot;A&quot;,&amp;PredicateBoolean::getA).add_property(&quot;B&quot;,&amp;PredicateBoolean::getB);
-	python::class_&lt;PredicateUnion,python::bases&lt;PredicateBoolean&gt; &gt;(&quot;PredicateUnion&quot;,&quot;Union of 2 predicates&quot;,python::init&lt;python::object,python::object&gt;());
-	python::class_&lt;PredicateIntersection,python::bases&lt;PredicateBoolean&gt; &gt;(&quot;PredicateIntersection&quot;,&quot;Intersection of 2 predicates&quot;,python::init&lt;python::object,python::object &gt;());
-	python::class_&lt;PredicateDifference,python::bases&lt;PredicateBoolean&gt; &gt;(&quot;PredicateDifference&quot;,&quot;Difference of 2 predicates&quot;,python::init&lt;python::object,python::object &gt;());
-	python::class_&lt;PredicateSymmetricDifference,python::bases&lt;PredicateBoolean&gt; &gt;(&quot;PredicateSymmetricDifference&quot;,&quot;SymmetricDifference of 2 predicates&quot;,python::init&lt;python::object,python::object &gt;());
-	// primitive predicates
-	python::class_&lt;inSphere,python::bases&lt;Predicate&gt; &gt;(&quot;inSphere&quot;,&quot;Sphere predicate.&quot;,python::init&lt;const Vector3r&amp;,Real&gt;(python::args(&quot;center&quot;,&quot;radius&quot;),&quot;Ctor taking center (as a 3-tuple) and radius&quot;));
-	python::class_&lt;inAlignedBox,python::bases&lt;Predicate&gt; &gt;(&quot;inAlignedBox&quot;,&quot;Axis-aligned box predicate&quot;,python::init&lt;const Vector3r&amp;,const Vector3r&amp;&gt;(python::args(&quot;minAABB&quot;,&quot;maxAABB&quot;),&quot;Ctor taking minumum and maximum points of the box (as 3-tuples).&quot;));
-	python::class_&lt;inCylinder,python::bases&lt;Predicate&gt; &gt;(&quot;inCylinder&quot;,&quot;Cylinder predicate&quot;,python::init&lt;const Vector3r&amp;,const Vector3r&amp;,Real&gt;(python::args(&quot;centerBottom&quot;,&quot;centerTop&quot;,&quot;radius&quot;),&quot;Ctor taking centers of the lateral walls (as 3-tuples) and radius.&quot;));
-	python::class_&lt;inHyperboloid,python::bases&lt;Predicate&gt; &gt;(&quot;inHyperboloid&quot;,&quot;Hyperboloid predicate&quot;,python::init&lt;const Vector3r&amp;,const Vector3r&amp;,Real,Real&gt;(python::args(&quot;centerBottom&quot;,&quot;centerTop&quot;,&quot;radius&quot;,&quot;skirt&quot;),&quot;Ctor taking centers of the lateral walls (as 3-tuples), radius at bases and skirt (middle radius).&quot;));
-	python::class_&lt;inEllipsoid,python::bases&lt;Predicate&gt; &gt;(&quot;inEllipsoid&quot;,&quot;Ellipsoid predicate&quot;,python::init&lt;const Vector3r&amp;,const Vector3r&amp;&gt;(python::args(&quot;centerPoint&quot;,&quot;abc&quot;),&quot;Ctor taking center of the ellipsoid (3-tuple) and its 3 radii (3-tuple).&quot;));
-	python::class_&lt;notInNotch,python::bases&lt;Predicate&gt; &gt;(&quot;notInNotch&quot;,&quot;Outside of infinite, rectangle-shaped notch predicate&quot;,python::init&lt;const Vector3r&amp;,const Vector3r&amp;,const Vector3r&amp;,Real&gt;(python::args(&quot;centerPoint&quot;,&quot;edge&quot;,&quot;normal&quot;,&quot;aperture&quot;),&quot;Ctor taking point in the symmetry plane, vector pointing along the edge, plane normal and aperture size.\nThe side inside the notch is edge&#215;normal.\nNormal is made perpendicular to the edge.\nAll vectors are normalized at construction time.&quot;)); 
-	#ifdef YADE_GTS
-		python::class_&lt;inGtsSurface,python::bases&lt;Predicate&gt; &gt;(&quot;inGtsSurface&quot;,&quot;GTS surface predicate&quot;,python::init&lt;python::object,python::optional&lt;bool&gt; &gt;(python::args(&quot;surface&quot;,&quot;noPad&quot;),&quot;Ctor taking a gts.Surface() instance, which must not be modified during instance lifetime.\nThe optional noPad can disable padding (if set to True), which speeds up calls several times.\nNote: padding checks inclusion of 6 points along +- cardinal directions in the pad distance from given point, which is not exact.&quot;));
-	#endif
-}
-

Deleted: trunk/lib/py/_packSpheres.cpp
===================================================================
--- trunk/lib/py/_packSpheres.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/_packSpheres.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,143 +0,0 @@
-// 2009 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
-#include&lt;boost/python.hpp&gt;
-#include&lt;yade/extra/boost_python_len.hpp&gt;
-#include&lt;yade/lib-base/Logging.hpp&gt;
-#include&lt;yade/lib-base/yadeWm3.hpp&gt;
-#include&lt;yade/lib-base/yadeWm3Extra.hpp&gt;
-// #include&lt;yade/gui-py/_utils.hpp&gt; // will be: yade/lib-py/_utils.hpp&gt; at some point
-#include&lt;Wm3Vector3.h&gt;
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/core/MetaBody.hpp&gt;
-#include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
-
-#include&lt;yade/extra/Shop.hpp&gt;
-
-using namespace boost;
-using namespace std;
-#ifdef LOG4CXX
-	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.pack.spheres&quot;);
-#endif
-
-// copied from _packPredicates.cpp :-(
-python::tuple vec2tuple(const Vector3r&amp; v){return boost::python::make_tuple(v[0],v[1],v[2]);}
-Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
-Vector3r tuple2vec(python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
-
-struct SpherePack{
-	struct Sph{ Vector3r c; Real r; Sph(const Vector3r&amp; _c, Real _r): c(_c), r(_r){};
-		python::tuple asTuple() const { return python::make_tuple(c,r); }
-	};
-	vector&lt;Sph&gt; pack;
-	SpherePack(){};
-	SpherePack(const python::list&amp; l){ fromList(l); }
-	// add single sphere
-	void add(const Vector3r&amp; c, Real r){ pack.push_back(Sph(c,r)); }
-	// I/O
-	void fromList(const python::list&amp; l);
-	python::list toList() const;
-	void fromFile(const string file);
-	void toFile(const string file) const;
-	void fromSimulation();
-	// spatial characteristics
-	Vector3r dim() const {Vector3r mn,mx; aabb(mn,mx); return mx-mn;}
-	python::tuple aabb_py() const { Vector3r mn,mx; aabb(mn,mx); return python::make_tuple(mn,mx); }
-	void aabb(Vector3r&amp; mn, Vector3r&amp; mx) const {
-		Real inf=std::numeric_limits&lt;Real&gt;::infinity(); mn=Vector3r(inf,inf,inf); mx=Vector3r(-inf,-inf,-inf);
-		FOREACH(const Sph&amp; s, pack){ Vector3r r(s.r,s.r,s.r); mn=componentMinVector(mn,s.c-r); mx=componentMaxVector(mx,s.c+r);}
-	}
-	Vector3r midPt() const {Vector3r mn,mx; aabb(mn,mx); return .5*(mn+mx);}
-	Real relDensity() const {
-		Real sphVol=0; Vector3r dd=dim();
-		FOREACH(const Sph&amp; s, pack) sphVol+=pow(s.r,3);
-		sphVol*=(4/3.)*Mathr::PI;
-		return sphVol/(dd[0]*dd[1]*dd[2]);
-	}
-	// transformations
-	void translate(const Vector3r&amp; shift){ FOREACH(Sph&amp; s, pack) s.c+=shift; }
-	void rotate(const Vector3r&amp; axis, Real angle){ Vector3r mid=midPt(); Quaternionr q(axis,angle); FOREACH(Sph&amp; s, pack) s.c=q*(s.c-mid)+mid; }
-	void scale(Real scale){ Vector3r mid=midPt(); FOREACH(Sph&amp; s, pack) {s.c=scale*(s.c-mid)+mid; s.r*=abs(scale); } }
-	// iteration 
-	size_t len() const{ return pack.size(); }
-	python::tuple getitem(size_t idx){ if(idx&lt;0 || idx&gt;=pack.size()) throw runtime_error(&quot;Index &quot;+lexical_cast&lt;string&gt;(idx)+&quot; out of range 0..&quot;+lexical_cast&lt;string&gt;(pack.size()-1)); return pack[idx].asTuple(); }
-	struct iterator{
-		const SpherePack&amp; sPack; size_t pos;
-		iterator(const SpherePack&amp; _sPack): sPack(_sPack), pos(0){}
-		iterator iter(){ return *this;}
-		python::tuple next(){
-			if(pos==sPack.pack.size()-1){ PyErr_SetNone(PyExc_StopIteration); python::throw_error_already_set(); }
-			return sPack.pack[pos++].asTuple();
-		}
-	};
-	SpherePack::iterator getIterator() const{ return SpherePack::iterator(*this);};
-};
-
-void SpherePack::fromList(const python::list&amp; l){
-	pack.clear();
-	size_t len=python::len(l);
-	for(size_t i=0; i&lt;len; i++){
-		const python::tuple&amp; t=python::extract&lt;python::tuple&gt;(l[i]);
-		const Vector3r t0=python::extract&lt;Vector3r&gt;(t[0]);
-		pack.push_back(Sph(t0,python::extract&lt;double&gt;(t[1])));
-	}
-};
-
-python::list SpherePack::toList() const {
-	python::list ret;
-	FOREACH(const Sph&amp; s, pack) ret.append(python::make_tuple(s.c,s.r));
-	return ret;
-};
-
-void SpherePack::fromFile(string file) {
-	typedef pair&lt;Vector3r,Real&gt; pairVector3rReal;
-	vector&lt;pairVector3rReal&gt; ss;
-	Vector3r mn,mx;
-	ss=Shop::loadSpheresFromFile(file,mn,mx);
-	pack.clear();
-	FOREACH(const pairVector3rReal&amp; s, ss) pack.push_back(Sph(s.first,s.second));
-}
-
-void SpherePack::toFile(const string fname) const {
-	ofstream f(fname.c_str());
-	if(!f.good()) throw runtime_error(&quot;Unable to open file `&quot;+fname+&quot;'&quot;);
-	FOREACH(const Sph&amp; s, pack) f&lt;&lt;s.c[0]&lt;&lt;&quot; &quot;&lt;&lt;s.c[1]&lt;&lt;&quot; &quot;&lt;&lt;s.c[2]&lt;&lt;&quot; &quot;&lt;&lt;s.r&lt;&lt;endl;
-	f.close();
-};
-
-void SpherePack::fromSimulation() {
-	pack.clear();
-	MetaBody* rootBody=Omega::instance().getRootBody().get();
-	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *rootBody-&gt;bodies){
-		shared_ptr&lt;InteractingSphere&gt;	intSph=dynamic_pointer_cast&lt;InteractingSphere&gt;(b-&gt;interactingGeometry);
-		if(!intSph) continue;
-		pack.push_back(Sph(b-&gt;physicalParameters-&gt;se3.position,intSph-&gt;radius));
-	}
-}
-
-
-
-BOOST_PYTHON_MODULE(_packSpheres){
-	python::class_&lt;SpherePack&gt;(&quot;SpherePack&quot;,&quot;Set of spheres as centers and radii&quot;,python::init&lt;python::optional&lt;python::list&gt; &gt;(python::args(&quot;list&quot;),&quot;Empty constructor, optionally taking list [ ((cx,cy,cz),r), &#8230; ] for initial data.&quot; ))
-		.def(&quot;add&quot;,&amp;SpherePack::add,&quot;Add single sphere to packing, given center as 3-tuple and radius&quot;)
-		.def(&quot;toList&quot;,&amp;SpherePack::toList,&quot;Return packing data as python list.&quot;)
-		.def(&quot;fromList&quot;,&amp;SpherePack::fromList,&quot;Make packing from given list, same format as for constructor. Discards current data.&quot;)
-		.def(&quot;load&quot;,&amp;SpherePack::fromFile,&quot;Load packing from external text file (current data will be discarded).&quot;)
-		.def(&quot;save&quot;,&amp;SpherePack::toFile,&quot;Save packing to external text file (will be overwritten).&quot;)
-		.def(&quot;fromSimulation&quot;,&amp;SpherePack::fromSimulation,&quot;Make packing corresponding to the current simulation. Discards current data.&quot;)
-		.def(&quot;aabb&quot;,&amp;SpherePack::aabb_py,&quot;Get axis-aligned bounding box coordinates, as 2 3-tuples.&quot;)
-		.def(&quot;dim&quot;,&amp;SpherePack::dim,&quot;Return dimensions of the packing in terms of aabb(), as a 3-tuple.&quot;)
-		.def(&quot;center&quot;,&amp;SpherePack::midPt,&quot;Return coordinates of the bounding box center.&quot;)
-		.def(&quot;relDensity&quot;,&amp;SpherePack::relDensity,&quot;Relative packing density, measured as sum of spheres' volumes / aabb volume.\n(Sphere overlaps are ignored.)&quot;)
-		.def(&quot;translate&quot;,&amp;SpherePack::translate,&quot;Translate all spheres by given vector.&quot;)
-		.def(&quot;rotate&quot;,&amp;SpherePack::rotate,&quot;Rotate all spheres around packing center (in terms of aabb()), given axis and angle of the rotation.&quot;)
-		.def(&quot;scale&quot;,&amp;SpherePack::scale,&quot;Scale the packing around its center (in terms of aabb()) by given factor (may be negative).&quot;)
-		.def(&quot;__len__&quot;,&amp;SpherePack::len,&quot;Get number of spheres in the packing&quot;)
-		.def(&quot;__getitem__&quot;,&amp;SpherePack::getitem,&quot;Get entry at given index, as tuple of center and radius.&quot;)
-		.def(&quot;__iter__&quot;,&amp;SpherePack::getIterator,&quot;Return iterator over spheres.&quot;)
-		;
-	python::class_&lt;SpherePack::iterator&gt;(&quot;SpherePackIterator&quot;,python::init&lt;SpherePack::iterator&amp;&gt;())
-		.def(&quot;__iter__&quot;,&amp;SpherePack::iterator::iter)
-		.def(&quot;next&quot;,&amp;SpherePack::iterator::next)
-	;
-}
-

Deleted: trunk/lib/py/_utils.cpp
===================================================================
--- trunk/lib/py/_utils.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/_utils.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,432 +0,0 @@
-#include&lt;yade/extra/Shop.hpp&gt;
-#include&lt;boost/python.hpp&gt;
-#include&lt;yade/extra/boost_python_len.hpp&gt;
-#include&lt;yade/core/MetaBody.hpp&gt;
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/pkg-common/Sphere.hpp&gt;
-#include&lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
-#include&lt;yade/pkg-dem/DemXDofGeom.hpp&gt;
-#include&lt;yade/pkg-dem/SimpleViscoelasticBodyParameters.hpp&gt;
-#include&lt;yade/pkg-common/NormalShearInteractions.hpp&gt;
-#include&lt;yade/lib-computational-geometry/Hull2d.hpp&gt;
-#include&lt;cmath&gt;
-
-#include&lt;numpy/ndarrayobject.h&gt;
-
-// #include&quot;_utils.hpp&quot;
-
-
-
-using namespace boost::python;
-
-#ifdef LOG4CXX
-	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.utils&quot;);
-#endif
-
-python::tuple vec2tuple(const Vector3r&amp; v){return boost::python::make_tuple(v[0],v[1],v[2]);}
-Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(extract&lt;double&gt;(t[0])(),extract&lt;double&gt;(t[1])(),extract&lt;double&gt;(t[2])());}
-bool isInBB(Vector3r p, Vector3r bbMin, Vector3r bbMax){return p[0]&gt;bbMin[0] &amp;&amp; p[0]&lt;bbMax[0] &amp;&amp; p[1]&gt;bbMin[1] &amp;&amp; p[1]&lt;bbMax[1] &amp;&amp; p[2]&gt;bbMin[2] &amp;&amp; p[2]&lt;bbMax[2];}
-
-bool ptInAABB(python::tuple p, python::tuple bbMin, python::tuple bbMax){return isInBB(tuple2vec(p),tuple2vec(bbMin),tuple2vec(bbMax));}
-
-/* \todo implement groupMask */
-python::tuple aabbExtrema(Real cutoff=0.0, bool centers=false){
-	if(cutoff&lt;0. || cutoff&gt;1.) throw invalid_argument(&quot;Cutoff must be &gt;=0 and &lt;=1.&quot;);
-	Real inf=std::numeric_limits&lt;Real&gt;::infinity();
-	Vector3r minimum(inf,inf,inf),maximum(-inf,-inf,-inf);
-	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
-		shared_ptr&lt;Sphere&gt; s=dynamic_pointer_cast&lt;Sphere&gt;(b-&gt;geometricalModel); if(!s) continue;
-		Vector3r rrr(s-&gt;radius,s-&gt;radius,s-&gt;radius);
-		minimum=componentMinVector(minimum,b-&gt;physicalParameters-&gt;se3.position-(centers?Vector3r::ZERO:rrr));
-		maximum=componentMaxVector(maximum,b-&gt;physicalParameters-&gt;se3.position+(centers?Vector3r::ZERO:rrr));
-	}
-	Vector3r dim=maximum-minimum;
-	return python::make_tuple(minimum+.5*cutoff*dim,maximum-.5*cutoff*dim);
-}
-BOOST_PYTHON_FUNCTION_OVERLOADS(aabbExtrema_overloads,aabbExtrema,0,2);
-
-python::tuple negPosExtremeIds(int axis, Real distFactor=1.1){
-	python::tuple extrema=aabbExtrema();
-	Real minCoord=extract&lt;double&gt;(extrema[0][axis])(),maxCoord=extract&lt;double&gt;(extrema[1][axis])();
-	python::list minIds,maxIds;
-	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
-		shared_ptr&lt;Sphere&gt; s=dynamic_pointer_cast&lt;Sphere&gt;(b-&gt;geometricalModel); if(!s) continue;
-		if(b-&gt;physicalParameters-&gt;se3.position[axis]-s-&gt;radius*distFactor&lt;=minCoord) minIds.append(b-&gt;getId());
-		if(b-&gt;physicalParameters-&gt;se3.position[axis]+s-&gt;radius*distFactor&gt;=maxCoord) maxIds.append(b-&gt;getId());
-	}
-	return python::make_tuple(minIds,maxIds);
-}
-BOOST_PYTHON_FUNCTION_OVERLOADS(negPosExtremeIds_overloads,negPosExtremeIds,1,2);
-
-python::tuple coordsAndDisplacements(int axis,python::tuple AABB=python::tuple()){
-	Vector3r bbMin(Vector3r::ZERO), bbMax(Vector3r::ZERO); bool useBB=python::len(AABB)&gt;0;
-	if(useBB){bbMin=extract&lt;Vector3r&gt;(AABB[0])();bbMax=extract&lt;Vector3r&gt;(AABB[1])();}
-	python::list retCoord,retDispl;
-	FOREACH(const shared_ptr&lt;Body&gt;&amp;b, *Omega::instance().getRootBody()-&gt;bodies){
-		if(useBB &amp;&amp; !isInBB(b-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax)) continue;
-		retCoord.append(b-&gt;physicalParameters-&gt;se3.position[axis]);
-		retDispl.append(b-&gt;physicalParameters-&gt;se3.position[axis]-b-&gt;physicalParameters-&gt;refSe3.position[axis]);
-	}
-	return python::make_tuple(retCoord,retDispl);
-}
-BOOST_PYTHON_FUNCTION_OVERLOADS(coordsAndDisplacements_overloads,coordsAndDisplacements,1,2);
-
-void setRefSe3(){
-	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
-		b-&gt;physicalParameters-&gt;refSe3.position=b-&gt;physicalParameters-&gt;se3.position;
-		b-&gt;physicalParameters-&gt;refSe3.orientation=b-&gt;physicalParameters-&gt;se3.orientation;
-	}
-}
-
-Real PWaveTimeStep(){return Shop::PWaveTimeStep();};
-
-Real elasticEnergyInAABB(python::tuple AABB){
-	Vector3r bbMin=extract&lt;Vector3r&gt;(AABB[0])(), bbMax=extract&lt;Vector3r&gt;(AABB[1])();
-	shared_ptr&lt;MetaBody&gt; rb=Omega::instance().getRootBody();
-	Real E=0;
-	FOREACH(const shared_ptr&lt;Interaction&gt;&amp;i, *rb-&gt;transientInteractions){
-		if(!i-&gt;interactionPhysics) continue;
-		shared_ptr&lt;NormalShearInteraction&gt; bc=dynamic_pointer_cast&lt;NormalShearInteraction&gt;(i-&gt;interactionPhysics); if(!bc) continue;
-		shared_ptr&lt;Dem3DofGeom&gt; geom=dynamic_pointer_cast&lt;Dem3DofGeom&gt;(i-&gt;interactionGeometry); if(!bc){LOG_ERROR(&quot;NormalShearInteraction contact doesn't have SpheresContactGeomety associated?!&quot;); continue;}
-		const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(i-&gt;getId1(),rb), b2=Body::byId(i-&gt;getId2(),rb);
-		bool isIn1=isInBB(b1-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax), isIn2=isInBB(b2-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax);
-		if(!isIn1 &amp;&amp; !isIn2) continue;
-		LOG_DEBUG(&quot;Interaction #&quot;&lt;&lt;i-&gt;getId1()&lt;&lt;&quot;--#&quot;&lt;&lt;i-&gt;getId2());
-		Real weight=1.;
-		if((!isIn1 &amp;&amp; isIn2) || (isIn1 &amp;&amp; !isIn2)){
-			//shared_ptr&lt;Body&gt; bIn=isIn1?b1:b2, bOut=isIn2?b2:b1;
-			Vector3r vIn=(isIn1?b1:b2)-&gt;physicalParameters-&gt;se3.position, vOut=(isIn2?b1:b2)-&gt;physicalParameters-&gt;se3.position;
-			#define _WEIGHT_COMPONENT(axis) if(vOut[axis]&lt;bbMin[axis]) weight=min(weight,abs((vOut[axis]-bbMin[axis])/(vOut[axis]-vIn[axis]))); else if(vOut[axis]&gt;bbMax[axis]) weight=min(weight,abs((vOut[axis]-bbMax[axis])/(vOut[axis]-vIn[axis])));
-			_WEIGHT_COMPONENT(0); _WEIGHT_COMPONENT(1); _WEIGHT_COMPONENT(2);
-			assert(weight&gt;=0 &amp;&amp; weight&lt;=1);
-			//cerr&lt;&lt;&quot;Interaction crosses AABB boundary, weight is &quot;&lt;&lt;weight&lt;&lt;endl;
-			//LOG_DEBUG(&quot;Interaction crosses AABB boundary, weight is &quot;&lt;&lt;weight);
-		} else {assert(isIn1 &amp;&amp; isIn2); /* cerr&lt;&lt;&quot;Interaction inside, weight is &quot;&lt;&lt;weight&lt;&lt;endl;*/ /*LOG_DEBUG(&quot;Interaction inside, weight is &quot;&lt;&lt;weight);*/}
-		E+=geom-&gt;refLength*weight*(.5*bc-&gt;kn*pow(geom-&gt;strainN(),2)+.5*bc-&gt;ks*pow(geom-&gt;strainT().Length(),2));
-	}
-	return E;
-}
-
-/* return histogram ([bin1Min,bin2Min,&#8230;],[value1,value2,&#8230;]) from projections of interactions
- * to the plane perpendicular to axis&#8712;[0,1,2]; the number of bins can be specified and they cover
- * the range (0,&#960;), since interactions are bidirecional, hence periodically the same on (&#960;,2&#960;).
- *
- * Only contacts using SpheresContactGeometry are considered.
- * Both bodies must be in the mask (except if mask is 0, when all bodies are considered)
- * If the projection is shorter than minProjLen, it is skipped.
- *
- * If both bodies are _outside_ the aabb (if specified), the interaction is skipped.
- *
- */
-python::tuple interactionAnglesHistogram(int axis, int mask=0, size_t bins=20, python::tuple aabb=python::tuple(), Real minProjLen=1e-6){
-	if(axis&lt;0||axis&gt;2) throw invalid_argument(&quot;Axis must be from {0,1,2}=x,y,z.&quot;);
-	Vector3r bbMin(Vector3r::ZERO), bbMax(Vector3r::ZERO); bool useBB=python::len(aabb)&gt;0; if(useBB){bbMin=extract&lt;Vector3r&gt;(aabb[0])();bbMax=extract&lt;Vector3r&gt;(aabb[1])();}
-	Real binStep=Mathr::PI/bins; int axis2=(axis+1)%3, axis3=(axis+2)%3;
-	vector&lt;Real&gt; cummProj(bins,0.);
-	shared_ptr&lt;MetaBody&gt; rb=Omega::instance().getRootBody();
-	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; i, *rb-&gt;transientInteractions){
-		if(!i-&gt;isReal()) continue;
-		const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(i-&gt;getId1(),rb), b2=Body::byId(i-&gt;getId2(),rb);
-		if(!b1-&gt;maskOk(mask) || !b2-&gt;maskOk(mask)) continue;
-		if(useBB &amp;&amp; !isInBB(b1-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax) &amp;&amp; !isInBB(b2-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax)) continue;
-		shared_ptr&lt;SpheresContactGeometry&gt; scg=dynamic_pointer_cast&lt;SpheresContactGeometry&gt;(i-&gt;interactionGeometry); if(!scg) continue;
-		Vector3r n(scg-&gt;normal); n[axis]=0.; Real nLen=n.Length();
-		if(nLen&lt;minProjLen) continue; // this interaction is (almost) exactly parallel to our axis; skip that one
-		Real theta=acos(n[axis2]/nLen)*(n[axis3]&gt;0?1:-1); if(theta&lt;0) theta+=Mathr::PI;
-		int binNo=theta/binStep;
-		cummProj[binNo]+=nLen;
-	}
-	python::list val,binMid;
-	for(size_t i=0; i&lt;(size_t)bins; i++){ val.append(cummProj[i]); binMid.append(i*binStep);}
-	return python::make_tuple(binMid,val);
-}
-BOOST_PYTHON_FUNCTION_OVERLOADS(interactionAnglesHistogram_overloads,interactionAnglesHistogram,1,4);
-
-python::tuple bodyNumInteractionsHistogram(python::tuple aabb=python::tuple()){
-	Vector3r bbMin(Vector3r::ZERO), bbMax(Vector3r::ZERO); bool useBB=python::len(aabb)&gt;0; if(useBB){bbMin=extract&lt;Vector3r&gt;(aabb[0])();bbMax=extract&lt;Vector3r&gt;(aabb[1])();}
-	const shared_ptr&lt;MetaBody&gt;&amp; rb=Omega::instance().getRootBody();
-	vector&lt;int&gt; bodyNumInta; bodyNumInta.resize(rb-&gt;bodies-&gt;size(),-1 /* uninitialized */);
-	int maxInta=0;
-	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; i, *rb-&gt;transientInteractions){
-		if(!i-&gt;isReal()) continue;
-		const body_id_t id1=i-&gt;getId1(), id2=i-&gt;getId2(); const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(id1,rb), b2=Body::byId(id2,rb);
-		if(useBB &amp;&amp; isInBB(b1-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax)) bodyNumInta[id1]=bodyNumInta[id1]&gt;0?bodyNumInta[id1]+1:1;
-		if(useBB &amp;&amp; isInBB(b2-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax)) bodyNumInta[id2]=bodyNumInta[id2]&gt;0?bodyNumInta[id2]+1:1;
-		maxInta=max(max(maxInta,bodyNumInta[b1-&gt;getId()]),bodyNumInta[b2-&gt;getId()]);
-	}
-	vector&lt;int&gt; bins; bins.resize(maxInta+1);
-	for(size_t id=0; id&lt;bodyNumInta.size(); id++){ if(bodyNumInta[id]&gt;=0) bins[bodyNumInta[id]]+=1; }
-	python::list count,num;
-	for(size_t n=1; n&lt;bins.size(); n++){
-		if(bins[n]==0) continue;
-		num.append(n); count.append(bins[n]);
-	}
-	return python::make_tuple(num,count);
-}
-BOOST_PYTHON_FUNCTION_OVERLOADS(bodyNumInteractionsHistogram_overloads,bodyNumInteractionsHistogram,0,1);
-
-Vector3r inscribedCircleCenter(const Vector3r&amp; v0, const Vector3r&amp; v1, const Vector3r&amp; v2)
-{
-	return Shop::inscribedCircleCenter(v0,v1,v2);
-}
-
-python::dict getViscoelasticFromSpheresInteraction(Real m, Real tc, Real en, Real es)
-{
-    shared_ptr&lt;SimpleViscoelasticBodyParameters&gt; b = shared_ptr&lt;SimpleViscoelasticBodyParameters&gt;(new SimpleViscoelasticBodyParameters());
-    Shop::getViscoelasticFromSpheresInteraction(m,tc,en,es,b);
-	python::dict d;
-	d[&quot;kn&quot;]=b-&gt;kn;
-	d[&quot;cn&quot;]=b-&gt;cn;
-	d[&quot;ks&quot;]=b-&gt;ks;
-	d[&quot;cs&quot;]=b-&gt;cs;
-    return d;
-}
-/* reset highlight of all bodies */
-void highlightNone(){
-	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
-		if(!b-&gt;geometricalModel) continue;
-		b-&gt;geometricalModel-&gt;highlight=false;
-	}
-}
-
-/*!Sum moments acting on given bodies
- *
- * @param mask is Body::groupMask that must match for a body to be taken in account.
- * @param axis is the direction of axis with respect to which the moment is calculated.
- * @param axisPt is a point on the axis.
- *
- * The computation is trivial: moment from force is is by definition r&#215;F, where r
- * is position relative to axisPt; moment from moment is m; such moment per body is
- * projected onto axis.
- */
-Real sumBexTorques(python::tuple ids, const Vector3r&amp; axis, const Vector3r&amp; axisPt){
-	shared_ptr&lt;MetaBody&gt; rb=Omega::instance().getRootBody();
-	rb-&gt;bex.sync();
-	Real ret=0;
-	size_t len=python::len(ids);
-	for(size_t i=0; i&lt;len; i++){
-		const Body* b=(*rb-&gt;bodies)[python::extract&lt;int&gt;(ids[i])].get();
-		const Vector3r&amp; m=rb-&gt;bex.getTorque(b-&gt;getId());
-		const Vector3r&amp; f=rb-&gt;bex.getForce(b-&gt;getId());
-		Vector3r r=b-&gt;physicalParameters-&gt;se3.position-axisPt;
-		ret+=axis.Dot(m+r.Cross(f));
-	}
-	return ret;
-}
-/* Sum forces actiong on bodies within mask.
- *
- * @param mask groupMask of matching bodies
- * @param direction direction in which forces are summed
- *
- */
-Real sumBexForces(python::tuple ids, const Vector3r&amp; direction){
-	shared_ptr&lt;MetaBody&gt; rb=Omega::instance().getRootBody();
-	rb-&gt;bex.sync();
-	Real ret=0;
-	size_t len=python::len(ids);
-	for(size_t i=0; i&lt;len; i++){
-		body_id_t id=python::extract&lt;int&gt;(ids[i]);
-		const Vector3r&amp; f=rb-&gt;bex.getForce(id);
-		ret+=direction.Dot(f);
-	}
-	return ret;
-}
-
-/* Set wire display of all/some/none bodies depending on the filter. */
-void wireSome(string filter){
-	enum{none,all,noSpheres,unknown};
-	int mode=(filter==&quot;none&quot;?none:(filter==&quot;all&quot;?all:(filter==&quot;noSpheres&quot;?noSpheres:unknown)));
-	if(mode==unknown) { LOG_WARN(&quot;Unknown wire filter `&quot;&lt;&lt;filter&lt;&lt;&quot;', using noSpheres instead.&quot;); mode=noSpheres; }
-	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
-		if(!b-&gt;geometricalModel) return;
-		bool wire;
-		switch(mode){
-			case none: wire=false; break;
-			case all: wire=true; break;
-			case noSpheres: wire=!(bool)(dynamic_pointer_cast&lt;Sphere&gt;(b-&gt;geometricalModel)); break;
-			default: throw logic_error(&quot;No such case possible&quot;);
-		}
-		b-&gt;geometricalModel-&gt;wire=wire;
-	}
-}
-void wireAll(){wireSome(&quot;all&quot;);}
-void wireNone(){wireSome(&quot;none&quot;);}
-void wireNoSpheres(){wireSome(&quot;noSpheres&quot;);}
-
-
-/* Tell us whether a point lies in polygon given by array of points.
- *  @param xy is the point that is being tested
- *  @param vertices is Numeric.array (or list or tuple) of vertices of the polygon.
- *         Every row of the array is x and y coordinate, numer of rows is &gt;= 3 (triangle).
- *
- * Copying the algorithm from <A HREF="http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html">http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html</A>
- * is gratefully acknowledged:
- *
- * License to Use:
- * Copyright (c) 1970-2003, Wm. Randolph Franklin
- * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
- *   1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.
- *   2. Redistributions in binary form must reproduce the above copyright notice in the documentation and/or other materials provided with the distribution.
- *   3. The name of W. Randolph Franklin may not be used to endorse or promote products derived from this Software without specific prior written permission. 
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * <A HREF="http://numpy.scipy.org/numpydoc/numpy-13.html">http://numpy.scipy.org/numpydoc/numpy-13.html</A> told me how to use Numeric.array from c
- */
-bool pointInsidePolygon(python::tuple xy, python::object vertices){
-	Real testx=python::extract&lt;double&gt;(xy[0])(),testy=python::extract&lt;double&gt;(xy[1])();
-	char** vertData; int rows, cols; PyArrayObject* vert=(PyArrayObject*)vertices.ptr();
-	int result=PyArray_As2D((PyObject**)&amp;vert /* is replaced */ ,&amp;vertData,&amp;rows,&amp;cols,PyArray_DOUBLE);
-	if(result!=0) throw invalid_argument(&quot;Unable to cast vertices to 2d array&quot;);
-	if(cols!=2 || rows&lt;3) throw invalid_argument(&quot;Vertices must have 2 columns (x and y) and at least 3 rows.&quot;);
-	int i /*current node*/, j/*previous node*/; bool inside=false;
-	for(i=0,j=rows-1; i&lt;rows; j=i++){
-		double vx_i=*(double*)(vert-&gt;data+i*vert-&gt;strides[0]), vy_i=*(double*)(vert-&gt;data+i*vert-&gt;strides[0]+vert-&gt;strides[1]), vx_j=*(double*)(vert-&gt;data+j*vert-&gt;strides[0]), vy_j=*(double*)(vert-&gt;data+j*vert-&gt;strides[0]+vert-&gt;strides[1]);
-		if (((vy_i&gt;testy)!=(vy_j&gt;testy)) &amp;&amp; (testx &lt; (vx_j-vx_i) * (testy-vy_i) / (vy_j-vy_i) + vx_i) ) inside=!inside;
-	}
-	Py_DECREF(vert);
-	return inside;
-}
-
-/* Compute area of convex hull when when taking (swept) spheres crossing the plane at coord, perpendicular to axis.
-
-	All spheres that touch the plane are projected as hexagons on their circumference to the plane.
-	Convex hull from this cloud is computed.
-	The area of the hull is returned.
-
-*/
-Real approxSectionArea(Real coord, int axis){
-	std::list&lt;Vector2r&gt; cloud;
-	if(axis&lt;0 || axis&gt;2) throw invalid_argument(&quot;Axis must be &#8712; {0,1,2}&quot;);
-	const int ax1=(axis+1)%3, ax2=(axis+2)%3;
-	const Real sqrt3=sqrt(3);
-	Vector2r mm(-10.,0),mx(0,0);
-	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
-		Sphere* s=dynamic_cast&lt;Sphere*&gt;(b-&gt;geometricalModel.get());
-		if(!s) continue;
-		const Vector3r&amp; pos(b-&gt;physicalParameters-&gt;se3.position); const Real r(s-&gt;radius);
-		if((pos[axis]&gt;coord &amp;&amp; (pos[axis]-r)&gt;coord) || (pos[axis]&lt;coord &amp;&amp; (pos[axis]+r)&lt;coord)) continue;
-		Vector2r c(pos[ax1],pos[ax2]);
-		cloud.push_back(c+Vector2r(r,0)); cloud.push_back(c+Vector2r(-r,0));
-		cloud.push_back(c+Vector2r( r/2., sqrt3*r)); cloud.push_back(c+Vector2r( r/2.,-sqrt3*r));
-		cloud.push_back(c+Vector2r(-r/2., sqrt3*r)); cloud.push_back(c+Vector2r(-r/2.,-sqrt3*r));
-		if(mm[0]==-10.){ mm=c, mx=c;}
-		mm=Vector2r(min(c[0]-r,mm[0]),min(c[1]-r,mm[1]));
-		mx=Vector2r(max(c[0]+r,mx[0]),max(c[1]+r,mx[1]));
-	}
-	if(cloud.size()==0) return 0;
-	ConvexHull2d ch2d(cloud);
-	vector&lt;Vector2r&gt; hull=ch2d();
-	return simplePolygonArea2d(hull);
-}
-/* Find all interactions deriving from NormalShearInteraction that cross plane given by a point and normal
-	(the normal may not be normalized in this case, though) and sum forces (both normal and shear) on them.
-	
-	Return a 3-tuple with the components along global x,y,z axes.
-
-	(This could be easily extended to return sum of only normal forces or only of shear forces.)
-*/
-Vector3r forcesOnPlane(const Vector3r&amp; planePt, const Vector3r&amp;  normal){
-	Vector3r ret(Vector3r::ZERO);
-	MetaBody* rootBody=Omega::instance().getRootBody().get();
-	FOREACH(const shared_ptr&lt;Interaction&gt;&amp;I, *rootBody-&gt;interactions){
-		if(!I-&gt;isReal()) continue;
-		NormalShearInteraction* nsi=dynamic_cast&lt;NormalShearInteraction*&gt;(I-&gt;interactionPhysics.get());
-		if(!nsi) continue;
-		Vector3r pos1,pos2;
-		Dem3DofGeom* d3dg=dynamic_cast&lt;Dem3DofGeom*&gt;(I-&gt;interactionGeometry.get()); // Dem3DofGeom has copy of se3 in itself, otherwise we have to look up the bodies
-		if(d3dg){ pos1=d3dg-&gt;se31.position; pos2=d3dg-&gt;se32.position; }
-		else{ pos1=Body::byId(I-&gt;getId1(),rootBody)-&gt;physicalParameters-&gt;se3.position; pos2=Body::byId(I-&gt;getId2(),rootBody)-&gt;physicalParameters-&gt;se3.position; }
-		Real dot1=(pos1-planePt).Dot(normal), dot2=(pos2-planePt).Dot(normal);
-		if(dot1*dot2&gt;0) continue; // both interaction points on the same side of the plane
-		// if pt1 is on the negative plane side, d3dg-&gt;normal.Dot(normal)&gt;0, the force is well oriented;
-		// otherwise, reverse its contribution
-		ret+=(dot1&lt;0.?1.:-1.)*(nsi-&gt;normalForce+nsi-&gt;shearForce);
-	}
-	return ret;
-}
-
-/* Less general than forcesOnPlane, computes force on plane perpendicular to axis, passing through coordinate coord. */
-Vector3r forcesOnCoordPlane(Real coord, int axis){
-	Vector3r planePt(Vector3r::ZERO); planePt[axis]=coord;
-	Vector3r normal(Vector3r::ZERO); normal[axis]=1;
-	return forcesOnPlane(planePt,normal);
-}
-
-
-/* Project 3d point into 2d using spiral projection along given axis;
- * the returned tuple is
- * 	
- *  ( (height relative to the spiral, distance from axis), theta )
- *
- * dH_dTheta is the inclination of the spiral (height increase per radian),
- * theta0 is the angle for zero height (by given axis).
- */
-python::tuple spiralProject(const Vector3r&amp; pt, Real dH_dTheta, int axis=2, Real periodStart=std::numeric_limits&lt;Real&gt;::quiet_NaN(), Real theta0=0){
-	int ax1=(axis+1)%3,ax2=(axis+2)%3;
-	Real r=sqrt(pow(pt[ax1],2)+pow(pt[ax2],2));
-	Real theta;
-	if(r&gt;Mathr::ZERO_TOLERANCE){
-		theta=acos(pt[ax1]/r);
-		if(pt[ax2]&lt;0) theta=Mathr::TWO_PI-theta;
-	}
-	else theta=0;
-	Real hRef=dH_dTheta*(theta-theta0);
-	long period;
-	if(isnan(periodStart)){
-		Real h=Shop::periodicWrap(pt[axis]-hRef,hRef-Mathr::PI*dH_dTheta,hRef+Mathr::PI*dH_dTheta,&amp;period);
-		return python::make_tuple(python::make_tuple(r,h),theta);
-	}
-	else{
-		// Real hPeriodStart=(periodStart-theta0)*dH_dTheta;
-		//TRVAR4(hPeriodStart,periodStart,theta0,theta);
-		//Real h=Shop::periodicWrap(pt[axis]-hRef,hPeriodStart,hPeriodStart+2*Mathr::PI*dH_dTheta,&amp;period);
-		theta=Shop::periodicWrap(theta,periodStart,periodStart+2*Mathr::PI,&amp;period);
-		Real h=pt[axis]-hRef+period*2*Mathr::PI*dH_dTheta;
-		//TRVAR3(pt[axis],pt[axis]-hRef,period);
-		//TRVAR2(h,theta);
-		return python::make_tuple(python::make_tuple(r,h),theta);
-	}
-}
-BOOST_PYTHON_FUNCTION_OVERLOADS(spiralProject_overloads,spiralProject,2,5);
-
-// for now, don't return anything, since we would have to include the whole yadeControl.cpp because of pyInteraction
-void Shop__createExplicitInteraction(body_id_t id1, body_id_t id2){ (void) Shop::createExplicitInteraction(id1,id2);}
-
-//Vector3r Shop__scalarOnColorScale(Real scalar){ return Shop::scalarOnColorScale(scalar);}
-
-BOOST_PYTHON_FUNCTION_OVERLOADS(unbalancedForce_overloads,Shop::unbalancedForce,0,1);
-Real Shop__kineticEnergy(){return Shop::kineticEnergy();}
-
-BOOST_PYTHON_MODULE(_utils){
-	// <A HREF="http://numpy.scipy.org/numpydoc/numpy-13.html">http://numpy.scipy.org/numpydoc/numpy-13.html</A> mentions this must be done in module init, otherwise we will crash
-	import_array();
-
-	def(&quot;PWaveTimeStep&quot;,PWaveTimeStep,&quot;Get timestep accoring to the velocity of P-Wave propagation; computed from sphere radii, rigidities and masses.&quot;);
-	def(&quot;aabbExtrema&quot;,aabbExtrema,aabbExtrema_overloads(args(&quot;cutoff&quot;,&quot;centers&quot;),&quot;Return coordinates of box enclosing all bodies\n centers: do not take sphere radii in account, only their centroids (default=False)\n cutoff: 0-1 number by which the box will be scaled around its center (default=0)&quot;));
-	def(&quot;ptInAABB&quot;,ptInAABB,&quot;Return True/False whether the point (3-tuple) p is within box given by its min (3-tuple) and max (3-tuple) corners&quot;);
-	def(&quot;negPosExtremeIds&quot;,negPosExtremeIds,negPosExtremeIds_overloads(args(&quot;axis&quot;,&quot;distFactor&quot;),&quot;Return list of ids for spheres (only) that are on extremal ends of the specimen along given axis; distFactor multiplies their radius so that sphere that do not touch the boundary coordinate can also be returned.&quot;));
-	def(&quot;approxSectionArea&quot;,approxSectionArea,&quot;Compute area of convex hull when when taking (swept) spheres crossing the plane at coord, perpendicular to axis.&quot;);
-	def(&quot;coordsAndDisplacements&quot;,coordsAndDisplacements,coordsAndDisplacements_overloads(args(&quot;AABB&quot;),&quot;Return tuple of 2 same-length lists for coordinates and displacements (coordinate minus reference coordinate) along given axis (1st arg); if the AABB=((x_min,y_min,z_min),(x_max,y_max,z_max)) box is given, only bodies within this box will be considered.&quot;));
-	def(&quot;setRefSe3&quot;,setRefSe3,&quot;Set reference positions and orientation of all bodies equal to their current ones.&quot;);
-	def(&quot;interactionAnglesHistogram&quot;,interactionAnglesHistogram,interactionAnglesHistogram_overloads(args(&quot;axis&quot;,&quot;mask&quot;,&quot;bins&quot;,&quot;aabb&quot;)));
-	def(&quot;bodyNumInteractionsHistogram&quot;,bodyNumInteractionsHistogram,bodyNumInteractionsHistogram_overloads(args(&quot;aabb&quot;)));
-	def(&quot;elasticEnergy&quot;,elasticEnergyInAABB);
-	def(&quot;inscribedCircleCenter&quot;,inscribedCircleCenter);
-	def(&quot;getViscoelasticFromSpheresInteraction&quot;,getViscoelasticFromSpheresInteraction);
-	def(&quot;unbalancedForce&quot;,&amp;Shop::unbalancedForce,unbalancedForce_overloads(args(&quot;useMaxForce&quot;)));
-	def(&quot;kineticEnergy&quot;,Shop__kineticEnergy);
-	def(&quot;sumBexForces&quot;,sumBexForces);
-	def(&quot;sumBexTorques&quot;,sumBexTorques);
-	def(&quot;forcesOnPlane&quot;,forcesOnPlane);
-	def(&quot;forcesOnCoordPlane&quot;,forcesOnCoordPlane);
-	def(&quot;createInteraction&quot;,Shop__createExplicitInteraction);
-	def(&quot;spiralProject&quot;,spiralProject,spiralProject_overloads(args(&quot;axis&quot;,&quot;periodStart&quot;,&quot;theta0&quot;)));
-	def(&quot;pointInsidePolygon&quot;,pointInsidePolygon);
-	def(&quot;scalarOnColorScale&quot;,Shop::scalarOnColorScale);
-	def(&quot;highlightNone&quot;,highlightNone);
-	def(&quot;wireAll&quot;,wireAll);
-	def(&quot;wireNone&quot;,wireNone);
-	def(&quot;wireNoSpheres&quot;,wireNoSpheres);
-}
-
-

Deleted: trunk/lib/py/euclid.py
===================================================================
--- trunk/lib/py/euclid.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/euclid.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,2228 +0,0 @@
-#!/usr/bin/env python
-#
-# euclid graphics maths module
-#
-# Copyright (c) 2006 Alex Holkner
-# <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">Alex.Holkner at mail.google.com</A>
-#
-# This library is free software; you can redistribute it and/or modify it
-# under the terms of the GNU Lesser General Public License as published by the
-# Free Software Foundation; either version 2.1 of the License, or (at your
-# option) any later version.
-# 
-# This library is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
-# for more details.
-# 
-# You should have received a copy of the GNU Lesser General Public License
-# along with this library; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
-
-'''euclid graphics maths module
-
-Documentation and tests are included in the file &quot;euclid.txt&quot;, or online
-at <A HREF="http://code.google.com/p/pyeuclid">http://code.google.com/p/pyeuclid</A>
-'''
-
-__docformat__ = 'restructuredtext'
-__version__ = '$Id$'
-__revision__ = '$Revision$'
-
-import math
-import operator
-import types
-
-# Some magic here.  If _use_slots is True, the classes will derive from
-# object and will define a __slots__ class variable.  If _use_slots is
-# False, classes will be old-style and will not define __slots__.
-#
-# _use_slots = True:   Memory efficient, probably faster in future versions
-#                      of Python, &quot;better&quot;.
-# _use_slots = False:  Ordinary classes, much faster than slots in current
-#                      versions of Python (2.4 and 2.5).
-_use_slots = True
-
-# If True, allows components of Vector2 and Vector3 to be set via swizzling;
-# e.g.  v.xyz = (1, 2, 3).  This is much, much slower than the more verbose
-# v.x = 1; v.y = 2; v.z = 3,  and slows down ordinary element setting as
-# well.  Recommended setting is False.
-_enable_swizzle_set = False
-
-# Requires class to derive from object.
-if _enable_swizzle_set:
-    _use_slots = True
-
-# Implement _use_slots magic.
-class _EuclidMetaclass(type):
-    def __new__(cls, name, bases, dct):
-        if '__slots__' in dct:
-            dct['__getstate__'] = cls._create_getstate(dct['__slots__'])
-            dct['__setstate__'] = cls._create_setstate(dct['__slots__'])
-        if _use_slots:
-            return type.__new__(cls, name, bases + (object,), dct)
-        else:
-            if '__slots__' in dct:
-                del dct['__slots__']
-            return types.ClassType.__new__(types.ClassType, name, bases, dct)
-
-    @classmethod
-    def _create_getstate(cls, slots):
-        def __getstate__(self):
-            d = {}
-            for slot in slots:
-                d[slot] = getattr(self, slot)
-            return d
-        return __getstate__
-
-    @classmethod
-    def _create_setstate(cls, slots):
-        def __setstate__(self, state):
-            for name, value in state.items():
-                setattr(self, name, value)
-        return __setstate__
-
-__metaclass__ = _EuclidMetaclass
-
-class Vector2:
-    __slots__ = ['x', 'y']
-
-    def __init__(self, x=0, y=0):
-        self.x = x
-        self.y = y
-
-    def __copy__(self):
-        return self.__class__(self.x, self.y)
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Vector2(%.2f, %.2f)' % (self.x, self.y)
-
-    def __eq__(self, other):
-        if isinstance(other, Vector2):
-            return self.x == other.x and \
-                   self.y == other.y
-        else:
-            assert hasattr(other, '__len__') and len(other) == 2
-            return self.x == other[0] and \
-                   self.y == other[1]
-
-    def __neq__(self, other):
-        return not self.__eq__(other)
-
-    def __nonzero__(self):
-        return self.x != 0 or self.y != 0
-
-    def __len__(self):
-        return 2
-
-    def __getitem__(self, key):
-        return (self.x, self.y)[key]
-
-    def __setitem__(self, key, value):
-        l = [self.x, self.y]
-        l[key] = value
-        self.x, self.y = l
-
-    def __iter__(self):
-        return iter((self.x, self.y))
-
-    def __getattr__(self, name):
-        try:
-            return tuple([(self.x, self.y)['xy'.index(c)] \
-                          for c in name])
-        except ValueError:
-            raise AttributeError, name
-
-    if _enable_swizzle_set:
-        # This has detrimental performance on ordinary setattr as well
-        # if enabled
-        def __setattr__(self, name, value):
-            if len(name) == 1:
-                object.__setattr__(self, name, value)
-            else:
-                try:
-                    l = [self.x, self.y]
-                    for c, v in map(None, name, value):
-                        l['xy'.index(c)] = v
-                    self.x, self.y = l
-                except ValueError:
-                    raise AttributeError, name
-
-    def __add__(self, other):
-        if isinstance(other, Vector2):
-            # Vector + Vector -&gt; Vector
-            # Vector + Point -&gt; Point
-            # Point + Point -&gt; Vector
-            if self.__class__ is other.__class__:
-                _class = Vector2
-            else:
-                _class = Point2
-            return _class(self.x + other.x,
-                          self.y + other.y)
-        else:
-            assert hasattr(other, '__len__') and len(other) == 2
-            return Vector2(self.x + other[0],
-                           self.y + other[1])
-    __radd__ = __add__
-
-    def __iadd__(self, other):
-        if isinstance(other, Vector2):
-            self.x += other.x
-            self.y += other.y
-        else:
-            self.x += other[0]
-            self.y += other[1]
-        return self
-
-    def __sub__(self, other):
-        if isinstance(other, Vector2):
-            # Vector - Vector -&gt; Vector
-            # Vector - Point -&gt; Point
-            # Point - Point -&gt; Vector
-            if self.__class__ is other.__class__:
-                _class = Vector2
-            else:
-                _class = Point2
-            return _class(self.x - other.x,
-                          self.y - other.y)
-        else:
-            assert hasattr(other, '__len__') and len(other) == 2
-            return Vector2(self.x - other[0],
-                           self.y - other[1])
-
-   
-    def __rsub__(self, other):
-        if isinstance(other, Vector2):
-            return Vector2(other.x - self.x,
-                           other.y - self.y)
-        else:
-            assert hasattr(other, '__len__') and len(other) == 2
-            return Vector2(other.x - self[0],
-                           other.y - self[1])
-
-    def __mul__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector2(self.x * other,
-                       self.y * other)
-
-    __rmul__ = __mul__
-
-    def __imul__(self, other):
-        assert type(other) in (int, long, float)
-        self.x *= other
-        self.y *= other
-        return self
-
-    def __div__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector2(operator.div(self.x, other),
-                       operator.div(self.y, other))
-
-
-    def __rdiv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector2(operator.div(other, self.x),
-                       operator.div(other, self.y))
-
-    def __floordiv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector2(operator.floordiv(self.x, other),
-                       operator.floordiv(self.y, other))
-
-
-    def __rfloordiv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector2(operator.floordiv(other, self.x),
-                       operator.floordiv(other, self.y))
-
-    def __truediv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector2(operator.truediv(self.x, other),
-                       operator.truediv(self.y, other))
-
-
-    def __rtruediv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector2(operator.truediv(other, self.x),
-                       operator.truediv(other, self.y))
-    
-    def __neg__(self):
-        return Vector2(-self.x,
-                        -self.y)
-
-    __pos__ = __copy__
-    
-    def __abs__(self):
-        return math.sqrt(self.x ** 2 + \
-                         self.y ** 2)
-
-    magnitude = __abs__
-
-    def magnitude_squared(self):
-        return self.x ** 2 + \
-               self.y ** 2
-
-    def normalize(self):
-        d = self.magnitude()
-        if d:
-            self.x /= d
-            self.y /= d
-        return self
-
-    def normalized(self):
-        d = self.magnitude()
-        if d:
-            return Vector2(self.x / d, 
-                           self.y / d)
-        return self.copy()
-
-    def dot(self, other):
-        assert isinstance(other, Vector2)
-        return self.x * other.x + \
-               self.y * other.y
-
-    def cross(self):
-        return Vector2(self.y, -self.x)
-
-    def reflect(self, normal):
-        # assume normal is normalized
-        assert isinstance(normal, Vector2)
-        d = 2 * (self.x * normal.x + self.y * normal.y)
-        return Vector2(self.x - d * normal.x,
-                       self.y - d * normal.y)
-
-class Vector3:
-    __slots__ = ['x', 'y', 'z']
-
-    def __init__(self, x=0, y=0, z=0):
-        self.x = x
-        self.y = y
-        self.z = z
-
-    def __copy__(self):
-        return self.__class__(self.x, self.y, self.z)
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Vector3(%.2f, %.2f, %.2f)' % (self.x,
-                                              self.y,
-                                              self.z)
-
-    def __eq__(self, other):
-        if isinstance(other, Vector3):
-            return self.x == other.x and \
-                   self.y == other.y and \
-                   self.z == other.z
-        else:
-            assert hasattr(other, '__len__') and len(other) == 3
-            return self.x == other[0] and \
-                   self.y == other[1] and \
-                   self.z == other[2]
-
-    def __neq__(self, other):
-        return not self.__eq__(other)
-
-    def __nonzero__(self):
-        return self.x != 0 or self.y != 0 or self.z != 0
-
-    def __len__(self):
-        return 3
-
-    def __getitem__(self, key):
-        return (self.x, self.y, self.z)[key]
-
-    def __setitem__(self, key, value):
-        l = [self.x, self.y, self.z]
-        l[key] = value
-        self.x, self.y, self.z = l
-
-    def __iter__(self):
-        return iter((self.x, self.y, self.z))
-
-    def __getattr__(self, name):
-        try:
-            return tuple([(self.x, self.y, self.z)['xyz'.index(c)] \
-                          for c in name])
-        except ValueError:
-            raise AttributeError, name
-
-    if _enable_swizzle_set:
-        # This has detrimental performance on ordinary setattr as well
-        # if enabled
-        def __setattr__(self, name, value):
-            if len(name) == 1:
-                object.__setattr__(self, name, value)
-            else:
-                try:
-                    l = [self.x, self.y, self.z]
-                    for c, v in map(None, name, value):
-                        l['xyz'.index(c)] = v
-                    self.x, self.y, self.z = l
-                except ValueError:
-                    raise AttributeError, name
-
-
-    def __add__(self, other):
-        if isinstance(other, Vector3):
-            # Vector + Vector -&gt; Vector
-            # Vector + Point -&gt; Point
-            # Point + Point -&gt; Vector
-            if self.__class__ is other.__class__:
-                _class = Vector3
-            else:
-                _class = Point3
-            return _class(self.x + other.x,
-                          self.y + other.y,
-                          self.z + other.z)
-        else:
-            assert hasattr(other, '__len__') and len(other) == 3
-            return Vector3(self.x + other[0],
-                           self.y + other[1],
-                           self.z + other[2])
-    __radd__ = __add__
-
-    def __iadd__(self, other):
-        if isinstance(other, Vector3):
-            self.x += other.x
-            self.y += other.y
-            self.z += other.z
-        else:
-            self.x += other[0]
-            self.y += other[1]
-            self.z += other[2]
-        return self
-
-    def __sub__(self, other):
-        if isinstance(other, Vector3):
-            # Vector - Vector -&gt; Vector
-            # Vector - Point -&gt; Point
-            # Point - Point -&gt; Vector
-            if self.__class__ is other.__class__:
-                _class = Vector3
-            else:
-                _class = Point3
-            return Vector3(self.x - other.x,
-                           self.y - other.y,
-                           self.z - other.z)
-        else:
-            assert hasattr(other, '__len__') and len(other) == 3
-            return Vector3(self.x - other[0],
-                           self.y - other[1],
-                           self.z - other[2])
-
-   
-    def __rsub__(self, other):
-        if isinstance(other, Vector3):
-            return Vector3(other.x - self.x,
-                           other.y - self.y,
-                           other.z - self.z)
-        else:
-            assert hasattr(other, '__len__') and len(other) == 3
-            return Vector3(other.x - self[0],
-                           other.y - self[1],
-                           other.z - self[2])
-
-    def __mul__(self, other):
-        if isinstance(other, Vector3):
-            # TODO component-wise mul/div in-place and on Vector2; docs.
-            if self.__class__ is Point3 or other.__class__ is Point3:
-                _class = Point3
-            else:
-                _class = Vector3
-            return _class(self.x * other.x,
-                          self.y * other.y,
-                          self.z * other.z)
-        else: 
-            assert type(other) in (int, long, float)
-            return Vector3(self.x * other,
-                           self.y * other,
-                           self.z * other)
-
-    __rmul__ = __mul__
-
-    def __imul__(self, other):
-        assert type(other) in (int, long, float)
-        self.x *= other
-        self.y *= other
-        self.z *= other
-        return self
-
-    def __div__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector3(operator.div(self.x, other),
-                       operator.div(self.y, other),
-                       operator.div(self.z, other))
-
-
-    def __rdiv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector3(operator.div(other, self.x),
-                       operator.div(other, self.y),
-                       operator.div(other, self.z))
-
-    def __floordiv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector3(operator.floordiv(self.x, other),
-                       operator.floordiv(self.y, other),
-                       operator.floordiv(self.z, other))
-
-
-    def __rfloordiv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector3(operator.floordiv(other, self.x),
-                       operator.floordiv(other, self.y),
-                       operator.floordiv(other, self.z))
-
-    def __truediv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector3(operator.truediv(self.x, other),
-                       operator.truediv(self.y, other),
-                       operator.truediv(self.z, other))
-
-
-    def __rtruediv__(self, other):
-        assert type(other) in (int, long, float)
-        return Vector3(operator.truediv(other, self.x),
-                       operator.truediv(other, self.y),
-                       operator.truediv(other, self.z))
-    
-    def __neg__(self):
-        return Vector3(-self.x,
-                        -self.y,
-                        -self.z)
-
-    __pos__ = __copy__
-    
-    def __abs__(self):
-        return math.sqrt(self.x ** 2 + \
-                         self.y ** 2 + \
-                         self.z ** 2)
-
-    magnitude = __abs__
-
-    def magnitude_squared(self):
-        return self.x ** 2 + \
-               self.y ** 2 + \
-               self.z ** 2
-
-    def normalize(self):
-        d = self.magnitude()
-        if d:
-            self.x /= d
-            self.y /= d
-            self.z /= d
-        return self
-
-    def normalized(self):
-        d = self.magnitude()
-        if d:
-            return Vector3(self.x / d, 
-                           self.y / d, 
-                           self.z / d)
-        return self.copy()
-
-    def dot(self, other):
-        assert isinstance(other, Vector3)
-        return self.x * other.x + \
-               self.y * other.y + \
-               self.z * other.z
-
-    def cross(self, other):
-        assert isinstance(other, Vector3)
-        return Vector3(self.y * other.z - self.z * other.y,
-                       -self.x * other.z + self.z * other.x,
-                       self.x * other.y - self.y * other.x)
-
-    def reflect(self, normal):
-        # assume normal is normalized
-        assert isinstance(normal, Vector3)
-        d = 2 * (self.x * normal.x + self.y * normal.y + self.z * normal.z)
-        return Vector3(self.x - d * normal.x,
-                       self.y - d * normal.y,
-                       self.z - d * normal.z)
-
-# a b c 
-# e f g 
-# i j k 
-
-class Matrix3:
-    __slots__ = list('abcefgijk')
-
-    def __init__(self):
-        self.identity()
-
-    def __copy__(self):
-        M = Matrix3()
-        M.a = self.a
-        M.b = self.b
-        M.c = self.c
-        M.e = self.e 
-        M.f = self.f
-        M.g = self.g
-        M.i = self.i
-        M.j = self.j
-        M.k = self.k
-        return M
-
-    copy = __copy__
-    def __repr__(self):
-        return ('Matrix3([% 8.2f % 8.2f % 8.2f\n'  \
-                '         % 8.2f % 8.2f % 8.2f\n'  \
-                '         % 8.2f % 8.2f % 8.2f])') \
-                % (self.a, self.b, self.c,
-                   self.e, self.f, self.g,
-                   self.i, self.j, self.k)
-
-    def __getitem__(self, key):
-        return [self.a, self.e, self.i,
-                self.b, self.f, self.j,
-                self.c, self.g, self.k][key]
-
-    def __setitem__(self, key, value):
-        L = self[:]
-        L[key] = value
-        (self.a, self.e, self.i,
-         self.b, self.f, self.j,
-         self.c, self.g, self.k) = L
-
-    def __mul__(self, other):
-        if isinstance(other, Matrix3):
-            # Caching repeatedly accessed attributes in local variables
-            # apparently increases performance by 20%.  Attrib: Will McGugan.
-            Aa = self.a
-            Ab = self.b
-            Ac = self.c
-            Ae = self.e
-            Af = self.f
-            Ag = self.g
-            Ai = self.i
-            Aj = self.j
-            Ak = self.k
-            Ba = other.a
-            Bb = other.b
-            Bc = other.c
-            Be = other.e
-            Bf = other.f
-            Bg = other.g
-            Bi = other.i
-            Bj = other.j
-            Bk = other.k
-            C = Matrix3()
-            C.a = Aa * Ba + Ab * Be + Ac * Bi
-            C.b = Aa * Bb + Ab * Bf + Ac * Bj
-            C.c = Aa * Bc + Ab * Bg + Ac * Bk
-            C.e = Ae * Ba + Af * Be + Ag * Bi
-            C.f = Ae * Bb + Af * Bf + Ag * Bj
-            C.g = Ae * Bc + Af * Bg + Ag * Bk
-            C.i = Ai * Ba + Aj * Be + Ak * Bi
-            C.j = Ai * Bb + Aj * Bf + Ak * Bj
-            C.k = Ai * Bc + Aj * Bg + Ak * Bk
-            return C
-        elif isinstance(other, Point2):
-            A = self
-            B = other
-            P = Point2(0, 0)
-            P.x = A.a * B.x + A.b * B.y + A.c
-            P.y = A.e * B.x + A.f * B.y + A.g
-            return P
-        elif isinstance(other, Vector2):
-            A = self
-            B = other
-            V = Vector2(0, 0)
-            V.x = A.a * B.x + A.b * B.y 
-            V.y = A.e * B.x + A.f * B.y 
-            return V
-        else:
-            other = other.copy()
-            other._apply_transform(self)
-            return other
-
-    def __imul__(self, other):
-        assert isinstance(other, Matrix3)
-        # Cache attributes in local vars (see Matrix3.__mul__).
-        Aa = self.a
-        Ab = self.b
-        Ac = self.c
-        Ae = self.e
-        Af = self.f
-        Ag = self.g
-        Ai = self.i
-        Aj = self.j
-        Ak = self.k
-        Ba = other.a
-        Bb = other.b
-        Bc = other.c
-        Be = other.e
-        Bf = other.f
-        Bg = other.g
-        Bi = other.i
-        Bj = other.j
-        Bk = other.k
-        self.a = Aa * Ba + Ab * Be + Ac * Bi
-        self.b = Aa * Bb + Ab * Bf + Ac * Bj
-        self.c = Aa * Bc + Ab * Bg + Ac * Bk
-        self.e = Ae * Ba + Af * Be + Ag * Bi
-        self.f = Ae * Bb + Af * Bf + Ag * Bj
-        self.g = Ae * Bc + Af * Bg + Ag * Bk
-        self.i = Ai * Ba + Aj * Be + Ak * Bi
-        self.j = Ai * Bb + Aj * Bf + Ak * Bj
-        self.k = Ai * Bc + Aj * Bg + Ak * Bk
-        return self
-
-    def identity(self):
-        self.a = self.f = self.k = 1.
-        self.b = self.c = self.e = self.g = self.i = self.j = 0
-        return self
-
-    def scale(self, x, y):
-        self *= Matrix3.new_scale(x, y)
-        return self
-
-    def translate(self, x, y):
-        self *= Matrix3.new_translate(x, y)
-        return self 
-
-    def rotate(self, angle):
-        self *= Matrix3.new_rotate(angle)
-        return self
-
-    # Static constructors
-    def new_identity(cls):
-        self = cls()
-        return self
-    new_identity = classmethod(new_identity)
-
-    def new_scale(cls, x, y):
-        self = cls()
-        self.a = x
-        self.f = y
-        return self
-    new_scale = classmethod(new_scale)
-
-    def new_translate(cls, x, y):
-        self = cls()
-        self.c = x
-        self.g = y
-        return self
-    new_translate = classmethod(new_translate)
-
-    def new_rotate(cls, angle):
-        self = cls()
-        s = math.sin(angle)
-        c = math.cos(angle)
-        self.a = self.f = c
-        self.b = -s
-        self.e = s
-        return self
-    new_rotate = classmethod(new_rotate)
-
-# a b c d
-# e f g h
-# i j k l
-# m n o p
-
-class Matrix4:
-    __slots__ = list('abcdefghijklmnop')
-
-    def __init__(self):
-        self.identity()
-
-    def __copy__(self):
-        M = Matrix4()
-        M.a = self.a
-        M.b = self.b
-        M.c = self.c
-        M.d = self.d
-        M.e = self.e 
-        M.f = self.f
-        M.g = self.g
-        M.h = self.h
-        M.i = self.i
-        M.j = self.j
-        M.k = self.k
-        M.l = self.l
-        M.m = self.m
-        M.n = self.n
-        M.o = self.o
-        M.p = self.p
-        return M
-
-    copy = __copy__
-
-
-    def __repr__(self):
-        return ('Matrix4([% 8.2f % 8.2f % 8.2f % 8.2f\n'  \
-                '         % 8.2f % 8.2f % 8.2f % 8.2f\n'  \
-                '         % 8.2f % 8.2f % 8.2f % 8.2f\n'  \
-                '         % 8.2f % 8.2f % 8.2f % 8.2f])') \
-                % (self.a, self.b, self.c, self.d,
-                   self.e, self.f, self.g, self.h,
-                   self.i, self.j, self.k, self.l,
-                   self.m, self.n, self.o, self.p)
-
-    def __getitem__(self, key):
-        return [self.a, self.e, self.i, self.m,
-                self.b, self.f, self.j, self.n,
-                self.c, self.g, self.k, self.o,
-                self.d, self.h, self.l, self.p][key]
-
-    def __setitem__(self, key, value):
-        L = self[:]
-        L[key] = value
-        (self.a, self.e, self.i, self.m,
-         self.b, self.f, self.j, self.n,
-         self.c, self.g, self.k, self.o,
-         self.d, self.h, self.l, self.p) = L
-
-    def __mul__(self, other):
-        if isinstance(other, Matrix4):
-            # Cache attributes in local vars (see Matrix3.__mul__).
-            Aa = self.a
-            Ab = self.b
-            Ac = self.c
-            Ad = self.d
-            Ae = self.e
-            Af = self.f
-            Ag = self.g
-            Ah = self.h
-            Ai = self.i
-            Aj = self.j
-            Ak = self.k
-            Al = self.l
-            Am = self.m
-            An = self.n
-            Ao = self.o
-            Ap = self.p
-            Ba = other.a
-            Bb = other.b
-            Bc = other.c
-            Bd = other.d
-            Be = other.e
-            Bf = other.f
-            Bg = other.g
-            Bh = other.h
-            Bi = other.i
-            Bj = other.j
-            Bk = other.k
-            Bl = other.l
-            Bm = other.m
-            Bn = other.n
-            Bo = other.o
-            Bp = other.p
-            C = Matrix4()
-            C.a = Aa * Ba + Ab * Be + Ac * Bi + Ad * Bm
-            C.b = Aa * Bb + Ab * Bf + Ac * Bj + Ad * Bn
-            C.c = Aa * Bc + Ab * Bg + Ac * Bk + Ad * Bo
-            C.d = Aa * Bd + Ab * Bh + Ac * Bl + Ad * Bp
-            C.e = Ae * Ba + Af * Be + Ag * Bi + Ah * Bm
-            C.f = Ae * Bb + Af * Bf + Ag * Bj + Ah * Bn
-            C.g = Ae * Bc + Af * Bg + Ag * Bk + Ah * Bo
-            C.h = Ae * Bd + Af * Bh + Ag * Bl + Ah * Bp
-            C.i = Ai * Ba + Aj * Be + Ak * Bi + Al * Bm
-            C.j = Ai * Bb + Aj * Bf + Ak * Bj + Al * Bn
-            C.k = Ai * Bc + Aj * Bg + Ak * Bk + Al * Bo
-            C.l = Ai * Bd + Aj * Bh + Ak * Bl + Al * Bp
-            C.m = Am * Ba + An * Be + Ao * Bi + Ap * Bm
-            C.n = Am * Bb + An * Bf + Ao * Bj + Ap * Bn
-            C.o = Am * Bc + An * Bg + Ao * Bk + Ap * Bo
-            C.p = Am * Bd + An * Bh + Ao * Bl + Ap * Bp
-            return C
-        elif isinstance(other, Point3):
-            A = self
-            B = other
-            P = Point3(0, 0, 0)
-            P.x = A.a * B.x + A.b * B.y + A.c * B.z + A.d
-            P.y = A.e * B.x + A.f * B.y + A.g * B.z + A.h
-            P.z = A.i * B.x + A.j * B.y + A.k * B.z + A.l
-            return P
-        elif isinstance(other, Vector3):
-            A = self
-            B = other
-            V = Vector3(0, 0, 0)
-            V.x = A.a * B.x + A.b * B.y + A.c * B.z
-            V.y = A.e * B.x + A.f * B.y + A.g * B.z
-            V.z = A.i * B.x + A.j * B.y + A.k * B.z
-            return V
-        else:
-            other = other.copy()
-            other._apply_transform(self)
-            return other
-
-    def __imul__(self, other):
-        assert isinstance(other, Matrix4)
-        # Cache attributes in local vars (see Matrix3.__mul__).
-        Aa = self.a
-        Ab = self.b
-        Ac = self.c
-        Ad = self.d
-        Ae = self.e
-        Af = self.f
-        Ag = self.g
-        Ah = self.h
-        Ai = self.i
-        Aj = self.j
-        Ak = self.k
-        Al = self.l
-        Am = self.m
-        An = self.n
-        Ao = self.o
-        Ap = self.p
-        Ba = other.a
-        Bb = other.b
-        Bc = other.c
-        Bd = other.d
-        Be = other.e
-        Bf = other.f
-        Bg = other.g
-        Bh = other.h
-        Bi = other.i
-        Bj = other.j
-        Bk = other.k
-        Bl = other.l
-        Bm = other.m
-        Bn = other.n
-        Bo = other.o
-        Bp = other.p
-        self.a = Aa * Ba + Ab * Be + Ac * Bi + Ad * Bm
-        self.b = Aa * Bb + Ab * Bf + Ac * Bj + Ad * Bn
-        self.c = Aa * Bc + Ab * Bg + Ac * Bk + Ad * Bo
-        self.d = Aa * Bd + Ab * Bh + Ac * Bl + Ad * Bp
-        self.e = Ae * Ba + Af * Be + Ag * Bi + Ah * Bm
-        self.f = Ae * Bb + Af * Bf + Ag * Bj + Ah * Bn
-        self.g = Ae * Bc + Af * Bg + Ag * Bk + Ah * Bo
-        self.h = Ae * Bd + Af * Bh + Ag * Bl + Ah * Bp
-        self.i = Ai * Ba + Aj * Be + Ak * Bi + Al * Bm
-        self.j = Ai * Bb + Aj * Bf + Ak * Bj + Al * Bn
-        self.k = Ai * Bc + Aj * Bg + Ak * Bk + Al * Bo
-        self.l = Ai * Bd + Aj * Bh + Ak * Bl + Al * Bp
-        self.m = Am * Ba + An * Be + Ao * Bi + Ap * Bm
-        self.n = Am * Bb + An * Bf + Ao * Bj + Ap * Bn
-        self.o = Am * Bc + An * Bg + Ao * Bk + Ap * Bo
-        self.p = Am * Bd + An * Bh + Ao * Bl + Ap * Bp
-        return self
-
-    def transform(self, other):
-        A = self
-        B = other
-        P = Point3(0, 0, 0)
-        P.x = A.a * B.x + A.b * B.y + A.c * B.z + A.d
-        P.y = A.e * B.x + A.f * B.y + A.g * B.z + A.h
-        P.z = A.i * B.x + A.j * B.y + A.k * B.z + A.l
-        w =   A.m * B.x + A.n * B.y + A.o * B.z + A.p
-        if w != 0:
-            P.x /= w
-            P.y /= w
-            P.z /= w
-        return P
-
-    def identity(self):
-        self.a = self.f = self.k = self.p = 1.
-        self.b = self.c = self.d = self.e = self.g = self.h = \
-        self.i = self.j = self.l = self.m = self.n = self.o = 0
-        return self
-
-    def scale(self, x, y, z):
-        self *= Matrix4.new_scale(x, y, z)
-        return self
-
-    def translate(self, x, y, z):
-        self *= Matrix4.new_translate(x, y, z)
-        return self 
-
-    def rotatex(self, angle):
-        self *= Matrix4.new_rotatex(angle)
-        return self
-
-    def rotatey(self, angle):
-        self *= Matrix4.new_rotatey(angle)
-        return self
-
-    def rotatez(self, angle):
-        self *= Matrix4.new_rotatez(angle)
-        return self
-
-    def rotate_axis(self, angle, axis):
-        self *= Matrix4.new_rotate_axis(angle, axis)
-        return self
-
-    def rotate_euler(self, heading, attitude, bank):
-        self *= Matrix4.new_rotate_euler(heading, attitude, bank)
-        return self
-
-    def rotate_triple_axis(self, x, y, z):
-        self *= Matrix4.new_rotate_triple_axis(x, y, z)
-        return self
-
-    def transpose(self):
-        (self.a, self.e, self.i, self.m,
-         self.b, self.f, self.j, self.n,
-         self.c, self.g, self.k, self.o,
-         self.d, self.h, self.l, self.p) = \
-        (self.a, self.b, self.c, self.d,
-         self.e, self.f, self.g, self.h,
-         self.i, self.j, self.k, self.l,
-         self.m, self.n, self.o, self.p)
-
-    def transposed(self):
-        M = self.copy()
-        M.transpose()
-        return M
-
-    # Static constructors
-    def new(cls, *values):
-        M = cls()
-        M[:] = values
-        return M
-    new = classmethod(new)
-
-    def new_identity(cls):
-        self = cls()
-        return self
-    new_identity = classmethod(new_identity)
-
-    def new_scale(cls, x, y, z):
-        self = cls()
-        self.a = x
-        self.f = y
-        self.k = z
-        return self
-    new_scale = classmethod(new_scale)
-
-    def new_translate(cls, x, y, z):
-        self = cls()
-        self.d = x
-        self.h = y
-        self.l = z
-        return self
-    new_translate = classmethod(new_translate)
-
-    def new_rotatex(cls, angle):
-        self = cls()
-        s = math.sin(angle)
-        c = math.cos(angle)
-        self.f = self.k = c
-        self.g = -s
-        self.j = s
-        return self
-    new_rotatex = classmethod(new_rotatex)
-
-    def new_rotatey(cls, angle):
-        self = cls()
-        s = math.sin(angle)
-        c = math.cos(angle)
-        self.a = self.k = c
-        self.c = s
-        self.i = -s
-        return self    
-    new_rotatey = classmethod(new_rotatey)
-    
-    def new_rotatez(cls, angle):
-        self = cls()
-        s = math.sin(angle)
-        c = math.cos(angle)
-        self.a = self.f = c
-        self.b = -s
-        self.e = s
-        return self
-    new_rotatez = classmethod(new_rotatez)
-
-    def new_rotate_axis(cls, angle, axis):
-        assert(isinstance(axis, Vector3))
-        vector = axis.normalized()
-        x = vector.x
-        y = vector.y
-        z = vector.z
-
-        self = cls()
-        s = math.sin(angle)
-        c = math.cos(angle)
-        c1 = 1. - c
-        
-        # from the glRotate man page
-        self.a = x * x * c1 + c
-        self.b = x * y * c1 - z * s
-        self.c = x * z * c1 + y * s
-        self.e = y * x * c1 + z * s
-        self.f = y * y * c1 + c
-        self.g = y * z * c1 - x * s
-        self.i = x * z * c1 - y * s
-        self.j = y * z * c1 + x * s
-        self.k = z * z * c1 + c
-        return self
-    new_rotate_axis = classmethod(new_rotate_axis)
-
-    def new_rotate_euler(cls, heading, attitude, bank):
-        # from <A HREF="http://www.euclideanspace.com/">http://www.euclideanspace.com/</A>
-        ch = math.cos(heading)
-        sh = math.sin(heading)
-        ca = math.cos(attitude)
-        sa = math.sin(attitude)
-        cb = math.cos(bank)
-        sb = math.sin(bank)
-
-        self = cls()
-        self.a = ch * ca
-        self.b = sh * sb - ch * sa * cb
-        self.c = ch * sa * sb + sh * cb
-        self.e = sa
-        self.f = ca * cb
-        self.g = -ca * sb
-        self.i = -sh * ca
-        self.j = sh * sa * cb + ch * sb
-        self.k = -sh * sa * sb + ch * cb
-        return self
-    new_rotate_euler = classmethod(new_rotate_euler)
-
-    def new_rotate_triple_axis(cls, x, y, z):
-      m = cls()
-      
-      m.a, m.b, m.c = x.x, y.x, z.x
-      m.e, m.f, m.g = x.y, y.y, z.y
-      m.i, m.j, m.k = x.z, y.z, z.z
-      
-      return m
-    new_rotate_triple_axis = classmethod(new_rotate_triple_axis)
-
-    def new_look_at(cls, eye, at, up):
-      z = (eye - at).normalized()
-      x = up.cross(z).normalized()
-      y = z.cross(x)
-      
-      m = cls.new_rotate_triple_axis(x, y, z)
-      m.d, m.h, m.l = eye.x, eye.y, eye.z
-      return m
-    new_look_at = classmethod(new_look_at)
-    
-    def new_perspective(cls, fov_y, aspect, near, far):
-        # from the gluPerspective man page
-        f = 1 / math.tan(fov_y / 2)
-        self = cls()
-        assert near != 0.0 and near != far
-        self.a = f / aspect
-        self.f = f
-        self.k = (far + near) / (near - far)
-        self.l = 2 * far * near / (near - far)
-        self.o = -1
-        self.p = 0
-        return self
-    new_perspective = classmethod(new_perspective)
-
-    def determinant(self):
-        return ((self.a * self.f - self.e * self.b)
-              * (self.k * self.p - self.o * self.l)
-              - (self.a * self.j - self.i * self.b)
-              * (self.g * self.p - self.o * self.h)
-              + (self.a * self.n - self.m * self.b)
-              * (self.g * self.l - self.k * self.h)
-              + (self.e * self.j - self.i * self.f)
-              * (self.c * self.p - self.o * self.d)
-              - (self.e * self.n - self.m * self.f)
-              * (self.c * self.l - self.k * self.d)
-              + (self.i * self.n - self.m * self.j)
-              * (self.c * self.h - self.g * self.d))
-
-    def inverse(self):
-        tmp = Matrix4()
-        d = self.determinant();
-
-        if abs(d) &lt; 0.001:
-            # No inverse, return identity
-            return tmp
-        else:
-            d = 1.0 / d;
-
-            tmp.a = d * (self.f * (self.k * self.p - self.o * self.l) + self.j * (self.o * self.h - self.g * self.p) + self.n * (self.g * self.l - self.k * self.h));
-            tmp.e = d * (self.g * (self.i * self.p - self.m * self.l) + self.k * (self.m * self.h - self.e * self.p) + self.o * (self.e * self.l - self.i * self.h));
-            tmp.i = d * (self.h * (self.i * self.n - self.m * self.j) + self.l * (self.m * self.f - self.e * self.n) + self.p * (self.e * self.j - self.i * self.f));
-            tmp.m = d * (self.e * (self.n * self.k - self.j * self.o) + self.i * (self.f * self.o - self.n * self.g) + self.m * (self.j * self.g - self.f * self.k));
-            
-            tmp.b = d * (self.j * (self.c * self.p - self.o * self.d) + self.n * (self.k * self.d - self.c * self.l) + self.b * (self.o * self.l - self.k * self.p));
-            tmp.f = d * (self.k * (self.a * self.p - self.m * self.d) + self.o * (self.i * self.d - self.a * self.l) + self.c * (self.m * self.l - self.i * self.p));
-            tmp.j = d * (self.l * (self.a * self.n - self.m * self.b) + self.p * (self.i * self.b - self.a * self.j) + self.d * (self.m * self.j - self.i * self.n));
-            tmp.n = d * (self.i * (self.n * self.c - self.b * self.o) + self.m * (self.b * self.k - self.j * self.c) + self.a * (self.j * self.o - self.n * self.k));
-            
-            tmp.c = d * (self.n * (self.c * self.h - self.g * self.d) + self.b * (self.g * self.p - self.o * self.h) + self.f * (self.o * self.d - self.c * self.p));
-            tmp.g = d * (self.o * (self.a * self.h - self.e * self.d) + self.c * (self.e * self.p - self.m * self.h) + self.g * (self.m * self.d - self.a * self.p));
-            tmp.k = d * (self.p * (self.a * self.f - self.e * self.b) + self.d * (self.e * self.n - self.m * self.f) + self.h * (self.m * self.b - self.a * self.n));
-            tmp.o = d * (self.m * (self.f * self.c - self.b * self.g) + self.a * (self.n * self.g - self.f * self.o) + self.e * (self.b * self.o - self.n * self.c));
-            
-            tmp.d = d * (self.b * (self.k * self.h - self.g * self.l) + self.f * (self.c * self.l - self.k * self.d) + self.j * (self.g * self.d - self.c * self.h));
-            tmp.h = d * (self.c * (self.i * self.h - self.e * self.l) + self.g * (self.a * self.l - self.i * self.d) + self.k * (self.e * self.d - self.a * self.h));
-            tmp.l = d * (self.d * (self.i * self.f - self.e * self.j) + self.h * (self.a * self.j - self.i * self.b) + self.l * (self.e * self.b - self.a * self.f));
-            tmp.p = d * (self.a * (self.f * self.k - self.j * self.g) + self.e * (self.j * self.c - self.b * self.k) + self.i * (self.b * self.g - self.f * self.c));
-
-        return tmp;
-        
-
-class Quaternion:
-    # All methods and naming conventions based off 
-    # <A HREF="http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions">http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions</A>
-
-    # w is the real part, (x, y, z) are the imaginary parts
-    __slots__ = ['w', 'x', 'y', 'z']
-
-    def __init__(self, w=1, x=0, y=0, z=0):
-        self.w = w
-        self.x = x
-        self.y = y
-        self.z = z
-
-    def __copy__(self):
-        Q = Quaternion()
-        Q.w = self.w
-        Q.x = self.x
-        Q.y = self.y
-        Q.z = self.z
-        return Q
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Quaternion(real=%.2f, imag=&lt;%.2f, %.2f, %.2f&gt;)' % \
-            (self.w, self.x, self.y, self.z)
-
-    def __mul__(self, other):
-        if isinstance(other, Quaternion):
-            Ax = self.x
-            Ay = self.y
-            Az = self.z
-            Aw = self.w
-            Bx = other.x
-            By = other.y
-            Bz = other.z
-            Bw = other.w
-            Q = Quaternion()
-            Q.x =  Ax * Bw + Ay * Bz - Az * By + Aw * Bx    
-            Q.y = -Ax * Bz + Ay * Bw + Az * Bx + Aw * By
-            Q.z =  Ax * By - Ay * Bx + Az * Bw + Aw * Bz
-            Q.w = -Ax * Bx - Ay * By - Az * Bz + Aw * Bw
-            return Q
-        elif isinstance(other, Vector3):
-            w = self.w
-            x = self.x
-            y = self.y
-            z = self.z
-            Vx = other.x
-            Vy = other.y
-            Vz = other.z
-            return other.__class__(\
-               w * w * Vx + 2 * y * w * Vz - 2 * z * w * Vy + \
-               x * x * Vx + 2 * y * x * Vy + 2 * z * x * Vz - \
-               z * z * Vx - y * y * Vx,
-               2 * x * y * Vx + y * y * Vy + 2 * z * y * Vz + \
-               2 * w * z * Vx - z * z * Vy + w * w * Vy - \
-               2 * x * w * Vz - x * x * Vy,
-               2 * x * z * Vx + 2 * y * z * Vy + \
-               z * z * Vz - 2 * w * y * Vx - y * y * Vz + \
-               2 * w * x * Vy - x * x * Vz + w * w * Vz)
-        else:
-            other = other.copy()
-            other._apply_transform(self)
-            return other
-
-    def __imul__(self, other):
-        assert isinstance(other, Quaternion)
-        Ax = self.x
-        Ay = self.y
-        Az = self.z
-        Aw = self.w
-        Bx = other.x
-        By = other.y
-        Bz = other.z
-        Bw = other.w
-        self.x =  Ax * Bw + Ay * Bz - Az * By + Aw * Bx    
-        self.y = -Ax * Bz + Ay * Bw + Az * Bx + Aw * By
-        self.z =  Ax * By - Ay * Bx + Az * Bw + Aw * Bz
-        self.w = -Ax * Bx - Ay * By - Az * Bz + Aw * Bw
-        return self
-
-    def __abs__(self):
-        return math.sqrt(self.w ** 2 + \
-                         self.x ** 2 + \
-                         self.y ** 2 + \
-                         self.z ** 2)
-
-    magnitude = __abs__
-
-    def magnitude_squared(self):
-        return self.w ** 2 + \
-               self.x ** 2 + \
-               self.y ** 2 + \
-               self.z ** 2 
-
-    def identity(self):
-        self.w = 1
-        self.x = 0
-        self.y = 0
-        self.z = 0
-        return self
-
-    def rotate_axis(self, angle, axis):
-        self *= Quaternion.new_rotate_axis(angle, axis)
-        return self
-
-    def rotate_euler(self, heading, attitude, bank):
-        self *= Quaternion.new_rotate_euler(heading, attitude, bank)
-        return self
-
-    def rotate_matrix(self, m):
-        self *= Quaternion.new_rotate_matrix(m)
-        return self
-
-    def conjugated(self):
-        Q = Quaternion()
-        Q.w = self.w
-        Q.x = -self.x
-        Q.y = -self.y
-        Q.z = -self.z
-        return Q
-
-    def normalize(self):
-        d = self.magnitude()
-        if d != 0:
-            self.w /= d
-            self.x /= d
-            self.y /= d
-            self.z /= d
-        return self
-
-    def normalized(self):
-        d = self.magnitude()
-        if d != 0:
-            Q = Quaternion()
-            Q.w = self.w / d
-            Q.x = self.x / d
-            Q.y = self.y / d
-            Q.z = self.z / d
-            return Q
-        else:
-            return self.copy()
-
-    def get_angle_axis(self):
-        if self.w &gt; 1:
-            self = self.normalized()
-        angle = 2 * math.acos(self.w)
-        s = math.sqrt(1 - self.w ** 2)
-        if s &lt; 0.001:
-            return angle, Vector3(1, 0, 0)
-        else:
-            return angle, Vector3(self.x / s, self.y / s, self.z / s)
-
-    def get_euler(self):
-        t = self.x * self.y + self.z * self.w
-        if t &gt; 0.4999:
-            heading = 2 * math.atan2(self.x, self.w)
-            attitude = math.pi / 2
-            bank = 0
-        elif t &lt; -0.4999:
-            heading = -2 * math.atan2(self.x, self.w)
-            attitude = -math.pi / 2
-            bank = 0
-        else:
-            sqx = self.x ** 2
-            sqy = self.y ** 2
-            sqz = self.z ** 2
-            heading = math.atan2(2 * self.y * self.w - 2 * self.x * self.z,
-                                 1 - 2 * sqy - 2 * sqz)
-            attitude = math.asin(2 * t)
-            bank = math.atan2(2 * self.x * self.w - 2 * self.y * self.z,
-                              1 - 2 * sqx - 2 * sqz)
-        return heading, attitude, bank
-
-    def get_matrix(self):
-        xx = self.x ** 2
-        xy = self.x * self.y
-        xz = self.x * self.z
-        xw = self.x * self.w
-        yy = self.y ** 2
-        yz = self.y * self.z
-        yw = self.y * self.w
-        zz = self.z ** 2
-        zw = self.z * self.w
-        M = Matrix4()
-        M.a = 1 - 2 * (yy + zz)
-        M.b = 2 * (xy - zw)
-        M.c = 2 * (xz + yw)
-        M.e = 2 * (xy + zw)
-        M.f = 1 - 2 * (xx + zz)
-        M.g = 2 * (yz - xw)
-        M.i = 2 * (xz - yw)
-        M.j = 2 * (yz + xw)
-        M.k = 1 - 2 * (xx + yy)
-        return M
-
-    # Static constructors
-    def new_identity(cls):
-        return cls()
-    new_identity = classmethod(new_identity)
-
-    def new_rotate_axis(cls, angle, axis):
-        assert(isinstance(axis, Vector3))
-        axis = axis.normalized()
-        s = math.sin(angle / 2)
-        Q = cls()
-        Q.w = math.cos(angle / 2)
-        Q.x = axis.x * s
-        Q.y = axis.y * s
-        Q.z = axis.z * s
-        return Q
-    new_rotate_axis = classmethod(new_rotate_axis)
-
-    def new_rotate_euler(cls, heading, attitude, bank):
-        Q = cls()
-        c1 = math.cos(heading / 2)
-        s1 = math.sin(heading / 2)
-        c2 = math.cos(attitude / 2)
-        s2 = math.sin(attitude / 2)
-        c3 = math.cos(bank / 2)
-        s3 = math.sin(bank / 2)
-
-        Q.w = c1 * c2 * c3 - s1 * s2 * s3
-        Q.x = s1 * s2 * c3 + c1 * c2 * s3
-        Q.y = s1 * c2 * c3 + c1 * s2 * s3
-        Q.z = c1 * s2 * c3 - s1 * c2 * s3
-        return Q
-    new_rotate_euler = classmethod(new_rotate_euler)
-    
-    def new_rotate_matrix(cls, m):
-      if m[0*4 + 0] + m[1*4 + 1] + m[2*4 + 2] &gt; 0.00000001:
-        t = m[0*4 + 0] + m[1*4 + 1] + m[2*4 + 2] + 1.0
-        s = 0.5/math.sqrt(t)
-        
-        return cls(
-          s*t,
-          (m[1*4 + 2] - m[2*4 + 1])*s,
-          (m[2*4 + 0] - m[0*4 + 2])*s,
-          (m[0*4 + 1] - m[1*4 + 0])*s
-          )
-        
-      elif m[0*4 + 0] &gt; m[1*4 + 1] and m[0*4 + 0] &gt; m[2*4 + 2]:
-        t = m[0*4 + 0] - m[1*4 + 1] - m[2*4 + 2] + 1.0
-        s = 0.5/math.sqrt(t)
-        
-        return cls(
-          (m[1*4 + 2] - m[2*4 + 1])*s,
-          s*t,
-          (m[0*4 + 1] + m[1*4 + 0])*s,
-          (m[2*4 + 0] + m[0*4 + 2])*s
-          )
-        
-      elif m[1*4 + 1] &gt; m[2*4 + 2]:
-        t = -m[0*4 + 0] + m[1*4 + 1] - m[2*4 + 2] + 1.0
-        s = 0.5/math.sqrt(t)
-        
-        return cls(
-          (m[2*4 + 0] - m[0*4 + 2])*s,
-          (m[0*4 + 1] + m[1*4 + 0])*s,
-          s*t,
-          (m[1*4 + 2] + m[2*4 + 1])*s
-          )
-        
-      else:
-        t = -m[0*4 + 0] - m[1*4 + 1] + m[2*4 + 2] + 1.0
-        s = 0.5/math.sqrt(t)
-        
-        return cls(
-          (m[0*4 + 1] - m[1*4 + 0])*s,
-          (m[2*4 + 0] + m[0*4 + 2])*s,
-          (m[1*4 + 2] + m[2*4 + 1])*s,
-          s*t
-          )
-    new_rotate_matrix = classmethod(new_rotate_matrix)
-    
-    def new_interpolate(cls, q1, q2, t):
-        assert isinstance(q1, Quaternion) and isinstance(q2, Quaternion)
-        Q = cls()
-
-        costheta = q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z
-        if costheta &lt; 0.:
-            costheta = -costheta
-            q1 = q1.conjugated()
-        elif costheta &gt; 1:
-            costheta = 1
-
-        theta = math.acos(costheta)
-        if abs(theta) &lt; 0.01:
-            Q.w = q2.w
-            Q.x = q2.x
-            Q.y = q2.y
-            Q.z = q2.z
-            return Q
-
-        sintheta = math.sqrt(1.0 - costheta * costheta)
-        if abs(sintheta) &lt; 0.01:
-            Q.w = (q1.w + q2.w) * 0.5
-            Q.x = (q1.x + q2.x) * 0.5
-            Q.y = (q1.y + q2.y) * 0.5
-            Q.z = (q1.z + q2.z) * 0.5
-            return Q
-
-        ratio1 = math.sin((1 - t) * theta) / sintheta
-        ratio2 = math.sin(t * theta) / sintheta
-
-        Q.w = q1.w * ratio1 + q2.w * ratio2
-        Q.x = q1.x * ratio1 + q2.x * ratio2
-        Q.y = q1.y * ratio1 + q2.y * ratio2
-        Q.z = q1.z * ratio1 + q2.z * ratio2
-        return Q
-    new_interpolate = classmethod(new_interpolate)
-
-# Geometry
-# Much maths thanks to Paul Bourke, <A HREF="http://astronomy.swin.edu.au/~pbourke">http://astronomy.swin.edu.au/~pbourke</A>
-# ---------------------------------------------------------------------------
-
-class Geometry:
-    def _connect_unimplemented(self, other):
-        raise AttributeError, 'Cannot connect %s to %s' % \
-            (self.__class__, other.__class__)
-
-    def _intersect_unimplemented(self, other):
-        raise AttributeError, 'Cannot intersect %s and %s' % \
-            (self.__class__, other.__class__)
-
-    _intersect_point2 = _intersect_unimplemented
-    _intersect_line2 = _intersect_unimplemented
-    _intersect_circle = _intersect_unimplemented
-    _connect_point2 = _connect_unimplemented
-    _connect_line2 = _connect_unimplemented
-    _connect_circle = _connect_unimplemented
-
-    _intersect_point3 = _intersect_unimplemented
-    _intersect_line3 = _intersect_unimplemented
-    _intersect_sphere = _intersect_unimplemented
-    _intersect_plane = _intersect_unimplemented
-    _connect_point3 = _connect_unimplemented
-    _connect_line3 = _connect_unimplemented
-    _connect_sphere = _connect_unimplemented
-    _connect_plane = _connect_unimplemented
-
-    def intersect(self, other):
-        raise NotImplementedError
-
-    def connect(self, other):
-        raise NotImplementedError
-
-    def distance(self, other):
-        c = self.connect(other)
-        if c:
-            return c.length
-        return 0.0
-
-def _intersect_point2_circle(P, C):
-    return abs(P - C.c) &lt;= C.r
-    
-def _intersect_line2_line2(A, B):
-    d = B.v.y * A.v.x - B.v.x * A.v.y
-    if d == 0:
-        return None
-
-    dy = A.p.y - B.p.y
-    dx = A.p.x - B.p.x
-    ua = (B.v.x * dy - B.v.y * dx) / d
-    if not A._u_in(ua):
-        return None
-    ub = (A.v.x * dy - A.v.y * dx) / d
-    if not B._u_in(ub):
-        return None
-
-    return Point2(A.p.x + ua * A.v.x,
-                  A.p.y + ua * A.v.y)
-
-def _intersect_line2_circle(L, C):
-    a = L.v.magnitude_squared()
-    b = 2 * (L.v.x * (L.p.x - C.c.x) + \
-             L.v.y * (L.p.y - C.c.y))
-    c = C.c.magnitude_squared() + \
-        L.p.magnitude_squared() - \
-        2 * C.c.dot(L.p) - \
-        C.r ** 2
-    det = b ** 2 - 4 * a * c
-    if det &lt; 0:
-        return None
-    sq = math.sqrt(det)
-    u1 = (-b + sq) / (2 * a)
-    u2 = (-b - sq) / (2 * a)
-    if not L._u_in(u1):
-        u1 = max(min(u1, 1.0), 0.0)
-    if not L._u_in(u2):
-        u2 = max(min(u2, 1.0), 0.0)
-
-    # Tangent
-    if u1 == u2:
-        return Point2(L.p.x + u1 * L.v.x,
-                      L.p.y + u1 * L.v.y)
-
-    return LineSegment2(Point2(L.p.x + u1 * L.v.x,
-                               L.p.y + u1 * L.v.y),
-                        Point2(L.p.x + u2 * L.v.x,
-                               L.p.y + u2 * L.v.y))
-
-def _connect_point2_line2(P, L):
-    d = L.v.magnitude_squared()
-    assert d != 0
-    u = ((P.x - L.p.x) * L.v.x + \
-         (P.y - L.p.y) * L.v.y) / d
-    if not L._u_in(u):
-        u = max(min(u, 1.0), 0.0)
-    return LineSegment2(P, 
-                        Point2(L.p.x + u * L.v.x,
-                               L.p.y + u * L.v.y))
-
-def _connect_point2_circle(P, C):
-    v = P - C.c
-    v.normalize()
-    v *= C.r
-    return LineSegment2(P, Point2(C.c.x + v.x, C.c.y + v.y))
-
-def _connect_line2_line2(A, B):
-    d = B.v.y * A.v.x - B.v.x * A.v.y
-    if d == 0:
-        # Parallel, connect an endpoint with a line
-        if isinstance(B, Ray2) or isinstance(B, LineSegment2):
-            p1, p2 = _connect_point2_line2(B.p, A)
-            return p2, p1
-        # No endpoint (or endpoint is on A), possibly choose arbitrary point
-        # on line.
-        return _connect_point2_line2(A.p, B)
-
-    dy = A.p.y - B.p.y
-    dx = A.p.x - B.p.x
-    ua = (B.v.x * dy - B.v.y * dx) / d
-    if not A._u_in(ua):
-        ua = max(min(ua, 1.0), 0.0)
-    ub = (A.v.x * dy - A.v.y * dx) / d
-    if not B._u_in(ub):
-        ub = max(min(ub, 1.0), 0.0)
-
-    return LineSegment2(Point2(A.p.x + ua * A.v.x, A.p.y + ua * A.v.y),
-                        Point2(B.p.x + ub * B.v.x, B.p.y + ub * B.v.y))
-
-def _connect_circle_line2(C, L):
-    d = L.v.magnitude_squared()
-    assert d != 0
-    u = ((C.c.x - L.p.x) * L.v.x + (C.c.y - L.p.y) * L.v.y) / d
-    if not L._u_in(u):
-        u = max(min(u, 1.0), 0.0)
-    point = Point2(L.p.x + u * L.v.x, L.p.y + u * L.v.y)
-    v = (point - C.c)
-    v.normalize()
-    v *= C.r
-    return LineSegment2(Point2(C.c.x + v.x, C.c.y + v.y), point)
-
-def _connect_circle_circle(A, B):
-    v = B.c - A.c
-    v.normalize()
-    return LineSegment2(Point2(A.c.x + v.x * A.r, A.c.y + v.y * A.r),
-                        Point2(B.c.x - v.x * B.r, B.c.y - v.y * B.r))
-
-
-class Point2(Vector2, Geometry):
-    def __repr__(self):
-        return 'Point2(%.2f, %.2f)' % (self.x, self.y)
-
-    def intersect(self, other):
-        return other._intersect_point2(self)
-
-    def _intersect_circle(self, other):
-        return _intersect_point2_circle(self, other)
-
-    def connect(self, other):
-        return other._connect_point2(self)
-
-    def _connect_point2(self, other):
-        return LineSegment2(other, self)
-    
-    def _connect_line2(self, other):
-        c = _connect_point2_line2(self, other)
-        if c:
-            return c._swap()
-
-    def _connect_circle(self, other):
-        c = _connect_point2_circle(self, other)
-        if c:
-            return c._swap()
-
-class Line2(Geometry):
-    __slots__ = ['p', 'v']
-
-    def __init__(self, *args):
-        if len(args) == 3:
-            assert isinstance(args[0], Point2) and \
-                   isinstance(args[1], Vector2) and \
-                   type(args[2]) == float
-            self.p = args[0].copy()
-            self.v = args[1] * args[2] / abs(args[1])
-        elif len(args) == 2:
-            if isinstance(args[0], Point2) and isinstance(args[1], Point2):
-                self.p = args[0].copy()
-                self.v = args[1] - args[0]
-            elif isinstance(args[0], Point2) and isinstance(args[1], Vector2):
-                self.p = args[0].copy()
-                self.v = args[1].copy()
-            else:
-                raise AttributeError, '%r' % (args,)
-        elif len(args) == 1:
-            if isinstance(args[0], Line2):
-                self.p = args[0].p.copy()
-                self.v = args[0].v.copy()
-            else:
-                raise AttributeError, '%r' % (args,)
-        else:
-            raise AttributeError, '%r' % (args,)
-        
-        if not self.v:
-            raise AttributeError, 'Line has zero-length vector'
-
-    def __copy__(self):
-        return self.__class__(self.p, self.v)
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Line2(&lt;%.2f, %.2f&gt; + u&lt;%.2f, %.2f&gt;)' % \
-            (self.p.x, self.p.y, self.v.x, self.v.y)
-
-    p1 = property(lambda self: self.p)
-    p2 = property(lambda self: Point2(self.p.x + self.v.x, 
-                                      self.p.y + self.v.y))
-
-    def _apply_transform(self, t):
-        self.p = t * self.p
-        self.v = t * self.v
-
-    def _u_in(self, u):
-        return True
-
-    def intersect(self, other):
-        return other._intersect_line2(self)
-
-    def _intersect_line2(self, other):
-        return _intersect_line2_line2(self, other)
-
-    def _intersect_circle(self, other):
-        return _intersect_line2_circle(self, other)
-
-    def connect(self, other):
-        return other._connect_line2(self)
-
-    def _connect_point2(self, other):
-        return _connect_point2_line2(other, self)
-
-    def _connect_line2(self, other):
-        return _connect_line2_line2(other, self)
-
-    def _connect_circle(self, other):
-        return _connect_circle_line2(other, self)
-
-class Ray2(Line2):
-    def __repr__(self):
-        return 'Ray2(&lt;%.2f, %.2f&gt; + u&lt;%.2f, %.2f&gt;)' % \
-            (self.p.x, self.p.y, self.v.x, self.v.y)
-
-    def _u_in(self, u):
-        return u &gt;= 0.0
-
-class LineSegment2(Line2):
-    def __repr__(self):
-        return 'LineSegment2(&lt;%.2f, %.2f&gt; to &lt;%.2f, %.2f&gt;)' % \
-            (self.p.x, self.p.y, self.p.x + self.v.x, self.p.y + self.v.y)
-
-    def _u_in(self, u):
-        return u &gt;= 0.0 and u &lt;= 1.0
-
-    def __abs__(self):
-        return abs(self.v)
-
-    def magnitude_squared(self):
-        return self.v.magnitude_squared()
-
-    def _swap(self):
-        # used by connect methods to switch order of points
-        self.p = self.p2
-        self.v *= -1
-        return self
-
-    length = property(lambda self: abs(self.v))
-
-class Circle(Geometry):
-    __slots__ = ['c', 'r']
-
-    def __init__(self, center, radius):
-        assert isinstance(center, Vector2) and type(radius) == float
-        self.c = center.copy()
-        self.r = radius
-
-    def __copy__(self):
-        return self.__class__(self.c, self.r)
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Circle(&lt;%.2f, %.2f&gt;, radius=%.2f)' % \
-            (self.c.x, self.c.y, self.r)
-
-    def _apply_transform(self, t):
-        self.c = t * self.c
-
-    def intersect(self, other):
-        return other._intersect_circle(self)
-
-    def _intersect_point2(self, other):
-        return _intersect_point2_circle(other, self)
-
-    def _intersect_line2(self, other):
-        return _intersect_line2_circle(other, self)
-
-    def connect(self, other):
-        return other._connect_circle(self)
-
-    def _connect_point2(self, other):
-        return _connect_point2_circle(other, self)
-
-    def _connect_line2(self, other):
-        c = _connect_circle_line2(self, other)
-        if c:
-            return c._swap()
-
-    def _connect_circle(self, other):
-        return _connect_circle_circle(other, self)
-
-# 3D Geometry
-# -------------------------------------------------------------------------
-
-def _connect_point3_line3(P, L):
-    d = L.v.magnitude_squared()
-    assert d != 0
-    u = ((P.x - L.p.x) * L.v.x + \
-         (P.y - L.p.y) * L.v.y + \
-         (P.z - L.p.z) * L.v.z) / d
-    if not L._u_in(u):
-        u = max(min(u, 1.0), 0.0)
-    return LineSegment3(P, Point3(L.p.x + u * L.v.x,
-                                  L.p.y + u * L.v.y,
-                                  L.p.z + u * L.v.z))
-
-def _connect_point3_sphere(P, S):
-    v = P - S.c
-    v.normalize()
-    v *= S.r
-    return LineSegment3(P, Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z))
-
-def _connect_point3_plane(p, plane):
-    n = plane.n.normalized()
-    d = p.dot(plane.n) - plane.k
-    return LineSegment3(p, Point3(p.x - n.x * d, p.y - n.y * d, p.z - n.z * d))
-
-def _connect_line3_line3(A, B):
-    assert A.v and B.v
-    p13 = A.p - B.p
-    d1343 = p13.dot(B.v)
-    d4321 = B.v.dot(A.v)
-    d1321 = p13.dot(A.v)
-    d4343 = B.v.magnitude_squared()
-    denom = A.v.magnitude_squared() * d4343 - d4321 ** 2
-    if denom == 0:
-        # Parallel, connect an endpoint with a line
-        if isinstance(B, Ray3) or isinstance(B, LineSegment3):
-            return _connect_point3_line3(B.p, A)._swap()
-        # No endpoint (or endpoint is on A), possibly choose arbitrary
-        # point on line.
-        return _connect_point3_line3(A.p, B)
-
-    ua = (d1343 * d4321 - d1321 * d4343) / denom
-    if not A._u_in(ua):
-        ua = max(min(ua, 1.0), 0.0)
-    ub = (d1343 + d4321 * ua) / d4343
-    if not B._u_in(ub):
-        ub = max(min(ub, 1.0), 0.0)
-    return LineSegment3(Point3(A.p.x + ua * A.v.x,
-                               A.p.y + ua * A.v.y,
-                               A.p.z + ua * A.v.z),
-                        Point3(B.p.x + ub * B.v.x,
-                               B.p.y + ub * B.v.y,
-                               B.p.z + ub * B.v.z))
-
-def _connect_line3_plane(L, P):
-    d = P.n.dot(L.v)
-    if not d:
-        # Parallel, choose an endpoint
-        return _connect_point3_plane(L.p, P)
-    u = (P.k - P.n.dot(L.p)) / d
-    if not L._u_in(u):
-        # intersects out of range, choose nearest endpoint
-        u = max(min(u, 1.0), 0.0)
-        return _connect_point3_plane(Point3(L.p.x + u * L.v.x,
-                                            L.p.y + u * L.v.y,
-                                            L.p.z + u * L.v.z), P)
-    # Intersection
-    return None
-
-def _connect_sphere_line3(S, L):
-    d = L.v.magnitude_squared()
-    assert d != 0
-    u = ((S.c.x - L.p.x) * L.v.x + \
-         (S.c.y - L.p.y) * L.v.y + \
-         (S.c.z - L.p.z) * L.v.z) / d
-    if not L._u_in(u):
-        u = max(min(u, 1.0), 0.0)
-    point = Point3(L.p.x + u * L.v.x, L.p.y + u * L.v.y, L.p.z + u * L.v.z)
-    v = (point - S.c)
-    v.normalize()
-    v *= S.r
-    return LineSegment3(Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z), 
-                        point)
-
-def _connect_sphere_sphere(A, B):
-    v = B.c - A.c
-    v.normalize()
-    return LineSegment3(Point3(A.c.x + v.x * A.r,
-                               A.c.y + v.y * A.r,
-                               A.c.x + v.z * A.r),
-                        Point3(B.c.x + v.x * B.r,
-                               B.c.y + v.y * B.r,
-                               B.c.x + v.z * B.r))
-
-def _connect_sphere_plane(S, P):
-    c = _connect_point3_plane(S.c, P)
-    if not c:
-        return None
-    p2 = c.p2
-    v = p2 - S.c
-    v.normalize()
-    v *= S.r
-    return LineSegment3(Point3(S.c.x + v.x, S.c.y + v.y, S.c.z + v.z), 
-                        p2)
-
-def _connect_plane_plane(A, B):
-    if A.n.cross(B.n):
-        # Planes intersect
-        return None
-    else:
-        # Planes are parallel, connect to arbitrary point
-        return _connect_point3_plane(A._get_point(), B)
-
-def _intersect_point3_sphere(P, S):
-    return abs(P - S.c) &lt;= S.r
-    
-def _intersect_line3_sphere(L, S):
-    a = L.v.magnitude_squared()
-    b = 2 * (L.v.x * (L.p.x - S.c.x) + \
-             L.v.y * (L.p.y - S.c.y) + \
-             L.v.z * (L.p.z - S.c.z))
-    c = S.c.magnitude_squared() + \
-        L.p.magnitude_squared() - \
-        2 * S.c.dot(L.p) - \
-        S.r ** 2
-    det = b ** 2 - 4 * a * c
-    if det &lt; 0:
-        return None
-    sq = math.sqrt(det)
-    u1 = (-b + sq) / (2 * a)
-    u2 = (-b - sq) / (2 * a)
-    if not L._u_in(u1):
-        u1 = max(min(u1, 1.0), 0.0)
-    if not L._u_in(u2):
-        u2 = max(min(u2, 1.0), 0.0)
-    return LineSegment3(Point3(L.p.x + u1 * L.v.x,
-                               L.p.y + u1 * L.v.y,
-                               L.p.z + u1 * L.v.z),
-                        Point3(L.p.x + u2 * L.v.x,
-                               L.p.y + u2 * L.v.y,
-                               L.p.z + u2 * L.v.z))
-
-def _intersect_line3_plane(L, P):
-    d = P.n.dot(L.v)
-    if not d:
-        # Parallel
-        return None
-    u = (P.k - P.n.dot(L.p)) / d
-    if not L._u_in(u):
-        return None
-    return Point3(L.p.x + u * L.v.x,
-                  L.p.y + u * L.v.y,
-                  L.p.z + u * L.v.z)
-
-def _intersect_plane_plane(A, B):
-    n1_m = A.n.magnitude_squared()
-    n2_m = B.n.magnitude_squared()
-    n1d2 = A.n.dot(B.n)
-    det = n1_m * n2_m - n1d2 ** 2
-    if det == 0:
-        # Parallel
-        return None
-    c1 = (A.k * n2_m - B.k * n1d2) / det
-    c2 = (B.k * n1_m - A.k * n1d2) / det
-    return Line3(Point3(c1 * A.n.x + c2 * B.n.x,
-                        c1 * A.n.y + c2 * B.n.y,
-                        c1 * A.n.z + c2 * B.n.z), 
-                 A.n.cross(B.n))
-
-class Point3(Vector3, Geometry):
-    def __repr__(self):
-        return 'Point3(%.2f, %.2f, %.2f)' % (self.x, self.y, self.z)
-
-    def intersect(self, other):
-        return other._intersect_point3(self)
-
-    def _intersect_sphere(self, other):
-        return _intersect_point3_sphere(self, other)
-
-    def connect(self, other):
-        return other._connect_point3(self)
-
-    def _connect_point3(self, other):
-        if self != other:
-            return LineSegment3(other, self)
-        return None
-
-    def _connect_line3(self, other):
-        c = _connect_point3_line3(self, other)
-        if c:
-            return c._swap()
-        
-    def _connect_sphere(self, other):
-        c = _connect_point3_sphere(self, other)
-        if c:
-            return c._swap()
-
-    def _connect_plane(self, other):
-        c = _connect_point3_plane(self, other)
-        if c:
-            return c._swap()
-
-class Line3:
-    __slots__ = ['p', 'v']
-
-    def __init__(self, *args):
-        if len(args) == 3:
-            assert isinstance(args[0], Point3) and \
-                   isinstance(args[1], Vector3) and \
-                   type(args[2]) == float
-            self.p = args[0].copy()
-            self.v = args[1] * args[2] / abs(args[1])
-        elif len(args) == 2:
-            if isinstance(args[0], Point3) and isinstance(args[1], Point3):
-                self.p = args[0].copy()
-                self.v = args[1] - args[0]
-            elif isinstance(args[0], Point3) and isinstance(args[1], Vector3):
-                self.p = args[0].copy()
-                self.v = args[1].copy()
-            else:
-                raise AttributeError, '%r' % (args,)
-        elif len(args) == 1:
-            if isinstance(args[0], Line3):
-                self.p = args[0].p.copy()
-                self.v = args[0].v.copy()
-            else:
-                raise AttributeError, '%r' % (args,)
-        else:
-            raise AttributeError, '%r' % (args,)
-        
-        # XXX This is annoying.
-        #if not self.v:
-        #    raise AttributeError, 'Line has zero-length vector'
-
-    def __copy__(self):
-        return self.__class__(self.p, self.v)
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Line3(&lt;%.2f, %.2f, %.2f&gt; + u&lt;%.2f, %.2f, %.2f&gt;)' % \
-            (self.p.x, self.p.y, self.p.z, self.v.x, self.v.y, self.v.z)
-
-    p1 = property(lambda self: self.p)
-    p2 = property(lambda self: Point3(self.p.x + self.v.x, 
-                                      self.p.y + self.v.y,
-                                      self.p.z + self.v.z))
-
-    def _apply_transform(self, t):
-        self.p = t * self.p
-        self.v = t * self.v
-
-    def _u_in(self, u):
-        return True
-
-    def intersect(self, other):
-        return other._intersect_line3(self)
-
-    def _intersect_sphere(self, other):
-        return _intersect_line3_sphere(self, other)
-
-    def _intersect_plane(self, other):
-        return _intersect_line3_plane(self, other)
-
-    def connect(self, other):
-        return other._connect_line3(self)
-
-    def _connect_point3(self, other):
-        return _connect_point3_line3(other, self)
-
-    def _connect_line3(self, other):
-        return _connect_line3_line3(other, self)
-
-    def _connect_sphere(self, other):
-        return _connect_sphere_line3(other, self)
-
-    def _connect_plane(self, other):
-        c = _connect_line3_plane(self, other)
-        if c:
-            return c
-
-class Ray3(Line3):
-    def __repr__(self):
-        return 'Ray3(&lt;%.2f, %.2f, %.2f&gt; + u&lt;%.2f, %.2f, %.2f&gt;)' % \
-            (self.p.x, self.p.y, self.p.z, self.v.x, self.v.y, self.v.z)
-
-    def _u_in(self, u):
-        return u &gt;= 0.0
-
-class LineSegment3(Line3):
-    def __repr__(self):
-        return 'LineSegment3(&lt;%.2f, %.2f, %.2f&gt; to &lt;%.2f, %.2f, %.2f&gt;)' % \
-            (self.p.x, self.p.y, self.p.z,
-             self.p.x + self.v.x, self.p.y + self.v.y, self.p.z + self.v.z)
-
-    def _u_in(self, u):
-        return u &gt;= 0.0 and u &lt;= 1.0
-
-    def __abs__(self):
-        return abs(self.v)
-
-    def magnitude_squared(self):
-        return self.v.magnitude_squared()
-
-    def _swap(self):
-        # used by connect methods to switch order of points
-        self.p = self.p2
-        self.v *= -1
-        return self
-
-    length = property(lambda self: abs(self.v))
-
-class Sphere:
-    __slots__ = ['c', 'r']
-
-    def __init__(self, center, radius):
-        assert isinstance(center, Vector3) and type(radius) == float
-        self.c = center.copy()
-        self.r = radius
-
-    def __copy__(self):
-        return self.__class__(self.c, self.r)
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Sphere(&lt;%.2f, %.2f, %.2f&gt;, radius=%.2f)' % \
-            (self.c.x, self.c.y, self.c.z, self.r)
-
-    def _apply_transform(self, t):
-        self.c = t * self.c
-
-    def intersect(self, other):
-        return other._intersect_sphere(self)
-
-    def _intersect_point3(self, other):
-        return _intersect_point3_sphere(other, self)
-
-    def _intersect_line3(self, other):
-        return _intersect_line3_sphere(other, self)
-
-    def connect(self, other):
-        return other._connect_sphere(self)
-
-    def _connect_point3(self, other):
-        return _connect_point3_sphere(other, self)
-
-    def _connect_line3(self, other):
-        c = _connect_sphere_line3(self, other)
-        if c:
-            return c._swap()
-
-    def _connect_sphere(self, other):
-        return _connect_sphere_sphere(other, self)
-
-    def _connect_plane(self, other):
-        c = _connect_sphere_plane(self, other)
-        if c:
-            return c
-
-class Plane:
-    # n.p = k, where n is normal, p is point on plane, k is constant scalar
-    __slots__ = ['n', 'k']
-
-    def __init__(self, *args):
-        if len(args) == 3:
-            assert isinstance(args[0], Point3) and \
-                   isinstance(args[1], Point3) and \
-                   isinstance(args[2], Point3)
-            self.n = (args[1] - args[0]).cross(args[2] - args[0])
-            self.n.normalize()
-            self.k = self.n.dot(args[0])
-        elif len(args) == 2:
-            if isinstance(args[0], Point3) and isinstance(args[1], Vector3):
-                self.n = args[1].normalized()
-                self.k = self.n.dot(args[0])
-            elif isinstance(args[0], Vector3) and type(args[1]) == float:
-                self.n = args[0].normalized()
-                self.k = args[1]
-            else:
-                raise AttributeError, '%r' % (args,)
-
-        else:
-            raise AttributeError, '%r' % (args,)
-        
-        if not self.n:
-            raise AttributeError, 'Points on plane are colinear'
-
-    def __copy__(self):
-        return self.__class__(self.n, self.k)
-
-    copy = __copy__
-
-    def __repr__(self):
-        return 'Plane(&lt;%.2f, %.2f, %.2f&gt;.p = %.2f)' % \
-            (self.n.x, self.n.y, self.n.z, self.k)
-
-    def _get_point(self):
-        # Return an arbitrary point on the plane
-        if self.n.z:
-            return Point3(0., 0., self.k / self.n.z)
-        elif self.n.y:
-            return Point3(0., self.k / self.n.y, 0.)
-        else:
-            return Point3(self.k / self.n.x, 0., 0.)
-
-    def _apply_transform(self, t):
-        p = t * self._get_point()
-        self.n = t * self.n
-        self.k = self.n.dot(p)
-
-    def intersect(self, other):
-        return other._intersect_plane(self)
-
-    def _intersect_line3(self, other):
-        return _intersect_line3_plane(other, self)
-
-    def _intersect_plane(self, other):
-        return _intersect_plane_plane(self, other)
-
-    def connect(self, other):
-        return other._connect_plane(self)
-
-    def _connect_point3(self, other):
-        return _connect_point3_plane(other, self)
-
-    def _connect_line3(self, other):
-        return _connect_line3_plane(other, self)
-
-    def _connect_sphere(self, other):
-        return _connect_sphere_plane(other, self)
-
-    def _connect_plane(self, other):
-        return _connect_plane_plane(other, self)
-

Deleted: trunk/lib/py/eudoxos.py
===================================================================
--- trunk/lib/py/eudoxos.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/eudoxos.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,244 +0,0 @@
-# encoding: utf-8
-# 2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
-#
-# I doubt there functions will be useful for anyone besides me.
-#
-from yade.wrapper import *
-from math import *
-from yade._eudoxos import * ## c++ implementations
-
-def estimateStress(strain,cutoff=0.):
-	&quot;&quot;&quot;Use summed stored energy in contacts to compute macroscopic stress over the same volume, provided known strain.&quot;&quot;&quot;
-	# E=(1/2)&#963;&#949;Al # global stored energy
-	# &#963;=EE/(.5&#949;Al)=EE/(.5&#949;V)
-	from yade import utils
-	dim=utils.aabbDim(cutoff,centers=False)
-	return utils.elasticEnergy(utils.aabbExtrema(cutoff))/(.5*strain*dim[0]*dim[1]*dim[2])
-
-def estimatePoissonYoung(principalAxis,stress=0,plot=False,cutoff=0.):
-	&quot;&quot;&quot;Estimate Poisson's ration given the &quot;principal&quot; axis of straining.
-	For every base direction, homogenized strain is computed
-	(slope in linear regression on discrete function particle coordinate &#8594;
-	&#8594; particle displacement	in the same direction as returned by
-	utils.coordsAndDisplacements) and, (if axis '0' is the strained 
-	axis) the poisson's ratio is given as -&#189;(&#949;&#8321;+&#949;&#8322;)/&#949;&#8320;.
-
-	Young's modulus is computed as &#963;/&#949;&#8320;; if stress &#963; is not given (default 0),
-	the result is 0.
-
-	cutoff, if &gt; 0., will take only smaller part (centered) or the specimen into account
-	&quot;&quot;&quot;
-	dd=[] # storage for linear regression parameters
-	import pylab,numpy,stats
-	from yade import utils
-	if cutoff&gt;0: cut=utils.fractionalBox(fraction=1-cutoff)
-	for axis in [0,1,2]:
-		if cutoff&gt;0:
-			w,dw=utils.coordsAndDisplacements(axis,AABB=cut)
-		else:
-			w,dw=utils.coordsAndDisplacements(axis)
-		l,ll=stats.linregress(w,dw)[0:2] # use only tangent and section
-		dd.append((l,ll,min(w),max(w)))
-		if plot: pylab.plot(w,dw,'.',label='xyz'[axis])
-	if plot:
-		for axis in [0,1,2]:
-			dist=dd[axis][-1]-dd[axis][-2]
-			c=numpy.linspace(dd[axis][-2]-.2*dist,dd[axis][-1]+.2*dist)
-			d=[dd[axis][0]*cc+dd[axis][1] for cc in c]
-			pylab.plot(c,d,label='interp '+'xyz'[axis])
-		pylab.legend()
-		pylab.show()
-	otherAxes=(principalAxis+1)%3,(principalAxis+2)%3
-	avgTransHomogenizedStrain=.5*(dd[otherAxes[0]][0]+dd[otherAxes[1]][0])
-	principalHomogenizedStrain=dd[principalAxis][0]
-	return -avgTransHomogenizedStrain/principalHomogenizedStrain,stress/principalHomogenizedStrain
-
-
-def oofemTextExport(fName):
-	&quot;&quot;&quot;Export simulation data in text format 
-	
-	The format is line-oriented as follows:
-		# 3 lines of material parameters:
-		1. E G # elastic
-		2. epsCrackOnset relDuctility xiShear transStrainCoeff #tension; epsFr=epsCrackOnset*relDuctility
-		3. cohesionT tanPhi # shear
-		4. [number of spheres] [number of links]
-		5. id x y z r -1/0/1[on negative/no/positive boundary] # spheres
-		&#8230;
-		n. id1 id2 contact_point_x cp_y cp_z A # interactions &quot;&quot;&quot;
-	from yade.wrapper import Omega
-	material,bodies,interactions=[],[],[]
-	o=Omega()
-
-	f=open(fName,'w') # fail early on I/O problem
-
-	ph=o.interactions.nth(0).phys # some params are the same everywhere
-	material.append(&quot;%g %g&quot;%(ph['E'],ph['G']))
-	material.append(&quot;%g %g %g %g&quot;%(ph['epsCrackOnset'],ph['epsFracture'],1e50,0.0))
-	material.append(&quot;%g %g&quot;%(ph['undamagedCohesion'],ph['tanFrictionAngle']))
-
-	# need strainer for getting bodies in positive/negative boundary
-	strainers=[e for e in o.engines if e.name=='UniaxialStrainer']
-	if len(strainers)&gt;0: strainer=strainers[0]
-	else: strainer=None
-
-	for b in o.bodies:
-		if strainer and b.id in strainer['negIds']: boundary=-1
-		elif strainer and b.id in strainer['posIds']: boundary=1
-		else: boundary=0
-		bodies.append(&quot;%d %g %g %g %g %d&quot;%(b.id,b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius'],boundary))
-
-	for i in o.interactions:
-		if not i.geom or not i.phys: continue
-		cp=i.geom['contactPoint']
-		interactions.append(&quot;%d %d %g %g %g %g&quot;%(i.id1,i.id2,cp[0],cp[1],cp[2],i.phys['crossSection']))
-	
-	f.write('\n'.join(material+[&quot;%d %d&quot;%(len(bodies),len(interactions))]+bodies+interactions))
-	f.close()
-
-def oofemPrescribedDisplacementsExport(fileName):
-	f=open(fileName,'w')
-	f.write(fileName+'.out\n'+'''All Yade displacements prescribed as boundary conditions
-NonLinearStatic nsteps 2 contextOutputStep 1 rtolv 1.e-2 stiffMode 2 maxiter 50 controllmode 1 nmodules 0
-domain 3dshell
-OutputManager tstep_all dofman_all element_all
-''')
-	inters=[i for i in O.interactions if (i.geom and i.phys)]
-	f.write(&quot;ndofman %d nelem %d ncrosssect 1 nmat 1 nbc %d nic 0 nltf 1 nbarrier 0\n&quot;%(len(O.bodies),len(inters),len(O.bodies)*6))
-	bcMax=0; bcMap={}
-	for b in O.bodies:
-		mf=' '.join([str(a) for a in list(O.actions.f(b.id))+list(O.actions.m(b.id))])
-		f.write(&quot;## #%d: forces %s\n&quot;%(b.id+1,mf))
-		f.write(&quot;Particle %d coords 3 %.15e %.15e %.15e rad %g&quot;%(b.id+1,b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius']))
-		bcMap[b.id]=tuple([bcMax+i for i in [1,2,3,4,5,6]])
-		bcMax+=6
-		f.write(' bc '+' '.join([str(i) for i in bcMap[b.id]])+'\n')
-	for j,i in enumerate(inters):
-		epsTNorm=sqrt(sum([e**2 for e in i.phys['epsT']]))
-		epsT='epsT [ %g %g %g ] %g'%(i.phys['epsT'][0],i.phys['epsT'][1],i.phys['epsT'][2],epsTNorm)
-		en=i.phys['epsN']; n=i.geom['normal']
-		epsN='epsN [ %g %g %g ] %g'%(en*n[0],en*n[1],en*n[2],en)
-		Fn='Fn [ %g %g %g ] %g'%(i.phys['normalForce'][0],i.phys['normalForce'][1],i.phys['normalForce'][2],i.phys['Fn'])
-		Fs='Fs [ %lf %lf %lf ] %lf'%(i.phys['shearForce'][0],i.phys['shearForce'][1],i.phys['shearForce'][2],sqrt(sum([fs**2 for fs in i.phys['shearForce']])))
-		f.write('## #%d #%d: %s %s %s %s\n'%(i.id1+1,i.id2+1,epsN,epsT,Fn,Fs))
-		f.write('CohSur3d %d nodes 2 %d %d mat 1 crossSect 1 area %g\n'%(j+1,i.id1+1,i.id2+1,i.phys['crossSection']))
-	# crosssection
-	f.write(&quot;SimpleCS 1 thick 1.0 width 1.0\n&quot;)
-	# material
-	ph=inters[0].phys
-	f.write(&quot;CohInt 1 kn %g ks %g e0 %g ef %g c 0. ksi %g coh %g tanphi %g d 1.0 conf 0.0 maxdist 0.0\n&quot;%(ph['E'],ph['G'],ph['epsCrackOnset'],ph['epsFracture'],ph['xiShear'],ph['undamagedCohesion'],ph['tanFrictionAngle']))
-	# boundary conditions
-	for b in O.bodies:
-		displ=b.phys.displ; rot=b.phys.rot
-		dofs=[displ[0],displ[1],displ[2],rot[0],rot[1],rot[2]]
-		f.write('# particle %d\n'%b.id)
-		for dof in range(6):
-			f.write('BoundaryCondition %d loadTimeFunction 1 prescribedvalue %.15e\n'%(bcMap[b.id][dof],dofs[dof]))
-	#f.write('PiecewiseLinFunction 1 npoints 3 t 3 0. 10. 1000.  f(t) 3 0. 10. 1000.\n')
-	f.write('ConstantFunction 1 f(t) 1.0\n')
-
-
-
-
-def oofemDirectExport(fileBase,title=None,negIds=[],posIds=[]):
-	from yade.wrapper import Omega
-	material,bodies,interactions=[],[],[]
-	o=Omega()
-	strainers=[e for e in o.engines if e.name=='UniaxialStrainer']
-	if len(strainers)&gt;0:
-		strainer=strainers[0]
-		posIds,negIds=strainer['posIds'],strainer['negIds']
-	else: strainer=None
-	f=open(fileBase+'.in','w')
-	# header
-	f.write(fileBase+'.out\n')
-	f.write((title if title else 'Yade simulation for '+fileBase)+'\n')
-	f.write(&quot;NonLinearStatic nsteps 2 contextOutputStep 1 rtolv 1.e-2 stiffMode 2 maxiter 50 controllmode 1 nmodules 0\n&quot;)
-	f.write(&quot;domain 3dShell\n&quot;)
-	f.write(&quot;OutputManager tstep_all dofman_all element_all\n&quot;)
-	inters=[i for i in o.interactions if (i.geom and i.phys)]
-	f.write(&quot;ndofman %d nelem %d ncrosssect 1 nmat 1 nbc 2 nic 0 nltf 1 nbarrier 0\n&quot;%(len(o.bodies)+2,len(inters)))
-	# elements
-	f.write(&quot;Node 1 coords 3 0.0 0.0 0.0 bc 6 1 1 1 1 1 1\n&quot;)
-	f.write(&quot;Node 2 coords 3 0.0 0.0 0.0 bc 6 1 2 1 1 1 1\n&quot;)
-	for b in o.bodies:
-		f.write(&quot;Particle %d coords 3 %g %g %g rad %g&quot;%(b.id+3,b.phys.refPos[0],b.phys.refPos[1],b.phys.refPos[2],b.shape['radius']))
-		if b.id in negIds: f.write(&quot; dofType 6 1 1 1 1 1 1 masterMask 6 0 1 0 0 0 0 &quot;)
-		elif b.id in posIds: f.write(&quot; dofType 6 1 1 1 1 1 1 masterMask 6 0 2 0 0 0 0 0&quot;)
-		f.write('\n')
-	j=1
-	for i in inters:
-		f.write('CohSur3d %d nodes 2 %d %d mat 1 crossSect 1 area %g\n'%(j,i.id1+3,i.id2+3,i.phys['crossSection']))
-		j+=1
-	# crosssection
-	f.write(&quot;SimpleCS 1 thick 1.0 width 1.0\n&quot;)
-	# material
-	ph=inters[0].phys
-	f.write(&quot;CohInt 1 kn %g ks %g e0 %g ef %g c 0. ksi %g coh %g tanphi %g damchartime %g damrateexp %g plchartime %g plrateexp %g d 1.0\n&quot;%(ph['E'],ph['G'],ph['epsCrackOnset'],ph['epsFracture'],0.0,ph['undamagedCohesion'],ph['tanFrictionAngle'],ph['dmgTau'],ph['dmgRateExp'],ph['plTau'],ph['plRateExp']))
-	# boundary conditions
-	f.write('BoundaryCondition 1 loadTimeFunction 1 prescribedvalue 0.0\n')
-	f.write('BoundaryCondition 2 loadTimeFunction 1 prescribedvalue 1.e-4\n')
-	f.write('PiecewiseLinFunction 1 npoints 3 t 3 0. 10. 1000.  f(t) 3 0. 10. 1000.\n')
-
-
-def displacementsInteractionsExport(fName):
-	f=open(fName,'w')
-	print &quot;Writing body displacements and interaction strains.&quot;
-	o=Omega()
-	for b in o.bodies:
-		x0,y0,z0=b.phys['refSe3'][0:3]; x,y,z=b.phys.pos
-		rx,ry,rz,rr=b.phys['se3'][3:7]
-		f.write('%d xyz [ %g %g %g ] dxyz [ %g %g %g ] rxyz [ %g %g %g ] \n'%(b.id,x0,y0,z0,x-x0,y-y0,z-z0,rr*rx,rr*ry,rr*rz))
-	f.write('\n')
-	for i in o.interactions:
-		if not i['isReal']:continue
-		epsTNorm=sqrt(sum([e**2 for e in i.phys['epsT']]))
-		epsT='epsT [ %g %g %g ] %g'%(i.phys['epsT'][0],i.phys['epsT'][1],i.phys['epsT'][2],epsTNorm)
-		en=i.phys['epsN']; n=i.geom['normal']
-		epsN='epsN [ %g %g %g ] %g'%(en*n[0],en*n[1],en*n[2],en)
-		Fn='Fn [ %g %g %g ] %g'%(i.phys['normalForce'][0],i.phys['normalForce'][1],i.phys['normalForce'][2],i.phys['Fn'])
-		Fs='Fs [ %lf %lf %lf ] %lf'%(i.phys['shearForce'][0],i.phys['shearForce'][1],i.phys['shearForce'][2],sqrt(sum([fs**2 for fs in i.phys['shearForce']])))
-		f.write('%d %d %s %s %s %s\n'%(i.id1,i.id2,epsN,epsT,Fn,Fs))
-		# f.write('%d %d %g %g %g %g %g\n'%(i.id1,i.id2,i.phys['epsN'],i.phys['epsT'][0],i.phys['epsT'][1],i.phys['epsT'][2],epsTNorm))
-	f.close()
-
-
-
-
-
-def eliminateJumps(eps,sigma,numSteep=10,gapWidth=5,movWd=40):
-	from matplotlib.mlab import movavg
-	from numpy import diff,abs
-	import numpy
-	# get histogram of 'derivatives'
-	ds=abs(diff(sigma))
-	n,bins=numpy.histogram(ds)
-	i=1; sum=0
-	# numSteep steepest pieces will be discarded
-	while sum&lt;numSteep:
-		#print n[-i],bins[-i]
-		sum+=n[-i]; i+=1
-	#print n[-i],bins[-i]
-	threshold=bins[-i]
-	# old algo: replace with nan's
-	##rEps,rSigma=eps[:],sigma[:]; nan=float('nan')
-	##indices=where(ds&gt;threshold)[0]
-	##for i in indices:
-	##	for ii in range(max(0,i-gapWidth),min(len(rEps),i+gapWidth+1)): rEps[ii]=rSigma[ii]=nan
-
-	## doesn't work with older numpy (?)
-	# indices1=where(ds&gt;threshold)[0]
-	indices1=[]
-	for i in range(len(ds)):
-		if ds[i]&gt;threshold: indices1.append(i)
-	indices=[]
-	for i in indices1:
-		for ii in range(i-gapWidth,i+gapWidth+1): indices.append(ii)
-	#print indices1, indices
-	rEps=[eps[i] for i in range(0,len(eps)) if i not in indices]
-	rSigma=[sigma[i] for i in range(0,len(sigma)) if i not in indices]
-	# apply moving average to the result
-	rSigma=movavg(rSigma,movWd)
-	rEps=rEps[movWd/2:-movWd/2+1]
-	return rEps,rSigma.flatten().tolist()
-

Deleted: trunk/lib/py/linterpolation.py
===================================================================
--- trunk/lib/py/linterpolation.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/linterpolation.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,99 +0,0 @@
-# encoding: utf-8
-#
-# &#169; 2009 V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
-#
-
-&quot;&quot;&quot;
-Module for rudimentary support of manipulation with piecewise-linear
-functions (which are usually interpolations of higher-order functions,
-whence the module name). Interpolation is always given as two lists
-of the same length, where the x-list must be increasing.
-
-Periodicity is supported by supposing that the interpolation
-can wrap from the last x-value to the first x-value (which
-should be 0 for meaningful results).
-
-Non-periodic interpolation can be converted to periodic one
-by padding the interpolation with constant head and tail using
-the sanitizeInterpolation function.
-
-There is a c++ template function for interpolating on such sequences in
-pkg/common/Engine/DeusExMachina/LinearInterpolate.hpp (stateful, therefore
-fast for sequential reads).
-
-TODO: Interpolating from within python is not (yet) supported.
-&quot;&quot;&quot;
-
-def revIntegrateLinear(I,x0,y0,x1,y1):
-	&quot;&quot;&quot;Helper function, returns value of integral variable x for
-	linear function f passing through (x0,y0),(x1,y1) such that
-	1. x&#8712;[x0,x1]
-	2. &#8747;_x0^x f dx=I
-	and raise exception if such number doesn't exist or the solution
-	is not unique (possible?)
-	&quot;&quot;&quot;
-	from math import sqrt
-	dx,dy=x1-x0,y1-y0
-	if dy==0: # special case, degenerates to linear equation
-		return (x0*y0+I)/y0
-	a=dy/dx; b=2*(y0-x0*dy/dx); c=x0**2*dy/dx-2*x0*y0-2*I
-	det=b**2-4*a*c; assert(det&gt;0)
-	p,q=(-b+sqrt(det))/(2*a),(-b-sqrt(det))/(2*a)
-	pOK,qOK=x0&lt;=p&lt;=x1,x0&lt;=q&lt;=x1
-	if pOK and qOK: raise ValueError(&quot;Both radices within interval!?&quot;)
-	if not pOK and not qOK: raise ValueError(&quot;No radix in given interval!&quot;)
-	return p if pOK else q
-
-def integral(x,y):
-	&quot;&quot;&quot;Return integral of piecewise-linear function given by points
-	x0,x1,&#8230; and y0,y1,&#8230; &quot;&quot;&quot;
-	assert(len(x)==len(y))
-	sum=0
-	for i in range(1,len(x)): sum+=(x[i]-x[i-1])*.5*(y[i]+y[i-1])
-	return sum
-
-def xFractionalFromIntegral(integral,x,y):
-	&quot;&quot;&quot;Return x within range x0&#8230;xn such that &#8747;_x0^x f dx==integral.
-	Raises error if the integral value is not reached within the x-range.
-	&quot;&quot;&quot;
-	sum=0
-	for i in range(1,len(x)):
-		diff=(x[i]-x[i-1])*.5*(y[i]+y[i-1])
-		if sum+diff&gt;integral:
-			return revIntegrateLinear(integral-sum,x[i-1],y[i-1],x[i],y[i])
-		else: sum+=diff
-	raise &quot;Integral not reached within the interpolation range!&quot;
-
-
-def xFromIntegral(integralValue,x,y):
-	&quot;&quot;&quot;Return x such that &#8747;_x0^x f dx==integral.
-	x wraps around at xn. For meaningful results, therefore, x0 should == 0 &quot;&quot;&quot;
-	from math import floor
-	period=x[-1]-x[0]
-	periodIntegral=integral(x,y)
-	numPeriods=floor(integralValue/periodIntegral)
-	xFrac=xFractionalFromIntegral(integralValue-numPeriods*periodIntegral,x,y)
-	#print '### wanted _%g; period=%g; periodIntegral=_%g (numPeriods=%g); rests _%g (xFrac=%g)'%(integralValue,period,periodIntegral,numPeriods,integralValue-numPeriods*periodIntegral,xFrac)
-	#print '### returning %g*%g+%g=%g'%(period,numPeriods,xFrac,period*numPeriods+xFrac)
-	return period*numPeriods+xFrac
-
-def sanitizeInterpolation(x,y,x0,x1):
-	&quot;&quot;&quot;Extends piecewise-linear function in such way that it spans at least
-	the x0&#8230;x1 interval, by adding constant padding at the beginning (using y0)
-	and/or at the end (using y1) or not at all.&quot;&quot;&quot;
-	xx,yy=[],[]
-	if x0&lt;x[0]:
-		xx+=[x0]; yy+=[y[0]]
-	xx+=x; yy+=y
-	if x1&gt;x[-1]:
-		xx+=[x1]; yy+=[y[-1]]
-	return xx,yy
-
-if __name__==&quot;main&quot;:
-	xx,yy=sanitizeInterpolation([1,2,3],[1,1,2],0,4)
-	print xx,yy
-	print integral(xx,yy) # 5.5
-	print revIntegrateLinear(.625,1,1,2,2) # 1.5
-	print xFractionalFromIntegral(1.625,xx,yy) # 1.625
-	print xFractionalFromIntegral(2.625,xx,yy) # 2.5
-

Deleted: trunk/lib/py/log.cpp
===================================================================
--- trunk/lib/py/log.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/log.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,55 +0,0 @@
-#include&lt;boost/python.hpp&gt;
-#include&lt;string&gt;
-#include&lt;yade/lib-base/Logging.hpp&gt;
-using namespace boost;
-enum{ll_TRACE,ll_DEBUG,ll_INFO,ll_WARN,ll_ERROR,ll_FATAL};
-
-#ifdef LOG4CXX
-	#include&lt;log4cxx/logmanager.h&gt;
-
-	void logSetLevel(std::string loggerName,int level){
-		std::string fullName(loggerName.empty()?&quot;yade&quot;:(&quot;yade.&quot;+loggerName));
-		if(!log4cxx::LogManager::exists(fullName)) throw std::invalid_argument(&quot;No logger named `&quot;+fullName+&quot;'&quot;);
-		log4cxx::LevelPtr l;
-		switch(level){
-			#ifdef LOG4CXX_TRACE
-				case ll_TRACE: l=log4cxx::Level::getTrace(); break;
-				case ll_DEBUG: l=log4cxx::Level::getDebug(); break;
-				case ll_INFO:  l=log4cxx::Level::getInfo(); break;
-				case ll_WARN:  l=log4cxx::Level::getWarn(); break;
-				case ll_ERROR: l=log4cxx::Level::getError(); break;
-				case ll_FATAL: l=log4cxx::Level::getFatal(); break;
-			#else
-				case ll_TRACE: l=log4cxx::Level::DEBUG; break;
-				case ll_DEBUG: l=log4cxx::Level::DEBUG; break;
-				case ll_INFO:  l=log4cxx::Level::INFO; break;
-				case ll_WARN:  l=log4cxx::Level::WARN; break;
-				case ll_ERROR: l=log4cxx::Level::ERROR; break;
-				case ll_FATAL: l=log4cxx::Level::FATAL; break;
-			#endif
-			default: throw std::invalid_argument(&quot;Unrecognized logging level &quot;+lexical_cast&lt;std::string&gt;(level));
-		}
-		log4cxx::LogManager::getLogger(&quot;yade.&quot;+loggerName)-&gt;setLevel(l);
-	}
-#else
-	bool warnedOnce=false;
-	void logSetLevel(std::string loggerName, int level){
-		// better somehow python's raise RuntimeWarning, but not sure how to do that from c++
-		// it shouldn't be trapped by boost::python's exception translator, just print warning
-		// Do like this for now.
-		if(!warnedOnce){
-			LOG_WARN(&quot;Yade was compiled without log4cxx support. Setting log levels from python will have no effect (warn once).&quot;);
-			warnedOnce=true;
-		}
-	}
-#endif
-
-BOOST_PYTHON_MODULE(log){
-	python::def(&quot;setLevel&quot;,logSetLevel,&quot;Set minimum severity level (constants TRACE,DEBUG,INFO,WARN,ERROR,FATAL) for given logger\nleading 'yade.' will be appended automatically to the logger name; if logger is '', the root logger 'yade' will be operated on.&quot;);
-	python::scope().attr(&quot;TRACE&quot;)=(int)ll_TRACE;
-	python::scope().attr(&quot;DEBUG&quot;)=(int)ll_DEBUG;
-	python::scope().attr(&quot;INFO&quot;)= (int)ll_INFO;
-	python::scope().attr(&quot;WARN&quot;)= (int)ll_WARN;
-	python::scope().attr(&quot;ERROR&quot;)=(int)ll_ERROR;
-	python::scope().attr(&quot;FATAL&quot;)=(int)ll_FATAL;
-}

Deleted: trunk/lib/py/pack.py
===================================================================
--- trunk/lib/py/pack.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/pack.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,249 +0,0 @@
-# encoding: utf-8
-#
-import itertools,warnings
-from numpy import arange
-from math import sqrt
-from yade import utils
-
-# for now skip the import, but try in inGtsSurface constructor again, to give error if we really use it
-try:
-	import gts
-except ImportError: pass
-
-# make c++ predicates available in this module
-from _packPredicates import *
-# import SpherePack
-from _packSpheres import *
-
-class inGtsSurface_py(Predicate):
-	&quot;&quot;&quot;This class was re-implemented in c++, but should stay here to serve as reference for implementing
-	Predicates in pure python code. C++ allows us to play dirty tricks in GTS which are not accessible
-	through pygts itself; the performance penalty of pygts comes from fact that if constructs and destructs
-	bb tree for the surface at every invocation of gts.Point().is_inside(). That is cached in the c++ code,
-	provided that the surface is not manipulated with during lifetime of the object (user's responsibility).
-
-	---
-	
-	Predicate for GTS surfaces. Constructed using an already existing surfaces, which must be closed.
-
-		import gts
-		surf=gts.read(open('horse.gts'))
-		inGtsSurface(surf)
-
-	Note: padding is optionally supported by testing 6 points along the axes in the pad distance. This
-	must be enabled in the ctor by saying doSlowPad=True. If it is not enabled and pad is not zero,
-	warning is issued.
-	&quot;&quot;&quot;
-	def __init__(self,surf,noPad=False):
-		# call base class ctor; necessary for virtual methods to work as expected.
-		# see comments in _packPredicates.cpp for struct PredicateWrap.
-		super(inGtsSurface,self).__init__()
-		if not surf.is_closed(): raise RuntimeError(&quot;Surface for inGtsSurface predicate must be closed.&quot;)
-		self.surf=surf
-		self.noPad=noPad
-		inf=float('inf')
-		mn,mx=[inf,inf,inf],[-inf,-inf,-inf]
-		for v in surf.vertices():
-			c=v.coords()
-			mn,mx=[min(mn[i],c[i]) for i in 0,1,2],[max(mx[i],c[i]) for i in 0,1,2]
-		self.mn,self.mx=tuple(mn),tuple(mx)
-		import gts
-	def aabb(self): return self.mn,self.mx
-	def __call__(self,_pt,pad=0.):
-		p=gts.Point(*_pt)
-		if self.noPad:
-			if pad!=0: warnings.warn(&quot;Padding disabled in ctor, using 0 instead.&quot;)
-			return p.is_inside(self.surf)
-		pp=[gts.Point(_pt[0]-pad,_pt[1],_pt[2]),gts.Point(_pt[0]+pad,_pt[1],_pt[2]),gts.Point(_pt[0],_pt[1]-pad,_pt[2]),gts.Point(_pt[0],_pt[1]+pad,_pt[2]),gts.Point(_pt[0],_pt[1],_pt[2]-pad),gts.Point(_pt[0],_pt[1],_pt[2]+pad)]
-		return p.is_inside(self.surf) and pp[0].is_inside(self.surf) and pp[1].is_inside(self.surf) and pp[2].is_inside(self.surf) and pp[3].is_inside(self.surf) and pp[4].is_inside(self.surf) and pp[5].is_inside(self.surf)
-
-class inSpace(Predicate):
-	&quot;&quot;&quot;Predicate returning True for any points, with infinite bounding box.&quot;&quot;&quot;
-	def aabb(self):
-		inf=float('inf'); return [-inf,-inf,-inf],[inf,inf,inf]
-	def __call__(self,pt): return True
-
-#####
-## surface construction and manipulation
-#####
-
-def gtsSurface2Facets(surf,**kw):
-	&quot;&quot;&quot;Construct facets from given GTS surface. **kw is passed to utils.facet.&quot;&quot;&quot;
-	return [utils.facet([v.coords() for v in face.vertices()],**kw) for face in surf]
-
-def sweptPolylines2gtsSurface(pts,threshold=0,capStart=False,capEnd=False):
-	&quot;&quot;&quot;Create swept suface (as GTS triangulation) given same-length sequences of points (as 3-tuples).
-	If threshold is given (&gt;0), gts.Surface().cleanup(threshold) will be called before returning, which
-	removes vertices mutually closer than threshold. Can be used to create closed swept surface (revolved), as
-	we don't check for coincident vertices otherwise.
-	&quot;&quot;&quot;
-	if not len(set([len(pts1) for pts1 in pts]))==1: raise RuntimeError(&quot;Polylines must be all of the same length!&quot;)
-	vtxs=[[gts.Vertex(x,y,z) for x,y,z in pts1] for pts1 in pts]
-	sectEdges=[[gts.Edge(vtx[i],vtx[i+1]) for i in xrange(0,len(vtx)-1)] for vtx in vtxs]
-	interSectEdges=[[] for i in range(0,len(vtxs)-1)]
-	for i in range(0,len(vtxs)-1):
-		for j in range(0,len(vtxs[i])):
-			interSectEdges[i].append(gts.Edge(vtxs[i][j],vtxs[i+1][j]))
-			if j&lt;len(vtxs[i])-1: interSectEdges[i].append(gts.Edge(vtxs[i][j],vtxs[i+1][j+1]))
-	surf=gts.Surface()
-	for i in range(0,len(vtxs)-1):
-		for j in range(0,len(vtxs[i])-1):
-			surf.add(gts.Face(interSectEdges[i][2*j+1],sectEdges[i+1][j],interSectEdges[i][2*j]))
-			surf.add(gts.Face(sectEdges[i][j],interSectEdges[i][2*j+2],interSectEdges[i][2*j+1]))
-	def doCap(vtx,edg,start):
-		ret=[]
-		eFan=[edg[0]]+[gts.Edge(vtx[i],vtx[0]) for i in range(2,len(vtx))]
-		for i in range(1,len(edg)):
-			ret+=[gts.Face(eFan[i-1],eFan[i],edg[i]) if start else gts.Face(eFan[i-1],edg[i],eFan[i])]
-		return ret
-	caps=[]
-	if capStart: caps+=doCap(vtxs[0],sectEdges[0],start=True)
-	if capEnd: caps+=doCap(vtxs[-1],sectEdges[-1],start=False)
-	for cap in caps: surf.add(cap)
-	if threshold&gt;0: surf.cleanup(threshold)
-	return surf
-
-import euclid
-
-def revolutionSurfaceMeridians(sects,angles,origin=euclid.Vector3(0,0,0),orientation=euclid.Quaternion()):
-	&quot;&quot;&quot;Revolution surface given sequences of 2d points and sequence of corresponding angles,
-	returning sequences of 3d points representing meridian sections of the revolution surface.
-	The 2d sections are turned around z-axis, but they can be transformed
-	using the origin and orientation arguments to give arbitrary orientation.&quot;&quot;&quot;
-	import math
-	def toGlobal(x,y,z):
-		return tuple(origin+orientation*(euclid.Vector3(x,y,z)))
-	return [[toGlobal(x2d*math.cos(angles[i]),x2d*math.sin(angles[i]),y2d) for x2d,y2d in sects[i]] for i in range(0,len(sects))]
-
-########
-## packing generators
-########
-
-
-def regularOrtho(predicate,radius,gap,**kw):
-	&quot;&quot;&quot;Return set of spheres in regular orthogonal grid, clipped inside solid given by predicate.
-	Created spheres will have given radius and will be separated by gap space.&quot;&quot;&quot;
-	ret=[]
-	mn,mx=predicate.aabb()
-	if(max([mx[i]-mn[i] for i in 0,1,2])==float('inf')): raise ValueError(&quot;AABB of the predicate must not be infinite (didn't you use union | instead of intersection &amp; for unbounded predicate such as notInNotch?&quot;);
-	xx,yy,zz=[arange(mn[i]+radius,mx[i]-radius,2*radius+gap) for i in 0,1,2]
-	for xyz in itertools.product(xx,yy,zz):
-		if predicate(xyz,radius): ret+=[utils.sphere(xyz,radius=radius,**kw)]
-	return ret
-
-def regularHexa(predicate,radius,gap,**kw):
-	&quot;&quot;&quot;Return set of spheres in regular hexagonal grid, clipped inside solid given by predicate.
-	Created spheres will have given radius and will be separated by gap space.&quot;&quot;&quot;
-	ret=[]
-	a=2*radius+gap
-	h=a*sqrt(3)/2.
-	mn,mx=predicate.aabb()
-	dim=[mx[i]-mn[i] for i in 0,1,2]
-	if(max(dim)==float('inf')): raise ValueError(&quot;AABB of the predicate must not be infinite (didn't you use union | instead of intersection &amp; for unbounded predicate such as notInNotch?&quot;);
-	ii,jj,kk=[range(0,int(dim[0]/a)+1),range(0,int(dim[1]/h)+1),range(0,int(dim[2]/h)+1)]
-	for i,j,k in itertools.product(ii,jj,kk):
-		x,y,z=mn[0]+radius+i*a,mn[1]+radius+j*h,mn[2]+radius+k*h
-		if j%2==0: x+= a/2. if k%2==0 else -a/2.
-		if k%2!=0: x+=a/2.; y+=h/2.
-		if predicate((x,y,z),radius): ret+=[utils.sphere((x,y,z),radius=radius,**kw)]
-	return ret
-
-def filterSpherePack(predicate,spherePack,**kw):
-	&quot;&quot;&quot;Using given SpherePack instance, return spheres the satisfy predicate.
-	The packing will be recentered to match the predicate and warning is given if the predicate
-	is larger than the packing.&quot;&quot;&quot;
-	mn,mx=predicate.aabb()
-	dimP,centP=predicate.dim(),predicate.center()
-	dimS,centS=spherePack.dim(),spherePack.center()
-	if dimP[0]&gt;dimS[0] or dimP[1]&gt;dimS[1] or dimP[2]&gt;dimS[2]: warnings.warn(&quot;Packing's dimension (%s) doesn't fully contain dimension of the predicate (%s).&quot;%(dimS,dimP))
-	spherePack.translate(tuple([centP[i]-centS[i] for i in 0,1,2]))
-	ret=[]
-	for s in spherePack:
-		if predicate(s[0],s[1]): ret+=[utils.sphere(s[0],radius=s[1],**kw)]
-	return ret
-
-def triaxialPack(predicate,radius,dim=None,cropLayers=1,radiusStDev=0.,assumedFinalDensity=.6,memoizeDb=None,**kw):
-	&quot;&quot;&quot;Generator of triaxial packing, using TriaxialTest. Radius is radius of spheres, radiusStDev is its standard deviation.
-	By default, all spheres are of the same radius. cropLayers is how many layer of spheres will be added to the computed
-	dimension of the box so that there no (or not so much, at least) boundary effects at the boundaris of the predicate.
-	assumedFinalDensity should be OK as it is, it is used to compute necessary number of spheres for the packing.
-
-	The memoizeDb parameter can be passed a file (existent or nonexistent). If the file exists, it will be first looked
-	for a suitable packing that was previously saved already (known as memoization). Saved packings will be scaled to
-	requested sphere radius; those that are smaller are distcarded as well as those with different radiusStDev. From
-	the remaining ones, the one with the least spheres will be loaded and returned. If no suitable packing is found, it
-	is generated as usually, but saved into the database for later use.
-
-	O.switchWorld() magic is used to have clean simulation for TriaxialTest without deleting the original simulation.
-	This function therefore should never run in parallel with some code accessing your simulation.
-	&quot;&quot;&quot;
-	import sqlite3, os.path, cPickle, time, sys
-	from yade import log
-	from math import pi
-	if not dim: dim=predicate.dim()
-	if max(dim)==float('inf'): raise RuntimeError(&quot;Infinite predicate and no dimension of packing requested.&quot;)
-	fullDim=tuple([dim[i]+4*cropLayers*radius for i in 0,1,2])
-	if(memoizeDb and os.path.exists(memoizeDb)):
-		# find suitable packing and return it directly
-		conn=sqlite3.connect(memoizeDb); c=conn.cursor();
-		c.execute('select radius,radiusStDev,dimx,dimy,dimz,N,timestamp from packings order by N')
-		for row in c:
-			R,rDev,X,Y,Z,NN,timestamp=row[0:7]; scale=radius/R
-			rDev*=scale; X*=scale; Y*=scale; Z*=scale
-			if (radiusStDev==0 and rDev!=0) or (radiusStDev==0 and rDev!=0) or (radiusStDev!=0 and abs((rDev-radiusStDev)/radiusStDev)&gt;1e-2): continue # not suitable, standard deviation differs too much
-			if X&lt;fullDim[0] or Y&lt;fullDim[1] or Z&lt;fullDim[2]: continue # not suitable, not large enough
-			print &quot;Found suitable packing in database (radius=%g&#177;%g,N=%g,dim=%g&#215;%g&#215;%g,scale=%g), created %s&quot;%(R,rDev,NN,X,Y,Z,scale,time.asctime(time.gmtime(timestamp)))
-			c.execute('select pack from packings where timestamp=?',(timestamp,))
-			sp=SpherePack(cPickle.loads(str(c.fetchone()[0])))
-			sp.scale(scale)
-			return filterSpherePack(predicate,sp,**kw)
-		print &quot;No suitable packing in database found, running triaxial&quot;
-		sys.stdout.flush()
-	V=(4/3)*pi*radius**3; N=assumedFinalDensity*fullDim[0]*fullDim[1]*fullDim[2]/V;
-	##
-	O.switchWorld()
-	##
-	TriaxialTest(
-		numberOfGrains=int(N),
-		radiusMean=radius,
-		# this is just size ratio if radiusMean is specified
-		# if you comment out the line above, it will be the corner (before compaction) and radiusMean will be set accordingly
-		upperCorner=fullDim,
-		radiusStdDev=radiusStDev,
-		## no need to touch any the following, I think
-		noFiles=True,
-		lowerCorner=[0,0,0],
-		sigmaIsoCompaction=1e7,
-		sigmaLateralConfinement=1e3,
-		StabilityCriterion=.05,
-		strainRate=.2,
-		fast=True,
-		thickness=-1, # will be set to sphere radius if negative
-		maxWallVelocity=.1,
-		wallOversizeFactor=1.5,
-		autoUnload=True, # unload after isotropic compaction
-		autoCompressionActivation=False # stop once unloaded
-	).load()
-	log.setLevel('TriaxialCompressionEngine',log.WARN)
-	O.run(); O.wait()
-	sp=SpherePack(); sp.fromSimulation()
-	##
-	O.switchWorld()
-	##
-	if(memoizeDb):
-		if os.path.exists(memoizeDb):
-			conn=sqlite3.connect(memoizeDb)
-		else:
-			conn=sqlite3.connect(memoizeDb)
-			c=conn.cursor()
-			c.execute('create table packings (radius real, radiusStDev real, dimx real, dimy real, dimz real, N integer, timestamp real, pack blob)')
-		c=conn.cursor()
-		packBlob=buffer(cPickle.dumps(sp.toList(),cPickle.HIGHEST_PROTOCOL))
-		c.execute('insert into packings values (?,?,?,?,?,?,?,?)',(radius,radiusStDev,fullDim[0],fullDim[1],fullDim[2],len(sp),time.time(),packBlob,))
-		c.close()
-		conn.commit()
-		print &quot;Packing saved to the database&quot;,memoizeDb
-	return filterSpherePack(predicate,sp,**kw)
-
-
-

Deleted: trunk/lib/py/plot.py
===================================================================
--- trunk/lib/py/plot.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/plot.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,190 +0,0 @@
-# encoding: utf-8
-# 2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
-&quot;&quot;&quot;
-Module containing utility functions for plotting inside yade.
-
-Experimental, interface may change (even drastically).
-
-&quot;&quot;&quot;
-import matplotlib
-matplotlib.use('TkAgg')
-#matplotlib.use('GTKCairo')
-#matplotlib.use('QtAgg')
-matplotlib.rc('axes',grid=True) # put grid in all figures
-import pylab
-
-
-data={} # global, common for all plots: {'name':[value,...],...}
-plots={} # dictionary x-name -&gt; (yspec,...), where yspec is either y-name or (y-name,'line-specification')
-plotsFilled={} # same as plots but with standalone plot specs filled to tuples (used internally only)
-plotLines={} # dictionary x-name -&gt; Line2d objects (that hopefully still correspond to yspec in plots)
-needsFullReplot=True
-
-def reset():
-	global data, plots, plotsFilled, plotLines, needsFullReplot
-	data={}; plots={}; plotsFilled={}; plotLines={}; needsFullReplot=True; 
-	pylab.close('all')
-
-# we could have a yplot class, that would hold: (yspec,...), (Line2d,Line2d,...) ?
-
-
-plotDataCollector=None
-import yade.wrapper
-o=yade.wrapper.Omega()
-
-maxDataLen=1000
-
-def reduceData(l):
-	&quot;&quot;&quot;If we have too much data, take every second value and double the step for DateGetterEngine. This will keep the samples equidistant.
-	&quot;&quot;&quot;
-	if l&gt;maxDataLen:
-		global plotDataCollector
-		if not plotDataCollector: plotDataCollector=o.labeledEngine('plotDataCollector') # will raise RuntimeError if not found
-		if plotDataCollector['mayStretch']: # may we double the period without getting over limits?
-			plotDataCollector['stretchFactor']=2. # just to make sure
-			print &quot;Reducing data: %d &gt; %d&quot;%(l,maxDataLen)
-			for d in data: data[d]=data[d][::2]
-			for attr in ['virtPeriod','realPeriod','iterPeriod']:
-				if(plotDataCollector[attr]&gt;0): plotDataCollector[attr]=2*plotDataCollector[attr]
-
-def splitData():
-	&quot;Make all plots discontinuous at this point (adds nan's to all data fields)&quot;
-	addData({})
-
-
-def reverseData():
-	for k in data: data[k].reverse()
-
-def addData(d):
-	&quot;&quot;&quot;Add data from argument {'name':value,...} to yade.plot.data.
-
-	New data will be left-padded with nan's, unspecified data will be nan.
-	This way, equal length of all data is assured so that they can be plotted one against any other.
-
-	Nan's don't appear in graphs.&quot;&quot;&quot;
-	import numpy
-	if len(data)&gt;0: numSamples=len(data[data.keys()[0]])
-	else: numSamples=0
-	reduceData(numSamples)
-	nan=float('nan')
-	for name in d:
-		if not name in data.keys():
-			data[name]=[nan for i in range(numSamples)] #numpy.array([nan for i in range(numSamples)])
-	for name in data:
-		if name in d: data[name].append(d[name]) #numpy.append(data[name],[d[name]],1)
-		else: data[name].append(nan)
-
-def fillNonSequence(o):
-	if o.__class__==tuple().__class__ or o.__class__==list().__class__: return o
-	else: return (o,'')
-
-def show(): plot()
-
-def plot():
-	pylab.ion() ## # no interactive mode (hmmm, I don't know why actually...)
-	for p in plots:
-		pylab.figure()
-		plots_p=[fillNonSequence(o) for o in plots[p]]
-		plotsFilled[p]=plots_p
-		plotLines[p]=pylab.plot(*sum([[data[p],data[d[0]],d[1]] for d in plots_p],[]))
-		pylab.legend([_p[0] for _p in plots_p])
-		pylab.xlabel(p)
-		if 'title' in O.tags.keys(): pylab.title(O.tags['title'])
-	pylab.show()
-updatePeriod=0
-def periodicUpdate(period):
-	import time
-	global updatePeriod
-	while updatePeriod&gt;0:
-		doUpdate()
-		time.sleep(updatePeriod)
-def startUpdate(period=10):
-	global updatePeriod
-	updatePeriod=period
-	import threading
-	threading.Thread(target=periodicUpdate,args=(period,),name='Thread-update').start()
-def stopUpdate():
-	global updatePeriod
-	updatePeriod=0
-def doUpdate():
-	pylab.close('all')
-	plot()
-
-
-def saveGnuplot(baseName,term='wxt',extension=None,timestamp=False,comment=None,title=None,varData=False):
-	&quot;&quot;&quot;baseName: used for creating baseName.gnuplot (command file for gnuplot),
-			associated baseName.data (data) and output files (if applicable) in the form baseName.[plot number].extension
-		term: specify the gnuplot terminal;
-			defaults to x11, in which case gnuplot will draw persistent windows to screen and terminate
-			other useful terminals are 'png', 'cairopdf' and so on
-		extension: defaults to terminal name
-			fine for png for example; if you use 'cairopdf', you should also say extension='pdf' however
-		timestamp: append numeric time to the basename
-		varData: whether file to plot will be declared as variable or be in-place in the plot expression
-		comment: a user comment (may be multiline) that will be embedded in the control file
-
-		Returns name fo the gnuplot file created.
-	&quot;&quot;&quot;
-	import time,bz2
-	vars=data.keys(); vars.sort()
-	lData=len(data[vars[0]])
-	if timestamp: baseName+=time.strftime('_%Y%m%d_%H:%M')
-	baseNameNoPath=baseName.split('/')[-1]
-	fData=bz2.BZ2File(baseName+&quot;.data.bz2&quot;,'w');
-	fData.write(&quot;# &quot;+&quot;\t\t&quot;.join(vars)+&quot;\n&quot;)
-	for i in range(lData):
-		fData.write(&quot;\t&quot;.join([str(data[var][i]) for var in vars])+&quot;\n&quot;)
-	fData.close()
-	fPlot=file(baseName+&quot;.gnuplot&quot;,'w')
-	fPlot.write('#!/usr/bin/env gnuplot\n#\n# created '+time.asctime()+' ('+time.strftime('%Y%m%d_%H:%M')+')\n#\n')
-	if comment: fPlot.write('# '+comment.replace('\n','\n# ')+'#\n')
-	dataFile='&quot;&lt; bzcat %s.data.bz2&quot;'%(baseNameNoPath)
-	if varData:
-		fPlot.write('dataFile=%s'%dataFile); dataFile='dataFile'
-	if not extension: extension=term
-	i=0
-	for p in plots:
-		# print p
-		plots_p=[fillNonSequence(o) for o in plots[p]]
-		if term in ['wxt','x11']: fPlot.write(&quot;set term %s %d persist\n&quot;%(term,i))
-		else: fPlot.write(&quot;set term %s; set output '%s.%d.%s'\n&quot;%(term,baseNameNoPath,i,extension))
-		fPlot.write(&quot;set xlabel '%s'\n&quot;%p)
-		fPlot.write(&quot;set grid\n&quot;)
-		fPlot.write(&quot;set datafile missing 'nan'\n&quot;)
-		if title: fPlot.write(&quot;set title '%s'\n&quot;%title)
-		fPlot.write(&quot;plot &quot;+&quot;,&quot;.join([&quot; %s using %d:%d title '%s(%s)' with lines&quot;%(dataFile,vars.index(p)+1,vars.index(pp[0])+1,pp[0],p) for pp in plots_p])+&quot;\n&quot;)
-		i+=1
-	fPlot.close()
-	return baseName+'.gnuplot'
-
-
-	
-import random
-if __name__ == &quot;__main__&quot;:
-	for i in range(10):
-		addData({'a':random.random(),'b':random.random(),'t':i*.001,'i':i})
-	print data
-	for i in range(15):
-		addData({'a':random.random(),'c':random.random(),'d':random.random(),'one':1,'t':(i+10)*.001,'i':i+10})
-	print data
-	# all lists must have the same length
-	l=set([len(data[n]) for n in data])
-	print l
-	assert(len(l)==1)
-	plots={'t':('a',('b','g^'),'d'),'i':('a',('one','g^'))}
-	fullPlot()
-	print &quot;PLOT DONE!&quot;
-	fullPlot()
-	plots['t']=('a',('b','r^','d'))
-	print &quot;FULL&#160;PLOT&#160;DONE!&quot;
-	for i in range(20):
-		addData({'d':.1,'a':.5,'c':.6,'c':random.random(),'t':(i+25)*0.001,'i':i+25})
-	updatePlot()
-	print &quot;UPDATED!&quot;
-	print data['d']
-	import time
-	#time.sleep(60)
-	killPlots()
-	#pylab.clf()
-
-

Deleted: trunk/lib/py/timing.py
===================================================================
--- trunk/lib/py/timing.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/timing.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,64 +0,0 @@
-# encoding: utf-8
-def _resetEngine(e):
-	if e.timingDeltas: e.timingDeltas.reset()
-	if e.__class__.__name__=='EngineUnit': return
-	if e.__class__.__name__=='MetaEngine':
-		for f in e.functors: _resetEngine(f)
-	elif e.__class__.__name__=='ParallelEngine':
-		for s in e.slaves: _resetEngine(s)
-	e.execTime,e.execCount=0,0
-
-def reset():
-	for e in O.engines: _resetEngine(e)
-
-_statCols={'label':40,'count':20,'time':20,'relTime':20}
-_maxLev=3
-
-def _formatLine(label,time,count,totalTime,level):
-	sp,negSp=' '*level*2,' '*(_maxLev-level)*2
-	raw=[]
-	raw.append(label)
-	raw.append(str(count) if count&gt;=0 else '')
-	raw.append((str(time/1000)+u'us') if time&gt;=0 else '')
-	raw.append(('%6.2f%%'%(time*100./totalTime)) if totalTime&gt;0 else '')
-	return u' '.join([
-		(sp+raw[0]).ljust(_statCols['label']),
-		(raw[1]+negSp).rjust(_statCols['count']),
-		(raw[2]+negSp).rjust(_statCols['time']),
-		(raw[3]+negSp).rjust(_statCols['relTime']),
-	])
-
-def _delta_stats(deltas,totalTime,level):
-	ret=0
-	deltaTime=sum([d[1] for d in deltas.data])
-	for d in deltas.data:
-		print _formatLine(d[0],d[1],d[2],totalTime,level); ret+=1
-	if len(deltas.data)&gt;1:
-		print _formatLine('TOTAL',deltaTime,-1,totalTime,level); ret+=1
-	return ret
-
-def _engines_stats(engines,totalTime,level):
-	lines=0; hereLines=0
-	for e in engines:
-		if e.__class__.__name__!='EngineUnit': print _formatLine(u'&quot;'+e['label']+'&quot;' if e['label'] else e.name,e.execTime,e.execCount,totalTime,level); lines+=1; hereLines+=1
-		if e.timingDeltas: 
-			if e.__class__.__name__=='EngineUnit':
-				print _formatLine(e.name,-1,-1,-1,level); lines+=1; hereLines+=1
-				execTime=sum([d[1] for d in e.timingDeltas.data])
-			else: execTime=e.execTime
-			lines+=_delta_stats(e.timingDeltas,execTime,level+1)
-		if e.__class__.__name__=='MetaEngine': lines+=_engines_stats(e.functors,e.execTime,level+1)
-		if e.__class__.__name__=='InteractionDispatcher':
-			lines+=_engines_stats(e.geomDispatcher.functors,e.execTime,level+1)
-			lines+=_engines_stats(e.physDispatcher.functors,e.execTime,level+1)
-			lines+=_engines_stats(e.constLawDispatcher.functors,e.execTime,level+1)
-		elif e.__class__.__name__=='ParallelEngine': lines+=_engines_stats(e.slave,e.execTime,level+1)
-	if hereLines&gt;1:
-		print _formatLine('TOTAL',totalTime,-1,totalTime,level); lines+=1
-	return lines
-
-def stats():
-	print 'Name'.ljust(_statCols['label'])+' '+'Count'.rjust(_statCols['count'])+' '+'Time'.rjust(_statCols['time'])+' '+'Rel. time'.rjust(_statCols['relTime'])
-	print '-'*(sum([_statCols[k] for k in _statCols])+len(_statCols)-1)
-	_engines_stats(O.engines,sum([e.execTime for e in O.engines]),0)
-	print

Deleted: trunk/lib/py/utils.py
===================================================================
--- trunk/lib/py/utils.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/lib/py/utils.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -1,452 +0,0 @@
-# encoding: utf-8
-#
-# utility functions for yade
-#
-# 2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
-
-import math,random
-from yade.wrapper import *
-try: # use psyco if available
-	import psyco
-	psyco.full()
-except ImportError: pass
-
-# c++ implementations for performance reasons
-from yade._utils import *
-
-def saveVars(mark='',loadNow=False,**kw):
-	&quot;&quot;&quot;Save passed variables into the simulation so that it can be recovered when the simulation is loaded again.
-
-	For example, variables a=5, b=66 and c=7.5e-4 are defined. To save those, use
-
-	 utils.saveVars(a=a,b=b,c=c)
-
-	those variables will be save in the .xml file, when the simulation itself is saved. To recover those variables once
-	the .xml is loaded again, use
-
-	 utils.loadVars(mark)
-
-	and they will be defined in the __builtin__ namespace (i.e. available from anywhere in the python code).
-
-	If loadParam==True, variables will be loaded immediately after saving. That effectively makes **kw available in builtin namespace.
-	&quot;&quot;&quot;
-	import cPickle
-	Omega().tags['pickledPythonVariablesDictionary'+mark]=cPickle.dumps(kw)
-	if loadNow: loadVars(mark)
-
-def loadVars(mark=None):
-	&quot;&quot;&quot;Load variables from saveVars, which are saved inside the simulation.
-	If mark==None, all save variables are loaded. Otherwise only those with
-	the mark passed.&quot;&quot;&quot;
-	import cPickle
-	import __builtin__
-	if mark!=None:
-		d=cPickle.loads(Omega().tags['pickledPythonVariablesDictionary'+mark])
-		for k in d: __builtin__.__dict__[k]=d[k]
-	else: # load everything one by one
-		for m in Omega().tags.keys():
-			if m.startswith('pickledPythonVariablesDictionary'):
-				loadVars(m[len('pickledPythonVariableDictionary')+1:])
-
-
-def SpherePWaveTimeStep(radius,density,young):
-	&quot;&quot;&quot;Compute P-wave critical timestep for a single sphere.
-	If you want to compute minimum critical timestep for all spheres in the simulation, use utils.PWaveTimeStep() instead.&quot;&quot;&quot;
-	from math import sqrt
-	return radius/sqrt(young/density)
-
-def randomColor(): return [random.random(),random.random(),random.random()]
-
-def typedEngine(name): return [e for e in Omega().engines if e.name==name][0]
-
-def downCast(obj,newClassName):
-	&quot;&quot;&quot;Cast given object to class deriving from the same yade root class and copy all parameters from given object.
-	Obj should be up in the inheritance tree, otherwise some attributes may not be defined in the new class.&quot;&quot;&quot;
-	return obj.__class__(newClassName,dict([ (key,obj[key]) for key in obj.keys() ]))
-
-def sphere(center,radius,density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=None,physParamsClass='BodyMacroParameters',physParamsAttr={},velocity=[0,0,0]):
-	&quot;&quot;&quot;Create default sphere, with given parameters. Physical properties such as mass and inertia are calculated automatically.&quot;&quot;&quot;
-	s=Body()
-	if not color: color=randomColor()
-	s.shape=GeometricalModel('Sphere',{'radius':radius,'diffuseColor':color,'wire':wire})
-	s.mold=InteractingGeometry('InteractingSphere',{'radius':radius,'diffuseColor':color})
-	V=(4./3)*math.pi*radius**3
-	inert=(2./5.)*V*density*radius**2
-	pp={'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':V*density,'inertia':[inert,inert,inert],'young':young,'poisson':poisson,'frictionAngle':frictionAngle, 'velocity':[velocity[0],velocity[1],velocity[2]]}
-	pp.update(physParamsAttr)
-	s.phys=PhysicalParameters(physParamsClass)
-	for k in [attr for attr in pp.keys() if attr in s.phys.keys()]:
-		s.phys[k]=pp[k]
-	s.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
-	s['isDynamic']=dynamic
-	return s
-
-def box(center,extents,orientation=[1,0,0,0],density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=None,physParamsClass='BodyMacroParameters',physParamsAttr={}):
-	&quot;&quot;&quot;Create default box (cuboid), with given parameters. Physical properties such as mass and inertia are calculated automatically.&quot;&quot;&quot;
-	b=Body()
-	if not color: color=randomColor()
-	b.shape=GeometricalModel('Box',{'extents':extents,'diffuseColor':color,'wire':wire})
-	b.mold=InteractingGeometry('InteractingBox',{'extents':extents,'diffuseColor':color})
-	mass=8*extents[0]*extents[1]*extents[2]*density
-
-	V=extents[0]*extents[1]*extents[2]
-	
-	Pp={'se3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'refSe3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'mass':V*density,'inertia':[mass*4*(extents[1]**2+extents[2]**2),mass*4*(extents[0]**2+extents[2]**2),mass*4*(extents[0]**2+extents[1]**2)],'young':young,'poisson':poisson,'frictionAngle':frictionAngle}
-
-	b.phys=PhysicalParameters(physParamsClass)
-	for k in [attr for attr in Pp.keys() if attr in b.phys.keys()]:
-		b.phys[k]=Pp[k]
-
-	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
-	b['isDynamic']=dynamic
-	return b
-
-def alignedFacetBox(center,extents,wallMask=63,**kw):
-	&quot;&quot;&quot;Create axis-aligned box composed of facets, with given center and extents. wallMask determines which walls will be created,
-	in the order -x (1), +x (2), -y (4), +y (8), -z (16), +z (32). The numbers are ANDed; the default 63 means to create all walls.
-	Remaining **kw arguments are passed to utils.facet. The facets are oriented outwards from the box.&quot;&quot;&quot;
-	mn,mx=[center[i]-extents[i] for i in 0,1,2],[center[i]+extents[i] for i in 0,1,2]
-	def doWall(a,b,c,d):
-		return [facet((a,b,c),**kw),facet((a,c,d),**kw)]
-	ret=[]
-	A,B,C,D=(mn[0],mn[1],mn[2]),(mx[0],mn[1],mn[2]),(mx[0],mx[1],mn[2]),(mn[0],mx[1],mn[2])
-	E,F,G,H=(mn[0],mn[1],mx[2]),(mx[0],mn[1],mx[2]),(mx[0],mx[1],mx[2]),(mn[0],mx[1],mx[2])
-	if wallMask&amp;1:  ret+=doWall(A,D,H,E)
-	if wallMask&amp;2:  ret+=doWall(B,C,G,F)
-	if wallMask&amp;4:  ret+=doWall(A,B,F,E)
-	if wallMask&amp;8:  ret+=doWall(D,H,G,C)
-	if wallMask&amp;16: ret+=doWall(A,D,C,B)
-	if wallMask&amp;32: ret+=doWall(E,F,G,H)
-	return ret
-
-def facet(vertices,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=False,wire=True,color=None,physParamsClass='BodyMacroParameters',physParamsAttr={}):
-	&quot;&quot;&quot;Create default facet with given parameters. Vertices are given as sequence of 3 3-tuple and they, all in global coordinates.&quot;&quot;&quot;
-	b=Body()
-	if not color: color=randomColor()
-	b.shape=GeometricalModel('Facet',{'diffuseColor':color,'wire':wire})
-	b.mold=InteractingGeometry('InteractingFacet',{'diffuseColor':color})
-	center=inscribedCircleCenter(list(vertices[0]),list(vertices[1]),list(vertices[2]))
-	vertices=map(lambda a,b:map(lambda x,y:x-y,a,b),vertices,[center,center,center]) 
-	vStr='['+' '.join(['{%g %g %g}'%(v[0],v[1],v[2]) for v in vertices])+']'
-	b.shape.setRaw('vertices',vStr)
-	b.mold.setRaw('vertices',vStr)
-	pp={'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'young':young,'poisson':poisson,'frictionAngle':frictionAngle,'inertia':[0,0,0]}
-	pp.update(physParamsAttr)
-	b.phys=PhysicalParameters(physParamsClass)
-	for k in [attr for attr in pp.keys() if attr in b.phys.keys()]:
-		b.phys[k]=pp[k]
-	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
-	b['isDynamic']=dynamic
-	b.mold.postProcessAttributes()
-	return b
-
-def aabbWalls(extrema=None,thickness=None,oversizeFactor=1.5,**kw):
-	&quot;&quot;&quot;return 6 walls that will wrap existing packing;
-	extrema are extremal points of the AABB of the packing (will be calculated if not specified)
-	thickness is wall thickness (will be 1/10 of the X-dimension if not specified)
-	Walls will be enlarged in their plane by oversizeFactor.
-	returns list of 6 wall Bodies enclosing the packing, in the order minX,maxX,minY,maxY,minZ,maxZ.
-	&quot;&quot;&quot;
-	walls=[]
-	if not extrema: extrema=aabbExtrema()
-	if not thickness: thickness=(extrema[1][0]-extrema[0][0])/10.
-	for axis in [0,1,2]:
-		mi,ma=extrema
-		center=[(mi[i]+ma[i])/2. for i in range(3)]
-		extents=[.5*oversizeFactor*(ma[i]-mi[i]) for i in range(3)]
-		extents[axis]=thickness/2.
-		for j in [0,1]:
-			center[axis]=extrema[j][axis]+(j-.5)*thickness
-			walls.append(box(center=center,extents=extents,dynamic=False,**kw))
-			walls[-1].shape['wire']=True
-	return walls
-
-
-def aabbDim(cutoff=0.,centers=False):
-	&quot;&quot;&quot;return dimensions of the bounding box, optionally cut.&quot;&quot;&quot;
-	a=aabbExtrema(cutoff,centers)
-	return (a[1][0]-a[0][0],a[1][1]-a[0][1],a[1][2]-a[0][2])
-
-def aabbExtrema2d(pts):
-	&quot;&quot;&quot;return 2d bounding box for a sequence of 2-tuples&quot;&quot;&quot;
-	inf=float('inf')
-	min,max=[inf,inf],[-inf,-inf]
-	for pt in pts:
-		if pt[0]&lt;min[0]: min[0]=pt[0]
-		elif pt[0]&gt;max[0]: max[0]=pt[0]
-		if pt[1]&lt;min[1]: min[1]=pt[1]
-		elif pt[1]&gt;max[1]: max[1]=pt[1]
-	return tuple(min),tuple(max)
-
-def perpendicularArea(axis):
-	&quot;&quot;&quot;return area perpendicular to given axis (0=x,1=y,2=z) generated by bodies
-	for which the function consider returns True (defaults to returning True always)
-	and which is of the type &quot;Sphere&quot;
-	&quot;&quot;&quot;
-	ext=aabbExtrema()
-	other=((axis+1)%3,(axis+2)%3)
-	return (ext[1][other[0]]-ext[0][other[0]])*(ext[1][other[1]]-ext[0][other[1]])
-
-def fractionalBox(fraction=1.,minMax=None):
-	&quot;&quot;&quot;retrurn (min,max) that is the original minMax box (or aabb of the whole simulation if not specified)
-	linearly scaled around its center to the fraction factor&quot;&quot;&quot;
-	if not minMax: minMax=aabbExtrema()
-	half=[.5*(minMax[1][i]-minMax[0][i]) for i in [0,1,2]]
-	return (tuple([minMax[0][i]+(1-fraction)*half[i] for i in [0,1,2]]),tuple([minMax[1][i]-(1-fraction)*half[i] for i in [0,1,2]]))
-
-
-def randomizeColors(onShapes=True,onMolds=False,onlyDynamic=False):
-	&quot;&quot;&quot;Assign random colors to shape's (GeometricalModel) and/or mold's (InteractingGeometry) diffuseColor.
-	
-	onShapes and onMolds turn on/off operating on the respective colors.
-	If onlyDynamic is true, only dynamic bodies will have the color changed.
-	&quot;&quot;&quot;
-	if not onShapes and not onMolds: return
-	o=Omega()
-	for b in o.bodies:
-		color=(random.random(),random.random(),random.random())
-		if onShapes and (b['isDynamic'] or not onlyDynamic): b.shape['diffuseColor']=color
-		if onMolds  and (b['isDynamic'] or not onlyDynamic): b.mold['diffuseColor']=color
-
-
-def spheresFromFile(filename,scale=1.,wenjieFormat=False,**kw):
-	&quot;&quot;&quot;Load sphere coordinates from file, create spheres, insert them to the simulation.
-
-	filename is the file holding ASCII numbers (at least 4 colums that hold x_center, y_center, z_center, radius).
-	All remaining arguments are passed the the yade.utils.sphere function that creates the bodies.
-
-	wenjieFormat will skip all lines that have exactly 5 numbers and where the 4th one is exactly 1.0 -
-	this was used by a fellow developer called Wenjie to mark box elements.
-	
-	Returns list of body ids that were inserted into simulation.&quot;&quot;&quot;
-	o=Omega()
-	ret=[]
-	for l in open(filename):
-		ss=[float(i) for i in l.split()]
-		if wenjieFormat and len(ss)==5 and ss[4]==1.0: continue
-		id=o.bodies.append(sphere([scale*ss[0],scale*ss[1],scale*ss[2]],scale*ss[3],**kw))
-		ret.append(id)
-	return ret
-
-def spheresToFile(filename,consider=lambda id: True):
-	&quot;&quot;&quot;Save sphere coordinates into ASCII file; the format of the line is: x y z r.
-	Non-spherical bodies are silently skipped.
-	
-	Returns number of spheres that were written.&quot;&quot;&quot;
-	o=Omega()
-	out=open(filename,'w')
-	count=0
-	for b in o.bodies:
-		if not b.shape or not b.shape.name=='Sphere' or not consider(b.id): continue
-		out.write('%g\t%g\t%g\t%g\n'%(b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius']))
-		count+=1
-	out.close()
-	return count
-
-def avgNumInteractions(cutoff=0.):
-	nums,counts=bodyNumInteractionsHistogram(aabbExtrema(cutoff))
-	return sum([nums[i]*counts[i] for i in range(len(nums))])/(1.*sum(counts))
-
-def plotNumInteractionsHistogram(cutoff=0.):
-	nums,counts=bodyNumInteractionsHistogram(aabbExtrema(cutoff))
-	import pylab
-	pylab.bar(nums,counts)
-	pylab.title('Number of interactions histogram, average %g (cutoff=%g)'%(avgNumInteractions(cutoff),cutoff))
-	pylab.xlabel('Number of interactions')
-	pylab.ylabel('Body count')
-	pylab.show()
-
-def plotDirections(aabb=(),mask=0,bins=20,numHist=True):
-	&quot;&quot;&quot;Plot 3 histograms for distribution of interaction directions, in yz,xz and xy planes and
-	(optional but default) histogram of number of interactions per body.&quot;&quot;&quot;
-	import pylab,math
-	from yade import utils
-	for axis in [0,1,2]:
-		d=utils.interactionAnglesHistogram(axis,mask=mask,bins=bins,aabb=aabb)
-		fc=[0,0,0]; fc[axis]=1.
-		subp=pylab.subplot(220+axis+1,polar=True);
-		# 1.1 makes small gaps between values (but the column is a bit decentered)
-		pylab.bar(d[0],d[1],width=math.pi/(1.1*bins),fc=fc,alpha=.7,label=['yz','xz','xy'][axis])
-		#pylab.title(['yz','xz','xy'][axis]+' plane')
-		pylab.text(.5,.25,['yz','xz','xy'][axis],horizontalalignment='center',verticalalignment='center',transform=subp.transAxes,fontsize='xx-large')
-	if numHist:
-		pylab.subplot(224,polar=False)
-		nums,counts=utils.bodyNumInteractionsHistogram(aabb if len(aabb)&gt;0 else utils.aabbExtrema())
-		avg=sum([nums[i]*counts[i] for i in range(len(nums))])/(1.*sum(counts))
-		pylab.bar(nums,counts,fc=[1,1,0],alpha=.7,align='center')
-		pylab.xlabel('Interactions per body (avg. %g)'%avg)
-		pylab.axvline(x=avg,linewidth=3,color='r')
-		pylab.ylabel('Body count')
-	pylab.show()
-
-
-def import_stl_geometry(file, young=30e9,poisson=.3,color=[0,1,0],frictionAngle=0.5236,wire=True,noBoundingVolume=False,noInteractingGeometry=False,physParamsClass='BodyMacroParameters',physParamsAttr={}):
-	&quot;&quot;&quot; Import geometry from stl file, create facets and return list of their ids.&quot;&quot;&quot;
-	imp = STLImporter()
-	imp.wire = wire
-	imp.open(file)
-	o=Omega()
-	begin=len(o.bodies)
-	for i in xrange(imp.number_of_facets):
-		b=Body()
-		b['isDynamic']=False
-		pp={'se3':[0,0,0,1,0,0,0],'young':young,'poisson':poisson,'frictionAngle':frictionAngle}
-		pp.update(physParamsAttr)
-		b.phys=PhysicalParameters(physParamsClass)
-		for k in [attr for attr in pp.keys() if attr in b.phys.keys()]:
-			b.phys[k]=pp[k]
-		if not noBoundingVolume:
-			b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
-		o.bodies.append(b)
-	imp.import_geometry(o.bodies,begin,noInteractingGeometry)
-	imported=range(begin,begin+imp.number_of_facets)
-	for i in imported:
-		if not noInteractingGeometry:
-			o.bodies[i].mold.postProcessAttributes()
-		o.bodies[i].shape['diffuseColor']=color
-	return imported
-
-def encodeVideoFromFrames(wildcard,out,renameNotOverwrite=True,fps=24):
-	import pygst,sys,gobject,os
-	pygst.require(&quot;0.10&quot;)
-	import gst
-	if renameNotOverwrite and os.path.exists(out):
-		i=0;
-		while(os.path.exists(out+&quot;~%d&quot;%i)): i+=1
-		os.rename(out,out+&quot;~%d&quot;%i); print &quot;Output file `%s' already existed, old file renamed to `%s'&quot;%(out,out+&quot;~%d&quot;%i)
-	print &quot;Encoding video from %s to %s&quot;%(wildcard,out)
-	pipeline=gst.parse_launch('multifilesrc location=&quot;%s&quot; index=0 caps=&quot;image/png,framerate=\(fraction\)%d/1&quot; ! pngdec ! ffmpegcolorspace ! theoraenc sharpness=2 quality=63 ! oggmux ! filesink location=&quot;%s&quot;'%(wildcard,fps,out))
-	bus=pipeline.get_bus()
-	bus.add_signal_watch()
-	mainloop=gobject.MainLoop();
-	bus.connect(&quot;message::eos&quot;,lambda bus,msg: mainloop.quit())
-	pipeline.set_state(gst.STATE_PLAYING)
-	mainloop.run()
-	pipeline.set_state(gst.STATE_NULL); pipeline.get_state()
-
-def readParamsFromTable(tableFileLine=None,noTableOk=False,unknownOk=False,**kw):
-	&quot;&quot;&quot;
-	Read parameters from a file and assign them to __builtin__ variables.
-
-	tableFile is a text file (with one value per blank-separated columns)
-	tableLine is number of line where to get the values from
-
-		The format of the file is as follows (commens starting with # and empty lines allowed)
-		
-		name1 name2 &#8230; # 0th line
-		val1  val2  &#8230; # 1st line
-		val2  val2  &#8230; # 2nd line
-		&#8230;
-
-	The name `description' is special and is assigned to Omega().tags['description']
-
-	assigns Omega().tags['params']=&quot;name1=val1,name2=val2,&#8230;&quot;
-	
-	assigns Omega().tags['defaultParams']=&quot;unassignedName1=defaultValue1,&#8230;&quot;
-
-	saves all parameters (default as well as settable) using saveVars('table')
-
-	return value is the number of assigned parameters.
-	&quot;&quot;&quot;
-	o=Omega()
-	tagsParams=[]
-	dictDefaults,dictParams={},{}
-	import os, __builtin__
-	if not tableFileLine and not os.environ.has_key('PARAM_TABLE'):
-		if not noTableOk: raise EnvironmentError(&quot;PARAM_TABLE is not defined in the environment&quot;)
-		o.tags['line']='l!'
-	else:
-		if not tableFileLine: tableFileLine=os.environ['PARAM_TABLE']
-		env=tableFileLine.split(':')
-		tableDesc=None
-		tableFile,tableLine=env[0],env[1]
-		if len(env)&gt;2: tableDesc=env[3]
-		o.tags['line']='l'+tableLine
-		ll=[l.split('#')[0] for l in ['']+open(tableFile).readlines()]; names=ll[1].split(); values=ll[int(tableLine)].split()
-		assert(len(names)==len(values))
-		if 'description' in names: O.tags['description']=values[names.index('description')]
-		else:
-			bangCols=[i for i,h in enumerate(names) if h[-1]=='!']
-			if len(bangCols)==0: bangCols=range(len(names))
-			for i in range(len(names)):
-				if names[i][-1]=='!': names[i]=names[i][:-1] # strip trailing !
-			O.tags['description']=','.join(names[col]+'='+('%g'%values[col] if isinstance(values[col],float) else str(values[col])) for col in bangCols).replace(&quot;'&quot;,'').replace('&quot;','')
-		for i in range(len(names)):
-			if names[i]=='description': continue
-			if names[i] not in kw.keys():
-				if (not unknownOk) and names[i][0]!='!': raise NameError(&quot;Parameter `%s' has no default value assigned&quot;%names[i])
-			else: kw.pop(names[i])
-			if names[i][0]!='!':
-				exec('%s=%s'%(names[i],values[i])) in __builtins__; tagsParams+=['%s=%s'%(names[i],values[i])]; dictParams[names[i]]=values[i]
-	defaults=[]
-	for k in kw.keys():
-		exec(&quot;%s=%s&quot;%(k,repr(kw[k]))) in __builtins__
-		defaults+=[&quot;%s=%s&quot;%(k,kw[k])]; dictDefaults[k]=kw[k]
-	o.tags['defaultParams']=&quot;,&quot;.join(defaults)
-	o.tags['params']=&quot;,&quot;.join(tagsParams)
-	dictParams.update(dictDefaults); saveVars('table',**dictParams)
-	return len(tagsParams)
-
-def ColorizedVelocityFilter(isFilterActivated=True,autoScale=True,minValue=0,maxValue=0,posX=0,posY=0.2,width=0.05,height=0.5,title='Velocity, m/s'):
-    f = DeusExMachina('ColorizedVelocityFilter',{'isFilterActivated':isFilterActivated,'autoScale':autoScale,'minValue':minValue,'maxValue':maxValue,'posX':posX,'posY':posY,'width':width,'height':height,'title':title})
-    O.engines+=[f]
-    return f
-
-def ColorizedTimeFilter(point=[0,0,0],normal=[0,1,0],isFilterActivated=True,autoScale=True,minValue=0,maxValue=0,posX=0,posY=0.2,width=0.05,height=0.5,title='Time, m/s'):
-    f = DeusExMachina('ColorizedTimeFilter',{'point':point,'normal':normal,'isFilterActivated':isFilterActivated,'autoScale':autoScale,'minValue':minValue,'maxValue':maxValue,'posX':posX,'posY':posY,'width':width,'height':height,'title':title})
-    O.engines+=[f]
-    return f
-
-def PythonRunnerFilter(command='pass',isFilterActivated=True):
-    f = DeusExMachina('PythonRunnerFilter',{'command':command,'isFilterActivated':isFilterActivated})
-    O.engines+=[f]
-    return f
-
-def replaceCollider(colliderEngine):
-	&quot;&quot;&quot;Replaces collider (Collider) engine with the engine supplied. Raises error if no collider is in engines.&quot;&quot;&quot;
-	colliderIdx=-1
-	for i,e in enumerate(O.engines):
-		if O.isChildClassOf(e.name,&quot;Collider&quot;):
-			colliderIdx=i
-			break
-	if colliderIdx&lt;0: raise RuntimeError(&quot;No Collider found within O.engines.&quot;)
-	O.engines=O.engines[:colliderIdx]+[colliderEngine]+O.engines[colliderIdx+1:]
-
-
-def procStatus(name):
-	import os
-	for l in open('/proc/%d/status'%os.getpid()):
-		if l.split(':')[0]==name: return l
-	raise &quot;No such line in /proc/[pid]/status: &quot;+name
-def vmData():
-	l=procStatus('VmData'); ll=l.split(); assert(ll[2]=='kB')
-	return int(ll[1])
-
-def spheresFromFileUniaxial(filename,areaSections=10,**kw):
-	&quot;&quot;&quot;Load spheres from file, but do some additional work useful for uniaxial test:
-	
-	1. Find the dimensions that is the longest (uniaxial loading axis)
-	2. Find the minimum cross-section area of the speciment by examining several (areaSections)
-		sections perpendicular to axis, computing area of the convex hull for each one. This will
-		work also for non-prismatic specimen.
-	3. Find the bodies that are on the negative/positive boundary, to which the straining condition
-		should be applied.
-
-	Returns dictionary with keys 'negIds', 'posIds', 'axis', 'area'.
-	&quot;&quot;&quot;
-	ids=spheresFromFile(filename,**kw)
-	mm,mx=aabbExtrema()
-	dim=aabbDim(); axis=dim.index(max(dim))
-	import numpy
-	areas=[approxSectionArea(coord,axis) for coord in numpy.linspace(mm[axis],mx[axis],num=10)[1:-1]]
-	negIds,posIds=negPosExtremeIds(axis=axis,distFactor=2.2)
-	return {'negIds':negIds,'posIds':posIds,'axis':axis,'area':min(areas)}
-
-def NormalRestitution2DampingRate(en):
-        &quot;&quot;&quot;Compute the normal damping rate as a function of the normal coefficient of restitution.
-        &quot;&quot;&quot;
-	if en == 0.0: return 0.999999999
-	if en == 1.0: return 0.0
-	from math import sqrt,log,pi
-	ln_en = math.log(en)
-	return (-ln_en/math.sqrt((math.pow(ln_en,2) + math.pi*math.pi)))

Copied: trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.cpp (from rev 1834, trunk/gui/py/PeriodicPythonRunner.cpp)
===================================================================
--- trunk/gui/py/PeriodicPythonRunner.cpp	2009-07-02 15:26:02 UTC (rev 1834)
+++ trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,2 @@
+#include&lt;yade/pkg-common/PeriodicPythonRunner.hpp&gt;
+YADE_PLUGIN();


Property changes on: trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.hpp (from rev 1834, trunk/gui/py/PeriodicPythonRunner.hpp)


Property changes on: trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.hpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/pkg/common/SConscript
===================================================================
--- trunk/pkg/common/SConscript	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/common/SConscript	2009-07-07 11:54:14 UTC (rev 1841)
@@ -4,6 +4,7 @@
 if 'EMBED_PYTHON' in env['CPPDEFINES']:
 	env.Install(&quot;$PREFIX/lib/yade$SUFFIX/pkg-common&quot;,[
 		env.SharedLibrary('PythonRunnerFilter',['Engine/FilterEngine/PythonRunnerFilter.cpp'],LIBS=env['LIBS']+['FilterEngine']),
+		env.SharedLibrary('PeriodicPythonRunner',['Engine/StandAloneEngine/PeriodicPythonRunner.cpp']),
 	])
 
 

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -39,11 +39,11 @@
 		#endif
 
 
-		SpheresContactGeometry():contactPoint(Vector3r::ZERO),radius1(0.),radius2(0.){createIndex();
+		SpheresContactGeometry():contactPoint(Vector3r::ZERO),radius1(0.),radius2(0.)
 		#ifdef SCG_SHEAR
-			shear=Vector3r::ZERO; prevNormal=Vector3r::ZERO /*initialized to proper value by geom functor*/;
-		#endif	
-		}
+			,shear(Vector3r::ZERO), prevNormal(Vector3r::ZERO) /*initialized to proper value by geom functor*/
+		#endif
+			{ createIndex(); }
 		virtual ~SpheresContactGeometry();
 
 		void updateShearForce(Vector3r&amp; shearForce, Real ks, const Vector3r&amp; prevNormal, const RigidBodyParameters* rbp1, const RigidBodyParameters* rbp2, Real dt, bool avoidGranularRatcheting=true);

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -77,7 +77,7 @@
 	height0 = 0;
 	width0 = 0;
 	depth0 = 0;
-	thickness = 0;
+	thickness = -1;
 	
 	//UnbalancedForce = 0;
 	
@@ -219,7 +219,7 @@
 	
 	
 
-	if(thickness&lt;=0) thickness=YADE_PTR_CAST&lt;InteractingBox&gt;(Body::byId(wall_bottom_id,ncb)-&gt;interactingGeometry)-&gt;extents.Y();
+	if(thickness&lt;0) thickness=YADE_PTR_CAST&lt;InteractingBox&gt;(Body::byId(wall_bottom_id,ncb)-&gt;interactingGeometry)-&gt;extents.Y();
 
 	PhysicalParameters* p_bottom = static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_bottom_id]-&gt;physicalParameters.get());
 	PhysicalParameters* p_top   =	 static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_top_id]-&gt;physicalParameters.get());

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -31,17 +31,16 @@
 		if(c-&gt;interactionGeometry) scm=YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
 		else { scm=shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry()); c-&gt;interactionGeometry=scm; }
 
-		#ifdef SCG_SHEAR
-			if(isNew) scm-&gt;prevNormal=normal; 
-			else scm-&gt;prevNormal=scm-&gt;normal;
-		#endif
-
 		Real penetrationDepth=s1-&gt;radius+s2-&gt;radius-normal.Normalize(); /* Normalize() works in-place and returns length before normalization; from here, normal is unit vector */
 		scm-&gt;contactPoint=se31.position+(s1-&gt;radius-0.5*penetrationDepth)*normal;//0.5*(pt1+pt2);
 		scm-&gt;normal=normal;
 		scm-&gt;penetrationDepth=penetrationDepth;
 		scm-&gt;radius1=s1-&gt;radius;
 		scm-&gt;radius2=s2-&gt;radius;
+		#ifdef SCG_SHEAR
+			if(isNew) scm-&gt;prevNormal=normal; 
+			else scm-&gt;prevNormal=scm-&gt;normal;
+		#endif
 		// keep this for reference on how to compute bending and torsion from relative orientation; parts in SpheresContactGeometry header
 		#if 0
 			scm-&gt;initRelOri12=se31.orientation.Conjugate()*se32.orientation;

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -121,6 +121,7 @@
 	phys-&gt;normalForce=phys-&gt;kn*displN*geom-&gt;normal;
 	Real maxFsSq=phys-&gt;normalForce.SquaredLength()*pow(phys-&gt;tangensOfFrictionAngle,2);
 	Vector3r trialFs=phys-&gt;ks*geom-&gt;displacementT();
-	if(trialFs.SquaredLength()&gt;maxFsSq){ geom-&gt;slipToDisplacementTMax(sqrt(maxFsSq)); trialFs*=sqrt(maxFsSq/(trialFs.SquaredLength()));} 
+	if(trialFs.SquaredLength()&gt;maxFsSq){ geom-&gt;slipToDisplacementTMax(sqrt(maxFsSq)); trialFs*=sqrt(maxFsSq/(trialFs.SquaredLength()));}
+	phys-&gt;shearForce=trialFs;
 	applyForceAtContactPoint(phys-&gt;normalForce+trialFs,geom-&gt;contactPoint,contact-&gt;getId1(),geom-&gt;se31.position,contact-&gt;getId2(),geom-&gt;se32.position,rootBody);
 }

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -32,6 +32,7 @@
 #include&lt;yade/pkg-common/Box.hpp&gt;
 #include&lt;yade/pkg-common/AABB.hpp&gt;
 #include&lt;yade/pkg-common/Sphere.hpp&gt;
+#include&lt;yade/pkg-common/Facet.hpp&gt;
 #include&lt;yade/core/MetaBody.hpp&gt;
 #include&lt;yade/pkg-common/PersistentSAPCollider.hpp&gt;
 #include&lt;yade/pkg-common/InsertionSortCollider.hpp&gt;
@@ -53,6 +54,7 @@
 #include&lt;yade/core/Body.hpp&gt;
 #include&lt;yade/pkg-common/InteractingBox.hpp&gt;
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
+#include&lt;yade/pkg-common/InteractingFacet.hpp&gt;
 
 #include&lt;yade/pkg-common/PhysicalActionContainerReseter.hpp&gt;
 
@@ -162,6 +164,7 @@
 	
 	fast=false;
 	noFiles=false;
+	facetWalls=false;
 
 	
 	
@@ -234,6 +237,7 @@
 	REGISTER_ATTRIBUTE(fixedBoxDims);
 	REGISTER_ATTRIBUTE(fast);
 	REGISTER_ATTRIBUTE(noFiles);
+	REGISTER_ATTRIBUTE(facetWalls);
 }
 
 
@@ -247,6 +251,10 @@
 		message=&quot;Biaxial test can be generated only if Z size is more than 8 times smaller than X size&quot;;
 		return false;
 	}
+	if(facetWalls &amp;&amp; !fast){
+		LOG_WARN(&quot;Turning TriaxialTest::fast on, since facetWalls were selected.&quot;);
+		fast=true;
+	}
 	
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);
 	positionRootBody(rootBody);
@@ -289,6 +297,7 @@
 	}
 
 	if(thickness&lt;0) thickness=radiusMean;
+	if(facetWalls) thickness=0;
 	
 	if(boxWalls)
 	{
@@ -465,47 +474,56 @@
 void TriaxialTest::createBox(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents, bool wire)
 {
 	body = shared_ptr&lt;Body&gt;(new Body(body_id_t(0),2));
-	shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
+	body-&gt;isDynamic			= false;
+
+
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
-	shared_ptr&lt;Box&gt; gBox(new Box);
-	shared_ptr&lt;InteractingBox&gt; iBox(new InteractingBox);
+	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
+	body-&gt;boundingVolume		= aabb;
 	
-	Quaternionr q;
-	q.FromAxisAngle( Vector3r(0,0,1),0);
-
-	body-&gt;isDynamic			= false;
-	
-	physics-&gt;angularVelocity	= Vector3r(0,0,0);
-	physics-&gt;velocity		= Vector3r(0,0,0);
-	physics-&gt;mass			= 0; 
+	shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
 	//physics-&gt;mass			= extents[0]*extents[1]*extents[2]*density*2; 
 	physics-&gt;inertia		= Vector3r(
 							  physics-&gt;mass*(extents[1]*extents[1]+extents[2]*extents[2])/3
 							, physics-&gt;mass*(extents[0]*extents[0]+extents[2]*extents[2])/3
 							, physics-&gt;mass*(extents[1]*extents[1]+extents[0]*extents[0])/3
 						);
-//	physics-&gt;mass			= 0;
+	physics-&gt;mass			= 0;
 //	physics-&gt;inertia		= Vector3r(0,0,0);
-	physics-&gt;se3			= Se3r(position,q);
+	physics-&gt;se3.position=position;
 
 	physics-&gt;young			= boxYoungModulus;
 	physics-&gt;poisson		= boxPoissonRatio;
 	physics-&gt;frictionAngle		= boxFrictionDeg * Mathr::PI/180.0;
+	body-&gt;physicalParameters	= physics;
 
-	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
-	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
-	gBox-&gt;wire			= wire;
-	gBox-&gt;shadowCaster		= false;
-	
-	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
+	if(!facetWalls){
+		shared_ptr&lt;Box&gt; gBox(new Box);
+		gBox-&gt;extents			= extents;
+		gBox-&gt;diffuseColor		= Vector3r(1,1,1);
+		gBox-&gt;wire			= wire;
+		gBox-&gt;shadowCaster		= false;
+		body-&gt;geometricalModel		= gBox;
 
-	body-&gt;boundingVolume		= aabb;
-	body-&gt;interactingGeometry	= iBox;
-	body-&gt;geometricalModel		= gBox;
-	body-&gt;physicalParameters	= physics;
+		shared_ptr&lt;InteractingBox&gt; iBox(new InteractingBox);
+		iBox-&gt;extents			= extents;
+		iBox-&gt;diffuseColor		= Vector3r(1,1,1);
+		body-&gt;interactingGeometry	= iBox;
+	} else {
+		int ax0 = extents[0]==0 ? 0 : (extents[1]==0 ? 1 : 2); int ax1=(ax0+1)%3, ax2=(ax0+2)%3;
+		Vector3r corner=position-extents; // &quot;lower right&quot; corner, with 90 degrees
+		Vector3r side1(Vector3r::ZERO); side1[ax1]=4*extents[ax1]; Vector3r side2(Vector3r::ZERO); side2[ax2]=4*extents[ax2];
+		Vector3r v[3]; v[0]=corner; v[1]=corner+side1; v[2]=corner+side2;
+		Vector3r cog=Shop::inscribedCircleCenter(v[0],v[1],v[2]);
+		shared_ptr&lt;InteractingFacet&gt; iFacet(new InteractingFacet);
+		shared_ptr&lt;Facet&gt; facet(new Facet);
+		for(int i=0; i&lt;3; i++){ iFacet-&gt;vertices.push_back(v[i]-cog); facet-&gt;vertices.push_back(v[i]-cog);}
+		iFacet-&gt;diffuseColor=facet-&gt;diffuseColor=Vector3r(1,1,1);
+		facet-&gt;wire=true;
+		body-&gt;geometricalModel=facet;
+		body-&gt;interactingGeometry=iFacet;
+	}
 }
 
 
@@ -513,19 +531,23 @@
 {
 	
 	shared_ptr&lt;InteractionGeometryMetaEngine&gt; interactionGeometryDispatcher(new InteractionGeometryMetaEngine);
-	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere2InteractingSphere4SpheresContactGeometry&quot;);
-	interactionGeometryDispatcher-&gt;add(&quot;InteractingBox2InteractingSphere4SpheresContactGeometry&quot;);
+	if(!facetWalls){
+		interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere2InteractingSphere4SpheresContactGeometry&quot;);
+		interactionGeometryDispatcher-&gt;add(&quot;InteractingBox2InteractingSphere4SpheresContactGeometry&quot;);
+	} else {
+		interactionGeometryDispatcher-&gt;add(&quot;ef2_Sphere_Sphere_Dem3DofGeom&quot;);
+		interactionGeometryDispatcher-&gt;add(&quot;ef2_Facet_Sphere_Dem3DofGeom&quot;);
+	}
 
+
 	shared_ptr&lt;InteractionPhysicsMetaEngine&gt; interactionPhysicsDispatcher(new InteractionPhysicsMetaEngine);
-//	interactionPhysicsDispatcher-&gt;add(&quot;SimpleElasticRelationships&quot;);
-// Unhandled exception: St13runtime_error : Class `SimpleElasticRelationships' could not be cast to required 2D EngineUnit	
 	shared_ptr&lt;InteractionPhysicsEngineUnit&gt; ss(new SimpleElasticRelationships);
 	interactionPhysicsDispatcher-&gt;add(ss);
 	
 		
 	shared_ptr&lt;BoundingVolumeMetaEngine&gt; boundingVolumeDispatcher	= shared_ptr&lt;BoundingVolumeMetaEngine&gt;(new BoundingVolumeMetaEngine);
 	boundingVolumeDispatcher-&gt;add(&quot;InteractingSphere2AABB&quot;);
-	boundingVolumeDispatcher-&gt;add(&quot;InteractingBox2AABB&quot;);
+	boundingVolumeDispatcher-&gt;add(facetWalls ? &quot;InteractingFacet2AABB&quot; : &quot;InteractingBox2AABB&quot;);
 	boundingVolumeDispatcher-&gt;add(&quot;MetaInteractingGeometry2AABB&quot;);
 		
 	shared_ptr&lt;GravityEngine&gt; gravityCondition(new GravityEngine);
@@ -615,11 +637,15 @@
 			ids-&gt;geomDispatcher=interactionGeometryDispatcher;
 			ids-&gt;physDispatcher=interactionPhysicsDispatcher;
 			ids-&gt;constLawDispatcher=shared_ptr&lt;ConstitutiveLawDispatcher&gt;(new ConstitutiveLawDispatcher);
-			shared_ptr&lt;ef2_Spheres_Elastic_ElasticLaw&gt; see(new ef2_Spheres_Elastic_ElasticLaw);
-				see-&gt;sdecGroupMask=2;
-			ids-&gt;constLawDispatcher-&gt;add(see);
+			if(!facetWalls){
+				shared_ptr&lt;ef2_Spheres_Elastic_ElasticLaw&gt; see(new ef2_Spheres_Elastic_ElasticLaw); see-&gt;sdecGroupMask=2;
+				ids-&gt;constLawDispatcher-&gt;add(see);
+			} else {
+				ids-&gt;constLawDispatcher-&gt;add(shared_ptr&lt;Law2_Dem3Dof_Elastic_Elastic&gt;(new Law2_Dem3Dof_Elastic_Elastic));
+			}
 		rootBody-&gt;engines.push_back(ids);
 	} else {
+		assert(!facetWalls);
 		rootBody-&gt;engines.push_back(interactionGeometryDispatcher);
 		rootBody-&gt;engines.push_back(interactionPhysicsDispatcher);
 		shared_ptr&lt;ElasticContactLaw&gt; elasticContactLaw(new ElasticContactLaw);
@@ -696,7 +722,7 @@
 	long tries = 1000; //nb of tries for positionning the next sphere
 	Vector3r dimensions = upperCorner - lowerCorner;
 
-	LOG_INFO(&quot;Generating aggregates ...&quot;);
+	LOG_INFO(&quot;Generating &quot;&lt;&lt;number&lt;&lt;&quot; aggregates ...&quot;);
 	
 	long t, i;
 	for (i=0; i&lt;number; ++i) {

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -107,6 +107,8 @@
 				,isotropicCompaction
 				//! do not create any files during run (.xml, .spheres, wall stress records)
 				,noFiles
+				// use Facets instead of Boxes for the walls
+				,facetWalls
 				;
 
 				//! Generate faster simulation: use InsertionSortCollider and InteractionDispatchers

Modified: trunk/pkg/dem/SConscript
===================================================================
--- trunk/pkg/dem/SConscript	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/pkg/dem/SConscript	2009-07-07 11:54:14 UTC (rev 1841)
@@ -652,6 +652,7 @@
 			'ElasticCriterionTimeStepper',
 			'InteractingSphere',
 			'InteractingBox',
+			'InteractingFacet',
 			'NewtonsDampedLaw',
 			'MetaInteractingGeometry',
 			'GravityEngines',
@@ -665,6 +666,7 @@
 			'yade-multimethods',
 			'Box',
 			'Sphere',
+			'Facet',
 			'AABB',
 			'PersistentSAPCollider',
 			'InsertionSortCollider',

Copied: trunk/py/_eudoxos.cpp (from rev 1834, trunk/lib/py/_eudoxos.cpp)

Copied: trunk/py/_packPredicates.cpp (from rev 1834, trunk/lib/py/_packPredicates.cpp)

Copied: trunk/py/_packSpheres.cpp (from rev 1834, trunk/lib/py/_packSpheres.cpp)
===================================================================
--- trunk/lib/py/_packSpheres.cpp	2009-07-02 15:26:02 UTC (rev 1834)
+++ trunk/py/_packSpheres.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,143 @@
+// 2009 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
+#include&lt;boost/python.hpp&gt;
+#include&lt;yade/extra/boost_python_len.hpp&gt;
+#include&lt;yade/lib-base/Logging.hpp&gt;
+#include&lt;yade/lib-base/yadeWm3.hpp&gt;
+#include&lt;yade/lib-base/yadeWm3Extra.hpp&gt;
+// #include&lt;yade/gui-py/_utils.hpp&gt; // will be: yade/lib-py/_utils.hpp&gt; at some point
+#include&lt;Wm3Vector3.h&gt;
+
+#include&lt;yade/core/Omega.hpp&gt;
+#include&lt;yade/core/MetaBody.hpp&gt;
+#include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
+
+#include&lt;yade/extra/Shop.hpp&gt;
+
+using namespace boost;
+using namespace std;
+#ifdef LOG4CXX
+	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.pack.spheres&quot;);
+#endif
+
+// copied from _packPredicates.cpp :-(
+python::tuple vec2tuple(const Vector3r&amp; v){return boost::python::make_tuple(v[0],v[1],v[2]);}
+Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
+Vector3r tuple2vec(python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
+
+struct SpherePack{
+	struct Sph{ Vector3r c; Real r; Sph(const Vector3r&amp; _c, Real _r): c(_c), r(_r){};
+		python::tuple asTuple() const { return python::make_tuple(c,r); }
+	};
+	vector&lt;Sph&gt; pack;
+	SpherePack(){};
+	SpherePack(const python::list&amp; l){ fromList(l); }
+	// add single sphere
+	void add(const Vector3r&amp; c, Real r){ pack.push_back(Sph(c,r)); }
+	// I/O
+	void fromList(const python::list&amp; l);
+	python::list toList() const;
+	void fromFile(const string file);
+	void toFile(const string file) const;
+	void fromSimulation();
+	// spatial characteristics
+	Vector3r dim() const {Vector3r mn,mx; aabb(mn,mx); return mx-mn;}
+	python::tuple aabb_py() const { Vector3r mn,mx; aabb(mn,mx); return python::make_tuple(mn,mx); }
+	void aabb(Vector3r&amp; mn, Vector3r&amp; mx) const {
+		Real inf=std::numeric_limits&lt;Real&gt;::infinity(); mn=Vector3r(inf,inf,inf); mx=Vector3r(-inf,-inf,-inf);
+		FOREACH(const Sph&amp; s, pack){ Vector3r r(s.r,s.r,s.r); mn=componentMinVector(mn,s.c-r); mx=componentMaxVector(mx,s.c+r);}
+	}
+	Vector3r midPt() const {Vector3r mn,mx; aabb(mn,mx); return .5*(mn+mx);}
+	Real relDensity() const {
+		Real sphVol=0; Vector3r dd=dim();
+		FOREACH(const Sph&amp; s, pack) sphVol+=pow(s.r,3);
+		sphVol*=(4/3.)*Mathr::PI;
+		return sphVol/(dd[0]*dd[1]*dd[2]);
+	}
+	// transformations
+	void translate(const Vector3r&amp; shift){ FOREACH(Sph&amp; s, pack) s.c+=shift; }
+	void rotate(const Vector3r&amp; axis, Real angle){ Vector3r mid=midPt(); Quaternionr q(axis,angle); FOREACH(Sph&amp; s, pack) s.c=q*(s.c-mid)+mid; }
+	void scale(Real scale){ Vector3r mid=midPt(); FOREACH(Sph&amp; s, pack) {s.c=scale*(s.c-mid)+mid; s.r*=abs(scale); } }
+	// iteration 
+	size_t len() const{ return pack.size(); }
+	python::tuple getitem(size_t idx){ if(idx&lt;0 || idx&gt;=pack.size()) throw runtime_error(&quot;Index &quot;+lexical_cast&lt;string&gt;(idx)+&quot; out of range 0..&quot;+lexical_cast&lt;string&gt;(pack.size()-1)); return pack[idx].asTuple(); }
+	struct iterator{
+		const SpherePack&amp; sPack; size_t pos;
+		iterator(const SpherePack&amp; _sPack): sPack(_sPack), pos(0){}
+		iterator iter(){ return *this;}
+		python::tuple next(){
+			if(pos==sPack.pack.size()-1){ PyErr_SetNone(PyExc_StopIteration); python::throw_error_already_set(); }
+			return sPack.pack[pos++].asTuple();
+		}
+	};
+	SpherePack::iterator getIterator() const{ return SpherePack::iterator(*this);};
+};
+
+void SpherePack::fromList(const python::list&amp; l){
+	pack.clear();
+	size_t len=python::len(l);
+	for(size_t i=0; i&lt;len; i++){
+		const python::tuple&amp; t=python::extract&lt;python::tuple&gt;(l[i]);
+		const python::tuple&amp; t1=python::extract&lt;python::tuple&gt;(t[0]);
+		pack.push_back(Sph(tuple2vec(t1),python::extract&lt;double&gt;(t[1])));
+	}
+};
+
+python::list SpherePack::toList() const {
+	python::list ret;
+	FOREACH(const Sph&amp; s, pack) ret.append(python::make_tuple(vec2tuple(s.c),s.r));
+	return ret;
+};
+
+void SpherePack::fromFile(string file) {
+	typedef pair&lt;Vector3r,Real&gt; pairVector3rReal;
+	vector&lt;pairVector3rReal&gt; ss;
+	Vector3r mn,mx;
+	ss=Shop::loadSpheresFromFile(file,mn,mx);
+	pack.clear();
+	FOREACH(const pairVector3rReal&amp; s, ss) pack.push_back(Sph(s.first,s.second));
+}
+
+void SpherePack::toFile(const string fname) const {
+	ofstream f(fname.c_str());
+	if(!f.good()) throw runtime_error(&quot;Unable to open file `&quot;+fname+&quot;'&quot;);
+	FOREACH(const Sph&amp; s, pack) f&lt;&lt;s.c[0]&lt;&lt;&quot; &quot;&lt;&lt;s.c[1]&lt;&lt;&quot; &quot;&lt;&lt;s.c[2]&lt;&lt;&quot; &quot;&lt;&lt;s.r&lt;&lt;endl;
+	f.close();
+};
+
+void SpherePack::fromSimulation() {
+	pack.clear();
+	MetaBody* rootBody=Omega::instance().getRootBody().get();
+	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *rootBody-&gt;bodies){
+		shared_ptr&lt;InteractingSphere&gt;	intSph=dynamic_pointer_cast&lt;InteractingSphere&gt;(b-&gt;interactingGeometry);
+		if(!intSph) continue;
+		pack.push_back(Sph(b-&gt;physicalParameters-&gt;se3.position,intSph-&gt;radius));
+	}
+}
+
+
+
+BOOST_PYTHON_MODULE(_packSpheres){
+	python::class_&lt;SpherePack&gt;(&quot;SpherePack&quot;,&quot;Set of spheres as centers and radii&quot;,python::init&lt;python::optional&lt;python::list&gt; &gt;(python::args(&quot;list&quot;),&quot;Empty constructor, optionally taking list [ ((cx,cy,cz),r), &#8230; ] for initial data.&quot; ))
+		.def(&quot;add&quot;,&amp;SpherePack::add,&quot;Add single sphere to packing, given center as 3-tuple and radius&quot;)
+		.def(&quot;toList&quot;,&amp;SpherePack::toList,&quot;Return packing data as python list.&quot;)
+		.def(&quot;fromList&quot;,&amp;SpherePack::fromList,&quot;Make packing from given list, same format as for constructor. Discards current data.&quot;)
+		.def(&quot;load&quot;,&amp;SpherePack::fromFile,&quot;Load packing from external text file (current data will be discarded).&quot;)
+		.def(&quot;save&quot;,&amp;SpherePack::toFile,&quot;Save packing to external text file (will be overwritten).&quot;)
+		.def(&quot;fromSimulation&quot;,&amp;SpherePack::fromSimulation,&quot;Make packing corresponding to the current simulation. Discards current data.&quot;)
+		.def(&quot;aabb&quot;,&amp;SpherePack::aabb_py,&quot;Get axis-aligned bounding box coordinates, as 2 3-tuples.&quot;)
+		.def(&quot;dim&quot;,&amp;SpherePack::dim,&quot;Return dimensions of the packing in terms of aabb(), as a 3-tuple.&quot;)
+		.def(&quot;center&quot;,&amp;SpherePack::midPt,&quot;Return coordinates of the bounding box center.&quot;)
+		.def(&quot;relDensity&quot;,&amp;SpherePack::relDensity,&quot;Relative packing density, measured as sum of spheres' volumes / aabb volume.\n(Sphere overlaps are ignored.)&quot;)
+		.def(&quot;translate&quot;,&amp;SpherePack::translate,&quot;Translate all spheres by given vector.&quot;)
+		.def(&quot;rotate&quot;,&amp;SpherePack::rotate,&quot;Rotate all spheres around packing center (in terms of aabb()), given axis and angle of the rotation.&quot;)
+		.def(&quot;scale&quot;,&amp;SpherePack::scale,&quot;Scale the packing around its center (in terms of aabb()) by given factor (may be negative).&quot;)
+		.def(&quot;__len__&quot;,&amp;SpherePack::len,&quot;Get number of spheres in the packing&quot;)
+		.def(&quot;__getitem__&quot;,&amp;SpherePack::getitem,&quot;Get entry at given index, as tuple of center and radius.&quot;)
+		.def(&quot;__iter__&quot;,&amp;SpherePack::getIterator,&quot;Return iterator over spheres.&quot;)
+		;
+	python::class_&lt;SpherePack::iterator&gt;(&quot;SpherePackIterator&quot;,python::init&lt;SpherePack::iterator&amp;&gt;())
+		.def(&quot;__iter__&quot;,&amp;SpherePack::iterator::iter)
+		.def(&quot;next&quot;,&amp;SpherePack::iterator::next)
+	;
+}
+


Property changes on: trunk/py/_packSpheres.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/py/_utils.cpp (from rev 1834, trunk/lib/py/_utils.cpp)

Copied: trunk/py/euclid.py (from rev 1834, trunk/lib/py/euclid.py)


Property changes on: trunk/py/euclid.py
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/py/eudoxos.py (from rev 1834, trunk/lib/py/eudoxos.py)

Copied: trunk/py/linterpolation.py (from rev 1834, trunk/lib/py/linterpolation.py)

Copied: trunk/py/log.cpp (from rev 1834, trunk/lib/py/log.cpp)

Added: trunk/py/miniWm3Wrap/README
===================================================================
--- trunk/py/miniWm3Wrap/README	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/py/miniWm3Wrap/README	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,13 @@
+This thin wrapper created using py++ wraps Vector2, Vector3 and Quaternion classes of Wm3
+(with real numbers, i.e. Vector2r, Vector3r, Quaternionr).
+
+* Matrix2 and Matrix3 are not wrapped (although they could be) as they are not used much in yade
+  (use numpy.Matrix if you need them in pure python code).
+* X(), Y(), Z(), W() methods are not supported, use the [] indexing to acces/update elements.
+* Methods taking or returning unwrapped types (like Quaternion().ToRotationMatrix()) are not
+  wrapped either.
+* This wrapper only works for typeof(Real)==typeof(double)
+
+The following files are generated by py++, but included so that you don't have to install py++:
+__call_policies.pypp.hpp, __convenience.pypp.hpp, miniWm3Wrap.cpp
+

Added: trunk/py/miniWm3Wrap/__call_policies.pypp.hpp
===================================================================
--- trunk/py/miniWm3Wrap/__call_policies.pypp.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/py/miniWm3Wrap/__call_policies.pypp.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,173 @@
+// This file has been generated by Py++.
+
+// Copyright 2004-2008 Roman Yakovenko.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#ifndef call_policies_pyplusplus_hpp__
+#define call_policies_pyplusplus_hpp__
+
+#include &quot;boost/python.hpp&quot;
+#include &quot;boost/cstdint.hpp&quot;
+#include &quot;boost/mpl/int.hpp&quot;
+#include &quot;boost/function.hpp&quot;
+#include &quot;boost/utility/addressof.hpp&quot;
+#include &quot;boost/type_traits/is_same.hpp&quot;
+#include &quot;boost/python/object/class_detail.hpp&quot;
+
+namespace pyplusplus{ namespace call_policies{
+
+namespace bpl = boost::python;
+
+namespace memory_managers{
+
+    struct none{
+        template&lt; typename T&gt;
+        static void deallocate_array(T*){}
+    };
+
+    struct delete_{
+        template&lt; typename T&gt;
+        static void deallocate_array(T* arr){
+            delete[] arr;
+        }
+    };
+
+}/*memory_managers*/
+
+
+namespace detail{
+
+struct make_value_holder{
+
+    template &lt;class T&gt;
+    static PyObject* execute(T* p){
+        if (p == 0){
+            return bpl::detail::none();
+        }
+        else{
+            bpl::object p_value( *p );
+            return bpl::incref( p_value.ptr() );
+        }
+    }
+};
+
+template &lt;class R&gt;
+struct return_pointee_value_requires_a_pointer_return_type
+# if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 3 || defined(__EDG__)
+{}
+# endif
+;
+
+struct make_addressof_holder{
+
+    template &lt;class T&gt;
+    static PyObject* execute(T* p){
+        if (p == 0){
+            return bpl::detail::none();
+        }
+        else{
+            boost::uint32_t addressof_p = reinterpret_cast&lt; boost::uint32_t &gt;( p );
+            bpl::object p_address( addressof_p );
+            return bpl::incref( p_address.ptr() );
+        }
+    }
+
+};
+
+template &lt;class R&gt;
+struct return_addressof_value_requires_a_pointer_return_type
+# if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 3 || defined(__EDG__)
+{}
+# endif
+;
+
+
+} //detail
+
+struct return_pointee_value{
+
+    template &lt;class T&gt;
+    struct apply{
+
+        BOOST_STATIC_CONSTANT( bool, ok = boost::is_pointer&lt;T&gt;::value );
+
+        typedef typename boost::mpl::if_c&lt;
+            ok
+            , bpl::to_python_indirect&lt;T, detail::make_value_holder&gt;
+            , detail::return_pointee_value_requires_a_pointer_return_type&lt;T&gt;
+        &gt;::type type;
+
+    };
+
+};
+
+struct return_addressof{
+
+    template &lt;class T&gt;
+    struct apply{
+
+        BOOST_STATIC_CONSTANT( bool, ok = boost::is_pointer&lt;T&gt;::value );
+
+        typedef typename boost::mpl::if_c&lt;
+            ok
+            , bpl::to_python_indirect&lt;T, detail::make_addressof_holder&gt;
+            , detail::return_addressof_value_requires_a_pointer_return_type&lt;T&gt;
+        &gt;::type type;
+
+    };
+
+};
+
+template&lt; typename CallPolicies, class T &gt;
+bpl::object make_object( T x ){
+    //constructs object using CallPolicies result_converter
+    typedef BOOST_DEDUCED_TYPENAME CallPolicies::result_converter:: template apply&lt; T &gt;::type result_converter_t;
+    result_converter_t rc;
+    return bpl::object( bpl::handle&lt;&gt;( rc( x ) ) );
+}
+
+namespace arrays{
+
+namespace details{
+
+template&lt; unsigned int size, typename MemoryManager, typename CallPolicies&gt;
+struct as_tuple_impl{
+
+    template &lt;class U&gt;
+    inline PyObject* operator()(U const* arr) const{
+        if( !arr ){
+            return bpl::incref( bpl::tuple().ptr() );
+        }
+        bpl::list list_;
+        for( unsigned int i = 0; i &lt; size; ++i ){
+            list_.append( make_object&lt; CallPolicies&gt;( arr[i] ) );
+        }
+        MemoryManager::deallocate_array( arr );
+        return bpl::incref( bpl::tuple( list_ ).ptr() );
+    }
+};
+
+}
+
+template&lt; unsigned int size, typename MemoryManager, typename MakeObjectCallPolicies=bpl::default_call_policies&gt;
+struct as_tuple{
+public:
+
+    template &lt;class T&gt;
+    struct apply{
+        BOOST_STATIC_CONSTANT( bool, ok = boost::is_pointer&lt;T&gt;::value );
+        typedef details::as_tuple_impl&lt;size, MemoryManager, MakeObjectCallPolicies&gt; type;
+    };
+
+};
+
+} /*arrays*/
+
+} /*pyplusplus*/ } /*call_policies*/
+
+
+#endif//call_policies_pyplusplus_hpp__
+
+

Added: trunk/py/miniWm3Wrap/__convenience.pypp.hpp
===================================================================
--- trunk/py/miniWm3Wrap/__convenience.pypp.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/py/miniWm3Wrap/__convenience.pypp.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,185 @@
+// This file has been generated by Py++.
+
+// Copyright 2004-2008 Roman Yakovenko.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#ifndef __convenience_pyplusplus_hpp__
+#define __convenience_pyplusplus_hpp__
+
+#include &quot;boost/python.hpp&quot;
+
+namespace pyplusplus{ namespace convenience{
+
+//TODO: Replace index_type with Boost.Python defined ssize_t type.
+//      This should be done by checking Python and Boost.Python version.
+typedef int index_type;
+
+inline void
+raise_error( PyObject *exception, const char *message ){
+   PyErr_SetString(exception, message);
+   boost::python::throw_error_already_set();
+}
+
+inline index_type sequence_len(boost::python::object const&amp; obj){
+    if( !PySequence_Check( obj.ptr() ) ){
+        raise_error( PyExc_TypeError, &quot;Sequence expected&quot; );
+    }
+
+    index_type result = PyObject_Length( obj.ptr() );
+    if( PyErr_Occurred() ){
+        boost::python::throw_error_already_set();
+    }
+    return result;
+}
+
+inline void
+ensure_sequence( boost::python::object seq, index_type expected_length=-1 ){
+    index_type length = sequence_len( seq );
+    if( expected_length != -1 &amp;&amp; length != expected_length ){
+        std::stringstream err;
+        err &lt;&lt; &quot;Expected sequence length is &quot; &lt;&lt; expected_length &lt;&lt; &quot;. &quot;
+            &lt;&lt; &quot;Actual sequence length is &quot; &lt;&lt; length &lt;&lt; &quot;.&quot;;
+        raise_error( PyExc_ValueError, err.str().c_str() );
+    }
+}
+
+template&lt; class ExpectedType &gt;
+void ensure_uniform_sequence( boost::python::object seq, index_type expected_length=-1 ){
+    ensure_sequence( seq, expected_length );
+
+    index_type length = sequence_len( seq );
+    for( index_type index = 0; index &lt; length; ++index ){
+        boost::python::object item = seq[index];
+
+        boost::python::extract&lt;ExpectedType&gt; type_checker( item );
+        if( !type_checker.check() ){
+            std::string expected_type_name( boost::python::type_id&lt;ExpectedType&gt;().name() );
+
+            std::string item_type_name(&quot;different&quot;);
+            PyObject* item_impl = item.ptr();
+            if( item_impl &amp;&amp; item_impl-&gt;ob_type &amp;&amp; item_impl-&gt;ob_type-&gt;tp_name ){
+                item_type_name = std::string( item_impl-&gt;ob_type-&gt;tp_name );
+            }
+
+            std::stringstream err;
+            err &lt;&lt; &quot;Sequence should contain only items with type \&quot;&quot; &lt;&lt; expected_type_name &lt;&lt; &quot;\&quot;. &quot;
+                &lt;&lt; &quot;Item at position &quot; &lt;&lt; index &lt;&lt; &quot; has \&quot;&quot; &lt;&lt; item_type_name &lt;&lt; &quot;\&quot; type.&quot;;
+            raise_error( PyExc_ValueError, err.str().c_str() );
+        }
+    }
+}
+
+template&lt; class Iterator, class Inserter &gt;
+void copy_container( Iterator begin, Iterator end, Inserter inserter ){
+    for( Iterator index = begin; index != end; ++index )
+        inserter( *index );
+}
+
+template&lt; class Inserter &gt;
+void copy_sequence( boost::python::object const&amp; seq, Inserter inserter ){
+    index_type length = sequence_len( seq );
+    for( index_type index = 0; index &lt; length; ++index ){
+        inserter = seq[index];
+    }
+}
+
+template&lt; class Inserter, class TItemType &gt;
+void copy_sequence( boost::python::object const&amp; seq, Inserter inserter, boost::type&lt; TItemType &gt; ){
+    index_type length = sequence_len( seq );
+    for( index_type index = 0; index &lt; length; ++index ){
+        boost::python::object item = seq[index];
+        inserter = boost::python::extract&lt; TItemType &gt;( item );
+    }
+}
+
+struct list_inserter{
+    list_inserter( boost::python::list&amp; py_list )
+    : m_py_list( py_list )
+    {}
+    
+    template&lt; class T &gt;
+    void operator()( T const &amp; value ){
+        m_py_list.append( value );
+    }
+private:
+    boost::python::list&amp; m_py_list;
+};
+
+template &lt; class T &gt;
+struct array_inserter_t{
+    array_inserter_t( T* array, index_type size )
+    : m_array( array )
+      , m_curr_pos( 0 )
+      , m_size( size )
+    {}
+
+    void insert( const T&amp; item ){
+        if( m_size &lt;= m_curr_pos ){
+            std::stringstream err;
+            err &lt;&lt; &quot;Index out of range. Array size is&quot; &lt;&lt; m_size &lt;&lt; &quot;, &quot;
+                &lt;&lt; &quot;current position is&quot; &lt;&lt; m_curr_pos &lt;&lt; &quot;.&quot;;
+            raise_error( PyExc_ValueError, err.str().c_str() );
+        }
+        m_array[ m_curr_pos ] = item;
+        m_curr_pos += 1;
+    }
+
+    array_inserter_t&lt;T&gt;&amp; 
+    operator=( boost::python::object const &amp; item ){
+        insert( boost::python::extract&lt; T &gt;( item ) );
+        return *this;
+    }
+    
+private:
+    T* m_array;
+    index_type m_curr_pos;
+    const index_type m_size;
+};
+
+template&lt; class T&gt;
+array_inserter_t&lt;T&gt; array_inserter( T* array, index_type size ){
+    return array_inserter_t&lt;T&gt;( array, size );
+}
+
+inline boost::python::object 
+get_out_argument( boost::python::object result, const char* arg_name ){
+    if( !PySequence_Check( result.ptr() ) ){
+        return result;
+    }    
+    boost::python::object cls = boost::python::getattr( result, &quot;__class__&quot; );
+    boost::python::object cls_name = boost::python::getattr( cls, &quot;__name__&quot; );
+    std::string name = boost::python::extract&lt; std::string &gt;( cls_name );
+    if( &quot;named_tuple&quot; == name ){
+        return boost::python::getattr( result, arg_name );    
+    }
+    else{
+        return result;
+    }
+    
+}
+
+inline boost::python::object 
+get_out_argument( boost::python::object result, index_type index ){
+    if( !PySequence_Check( result.ptr() ) ){
+        return result;
+    }    
+    boost::python::object cls = boost::python::getattr( result, &quot;__class__&quot; );
+    boost::python::object cls_name = boost::python::getattr( cls, &quot;__name__&quot; );
+    std::string name = boost::python::extract&lt; std::string &gt;( cls_name );
+    if( &quot;named_tuple&quot; == name ){
+        return result[ index ];    
+    }
+    else{
+        return result;
+    }
+}
+
+} /*pyplusplus*/ } /*convenience*/
+
+namespace pyplus_conv = pyplusplus::convenience;
+
+#endif//__convenience_pyplusplus_hpp__
+
+

Added: trunk/py/miniWm3Wrap/miniWm3Wrap-funcs.ipp
===================================================================
--- trunk/py/miniWm3Wrap/miniWm3Wrap-funcs.ipp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/py/miniWm3Wrap/miniWm3Wrap-funcs.ipp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,36 @@
+#include&lt;boost/lexical_cast.hpp&gt;
+#include&lt;string&gt;
+#include&lt;stdexcept&gt;
+
+#define IDX_CHECK(i,MAX){ if(i&lt;0 || i&gt;=MAX) { PyErr_SetString(PyExc_IndexError, &quot;Index out of range 0..&quot; #MAX); boost::python::throw_error_already_set(); } }
+void Vector2_set_item(Vector2r &amp; self, int idx, Real value){ IDX_CHECK(idx,2); self[idx]=value; }
+void Vector3_set_item(Vector3r &amp; self, int idx, Real value){ IDX_CHECK(idx,3); self[idx]=value; }
+void Quaternion_set_item(Quaternionr &amp; self, int idx, Real value){ IDX_CHECK(idx,4); self[idx]=value; }
+Real Vector2_get_item(const Vector2r &amp; self, int idx){ IDX_CHECK(idx,2); return self[idx]; }
+Real Vector3_get_item(const Vector3r &amp; self, int idx){ IDX_CHECK(idx,3); return self[idx]; }
+Real Quaternion_get_item(const Quaternionr &amp; self, int idx){ IDX_CHECK(idx,4); return self[idx]; }
+std::string Vector2_str(const Vector2r &amp; self){ return std::string(&quot;Vector2(&quot;)+boost::lexical_cast&lt;std::string&gt;(self[0])+&quot;,&quot;+boost::lexical_cast&lt;std::string&gt;(self[1])+&quot;)&quot;;}
+std::string Vector3_str(const Vector3r &amp; self){ return std::string(&quot;Vector3(&quot;)+boost::lexical_cast&lt;std::string&gt;(self[0])+&quot;,&quot;+boost::lexical_cast&lt;std::string&gt;(self[1])+&quot;,&quot;+boost::lexical_cast&lt;std::string&gt;(self[2])+&quot;)&quot;;}
+std::string Quaternion_str(const Quaternionr &amp; self){ Vector3r axis; Real angle; self.ToAxisAngle(axis,angle); return std::string(&quot;Quaternion((&quot;)+boost::lexical_cast&lt;std::string&gt;(axis[0])+&quot;,&quot;+boost::lexical_cast&lt;std::string&gt;(axis[1])+&quot;,&quot;+boost::lexical_cast&lt;std::string&gt;(axis[2])+&quot;),&quot;+boost::lexical_cast&lt;std::string&gt;(angle)+&quot;)&quot;;}
+int Vector2_len(){return 2;}
+int Vector3_len(){return 3;}
+int Quaternion_len(){return 4;}
+#undef IDX_CHECK
+
+// automagic converter from tuple to Vector3r
+struct custom_Vector3r_from_tuple{
+	custom_Vector3r_from_tuple(){
+		boost::python::converter::registry::push_back(&amp;convertible,&amp;construct,boost::python::type_id&lt;Vector3r&gt;());
+	}
+	static void* convertible(PyObject* obj_ptr){
+		if(!PySequence_Check(obj_ptr) || PySequence_Size(obj_ptr)!=3) return 0;
+		return obj_ptr;
+	}
+	static void construct(PyObject* obj_ptr, boost::python::converter::rvalue_from_python_stage1_data* data){
+		void* storage=((boost::python::converter::rvalue_from_python_storage&lt;Vector3r&gt;*)(data))-&gt;storage.bytes;
+		new (storage) Vector3r(boost::python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,0)),boost::python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,1)),boost::python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,2)));
+		data-&gt;convertible=storage;
+	}
+};
+
+

Added: trunk/py/miniWm3Wrap/miniWm3Wrap-generate.py
===================================================================
--- trunk/py/miniWm3Wrap/miniWm3Wrap-generate.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/py/miniWm3Wrap/miniWm3Wrap-generate.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,66 @@
+import os, os.path
+from pyplusplus import module_builder
+from pyplusplus.decl_wrappers import *
+from pyplusplus.module_builder import call_policies
+from pyplusplus import function_transformers as FT
+
+
+
+
+#Creating an instance of class that will help you to expose your declarations
+mb = module_builder.module_builder_t( [os.path.abspath(&quot;miniWm3Wrap-toExpose.hpp&quot;)]
+                                      , working_directory=r&quot;.&quot;
+                                      , include_paths=['../../lib','../../lib/miniWm3','/usr/include']
+                                      , define_symbols=['USE_MINIWM3'] )
+# exclude exerything first
+mb.decls().exclude()
+# include what is in Wm3
+mb.decls(lambda d: ('Wm3' in d.location.file_name) if d.location else False).include()
+
+
+## things we want to exclude:
+# we don't need system things from wm3
+mb.decls(lambda decl: 'System' in decl.name).exclude() 
+# do not expose instances we created just to instantiate templates
+mb.decls(lambda decl: decl.name.startswith('noexpose')).exclude() 
+# exclude casting operators
+mb.casting_operators().exclude()
+# exclude functions&amp;operators returning double&amp; (not representable)
+mb.member_functions(return_type='double &amp;').exclude()
+mb.global_ns.operators(return_type='double &amp;').exclude() # global_ns is a bug workaround: <A HREF="http://www.mail-archive.com/cplusplus-sig@python.org/msg00730.html">http://www.mail-archive.com/cplusplus-sig@python.org/msg00730.html</A>
+# exclude everything (member functions, operators, ...) taking or returning types we do not wrap
+mb.decls(lambda d: 'Matrix3' in str(d) or 'Matrix2' in str(d) or 'Vector4' in str(d)).exclude()
+# exclude operator[] since we implement __getitem__/__setitem__ by ourselves
+mb.member_operators(lambda o: o.symbol=='[]').exclude()
+
+# register manual wraps
+v2,v3,q4=mb.class_(lambda d: d.name=='Vector2&lt;double&gt;'),mb.class_(lambda d: d.name=='Vector3&lt;double&gt;'),mb.class_(lambda d: d.name=='Quaternion&lt;double&gt;')
+v2.add_registration_code('def(&quot;__len__&quot;,&amp;::Vector2_len)   .staticmethod(&quot;__len__&quot;).def(&quot;__setitem__&quot;,&amp;::Vector2_set_item)   .def(&quot;__getitem__&quot;,&amp;::Vector2_get_item)   .def(&quot;__str__&quot;,&amp;::Vector2_str)   .def(&quot;__repr__&quot;,&amp;::Vector2_str)')
+v3.add_registration_code('def(&quot;__len__&quot;,&amp;::Vector3_len)   .staticmethod(&quot;__len__&quot;).def(&quot;__setitem__&quot;,&amp;::Vector3_set_item)   .def(&quot;__getitem__&quot;,&amp;::Vector3_get_item)   .def(&quot;__str__&quot;,&amp;::Vector3_str)   .def(&quot;__repr__&quot;,&amp;::Vector3_str)')
+q4.add_registration_code('def(&quot;__len__&quot;,&amp;::Quaternion_len).staticmethod(&quot;__len__&quot;).def(&quot;__setitem__&quot;,&amp;::Quaternion_set_item).def(&quot;__getitem__&quot;,&amp;::Quaternion_get_item).def(&quot;__str__&quot;,&amp;::Quaternion_str).def(&quot;__repr__&quot;,&amp;::Quaternion_str)')
+
+# arg0 and arg1 will be returned as tuple, instead of the references ToAxisAngle takes
+mb.member_functions('ToAxisAngle').add_transformation(FT.output(0),FT.output(1))
+# quaternion operations returning itself
+mb.member_functions(lambda mf: 'Quaternion&lt;double&gt; &amp;' in str(mf.return_type)).call_policies=call_policies.return_self()
+
+mb.add_registration_code(&quot;custom_Vector3r_from_tuple();&quot;)
+
+if 0:
+	#mb.member_functions(return_type='Wm3::Matrix3&lt;double&gt; &amp;').call_policies=call_policies.return_self
+	mb.member_functions('ToAngle').add_transformation(FT.output(0)) # Matrix2
+	mb.member_functions(lambda mf: 'Matrix3&lt;double&gt; &amp;' in str(mf.return_type)).call_policies=call_policies.return_self()
+	mb.decls(lambda decl: decl.name.startswith('ToEulerAngles')).add_transformation(FT.output(0),FT.output(1),FT.output(2))
+
+mb.build_code_creator(module_name='miniWm3Wrap')
+mb.code_creator.add_include(&quot;miniWm3Wrap-funcs.ipp&quot;)
+mb.write_module('miniWm3Wrap.cpp')
+
+# cleaup unneeded generated files
+toClean='exposed_decl.pypp.txt','miniWm3Wrap.cpp~','named_tuple.py'
+for f in toClean:
+	if os.path.exists(f):
+		try:
+			os.remove(f)
+		except IOError: pass
+

Added: trunk/py/miniWm3Wrap/miniWm3Wrap-toExpose.hpp
===================================================================
--- trunk/py/miniWm3Wrap/miniWm3Wrap-toExpose.hpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/py/miniWm3Wrap/miniWm3Wrap-toExpose.hpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,22 @@
+#include&lt;base/yadeWm3.hpp&gt;
+#include&lt;base/yadeWm3Extra.hpp&gt;
+#include&lt;boost/lexical_cast.hpp&gt;
+#include&lt;string&gt;
+
+// define python names for these classes
+// see <A HREF="http://language-binding.net/pyplusplus/documentation/how_to/hints.html#pyplusplus-aliases-namespace">http://language-binding.net/pyplusplus/documentation/how_to/hints.html#pyplusplus-aliases-namespace</A>
+namespace pyplusplus{ namespace aliases {
+	typedef Vector3r Vector3;
+	typedef Vector2r Vector2;
+	typedef Quaternionr Quaternion;
+	typedef Matrix3r Matrix3;
+	typedef Matrix2r Matrix2;
+}}
+// instantiate those types so that they are exposed
+// but name them noexpose_*, as we ask for exclusion of such things in the wrapper script
+Vector3r noexpose_v3r;
+Vector2r noexpose_v2r;
+Quaternionr noexpose_qr;
+//Matrix3r noexpose_m3r;
+//Matrix2r noexpose_m2r;
+

Added: trunk/py/miniWm3Wrap/miniWm3Wrap.cpp
===================================================================
--- trunk/py/miniWm3Wrap/miniWm3Wrap.cpp	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/py/miniWm3Wrap/miniWm3Wrap.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,848 @@
+// This file has been generated by Py++.
+
+#include &quot;boost/python.hpp&quot;
+
+#include &quot;__convenience.pypp.hpp&quot;
+
+#include &quot;__call_policies.pypp.hpp&quot;
+
+#include &quot;/home/vaclav/yade/trunk/py/miniWm3Wrap/miniWm3Wrap-toExpose.hpp&quot;
+
+#include &quot;miniWm3Wrap-funcs.ipp&quot;
+
+namespace bp = boost::python;
+
+static boost::python::tuple ToAxisAngle_2c4febac34e606b4a98de72d9f8161c9( ::Wm3::Quaternion&lt; double &gt; const &amp; inst ){
+    Wm3::Vector3&lt;double&gt; rkAxis2;
+    double rfAngle2;
+    inst.ToAxisAngle(rkAxis2, rfAngle2);
+    return bp::make_tuple( rkAxis2, rfAngle2 );
+}
+
+BOOST_PYTHON_MODULE(miniWm3Wrap){
+    { //::Wm3::Quaternion&lt; double &gt;
+        typedef bp::class_&lt; Wm3::Quaternion&lt; double &gt; &gt; Quaternion_exposer_t;
+        Quaternion_exposer_t Quaternion_exposer = Quaternion_exposer_t( &quot;Quaternion&quot;, bp::init&lt; &gt;() );
+        bp::scope Quaternion_scope( Quaternion_exposer );
+        Quaternion_exposer.def( bp::init&lt; double, double, double, double &gt;(( bp::arg(&quot;fW&quot;), bp::arg(&quot;fX&quot;), bp::arg(&quot;fY&quot;), bp::arg(&quot;fZ&quot;) )) );
+        Quaternion_exposer.def( bp::init&lt; Wm3::Quaternion&lt; double &gt; const &amp; &gt;(( bp::arg(&quot;rkQ&quot;) )) );
+        Quaternion_exposer.def( bp::init&lt; Wm3::Vector3&lt; double &gt; const &amp;, double &gt;(( bp::arg(&quot;rkAxis&quot;), bp::arg(&quot;fAngle&quot;) )) );
+        Quaternion_exposer.def( bp::init&lt; Wm3::Vector3&lt; double &gt; const * &gt;(( bp::arg(&quot;akRotColumn&quot;) )) );
+        bp::implicitly_convertible&lt; Wm3::Vector3&lt; double &gt; const *, Wm3::Quaternion&lt; double &gt; &gt;();
+        { //::Wm3::Quaternion&lt; double &gt;::Align
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*Align_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp;,::Wm3::Vector3&lt; double &gt; const &amp; ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;Align&quot;
+                , Align_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Align )
+                , ( bp::arg(&quot;rkV1&quot;), bp::arg(&quot;rkV2&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Conjugate
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; ( exported_class_t::*Conjugate_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Conjugate&quot;
+                , Conjugate_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Conjugate ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::DecomposeSwingTimesTwist
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef void ( exported_class_t::*DecomposeSwingTimesTwist_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; &amp;,::Wm3::Quaternion&lt; double &gt; &amp; ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;DecomposeSwingTimesTwist&quot;
+                , DecomposeSwingTimesTwist_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::DecomposeSwingTimesTwist )
+                , ( bp::arg(&quot;rkV1&quot;), bp::arg(&quot;rkSwing&quot;), bp::arg(&quot;rkTwist&quot;) ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::DecomposeTwistTimesSwing
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef void ( exported_class_t::*DecomposeTwistTimesSwing_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; &amp;,::Wm3::Quaternion&lt; double &gt; &amp; ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;DecomposeTwistTimesSwing&quot;
+                , DecomposeTwistTimesSwing_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::DecomposeTwistTimesSwing )
+                , ( bp::arg(&quot;rkV1&quot;), bp::arg(&quot;rkTwist&quot;), bp::arg(&quot;rkSwing&quot;) ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Dot
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Dot_function_type )( ::Wm3::Quaternion&lt; double &gt; const &amp; ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Dot&quot;
+                , Dot_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Dot )
+                , ( bp::arg(&quot;rkQ&quot;) ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Exp
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; ( exported_class_t::*Exp_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Exp&quot;
+                , Exp_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Exp ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::FromAxisAngle
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*FromAxisAngle_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp;,double ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;FromAxisAngle&quot;
+                , FromAxisAngle_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::FromAxisAngle )
+                , ( bp::arg(&quot;rkAxis&quot;), bp::arg(&quot;fAngle&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::FromRotationMatrix
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*FromRotationMatrix_function_type )( ::Wm3::Vector3&lt; double &gt; const * ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;FromRotationMatrix&quot;
+                , FromRotationMatrix_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::FromRotationMatrix )
+                , ( bp::arg(&quot;akRotColumn&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Intermediate
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*Intermediate_function_type )( ::Wm3::Quaternion&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; const &amp; ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;Intermediate&quot;
+                , Intermediate_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Intermediate )
+                , ( bp::arg(&quot;rkQ0&quot;), bp::arg(&quot;rkQ1&quot;), bp::arg(&quot;rkQ2&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Inverse
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; ( exported_class_t::*Inverse_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Inverse&quot;
+                , Inverse_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Inverse ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Length
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Length_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Length&quot;
+                , Length_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Length ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Log
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; ( exported_class_t::*Log_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Log&quot;
+                , Log_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Log ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Normalize
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;Normalize&quot;
+                , Normalize_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Normalize ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Rotate
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Vector3&lt; double &gt; ( exported_class_t::*Rotate_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp; ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Rotate&quot;
+                , Rotate_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Rotate )
+                , ( bp::arg(&quot;rkVector&quot;) ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Slerp
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*Slerp_function_type )( double,::Wm3::Quaternion&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; const &amp; ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;Slerp&quot;
+                , Slerp_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Slerp )
+                , ( bp::arg(&quot;fT&quot;), bp::arg(&quot;rkP&quot;), bp::arg(&quot;rkQ&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::SlerpExtraSpins
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*SlerpExtraSpins_function_type )( double,::Wm3::Quaternion&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; const &amp;,int ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;SlerpExtraSpins&quot;
+                , SlerpExtraSpins_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::SlerpExtraSpins )
+                , ( bp::arg(&quot;fT&quot;), bp::arg(&quot;rkP&quot;), bp::arg(&quot;rkQ&quot;), bp::arg(&quot;iExtraSpins&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Squad
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*Squad_function_type )( double,::Wm3::Quaternion&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; const &amp;,::Wm3::Quaternion&lt; double &gt; const &amp; ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;Squad&quot;
+                , Squad_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Squad )
+                , ( bp::arg(&quot;fT&quot;), bp::arg(&quot;rkQ0&quot;), bp::arg(&quot;rkA0&quot;), bp::arg(&quot;rkA1&quot;), bp::arg(&quot;rkQ1&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::SquaredLength
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;SquaredLength&quot;
+                , SquaredLength_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::SquaredLength ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::ToAxisAngle
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef boost::python::tuple ( *ToAxisAngle_function_type )( ::Wm3::Quaternion&lt;double&gt; const &amp; );
+            
+            Quaternion_exposer.def( 
+                &quot;ToAxisAngle&quot;
+                , ToAxisAngle_function_type( &amp;ToAxisAngle_2c4febac34e606b4a98de72d9f8161c9 )
+                , ( bp::arg(&quot;inst&quot;) ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::ToRotationMatrix
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef void ( exported_class_t::*ToRotationMatrix_function_type )( ::Wm3::Vector3&lt; double &gt; * ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;ToRotationMatrix&quot;
+                , ToRotationMatrix_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::ToRotationMatrix )
+                , ( bp::arg(&quot;akRotColumn&quot;) ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::W
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*W_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;W&quot;
+                , W_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::W ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::X
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*X_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;X&quot;
+                , X_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::X ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Y
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Y_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Y&quot;
+                , Y_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Y ) );
+        
+        }
+        { //::Wm3::Quaternion&lt; double &gt;::Z
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Z_function_type )(  ) const;
+            
+            Quaternion_exposer.def( 
+                &quot;Z&quot;
+                , Z_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::Z ) );
+        
+        }
+        Quaternion_exposer.def( bp::self != bp::self );
+        Quaternion_exposer.def( bp::self * bp::self );
+        Quaternion_exposer.def( bp::self * bp::other&lt; double &gt;() );
+        Quaternion_exposer.def( bp::self *= bp::other&lt; double &gt;() );
+        Quaternion_exposer.def( bp::self + bp::self );
+        Quaternion_exposer.def( bp::self += bp::self );
+        Quaternion_exposer.def( bp::self - bp::self );
+        Quaternion_exposer.def( -bp::self );
+        Quaternion_exposer.def( bp::self -= bp::self );
+        Quaternion_exposer.def( bp::self / bp::other&lt; double &gt;() );
+        Quaternion_exposer.def( bp::self /= bp::other&lt; double &gt;() );
+        Quaternion_exposer.def( bp::self &lt; bp::self );
+        Quaternion_exposer.def( bp::self &lt;= bp::self );
+        { //::Wm3::Quaternion&lt; double &gt;::operator=
+        
+            typedef Wm3::Quaternion&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Quaternion&lt; double &gt; &amp; ( exported_class_t::*assign_function_type )( ::Wm3::Quaternion&lt; double &gt; const &amp; ) ;
+            
+            Quaternion_exposer.def( 
+                &quot;assign&quot;
+                , assign_function_type( &amp;::Wm3::Quaternion&lt; double &gt;::operator= )
+                , ( bp::arg(&quot;rkQ&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        Quaternion_exposer.def( bp::self == bp::self );
+        Quaternion_exposer.def( bp::self &gt; bp::self );
+        Quaternion_exposer.def( bp::self &gt;= bp::self );
+        Quaternion_exposer.def_readonly( &quot;IDENTITY&quot;, Wm3::Quaternion&lt; double &gt;::IDENTITY );
+        Quaternion_exposer.def_readonly( &quot;ZERO&quot;, Wm3::Quaternion&lt; double &gt;::ZERO );
+        Quaternion_exposer.def( bp::self * bp::other&lt; Wm3::Vector3&lt; double &gt; &gt;() );
+        Quaternion_exposer.def( bp::self_ns::str( bp::self ) );
+        Quaternion_exposer.def(&quot;__len__&quot;,&amp;::Quaternion_len).staticmethod(&quot;__len__&quot;).def(&quot;__setitem__&quot;,&amp;::Quaternion_set_item).def(&quot;__getitem__&quot;,&amp;::Quaternion_get_item).def(&quot;__str__&quot;,&amp;::Quaternion_str).def(&quot;__repr__&quot;,&amp;::Quaternion_str);
+    }
+
+    { //::Wm3::Vector2&lt; double &gt;
+        typedef bp::class_&lt; Wm3::Vector2&lt; double &gt; &gt; Vector2_exposer_t;
+        Vector2_exposer_t Vector2_exposer = Vector2_exposer_t( &quot;Vector2&quot;, bp::init&lt; &gt;() );
+        bp::scope Vector2_scope( Vector2_exposer );
+        Vector2_exposer.def( bp::init&lt; double, double &gt;(( bp::arg(&quot;fX&quot;), bp::arg(&quot;fY&quot;) )) );
+        Vector2_exposer.def( bp::init&lt; double const * &gt;(( bp::arg(&quot;afTuple&quot;) )) );
+        bp::implicitly_convertible&lt; double const *, Wm3::Vector2&lt; double &gt; &gt;();
+        Vector2_exposer.def( bp::init&lt; Wm3::Vector2&lt; double &gt; const &amp; &gt;(( bp::arg(&quot;rkV&quot;) )) );
+        { //::Wm3::Vector2&lt; double &gt;::ComputeExtremes
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef void ( *ComputeExtremes_function_type )( int,::Wm3::Vector2&lt; double &gt; const *,::Wm3::Vector2&lt; double &gt; &amp;,::Wm3::Vector2&lt; double &gt; &amp; );
+            
+            Vector2_exposer.def( 
+                &quot;ComputeExtremes&quot;
+                , ComputeExtremes_function_type( &amp;::Wm3::Vector2&lt; double &gt;::ComputeExtremes )
+                , ( bp::arg(&quot;iVQuantity&quot;), bp::arg(&quot;akPoint&quot;), bp::arg(&quot;rkMin&quot;), bp::arg(&quot;rkMax&quot;) ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::Dot
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Dot_function_type )( ::Wm3::Vector2&lt; double &gt; const &amp; ) const;
+            
+            Vector2_exposer.def( 
+                &quot;Dot&quot;
+                , Dot_function_type( &amp;::Wm3::Vector2&lt; double &gt;::Dot )
+                , ( bp::arg(&quot;rkV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::DotPerp
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*DotPerp_function_type )( ::Wm3::Vector2&lt; double &gt; const &amp; ) const;
+            
+            Vector2_exposer.def( 
+                &quot;DotPerp&quot;
+                , DotPerp_function_type( &amp;::Wm3::Vector2&lt; double &gt;::DotPerp )
+                , ( bp::arg(&quot;rkV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::GenerateOrthonormalBasis
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef void ( *GenerateOrthonormalBasis_function_type )( ::Wm3::Vector2&lt; double &gt; &amp;,::Wm3::Vector2&lt; double &gt; &amp;,bool );
+            
+            Vector2_exposer.def( 
+                &quot;GenerateOrthonormalBasis&quot;
+                , GenerateOrthonormalBasis_function_type( &amp;::Wm3::Vector2&lt; double &gt;::GenerateOrthonormalBasis )
+                , ( bp::arg(&quot;rkU&quot;), bp::arg(&quot;rkV&quot;), bp::arg(&quot;bUnitLengthV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::GetBarycentrics
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef void ( exported_class_t::*GetBarycentrics_function_type )( ::Wm3::Vector2&lt; double &gt; const &amp;,::Wm3::Vector2&lt; double &gt; const &amp;,::Wm3::Vector2&lt; double &gt; const &amp;,double * ) const;
+            
+            Vector2_exposer.def( 
+                &quot;GetBarycentrics&quot;
+                , GetBarycentrics_function_type( &amp;::Wm3::Vector2&lt; double &gt;::GetBarycentrics )
+                , ( bp::arg(&quot;rkV0&quot;), bp::arg(&quot;rkV1&quot;), bp::arg(&quot;rkV2&quot;), bp::arg(&quot;afBary&quot;) ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::Length
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Length_function_type )(  ) const;
+            
+            Vector2_exposer.def( 
+                &quot;Length&quot;
+                , Length_function_type( &amp;::Wm3::Vector2&lt; double &gt;::Length ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::Normalize
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
+            
+            Vector2_exposer.def( 
+                &quot;Normalize&quot;
+                , Normalize_function_type( &amp;::Wm3::Vector2&lt; double &gt;::Normalize ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::Orthonormalize
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef void ( *Orthonormalize_function_type )( ::Wm3::Vector2&lt; double &gt; &amp;,::Wm3::Vector2&lt; double &gt; &amp; );
+            
+            Vector2_exposer.def( 
+                &quot;Orthonormalize&quot;
+                , Orthonormalize_function_type( &amp;::Wm3::Vector2&lt; double &gt;::Orthonormalize )
+                , ( bp::arg(&quot;rkU&quot;), bp::arg(&quot;rkV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::Perp
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Vector2&lt; double &gt; ( exported_class_t::*Perp_function_type )(  ) const;
+            
+            Vector2_exposer.def( 
+                &quot;Perp&quot;
+                , Perp_function_type( &amp;::Wm3::Vector2&lt; double &gt;::Perp ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::SquaredLength
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
+            
+            Vector2_exposer.def( 
+                &quot;SquaredLength&quot;
+                , SquaredLength_function_type( &amp;::Wm3::Vector2&lt; double &gt;::SquaredLength ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::UnitPerp
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Vector2&lt; double &gt; ( exported_class_t::*UnitPerp_function_type )(  ) const;
+            
+            Vector2_exposer.def( 
+                &quot;UnitPerp&quot;
+                , UnitPerp_function_type( &amp;::Wm3::Vector2&lt; double &gt;::UnitPerp ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::X
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*X_function_type )(  ) const;
+            
+            Vector2_exposer.def( 
+                &quot;X&quot;
+                , X_function_type( &amp;::Wm3::Vector2&lt; double &gt;::X ) );
+        
+        }
+        { //::Wm3::Vector2&lt; double &gt;::Y
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Y_function_type )(  ) const;
+            
+            Vector2_exposer.def( 
+                &quot;Y&quot;
+                , Y_function_type( &amp;::Wm3::Vector2&lt; double &gt;::Y ) );
+        
+        }
+        Vector2_exposer.def( bp::self != bp::self );
+        Vector2_exposer.def( bp::self * bp::other&lt; double &gt;() );
+        Vector2_exposer.def( bp::self *= bp::other&lt; double &gt;() );
+        Vector2_exposer.def( bp::self + bp::self );
+        Vector2_exposer.def( bp::self += bp::self );
+        Vector2_exposer.def( bp::self - bp::self );
+        Vector2_exposer.def( -bp::self );
+        Vector2_exposer.def( bp::self -= bp::self );
+        Vector2_exposer.def( bp::self / bp::other&lt; double &gt;() );
+        Vector2_exposer.def( bp::self /= bp::other&lt; double &gt;() );
+        Vector2_exposer.def( bp::self &lt; bp::self );
+        Vector2_exposer.def( bp::self &lt;= bp::self );
+        { //::Wm3::Vector2&lt; double &gt;::operator=
+        
+            typedef Wm3::Vector2&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Vector2&lt; double &gt; &amp; ( exported_class_t::*assign_function_type )( ::Wm3::Vector2&lt; double &gt; const &amp; ) ;
+            
+            Vector2_exposer.def( 
+                &quot;assign&quot;
+                , assign_function_type( &amp;::Wm3::Vector2&lt; double &gt;::operator= )
+                , ( bp::arg(&quot;rkV&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        Vector2_exposer.def( bp::self == bp::self );
+        Vector2_exposer.def( bp::self &gt; bp::self );
+        Vector2_exposer.def( bp::self &gt;= bp::self );
+        Vector2_exposer.def_readonly( &quot;ONE&quot;, Wm3::Vector2&lt; double &gt;::ONE );
+        Vector2_exposer.def_readonly( &quot;UNIT_X&quot;, Wm3::Vector2&lt; double &gt;::UNIT_X );
+        Vector2_exposer.def_readonly( &quot;UNIT_Y&quot;, Wm3::Vector2&lt; double &gt;::UNIT_Y );
+        Vector2_exposer.def_readonly( &quot;ZERO&quot;, Wm3::Vector2&lt; double &gt;::ZERO );
+        Vector2_exposer.staticmethod( &quot;ComputeExtremes&quot; );
+        Vector2_exposer.staticmethod( &quot;GenerateOrthonormalBasis&quot; );
+        Vector2_exposer.staticmethod( &quot;Orthonormalize&quot; );
+        Vector2_exposer.def( bp::other&lt; Real &gt;() * bp::self );
+        Vector2_exposer.def(&quot;__len__&quot;,&amp;::Vector2_len)   .staticmethod(&quot;__len__&quot;).def(&quot;__setitem__&quot;,&amp;::Vector2_set_item)   .def(&quot;__getitem__&quot;,&amp;::Vector2_get_item)   .def(&quot;__str__&quot;,&amp;::Vector2_str)   .def(&quot;__repr__&quot;,&amp;::Vector2_str);
+    }
+
+    { //::Wm3::Vector3&lt; double &gt;
+        typedef bp::class_&lt; Wm3::Vector3&lt; double &gt; &gt; Vector3_exposer_t;
+        Vector3_exposer_t Vector3_exposer = Vector3_exposer_t( &quot;Vector3&quot;, bp::init&lt; &gt;() );
+        bp::scope Vector3_scope( Vector3_exposer );
+        Vector3_exposer.def( bp::init&lt; double, double, double &gt;(( bp::arg(&quot;fX&quot;), bp::arg(&quot;fY&quot;), bp::arg(&quot;fZ&quot;) )) );
+        Vector3_exposer.def( bp::init&lt; double const * &gt;(( bp::arg(&quot;afTuple&quot;) )) );
+        bp::implicitly_convertible&lt; double const *, Wm3::Vector3&lt; double &gt; &gt;();
+        Vector3_exposer.def( bp::init&lt; Wm3::Vector3&lt; double &gt; const &amp; &gt;(( bp::arg(&quot;rkV&quot;) )) );
+        { //::Wm3::Vector3&lt; double &gt;::ComputeExtremes
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef void ( *ComputeExtremes_function_type )( int,::Wm3::Vector3&lt; double &gt; const *,::Wm3::Vector3&lt; double &gt; &amp;,::Wm3::Vector3&lt; double &gt; &amp; );
+            
+            Vector3_exposer.def( 
+                &quot;ComputeExtremes&quot;
+                , ComputeExtremes_function_type( &amp;::Wm3::Vector3&lt; double &gt;::ComputeExtremes )
+                , ( bp::arg(&quot;iVQuantity&quot;), bp::arg(&quot;akPoint&quot;), bp::arg(&quot;rkMin&quot;), bp::arg(&quot;rkMax&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Cross
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Vector3&lt; double &gt; ( exported_class_t::*Cross_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp; ) const;
+            
+            Vector3_exposer.def( 
+                &quot;Cross&quot;
+                , Cross_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Cross )
+                , ( bp::arg(&quot;rkV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Dot
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Dot_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp; ) const;
+            
+            Vector3_exposer.def( 
+                &quot;Dot&quot;
+                , Dot_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Dot )
+                , ( bp::arg(&quot;rkV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::GenerateOrthonormalBasis
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef void ( *GenerateOrthonormalBasis_function_type )( ::Wm3::Vector3&lt; double &gt; &amp;,::Wm3::Vector3&lt; double &gt; &amp;,::Wm3::Vector3&lt; double &gt; &amp;,bool );
+            
+            Vector3_exposer.def( 
+                &quot;GenerateOrthonormalBasis&quot;
+                , GenerateOrthonormalBasis_function_type( &amp;::Wm3::Vector3&lt; double &gt;::GenerateOrthonormalBasis )
+                , ( bp::arg(&quot;rkU&quot;), bp::arg(&quot;rkV&quot;), bp::arg(&quot;rkW&quot;), bp::arg(&quot;bUnitLengthW&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::GetBarycentrics
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef void ( exported_class_t::*GetBarycentrics_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp;,::Wm3::Vector3&lt; double &gt; const &amp;,::Wm3::Vector3&lt; double &gt; const &amp;,::Wm3::Vector3&lt; double &gt; const &amp;,double * ) const;
+            
+            Vector3_exposer.def( 
+                &quot;GetBarycentrics&quot;
+                , GetBarycentrics_function_type( &amp;::Wm3::Vector3&lt; double &gt;::GetBarycentrics )
+                , ( bp::arg(&quot;rkV0&quot;), bp::arg(&quot;rkV1&quot;), bp::arg(&quot;rkV2&quot;), bp::arg(&quot;rkV3&quot;), bp::arg(&quot;afBary&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Length
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Length_function_type )(  ) const;
+            
+            Vector3_exposer.def( 
+                &quot;Length&quot;
+                , Length_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Length ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Normalize
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
+            
+            Vector3_exposer.def( 
+                &quot;Normalize&quot;
+                , Normalize_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Normalize ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Orthonormalize
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef void ( *Orthonormalize_function_type )( ::Wm3::Vector3&lt; double &gt; &amp;,::Wm3::Vector3&lt; double &gt; &amp;,::Wm3::Vector3&lt; double &gt; &amp; );
+            
+            Vector3_exposer.def( 
+                &quot;Orthonormalize&quot;
+                , Orthonormalize_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Orthonormalize )
+                , ( bp::arg(&quot;rkU&quot;), bp::arg(&quot;rkV&quot;), bp::arg(&quot;rkW&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Orthonormalize
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef void ( *Orthonormalize_function_type )( ::Wm3::Vector3&lt; double &gt; * );
+            
+            Vector3_exposer.def( 
+                &quot;Orthonormalize&quot;
+                , Orthonormalize_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Orthonormalize )
+                , ( bp::arg(&quot;akV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::SquaredLength
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
+            
+            Vector3_exposer.def( 
+                &quot;SquaredLength&quot;
+                , SquaredLength_function_type( &amp;::Wm3::Vector3&lt; double &gt;::SquaredLength ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::UnitCross
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Vector3&lt; double &gt; ( exported_class_t::*UnitCross_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp; ) const;
+            
+            Vector3_exposer.def( 
+                &quot;UnitCross&quot;
+                , UnitCross_function_type( &amp;::Wm3::Vector3&lt; double &gt;::UnitCross )
+                , ( bp::arg(&quot;rkV&quot;) ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::X
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*X_function_type )(  ) const;
+            
+            Vector3_exposer.def( 
+                &quot;X&quot;
+                , X_function_type( &amp;::Wm3::Vector3&lt; double &gt;::X ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Y
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Y_function_type )(  ) const;
+            
+            Vector3_exposer.def( 
+                &quot;Y&quot;
+                , Y_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Y ) );
+        
+        }
+        { //::Wm3::Vector3&lt; double &gt;::Z
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef double ( exported_class_t::*Z_function_type )(  ) const;
+            
+            Vector3_exposer.def( 
+                &quot;Z&quot;
+                , Z_function_type( &amp;::Wm3::Vector3&lt; double &gt;::Z ) );
+        
+        }
+        Vector3_exposer.def( bp::self != bp::self );
+        Vector3_exposer.def( bp::self * bp::other&lt; double &gt;() );
+        Vector3_exposer.def( bp::self *= bp::other&lt; double &gt;() );
+        Vector3_exposer.def( bp::self + bp::self );
+        Vector3_exposer.def( bp::self += bp::self );
+        Vector3_exposer.def( bp::self - bp::self );
+        Vector3_exposer.def( -bp::self );
+        Vector3_exposer.def( bp::self -= bp::self );
+        Vector3_exposer.def( bp::self / bp::other&lt; double &gt;() );
+        Vector3_exposer.def( bp::self /= bp::other&lt; double &gt;() );
+        Vector3_exposer.def( bp::self &lt; bp::self );
+        Vector3_exposer.def( bp::self &lt;= bp::self );
+        { //::Wm3::Vector3&lt; double &gt;::operator=
+        
+            typedef Wm3::Vector3&lt; double &gt; exported_class_t;
+            typedef ::Wm3::Vector3&lt; double &gt; &amp; ( exported_class_t::*assign_function_type )( ::Wm3::Vector3&lt; double &gt; const &amp; ) ;
+            
+            Vector3_exposer.def( 
+                &quot;assign&quot;
+                , assign_function_type( &amp;::Wm3::Vector3&lt; double &gt;::operator= )
+                , ( bp::arg(&quot;rkV&quot;) )
+                , bp::return_self&lt; &gt;() );
+        
+        }
+        Vector3_exposer.def( bp::self == bp::self );
+        Vector3_exposer.def( bp::self &gt; bp::self );
+        Vector3_exposer.def( bp::self &gt;= bp::self );
+        Vector3_exposer.def_readonly( &quot;ONE&quot;, Wm3::Vector3&lt; double &gt;::ONE );
+        Vector3_exposer.def_readonly( &quot;UNIT_X&quot;, Wm3::Vector3&lt; double &gt;::UNIT_X );
+        Vector3_exposer.def_readonly( &quot;UNIT_Y&quot;, Wm3::Vector3&lt; double &gt;::UNIT_Y );
+        Vector3_exposer.def_readonly( &quot;UNIT_Z&quot;, Wm3::Vector3&lt; double &gt;::UNIT_Z );
+        Vector3_exposer.def_readonly( &quot;ZERO&quot;, Wm3::Vector3&lt; double &gt;::ZERO );
+        Vector3_exposer.staticmethod( &quot;ComputeExtremes&quot; );
+        Vector3_exposer.staticmethod( &quot;GenerateOrthonormalBasis&quot; );
+        Vector3_exposer.staticmethod( &quot;Orthonormalize&quot; );
+        Vector3_exposer.def( bp::self_ns::str( bp::self ) );
+        Vector3_exposer.def(&quot;__len__&quot;,&amp;::Vector3_len)   .staticmethod(&quot;__len__&quot;).def(&quot;__setitem__&quot;,&amp;::Vector3_set_item)   .def(&quot;__getitem__&quot;,&amp;::Vector3_get_item)   .def(&quot;__str__&quot;,&amp;::Vector3_str)   .def(&quot;__repr__&quot;,&amp;::Vector3_str);
+    }
+
+    { //::componentMaxVector
+    
+        typedef ::Wm3::Vector3r ( *componentMaxVector_function_type )( ::Wm3::Vector3r const &amp;,::Wm3::Vector3r const &amp; );
+        
+        bp::def( 
+            &quot;componentMaxVector&quot;
+            , componentMaxVector_function_type( &amp;::componentMaxVector )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+
+    { //::componentMaxVector
+    
+        typedef ::Wm3::Vector2r ( *componentMaxVector_function_type )( ::Wm3::Vector2r const &amp;,::Wm3::Vector2r const &amp; );
+        
+        bp::def( 
+            &quot;componentMaxVector&quot;
+            , componentMaxVector_function_type( &amp;::componentMaxVector )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+
+    { //::componentMinVector
+    
+        typedef ::Wm3::Vector3r ( *componentMinVector_function_type )( ::Wm3::Vector3r const &amp;,::Wm3::Vector3r const &amp; );
+        
+        bp::def( 
+            &quot;componentMinVector&quot;
+            , componentMinVector_function_type( &amp;::componentMinVector )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+
+    { //::componentMinVector
+    
+        typedef ::Wm3::Vector2r ( *componentMinVector_function_type )( ::Wm3::Vector2r const &amp;,::Wm3::Vector2r const &amp; );
+        
+        bp::def( 
+            &quot;componentMinVector&quot;
+            , componentMinVector_function_type( &amp;::componentMinVector )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+
+    { //::componentSum
+    
+        typedef ::Real ( *componentSum_function_type )( ::Wm3::Vector3r const &amp; );
+        
+        bp::def( 
+            &quot;componentSum&quot;
+            , componentSum_function_type( &amp;::componentSum )
+            , ( bp::arg(&quot;v&quot;) ) );
+    
+    }
+
+    { //::diagDiv
+    
+        typedef ::Wm3::Vector3r ( *diagDiv_function_type )( ::Wm3::Vector3r const &amp;,::Wm3::Vector3r const &amp; );
+        
+        bp::def( 
+            &quot;diagDiv&quot;
+            , diagDiv_function_type( &amp;::diagDiv )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+
+    { //::diagMult
+    
+        typedef ::Wm3::Vector3r ( *diagMult_function_type )( ::Wm3::Vector3r const &amp;,::Wm3::Vector3r const &amp; );
+        
+        bp::def( 
+            &quot;diagMult&quot;
+            , diagMult_function_type( &amp;::diagMult )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+
+    { //::diagMult
+    
+        typedef ::Wm3::Vector2r ( *diagMult_function_type )( ::Wm3::Vector2r const &amp;,::Wm3::Vector2r const &amp; );
+        
+        bp::def( 
+            &quot;diagMult&quot;
+            , diagMult_function_type( &amp;::diagMult )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+
+    { //::quaternionFromAxes
+    
+        typedef ::Wm3::Quaternionr ( *quaternionFromAxes_function_type )( ::Wm3::Vector3r const &amp;,::Wm3::Vector3r const &amp;,::Wm3::Vector3r const &amp; );
+        
+        bp::def( 
+            &quot;quaternionFromAxes&quot;
+            , quaternionFromAxes_function_type( &amp;::quaternionFromAxes )
+            , ( bp::arg(&quot;axis1&quot;), bp::arg(&quot;axis2&quot;), bp::arg(&quot;axis3&quot;) ) );
+    
+    }
+
+    { //::quaternionToAxes
+    
+        typedef void ( *quaternionToAxes_function_type )( ::Wm3::Quaternionr const &amp;,::Wm3::Vector3r &amp;,::Wm3::Vector3r &amp;,::Wm3::Vector3r &amp; );
+        
+        bp::def( 
+            &quot;quaternionToAxes&quot;
+            , quaternionToAxes_function_type( &amp;::quaternionToAxes )
+            , ( bp::arg(&quot;q&quot;), bp::arg(&quot;axis1&quot;), bp::arg(&quot;axis2&quot;), bp::arg(&quot;axis3&quot;) ) );
+    
+    }
+
+    { //::quaternionToEulerAngles
+    
+        typedef void ( *quaternionToEulerAngles_function_type )( ::Wm3::Quaternionr const &amp;,::Wm3::Vector3r &amp;,::Real );
+        
+        bp::def( 
+            &quot;quaternionToEulerAngles&quot;
+            , quaternionToEulerAngles_function_type( &amp;::quaternionToEulerAngles )
+            , ( bp::arg(&quot;q&quot;), bp::arg(&quot;eulerAngles&quot;), bp::arg(&quot;threshold&quot;)=9.999999974752427078783512115478515625e-7f ) );
+    
+    }
+
+    { //::quaterniontoGLMatrix
+    
+        typedef void ( *quaterniontoGLMatrix_function_type )( ::Wm3::Quaternionr const &amp;,::Real * );
+        
+        bp::def( 
+            &quot;quaterniontoGLMatrix&quot;
+            , quaterniontoGLMatrix_function_type( &amp;::quaterniontoGLMatrix )
+            , ( bp::arg(&quot;q&quot;), bp::arg(&quot;m&quot;) ) );
+    
+    }
+
+    custom_Vector3r_from_tuple();
+
+    { //::unitVectorsAngle
+    
+        typedef ::Real ( *unitVectorsAngle_function_type )( ::Wm3::Vector3r const &amp;,::Wm3::Vector3r const &amp; );
+        
+        bp::def( 
+            &quot;unitVectorsAngle&quot;
+            , unitVectorsAngle_function_type( &amp;::unitVectorsAngle )
+            , ( bp::arg(&quot;a&quot;), bp::arg(&quot;rkV&quot;) ) );
+    
+    }
+}

Copied: trunk/py/pack.py (from rev 1834, trunk/lib/py/pack.py)
===================================================================
--- trunk/lib/py/pack.py	2009-07-02 15:26:02 UTC (rev 1834)
+++ trunk/py/pack.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,249 @@
+# encoding: utf-8
+#
+import itertools,warnings
+from numpy import arange
+from math import sqrt
+from yade import utils
+
+# for now skip the import, but try in inGtsSurface constructor again, to give error if we really use it
+try:
+	import gts
+except ImportError: pass
+
+# make c++ predicates available in this module
+from _packPredicates import *
+# import SpherePack
+from _packSpheres import *
+
+class inGtsSurface_py(Predicate):
+	&quot;&quot;&quot;This class was re-implemented in c++, but should stay here to serve as reference for implementing
+	Predicates in pure python code. C++ allows us to play dirty tricks in GTS which are not accessible
+	through pygts itself; the performance penalty of pygts comes from fact that if constructs and destructs
+	bb tree for the surface at every invocation of gts.Point().is_inside(). That is cached in the c++ code,
+	provided that the surface is not manipulated with during lifetime of the object (user's responsibility).
+
+	---
+	
+	Predicate for GTS surfaces. Constructed using an already existing surfaces, which must be closed.
+
+		import gts
+		surf=gts.read(open('horse.gts'))
+		inGtsSurface(surf)
+
+	Note: padding is optionally supported by testing 6 points along the axes in the pad distance. This
+	must be enabled in the ctor by saying doSlowPad=True. If it is not enabled and pad is not zero,
+	warning is issued.
+	&quot;&quot;&quot;
+	def __init__(self,surf,noPad=False):
+		# call base class ctor; necessary for virtual methods to work as expected.
+		# see comments in _packPredicates.cpp for struct PredicateWrap.
+		super(inGtsSurface,self).__init__()
+		if not surf.is_closed(): raise RuntimeError(&quot;Surface for inGtsSurface predicate must be closed.&quot;)
+		self.surf=surf
+		self.noPad=noPad
+		inf=float('inf')
+		mn,mx=[inf,inf,inf],[-inf,-inf,-inf]
+		for v in surf.vertices():
+			c=v.coords()
+			mn,mx=[min(mn[i],c[i]) for i in 0,1,2],[max(mx[i],c[i]) for i in 0,1,2]
+		self.mn,self.mx=tuple(mn),tuple(mx)
+		import gts
+	def aabb(self): return self.mn,self.mx
+	def __call__(self,_pt,pad=0.):
+		p=gts.Point(*_pt)
+		if self.noPad:
+			if pad!=0: warnings.warn(&quot;Padding disabled in ctor, using 0 instead.&quot;)
+			return p.is_inside(self.surf)
+		pp=[gts.Point(_pt[0]-pad,_pt[1],_pt[2]),gts.Point(_pt[0]+pad,_pt[1],_pt[2]),gts.Point(_pt[0],_pt[1]-pad,_pt[2]),gts.Point(_pt[0],_pt[1]+pad,_pt[2]),gts.Point(_pt[0],_pt[1],_pt[2]-pad),gts.Point(_pt[0],_pt[1],_pt[2]+pad)]
+		return p.is_inside(self.surf) and pp[0].is_inside(self.surf) and pp[1].is_inside(self.surf) and pp[2].is_inside(self.surf) and pp[3].is_inside(self.surf) and pp[4].is_inside(self.surf) and pp[5].is_inside(self.surf)
+
+class inSpace(Predicate):
+	&quot;&quot;&quot;Predicate returning True for any points, with infinite bounding box.&quot;&quot;&quot;
+	def aabb(self):
+		inf=float('inf'); return [-inf,-inf,-inf],[inf,inf,inf]
+	def __call__(self,pt): return True
+
+#####
+## surface construction and manipulation
+#####
+
+def gtsSurface2Facets(surf,**kw):
+	&quot;&quot;&quot;Construct facets from given GTS surface. **kw is passed to utils.facet.&quot;&quot;&quot;
+	return [utils.facet([v.coords() for v in face.vertices()],**kw) for face in surf]
+
+def sweptPolylines2gtsSurface(pts,threshold=0,capStart=False,capEnd=False):
+	&quot;&quot;&quot;Create swept suface (as GTS triangulation) given same-length sequences of points (as 3-tuples).
+	If threshold is given (&gt;0), gts.Surface().cleanup(threshold) will be called before returning, which
+	removes vertices mutually closer than threshold. Can be used to create closed swept surface (revolved), as
+	we don't check for coincident vertices otherwise.
+	&quot;&quot;&quot;
+	if not len(set([len(pts1) for pts1 in pts]))==1: raise RuntimeError(&quot;Polylines must be all of the same length!&quot;)
+	vtxs=[[gts.Vertex(x,y,z) for x,y,z in pts1] for pts1 in pts]
+	sectEdges=[[gts.Edge(vtx[i],vtx[i+1]) for i in xrange(0,len(vtx)-1)] for vtx in vtxs]
+	interSectEdges=[[] for i in range(0,len(vtxs)-1)]
+	for i in range(0,len(vtxs)-1):
+		for j in range(0,len(vtxs[i])):
+			interSectEdges[i].append(gts.Edge(vtxs[i][j],vtxs[i+1][j]))
+			if j&lt;len(vtxs[i])-1: interSectEdges[i].append(gts.Edge(vtxs[i][j],vtxs[i+1][j+1]))
+	surf=gts.Surface()
+	for i in range(0,len(vtxs)-1):
+		for j in range(0,len(vtxs[i])-1):
+			surf.add(gts.Face(interSectEdges[i][2*j+1],sectEdges[i+1][j],interSectEdges[i][2*j]))
+			surf.add(gts.Face(sectEdges[i][j],interSectEdges[i][2*j+2],interSectEdges[i][2*j+1]))
+	def doCap(vtx,edg,start):
+		ret=[]
+		eFan=[edg[0]]+[gts.Edge(vtx[i],vtx[0]) for i in range(2,len(vtx))]
+		for i in range(1,len(edg)):
+			ret+=[gts.Face(eFan[i-1],eFan[i],edg[i]) if start else gts.Face(eFan[i-1],edg[i],eFan[i])]
+		return ret
+	caps=[]
+	if capStart: caps+=doCap(vtxs[0],sectEdges[0],start=True)
+	if capEnd: caps+=doCap(vtxs[-1],sectEdges[-1],start=False)
+	for cap in caps: surf.add(cap)
+	if threshold&gt;0: surf.cleanup(threshold)
+	return surf
+
+import euclid
+
+def revolutionSurfaceMeridians(sects,angles,origin=euclid.Vector3(0,0,0),orientation=euclid.Quaternion()):
+	&quot;&quot;&quot;Revolution surface given sequences of 2d points and sequence of corresponding angles,
+	returning sequences of 3d points representing meridian sections of the revolution surface.
+	The 2d sections are turned around z-axis, but they can be transformed
+	using the origin and orientation arguments to give arbitrary orientation.&quot;&quot;&quot;
+	import math
+	def toGlobal(x,y,z):
+		return tuple(origin+orientation*(euclid.Vector3(x,y,z)))
+	return [[toGlobal(x2d*math.cos(angles[i]),x2d*math.sin(angles[i]),y2d) for x2d,y2d in sects[i]] for i in range(0,len(sects))]
+
+########
+## packing generators
+########
+
+
+def regularOrtho(predicate,radius,gap,**kw):
+	&quot;&quot;&quot;Return set of spheres in regular orthogonal grid, clipped inside solid given by predicate.
+	Created spheres will have given radius and will be separated by gap space.&quot;&quot;&quot;
+	ret=[]
+	mn,mx=predicate.aabb()
+	if(max([mx[i]-mn[i] for i in 0,1,2])==float('inf')): raise ValueError(&quot;AABB of the predicate must not be infinite (didn't you use union | instead of intersection &amp; for unbounded predicate such as notInNotch?&quot;);
+	xx,yy,zz=[arange(mn[i]+radius,mx[i]-radius,2*radius+gap) for i in 0,1,2]
+	for xyz in itertools.product(xx,yy,zz):
+		if predicate(xyz,radius): ret+=[utils.sphere(xyz,radius=radius,**kw)]
+	return ret
+
+def regularHexa(predicate,radius,gap,**kw):
+	&quot;&quot;&quot;Return set of spheres in regular hexagonal grid, clipped inside solid given by predicate.
+	Created spheres will have given radius and will be separated by gap space.&quot;&quot;&quot;
+	ret=[]
+	a=2*radius+gap
+	h=a*sqrt(3)/2.
+	mn,mx=predicate.aabb()
+	dim=[mx[i]-mn[i] for i in 0,1,2]
+	if(max(dim)==float('inf')): raise ValueError(&quot;AABB of the predicate must not be infinite (didn't you use union | instead of intersection &amp; for unbounded predicate such as notInNotch?&quot;);
+	ii,jj,kk=[range(0,int(dim[0]/a)+1),range(0,int(dim[1]/h)+1),range(0,int(dim[2]/h)+1)]
+	for i,j,k in itertools.product(ii,jj,kk):
+		x,y,z=mn[0]+radius+i*a,mn[1]+radius+j*h,mn[2]+radius+k*h
+		if j%2==0: x+= a/2. if k%2==0 else -a/2.
+		if k%2!=0: x+=a/2.; y+=h/2.
+		if predicate((x,y,z),radius): ret+=[utils.sphere((x,y,z),radius=radius,**kw)]
+	return ret
+
+def filterSpherePack(predicate,spherePack,**kw):
+	&quot;&quot;&quot;Using given SpherePack instance, return spheres the satisfy predicate.
+	The packing will be recentered to match the predicate and warning is given if the predicate
+	is larger than the packing.&quot;&quot;&quot;
+	mn,mx=predicate.aabb()
+	dimP,centP=predicate.dim(),predicate.center()
+	dimS,centS=spherePack.dim(),spherePack.center()
+	if dimP[0]&gt;dimS[0] or dimP[1]&gt;dimS[1] or dimP[2]&gt;dimS[2]: warnings.warn(&quot;Packing's dimension (%s) doesn't fully contain dimension of the predicate (%s).&quot;%(dimS,dimP))
+	spherePack.translate(centP-centS)
+	ret=[]
+	for s in spherePack:
+		if predicate(s[0],s[1]): ret+=[utils.sphere(s[0],radius=s[1],**kw)]
+	return ret
+
+def triaxialPack(predicate,radius,dim=None,cropLayers=0,radiusStDev=0.,assumedFinalDensity=.6,memoizeDb=None,**kw):
+	&quot;&quot;&quot;Generator of triaxial packing, using TriaxialTest. Radius is radius of spheres, radiusStDev is its standard deviation.
+	By default, all spheres are of the same radius. cropLayers is how many layers of spheres will be added to the computed
+	dimension of the box so that there no (or not so much, at least) boundary effects at the boundaries of the predicate.
+	assumedFinalDensity should be OK as it is, it is used to compute necessary number of spheres for the packing.
+
+	The memoizeDb parameter can be passed a file (existent or nonexistent). If the file exists, it will be first looked
+	for a suitable packing that was previously saved already (known as memoization). Saved packings will be scaled to
+	requested sphere radius; those that are smaller are distcarded as well as those with different radiusStDev. From
+	the remaining ones, the one with the least spheres will be loaded and returned. If no suitable packing is found, it
+	is generated as usually, but saved into the database for later use.
+
+	O.switchWorld() magic is used to have clean simulation for TriaxialTest without deleting the original simulation.
+	This function therefore should never run in parallel with some code accessing your simulation.
+	&quot;&quot;&quot;
+	import sqlite3, os.path, cPickle, time, sys
+	from yade import log
+	from math import pi
+	if not dim: dim=predicate.dim()
+	if max(dim)==float('inf'): raise RuntimeError(&quot;Infinite predicate and no dimension of packing requested.&quot;)
+	fullDim=tuple([dim[i]+4*cropLayers*radius for i in 0,1,2])
+	if(memoizeDb and os.path.exists(memoizeDb)):
+		# find suitable packing and return it directly
+		conn=sqlite3.connect(memoizeDb); c=conn.cursor();
+		c.execute('select radius,radiusStDev,dimx,dimy,dimz,N,timestamp from packings order by N')
+		for row in c:
+			R,rDev,X,Y,Z,NN,timestamp=row[0:7]; scale=radius/R
+			rDev*=scale; X*=scale; Y*=scale; Z*=scale
+			if (radiusStDev==0 and rDev!=0) or (radiusStDev==0 and rDev!=0) or (radiusStDev!=0 and abs((rDev-radiusStDev)/radiusStDev)&gt;1e-2): continue # not suitable, standard deviation differs too much
+			if X&lt;fullDim[0] or Y&lt;fullDim[1] or Z&lt;fullDim[2]: continue # not suitable, not large enough
+			print &quot;Found suitable packing in database (radius=%g&#177;%g,N=%g,dim=%g&#215;%g&#215;%g,scale=%g), created %s&quot;%(R,rDev,NN,X,Y,Z,scale,time.asctime(time.gmtime(timestamp)))
+			c.execute('select pack from packings where timestamp=?',(timestamp,))
+			sp=SpherePack(cPickle.loads(str(c.fetchone()[0])))
+			sp.scale(scale)
+			return filterSpherePack(predicate,sp,**kw)
+		print &quot;No suitable packing in database found, running triaxial&quot;
+		sys.stdout.flush()
+	V=(4/3)*pi*radius**3; N=assumedFinalDensity*fullDim[0]*fullDim[1]*fullDim[2]/V;
+	##
+	O.switchWorld()
+	##
+	TriaxialTest(
+		numberOfGrains=int(N),
+		radiusMean=radius,
+		# this is just size ratio if radiusMean is specified
+		# if you comment out the line above, it will be the corner (before compaction) and radiusMean will be set accordingly
+		upperCorner=fullDim,
+		radiusStdDev=radiusStDev,
+		## no need to touch any the following, I think
+		noFiles=True,
+		lowerCorner=[0,0,0],
+		sigmaIsoCompaction=1e7,
+		sigmaLateralConfinement=1e3,
+		StabilityCriterion=.05,
+		strainRate=.2,
+		fast=True,
+		thickness=-1, # will be set to sphere radius if negative
+		maxWallVelocity=.1,
+		wallOversizeFactor=1.5,
+		autoUnload=True, # unload after isotropic compaction
+		autoCompressionActivation=False # stop once unloaded
+	).load()
+	log.setLevel('TriaxialCompressionEngine',log.WARN)
+	O.run(); O.wait()
+	sp=SpherePack(); sp.fromSimulation()
+	##
+	O.switchWorld()
+	##
+	if(memoizeDb):
+		if os.path.exists(memoizeDb):
+			conn=sqlite3.connect(memoizeDb)
+		else:
+			conn=sqlite3.connect(memoizeDb)
+			c=conn.cursor()
+			c.execute('create table packings (radius real, radiusStDev real, dimx real, dimy real, dimz real, N integer, timestamp real, pack blob)')
+		c=conn.cursor()
+		packBlob=buffer(cPickle.dumps(sp.toList(),cPickle.HIGHEST_PROTOCOL))
+		c.execute('insert into packings values (?,?,?,?,?,?,?,?)',(radius,radiusStDev,fullDim[0],fullDim[1],fullDim[2],len(sp),time.time(),packBlob,))
+		c.close()
+		conn.commit()
+		print &quot;Packing saved to the database&quot;,memoizeDb
+	return filterSpherePack(predicate,sp,**kw)
+
+
+

Copied: trunk/py/plot.py (from rev 1834, trunk/lib/py/plot.py)

Copied: trunk/py/timing.py (from rev 1834, trunk/lib/py/timing.py)

Copied: trunk/py/utils.py (from rev 1834, trunk/lib/py/utils.py)
===================================================================
--- trunk/lib/py/utils.py	2009-07-02 15:26:02 UTC (rev 1834)
+++ trunk/py/utils.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,454 @@
+# encoding: utf-8
+#
+# utility functions for yade
+#
+# 2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
+
+import math,random
+from yade.wrapper import *
+from miniWm3Wrap import *
+try: # use psyco if available
+	import psyco
+	psyco.full()
+except ImportError: pass
+
+# c++ implementations for performance reasons
+from yade._utils import *
+
+def saveVars(mark='',loadNow=False,**kw):
+	&quot;&quot;&quot;Save passed variables into the simulation so that it can be recovered when the simulation is loaded again.
+
+	For example, variables a=5, b=66 and c=7.5e-4 are defined. To save those, use
+
+	 utils.saveVars(a=a,b=b,c=c)
+
+	those variables will be save in the .xml file, when the simulation itself is saved. To recover those variables once
+	the .xml is loaded again, use
+
+	 utils.loadVars(mark)
+
+	and they will be defined in the __builtin__ namespace (i.e. available from anywhere in the python code).
+
+	If loadParam==True, variables will be loaded immediately after saving. That effectively makes **kw available in builtin namespace.
+	&quot;&quot;&quot;
+	import cPickle
+	Omega().tags['pickledPythonVariablesDictionary'+mark]=cPickle.dumps(kw)
+	if loadNow: loadVars(mark)
+
+def loadVars(mark=None):
+	&quot;&quot;&quot;Load variables from saveVars, which are saved inside the simulation.
+	If mark==None, all save variables are loaded. Otherwise only those with
+	the mark passed.&quot;&quot;&quot;
+	import cPickle
+	import __builtin__
+	if mark!=None:
+		d=cPickle.loads(Omega().tags['pickledPythonVariablesDictionary'+mark])
+		for k in d: __builtin__.__dict__[k]=d[k]
+	else: # load everything one by one
+		for m in Omega().tags.keys():
+			if m.startswith('pickledPythonVariablesDictionary'):
+				loadVars(m[len('pickledPythonVariableDictionary')+1:])
+
+
+def SpherePWaveTimeStep(radius,density,young):
+	&quot;&quot;&quot;Compute P-wave critical timestep for a single sphere.
+	If you want to compute minimum critical timestep for all spheres in the simulation, use utils.PWaveTimeStep() instead.&quot;&quot;&quot;
+	from math import sqrt
+	return radius/sqrt(young/density)
+
+def randomColor(): return [random.random(),random.random(),random.random()]
+
+def typedEngine(name): return [e for e in Omega().engines if e.name==name][0]
+
+def downCast(obj,newClassName):
+	&quot;&quot;&quot;Cast given object to class deriving from the same yade root class and copy all parameters from given object.
+	Obj should be up in the inheritance tree, otherwise some attributes may not be defined in the new class.&quot;&quot;&quot;
+	return obj.__class__(newClassName,dict([ (key,obj[key]) for key in obj.keys() ]))
+
+bodiesPhysDefaults={'young':30e9,'poisson':.3,'frictionAngle':.5236}
+
+def sphere(center,radius,dynamic=True,wire=False,color=None,density=1,physParamsClass='BodyMacroParameters',**physParamsAttr):
+	&quot;&quot;&quot;Create default sphere, with given parameters. Physical properties such as mass and inertia are calculated automatically.&quot;&quot;&quot;
+	s=Body()
+	if not color: color=randomColor()
+	pp=bodiesPhysDefaults.copy(); pp.update(physParamsAttr);
+	s.shape=GeometricalModel('Sphere',{'radius':radius,'diffuseColor':color,'wire':wire})
+	s.mold=InteractingGeometry('InteractingSphere',{'radius':radius,'diffuseColor':color})
+	V=(4./3)*math.pi*radius**3
+	inert=(2./5.)*V*density*radius**2
+	pp.update({'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':V*density,'inertia':[inert,inert,inert]})
+	s.phys=PhysicalParameters(physParamsClass,pp)
+	s.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
+	s['isDynamic']=dynamic
+	return s
+
+def box(center,extents,orientation=[1,0,0,0],dynamic=True,wire=False,color=None,density=1,physParamsClass='BodyMacroParameters',**physParamsAttr):
+	&quot;&quot;&quot;Create default box (cuboid), with given parameters. Physical properties such as mass and inertia are calculated automatically.&quot;&quot;&quot;
+	b=Body()
+	if not color: color=randomColor()
+	pp=bodiesPhysDefaults.copy(); pp.update(physParamsAttr);
+	b.shape=GeometricalModel('Box',{'extents':extents,'diffuseColor':color,'wire':wire})
+	b.mold=InteractingGeometry('InteractingBox',{'extents':extents,'diffuseColor':color})
+	mass=8*extents[0]*extents[1]*extents[2]*density
+	V=extents[0]*extents[1]*extents[2]
+	pp.update({'se3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'refSe3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'mass':V*density,'inertia':[mass*4*(extents[1]**2+extents[2]**2),mass*4*(extents[0]**2+extents[2]**2),mass*4*(extents[0]**2+extents[1]**2)]})
+	b.phys=PhysicalParameters(physParamsClass,pp)
+	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
+	b['isDynamic']=dynamic
+	return b
+
+def facet(vertices,dynamic=False,wire=True,color=None,density=1,physParamsClass='BodyMacroParameters',**physParamsAttr):
+	&quot;&quot;&quot;Create default facet with given parameters. Vertices are given as sequence of 3 3-tuple and they, all in global coordinates.&quot;&quot;&quot;
+	b=Body()
+	if not color: color=randomColor()
+	pp=bodiesPhysDefaults.copy(); pp.update(physParamsAttr);
+	b.shape=GeometricalModel('Facet',{'diffuseColor':color,'wire':wire})
+	b.mold=InteractingGeometry('InteractingFacet',{'diffuseColor':color})
+	center=inscribedCircleCenter(vertices[0],vertices[1],vertices[2])
+	vertices=Vector3(vertices[0])-center,Vector3(vertices[1])-center,Vector3(vertices[2])-center
+	vStr='['+' '.join(['{%g %g %g}'%(v[0],v[1],v[2]) for v in vertices])+']'
+	b.shape.setRaw('vertices',vStr)
+	b.mold.setRaw('vertices',vStr)
+	pp.update({'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'inertia':[0,0,0]})
+	b.phys=PhysicalParameters(physParamsClass,pp)
+	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
+	b['isDynamic']=dynamic
+	b.mold.postProcessAttributes()
+	return b
+
+def alignedFacetBox(center,extents,wallMask=63,**kw):
+	&quot;&quot;&quot;Create axis-aligned box composed of facets, with given center and extents. wallMask determines which walls will be created,
+	in the order -x (1), +x (2), -y (4), +y (8), -z (16), +z (32). The numbers are ANDed; the default 63 means to create all walls.
+	Remaining **kw arguments are passed to utils.facet. The facets are oriented outwards from the box.&quot;&quot;&quot;
+	mn,mx=[center[i]-extents[i] for i in 0,1,2],[center[i]+extents[i] for i in 0,1,2]
+	def doWall(a,b,c,d):
+		return [facet((a,b,c),**kw),facet((a,c,d),**kw)]
+	ret=[]
+	A,B,C,D=(mn[0],mn[1],mn[2]),(mx[0],mn[1],mn[2]),(mx[0],mx[1],mn[2]),(mn[0],mx[1],mn[2])
+	E,F,G,H=(mn[0],mn[1],mx[2]),(mx[0],mn[1],mx[2]),(mx[0],mx[1],mx[2]),(mn[0],mx[1],mx[2])
+	if wallMask&amp;1:  ret+=doWall(A,D,H,E)
+	if wallMask&amp;2:  ret+=doWall(B,C,G,F)
+	if wallMask&amp;4:  ret+=doWall(A,B,F,E)
+	if wallMask&amp;8:  ret+=doWall(D,H,G,C)
+	if wallMask&amp;16: ret+=doWall(A,D,C,B)
+	if wallMask&amp;32: ret+=doWall(E,F,G,H)
+	return ret
+
+
+def aabbWalls(extrema=None,thickness=None,oversizeFactor=1.5,**kw):
+	&quot;&quot;&quot;return 6 walls that will wrap existing packing;
+	extrema are extremal points of the AABB of the packing (will be calculated if not specified)
+	thickness is wall thickness (will be 1/10 of the X-dimension if not specified)
+	Walls will be enlarged in their plane by oversizeFactor.
+	returns list of 6 wall Bodies enclosing the packing, in the order minX,maxX,minY,maxY,minZ,maxZ.
+	&quot;&quot;&quot;
+	walls=[]
+	if not extrema: extrema=aabbExtrema()
+	if not thickness: thickness=(extrema[1][0]-extrema[0][0])/10.
+	for axis in [0,1,2]:
+		mi,ma=extrema
+		center=[(mi[i]+ma[i])/2. for i in range(3)]
+		extents=[.5*oversizeFactor*(ma[i]-mi[i]) for i in range(3)]
+		extents[axis]=thickness/2.
+		for j in [0,1]:
+			center[axis]=extrema[j][axis]+(j-.5)*thickness
+			walls.append(box(center=center,extents=extents,dynamic=False,**kw))
+			walls[-1].shape['wire']=True
+	return walls
+
+
+def aabbDim(cutoff=0.,centers=False):
+	&quot;&quot;&quot;return dimensions of the bounding box, optionally cut.&quot;&quot;&quot;
+	a=aabbExtrema(cutoff,centers)
+	return (a[1][0]-a[0][0],a[1][1]-a[0][1],a[1][2]-a[0][2])
+
+def aabbExtrema2d(pts):
+	&quot;&quot;&quot;return 2d bounding box for a sequence of 2-tuples&quot;&quot;&quot;
+	inf=float('inf')
+	min,max=[inf,inf],[-inf,-inf]
+	for pt in pts:
+		if pt[0]&lt;min[0]: min[0]=pt[0]
+		elif pt[0]&gt;max[0]: max[0]=pt[0]
+		if pt[1]&lt;min[1]: min[1]=pt[1]
+		elif pt[1]&gt;max[1]: max[1]=pt[1]
+	return tuple(min),tuple(max)
+
+def perpendicularArea(axis):
+	&quot;&quot;&quot;return area perpendicular to given axis (0=x,1=y,2=z) generated by bodies
+	for which the function consider returns True (defaults to returning True always)
+	and which is of the type &quot;Sphere&quot;
+	&quot;&quot;&quot;
+	ext=aabbExtrema()
+	other=((axis+1)%3,(axis+2)%3)
+	return (ext[1][other[0]]-ext[0][other[0]])*(ext[1][other[1]]-ext[0][other[1]])
+
+def fractionalBox(fraction=1.,minMax=None):
+	&quot;&quot;&quot;retrurn (min,max) that is the original minMax box (or aabb of the whole simulation if not specified)
+	linearly scaled around its center to the fraction factor&quot;&quot;&quot;
+	if not minMax: minMax=aabbExtrema()
+	half=[.5*(minMax[1][i]-minMax[0][i]) for i in [0,1,2]]
+	return (tuple([minMax[0][i]+(1-fraction)*half[i] for i in [0,1,2]]),tuple([minMax[1][i]-(1-fraction)*half[i] for i in [0,1,2]]))
+
+
+def randomizeColors(onShapes=True,onMolds=False,onlyDynamic=False):
+	&quot;&quot;&quot;Assign random colors to shape's (GeometricalModel) and/or mold's (InteractingGeometry) diffuseColor.
+	
+	onShapes and onMolds turn on/off operating on the respective colors.
+	If onlyDynamic is true, only dynamic bodies will have the color changed.
+	&quot;&quot;&quot;
+	if not onShapes and not onMolds: return
+	o=Omega()
+	for b in o.bodies:
+		color=(random.random(),random.random(),random.random())
+		if onShapes and (b['isDynamic'] or not onlyDynamic): b.shape['diffuseColor']=color
+		if onMolds  and (b['isDynamic'] or not onlyDynamic): b.mold['diffuseColor']=color
+
+
+def spheresFromFile(filename,scale=1.,wenjieFormat=False,**kw):
+	&quot;&quot;&quot;Load sphere coordinates from file, create spheres, insert them to the simulation.
+
+	filename is the file holding ASCII numbers (at least 4 colums that hold x_center, y_center, z_center, radius).
+	All remaining arguments are passed the the yade.utils.sphere function that creates the bodies.
+
+	wenjieFormat will skip all lines that have exactly 5 numbers and where the 4th one is exactly 1.0 -
+	this was used by a fellow developer called Wenjie to mark box elements.
+	
+	Returns list of body ids that were inserted into simulation.&quot;&quot;&quot;
+	o=Omega()
+	ret=[]
+	for l in open(filename):
+		ss=[float(i) for i in l.split()]
+		if wenjieFormat and len(ss)==5 and ss[4]==1.0: continue
+		id=o.bodies.append(sphere([scale*ss[0],scale*ss[1],scale*ss[2]],scale*ss[3],**kw))
+		ret.append(id)
+	return ret
+
+def spheresToFile(filename,consider=lambda id: True):
+	&quot;&quot;&quot;Save sphere coordinates into ASCII file; the format of the line is: x y z r.
+	Non-spherical bodies are silently skipped.
+	
+	Returns number of spheres that were written.&quot;&quot;&quot;
+	o=Omega()
+	out=open(filename,'w')
+	count=0
+	for b in o.bodies:
+		if not b.shape or not b.shape.name=='Sphere' or not consider(b.id): continue
+		out.write('%g\t%g\t%g\t%g\n'%(b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius']))
+		count+=1
+	out.close()
+	return count
+
+def avgNumInteractions(cutoff=0.):
+	nums,counts=bodyNumInteractionsHistogram(aabbExtrema(cutoff))
+	return sum([nums[i]*counts[i] for i in range(len(nums))])/(1.*sum(counts))
+
+def plotNumInteractionsHistogram(cutoff=0.):
+	nums,counts=bodyNumInteractionsHistogram(aabbExtrema(cutoff))
+	import pylab
+	pylab.bar(nums,counts)
+	pylab.title('Number of interactions histogram, average %g (cutoff=%g)'%(avgNumInteractions(cutoff),cutoff))
+	pylab.xlabel('Number of interactions')
+	pylab.ylabel('Body count')
+	pylab.show()
+
+def plotDirections(aabb=(),mask=0,bins=20,numHist=True):
+	&quot;&quot;&quot;Plot 3 histograms for distribution of interaction directions, in yz,xz and xy planes and
+	(optional but default) histogram of number of interactions per body.&quot;&quot;&quot;
+	import pylab,math
+	from yade import utils
+	for axis in [0,1,2]:
+		d=utils.interactionAnglesHistogram(axis,mask=mask,bins=bins,aabb=aabb)
+		fc=[0,0,0]; fc[axis]=1.
+		subp=pylab.subplot(220+axis+1,polar=True);
+		# 1.1 makes small gaps between values (but the column is a bit decentered)
+		pylab.bar(d[0],d[1],width=math.pi/(1.1*bins),fc=fc,alpha=.7,label=['yz','xz','xy'][axis])
+		#pylab.title(['yz','xz','xy'][axis]+' plane')
+		pylab.text(.5,.25,['yz','xz','xy'][axis],horizontalalignment='center',verticalalignment='center',transform=subp.transAxes,fontsize='xx-large')
+	if numHist:
+		pylab.subplot(224,polar=False)
+		nums,counts=utils.bodyNumInteractionsHistogram(aabb if len(aabb)&gt;0 else utils.aabbExtrema())
+		avg=sum([nums[i]*counts[i] for i in range(len(nums))])/(1.*sum(counts))
+		pylab.bar(nums,counts,fc=[1,1,0],alpha=.7,align='center')
+		pylab.xlabel('Interactions per body (avg. %g)'%avg)
+		pylab.axvline(x=avg,linewidth=3,color='r')
+		pylab.ylabel('Body count')
+	pylab.show()
+
+
+def import_stl_geometry(file, young=30e9,poisson=.3,color=[0,1,0],frictionAngle=0.5236,wire=True,noBoundingVolume=False,noInteractingGeometry=False,physParamsClass='BodyMacroParameters',physParamsAttr={}):
+	&quot;&quot;&quot; Import geometry from stl file, create facets and return list of their ids.&quot;&quot;&quot;
+	imp = STLImporter()
+	imp.wire = wire
+	imp.open(file)
+	o=Omega()
+	begin=len(o.bodies)
+	for i in xrange(imp.number_of_facets):
+		b=Body()
+		b['isDynamic']=False
+		pp={'se3':[0,0,0,1,0,0,0],'young':young,'poisson':poisson,'frictionAngle':frictionAngle}
+		pp.update(physParamsAttr)
+		b.phys=PhysicalParameters(physParamsClass)
+		for k in [attr for attr in pp.keys() if attr in b.phys.keys()]:
+			b.phys[k]=pp[k]
+		if not noBoundingVolume:
+			b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
+		o.bodies.append(b)
+	imp.import_geometry(o.bodies,begin,noInteractingGeometry)
+	imported=range(begin,begin+imp.number_of_facets)
+	for i in imported:
+		if not noInteractingGeometry:
+			o.bodies[i].mold.postProcessAttributes()
+		o.bodies[i].shape['diffuseColor']=color
+	return imported
+
+def encodeVideoFromFrames(wildcard,out,renameNotOverwrite=True,fps=24):
+	import pygst,sys,gobject,os
+	pygst.require(&quot;0.10&quot;)
+	import gst
+	if renameNotOverwrite and os.path.exists(out):
+		i=0;
+		while(os.path.exists(out+&quot;~%d&quot;%i)): i+=1
+		os.rename(out,out+&quot;~%d&quot;%i); print &quot;Output file `%s' already existed, old file renamed to `%s'&quot;%(out,out+&quot;~%d&quot;%i)
+	print &quot;Encoding video from %s to %s&quot;%(wildcard,out)
+	pipeline=gst.parse_launch('multifilesrc location=&quot;%s&quot; index=0 caps=&quot;image/png,framerate=\(fraction\)%d/1&quot; ! pngdec ! ffmpegcolorspace ! theoraenc sharpness=2 quality=63 ! oggmux ! filesink location=&quot;%s&quot;'%(wildcard,fps,out))
+	bus=pipeline.get_bus()
+	bus.add_signal_watch()
+	mainloop=gobject.MainLoop();
+	bus.connect(&quot;message::eos&quot;,lambda bus,msg: mainloop.quit())
+	pipeline.set_state(gst.STATE_PLAYING)
+	mainloop.run()
+	pipeline.set_state(gst.STATE_NULL); pipeline.get_state()
+
+def readParamsFromTable(tableFileLine=None,noTableOk=False,unknownOk=False,**kw):
+	&quot;&quot;&quot;
+	Read parameters from a file and assign them to __builtin__ variables.
+
+	tableFile is a text file (with one value per blank-separated columns)
+	tableLine is number of line where to get the values from
+
+		The format of the file is as follows (commens starting with # and empty lines allowed)
+		
+		name1 name2 &#8230; # 0th line
+		val1  val2  &#8230; # 1st line
+		val2  val2  &#8230; # 2nd line
+		&#8230;
+
+	The name `description' is special and is assigned to Omega().tags['description']
+
+	assigns Omega().tags['params']=&quot;name1=val1,name2=val2,&#8230;&quot;
+	
+	assigns Omega().tags['defaultParams']=&quot;unassignedName1=defaultValue1,&#8230;&quot;
+
+	saves all parameters (default as well as settable) using saveVars('table')
+
+	return value is the number of assigned parameters.
+	&quot;&quot;&quot;
+	o=Omega()
+	tagsParams=[]
+	dictDefaults,dictParams={},{}
+	import os, __builtin__
+	if not tableFileLine and not os.environ.has_key('PARAM_TABLE'):
+		if not noTableOk: raise EnvironmentError(&quot;PARAM_TABLE is not defined in the environment&quot;)
+		o.tags['line']='l!'
+	else:
+		if not tableFileLine: tableFileLine=os.environ['PARAM_TABLE']
+		env=tableFileLine.split(':')
+		tableDesc=None
+		tableFile,tableLine=env[0],env[1]
+		if len(env)&gt;2: tableDesc=env[3]
+		o.tags['line']='l'+tableLine
+		ll=[l.split('#')[0] for l in ['']+open(tableFile).readlines()]; names=ll[1].split(); values=ll[int(tableLine)].split()
+		assert(len(names)==len(values))
+		if 'description' in names: O.tags['description']=values[names.index('description')]
+		else:
+			bangCols=[i for i,h in enumerate(names) if h[-1]=='!']
+			if len(bangCols)==0: bangCols=range(len(names))
+			for i in range(len(names)):
+				if names[i][-1]=='!': names[i]=names[i][:-1] # strip trailing !
+			O.tags['description']=','.join(names[col]+'='+('%g'%values[col] if isinstance(values[col],float) else str(values[col])) for col in bangCols).replace(&quot;'&quot;,'').replace('&quot;','')
+		for i in range(len(names)):
+			if names[i]=='description': continue
+			if names[i] not in kw.keys():
+				if (not unknownOk) and names[i][0]!='!': raise NameError(&quot;Parameter `%s' has no default value assigned&quot;%names[i])
+			else: kw.pop(names[i])
+			if names[i][0]!='!':
+				exec('%s=%s'%(names[i],values[i])) in __builtins__; tagsParams+=['%s=%s'%(names[i],values[i])]; dictParams[names[i]]=values[i]
+	defaults=[]
+	for k in kw.keys():
+		exec(&quot;%s=%s&quot;%(k,repr(kw[k]))) in __builtins__
+		defaults+=[&quot;%s=%s&quot;%(k,kw[k])]; dictDefaults[k]=kw[k]
+	o.tags['defaultParams']=&quot;,&quot;.join(defaults)
+	o.tags['params']=&quot;,&quot;.join(tagsParams)
+	dictParams.update(dictDefaults); saveVars('table',**dictParams)
+	return len(tagsParams)
+
+def ColorizedVelocityFilter(isFilterActivated=True,autoScale=True,minValue=0,maxValue=0,posX=0,posY=0.2,width=0.05,height=0.5,title='Velocity, m/s'):
+    f = DeusExMachina('ColorizedVelocityFilter',{'isFilterActivated':isFilterActivated,'autoScale':autoScale,'minValue':minValue,'maxValue':maxValue,'posX':posX,'posY':posY,'width':width,'height':height,'title':title})
+    O.engines+=[f]
+    return f
+
+def ColorizedTimeFilter(point=[0,0,0],normal=[0,1,0],isFilterActivated=True,autoScale=True,minValue=0,maxValue=0,posX=0,posY=0.2,width=0.05,height=0.5,title='Time, m/s'):
+    f = DeusExMachina('ColorizedTimeFilter',{'point':point,'normal':normal,'isFilterActivated':isFilterActivated,'autoScale':autoScale,'minValue':minValue,'maxValue':maxValue,'posX':posX,'posY':posY,'width':width,'height':height,'title':title})
+    O.engines+=[f]
+    return f
+
+def PythonRunnerFilter(command='pass',isFilterActivated=True):
+    f = DeusExMachina('PythonRunnerFilter',{'command':command,'isFilterActivated':isFilterActivated})
+    O.engines+=[f]
+    return f
+
+def replaceCollider(colliderEngine):
+	&quot;&quot;&quot;Replaces collider (Collider) engine with the engine supplied. Raises error if no collider is in engines.&quot;&quot;&quot;
+	colliderIdx=-1
+	for i,e in enumerate(O.engines):
+		if O.isChildClassOf(e.name,&quot;Collider&quot;):
+			colliderIdx=i
+			break
+	if colliderIdx&lt;0: raise RuntimeError(&quot;No Collider found within O.engines.&quot;)
+	O.engines=O.engines[:colliderIdx]+[colliderEngine]+O.engines[colliderIdx+1:]
+
+
+def procStatus(name):
+	import os
+	for l in open('/proc/%d/status'%os.getpid()):
+		if l.split(':')[0]==name: return l
+	raise &quot;No such line in /proc/[pid]/status: &quot;+name
+def vmData():
+	l=procStatus('VmData'); ll=l.split(); assert(ll[2]=='kB')
+	return int(ll[1])
+
+def spheresFromFileUniaxial(filename,areaSections=10,**kw):
+	&quot;&quot;&quot;Load spheres from file, but do some additional work useful for uniaxial test:
+	
+	1. Find the dimensions that is the longest (uniaxial loading axis)
+	2. Find the minimum cross-section area of the speciment by examining several (areaSections)
+		sections perpendicular to axis, computing area of the convex hull for each one. This will
+		work also for non-prismatic specimen.
+	3. Find the bodies that are on the negative/positive boundary, to which the straining condition
+		should be applied.
+
+	Returns dictionary with keys 'negIds', 'posIds', 'axis', 'area'.
+	&quot;&quot;&quot;
+	ids=spheresFromFile(filename,**kw)
+	mm,mx=aabbExtrema()
+	dim=aabbDim(); axis=dim.index(max(dim))
+	import numpy
+	areas=[approxSectionArea(coord,axis) for coord in numpy.linspace(mm[axis],mx[axis],num=10)[1:-1]]
+	negIds,posIds=negPosExtremeIds(axis=axis,distFactor=2.2)
+	return {'negIds':negIds,'posIds':posIds,'axis':axis,'area':min(areas)}
+
+def NormalRestitution2DampingRate(en):
+        &quot;&quot;&quot;Compute the normal damping rate as a function of the normal coefficient of restitution.
+        &quot;&quot;&quot;
+	if en == 0.0: return 0.999999999
+	if en == 1.0: return 0.0
+	from math import sqrt,log,pi
+	ln_en = math.log(en)
+	return (-ln_en/math.sqrt((math.pow(ln_en,2) + math.pi*math.pi)))
+
+def xMirror(half):
+	&quot;&quot;&quot;Mirror a sequence of 2d points around the x axis (changing sign on the y coord).
+	The sequence should start up and then it will wrap from y downwards (or vice versa).
+	If the last point's x coord is zero, it will not be duplicated.&quot;&quot;&quot;
+	return list(half)+[(x,-y) for x,y in reversed(half[:-1] if half[-1][0]==0 else half)]
+

Copied: trunk/py/yadeWrapper/yadeWrapper.cpp (from rev 1834, trunk/gui/py/yadeControl.cpp)
===================================================================
--- trunk/gui/py/yadeControl.cpp	2009-07-02 15:26:02 UTC (rev 1834)
+++ trunk/py/yadeWrapper/yadeWrapper.cpp	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,849 @@
+// 2007,2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
+
+#include&lt;sstream&gt;
+#include&lt;map&gt;
+#include&lt;vector&gt;
+#include&lt;unistd.h&gt;
+#include&lt;list&gt;
+
+
+#include&lt;boost/python.hpp&gt;
+#include&lt;boost/python/suite/indexing/vector_indexing_suite.hpp&gt;
+#include&lt;boost/bind.hpp&gt;
+#include&lt;boost/thread/thread.hpp&gt;
+#include&lt;boost/filesystem/operations.hpp&gt;
+#include&lt;boost/date_time/posix_time/posix_time.hpp&gt;
+#include&lt;boost/any.hpp&gt;
+#include&lt;boost/python.hpp&gt;
+#include&lt;boost/foreach.hpp&gt;
+#include&lt;boost/algorithm/string.hpp&gt;
+
+// [boost1.34] #include&lt;boost/python/stl_iterator.hpp&gt;
+
+#include&lt;yade/lib-base/Logging.hpp&gt;
+#include&lt;yade/lib-serialization-xml/XMLFormatManager.hpp&gt;
+#include&lt;yade/core/Omega.hpp&gt;
+#include&lt;yade/core/FileGenerator.hpp&gt;
+
+#include&lt;yade/lib-import/STLImporter.hpp&gt;
+
+#include&lt;yade/core/MetaEngine.hpp&gt;
+#include&lt;yade/core/MetaEngine1D.hpp&gt;
+#include&lt;yade/core/MetaEngine2D.hpp&gt;
+#include&lt;yade/core/StandAloneEngine.hpp&gt;
+#include&lt;yade/core/DeusExMachina.hpp&gt;
+#include&lt;yade/core/EngineUnit.hpp&gt;
+#include&lt;yade/pkg-common/ParallelEngine.hpp&gt;
+#include&lt;yade/core/EngineUnit1D.hpp&gt;
+#include&lt;yade/core/EngineUnit2D.hpp&gt;
+
+#include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/GeometricalModelMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/InteractingGeometryMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/InteractionGeometryMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/InteractionPhysicsMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/ConstitutiveLawDispatcher.hpp&gt;
+#include&lt;yade/pkg-common/InteractionDispatchers.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionDamper.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionApplier.hpp&gt;
+#include&lt;yade/pkg-common/MetaInteractingGeometry.hpp&gt;
+#include&lt;yade/pkg-common/AABB.hpp&gt;
+#include&lt;yade/pkg-common/ParticleParameters.hpp&gt;
+
+#include&lt;yade/pkg-common/BoundingVolumeEngineUnit.hpp&gt;
+#include&lt;yade/pkg-common/GeometricalModelEngineUnit.hpp&gt;
+#include&lt;yade/pkg-common/InteractingGeometryEngineUnit.hpp&gt;
+#include&lt;yade/pkg-common/InteractionGeometryEngineUnit.hpp&gt;
+#include&lt;yade/pkg-common/InteractionPhysicsEngineUnit.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalParametersEngineUnit.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionDamperUnit.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionApplierUnit.hpp&gt;
+#include&lt;yade/pkg-common/ConstitutiveLaw.hpp&gt;
+
+#include&lt;yade/extra/Shop.hpp&gt;
+#include&lt;yade/pkg-dem/Clump.hpp&gt;
+
+using namespace boost;
+using namespace std;
+
+#include&lt;yade/gui-py/pyAttrUtils.hpp&gt;
+#include&lt;yade/extra/boost_python_len.hpp&gt;
+
+class RenderingEngine;
+
+/*!
+	
+	A regular class (not Omega) is instantiated like this:
+
+		RootClass('optional class name as quoted string',{optional dictionary of attributes})
+		
+	if class name is not given, the RootClass itself is instantiated
+
+		p=PhysicalParameters() # p is now instance of PhysicalParameters
+		p=PhysicalParameters('RigidBodyParameters') # p is now instance of RigidBodyParameters, which has PhysicalParameters as the &quot;root&quot; class
+		p=PhysicalParameters('RigidBodyParameters',{'mass':100,'se3':[1,1,2,1,0,0,0]}) # convenience constructor
+
+	The last statement is equivalent to:
+
+		p=PhysicalParameters('RigidBodyParameters')
+		p['mass']=100; 
+		p['se3']=[1,1,2,1,0,0,0]
+
+	Class attributes are those that are registered as serializable, are accessed using the [] operator and are always read-write (be careful)
+
+		p['se3'] # this will show you the se3 attribute inside p
+		p['se3']=[1,2,3,1,0,0,0] # this sets se3 of p
+
+	Those attributes that are not fundamental types (strings, numbers, booleans, se3, vectors, quaternions, arrays of numbers, arrays of strings) can be accessed only through explicit python data members, for example:
+		
+		b=Body()
+		b.mold=InteractingGeometry(&quot;InteractingSphere&quot;,{'radius':1})
+		b.shape=GeometricalModel(&quot;Sphere&quot;,{'radius':1})
+		b.mold # will give you the interactingGeometry of body
+	
+	Instances can be queried about attributes and data members they have:
+
+		b.keys() # serializable attributes, accessible via b['attribute']
+		dir(b) # python data members, accessible via b.attribute; the __something__ attributes are python internal attributes/metods -- methods are just callable members
+
+	MetaEngine class has special constructor (for convenience):
+
+		m=MetaEngine('class name as string',[list of engine units])
+
+	and it is equivalent to
+
+		m=MetaEntine('class name as string')
+		m.functors=[list of engine units]
+
+	It is your responsibility to pass the right engineUnits, otherwise crash will results. There is currently no way I know of to prevent that. 
+
+*/
+
+/*
+TODO:
+	1. PhysicalActionContainer (constructor with actionName) with iteration
+	2. from yadeControl import Omega as _Omega, inherit from that and add other convenience functions
+*/
+
+#ifdef LOG4CXX
+	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.python&quot;);
+#endif
+
+BASIC_PY_PROXY(pyGeneric,Serializable);
+
+BASIC_PY_PROXY(pyInteractionGeometry,InteractionGeometry);
+BASIC_PY_PROXY(pyInteractionPhysics,InteractionPhysics);
+
+BASIC_PY_PROXY(pyGeometricalModel,GeometricalModel);
+BASIC_PY_PROXY_HEAD(pyPhysicalParameters,PhysicalParameters)
+	python::list blockedDOFs_get(){
+		python::list ret;
+		#define _SET_DOF(DOF_ANY,str) if((proxee-&gt;blockedDOFs &amp; PhysicalParameters::DOF_ANY)!=0) ret.append(str);
+		_SET_DOF(DOF_X,&quot;x&quot;); _SET_DOF(DOF_Y,&quot;y&quot;); _SET_DOF(DOF_Z,&quot;z&quot;); _SET_DOF(DOF_RX,&quot;rx&quot;); _SET_DOF(DOF_RY,&quot;ry&quot;); _SET_DOF(DOF_RZ,&quot;rz&quot;);
+		#undef _SET_DOF
+		return ret;
+	}
+	void blockedDOFs_set(python::list l){
+		proxee-&gt;blockedDOFs=PhysicalParameters::DOF_NONE;
+		int len=python::len(l);
+		for(int i=0; i&lt;len; i++){
+			string s=python::extract&lt;string&gt;(l[i])();
+			#define _GET_DOF(DOF_ANY,str) if(s==str) { proxee-&gt;blockedDOFs|=PhysicalParameters::DOF_ANY; continue; }
+			_GET_DOF(DOF_X,&quot;x&quot;); _GET_DOF(DOF_Y,&quot;y&quot;); _GET_DOF(DOF_Z,&quot;z&quot;); _GET_DOF(DOF_RX,&quot;rx&quot;); _GET_DOF(DOF_RY,&quot;ry&quot;); _GET_DOF(DOF_RZ,&quot;rz&quot;);
+			#undef _GET_DOF
+			throw std::invalid_argument(&quot;Invalid  DOF specification `&quot;+s+&quot;', must be &#8712;{x,y,z,rx,ry,rz}.&quot;);
+		}
+	}
+	Vector3r displ_get(){return proxee-&gt;se3.position-proxee-&gt;refSe3.position;}
+	python::tuple rot_get(){Quaternionr relRot=proxee-&gt;refSe3.orientation.Conjugate()*proxee-&gt;se3.orientation; Vector3r axis; Real angle; relRot.ToAxisAngle(axis,angle); axis*=angle; return python::make_tuple(axis[0],axis[1],axis[2]); }
+	Vector3r pos_get(){return proxee-&gt;se3.position;}
+	Vector3r refPos_get(){return proxee-&gt;refSe3.position;}
+	python::tuple ori_get(){Vector3r axis; Real angle; proxee-&gt;se3.orientation.ToAxisAngle(axis,angle); return python::make_tuple(axis[0],axis[1],axis[2],angle);}
+	void pos_set(const Vector3r&amp; p){ proxee-&gt;se3.position=p; }
+	void refPos_set(const Vector3r&amp; p){ proxee-&gt;refSe3.position=p;}
+	void ori_set(python::list l){if(python::len(l)!=4) throw invalid_argument(&quot;Wrong number of quaternion elements &quot;+lexical_cast&lt;string&gt;(python::len(l))+&quot;, should be 4&quot;); proxee-&gt;se3.orientation=Quaternionr(Vector3r(python::extract&lt;double&gt;(l[0])(),python::extract&lt;double&gt;(l[1])(),python::extract&lt;double&gt;(l[2])()),python::extract&lt;double&gt;(l[3])());}
+BASIC_PY_PROXY_TAIL;
+
+BASIC_PY_PROXY(pyBoundingVolume,BoundingVolume);
+BASIC_PY_PROXY(pyInteractingGeometry,InteractingGeometry);
+
+struct pyTimingDeltas{
+	shared_ptr&lt;TimingDeltas&gt; proxee;
+	pyTimingDeltas(shared_ptr&lt;TimingDeltas&gt; td){proxee=td;}
+	python::list data_get(){
+		python::list ret;
+		for(size_t i=0; i&lt;proxee-&gt;data.size(); i++){
+			ret.append(python::make_tuple(proxee-&gt;labels[i],proxee-&gt;data[i].nsec,proxee-&gt;data[i].nExec));
+		}
+		return ret;
+	}
+	void reset(){proxee-&gt;data.clear(); proxee-&gt;labels.clear();}
+};
+
+#define PY_PROXY_TIMING \
+	TimingInfo::delta execTime_get(void){return proxee-&gt;timingInfo.nsec;} void execTime_set(TimingInfo::delta t){proxee-&gt;timingInfo.nsec=t;} \
+	long execCount_get(void){return proxee-&gt;timingInfo.nExec;} void execCount_set(long n){proxee-&gt;timingInfo.nExec=n;} \
+	python::object timingDeltas_get(void){return proxee-&gt;timingDeltas?python::object(pyTimingDeltas(proxee-&gt;timingDeltas)):python::object();}
+
+
+BASIC_PY_PROXY_HEAD(pyDeusExMachina,DeusExMachina)
+	PY_PROXY_TIMING
+BASIC_PY_PROXY_TAIL;
+
+BASIC_PY_PROXY_HEAD(pyStandAloneEngine,StandAloneEngine)
+	PY_PROXY_TIMING
+BASIC_PY_PROXY_TAIL;
+	
+
+python::list anyEngines_get(const vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp;);
+void anyEngines_set(vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp;, python::object);
+
+BASIC_PY_PROXY_HEAD(pyParallelEngine,ParallelEngine)
+	pyParallelEngine(python::list slaves){init(&quot;ParallelEngine&quot;); slaves_set(slaves);}
+	void slaves_set(python::list slaves){
+		ensureAcc(); shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
+		int len=python::len(slaves);
+		me-&gt;slaves=ParallelEngine::slaveContainer(); // empty the container
+		for(int i=0; i&lt;len; i++){
+			python::extract&lt;python::list&gt; grpMaybe(slaves[i]);
+			python::list grpList;
+			if(grpMaybe.check()){ grpList=grpMaybe(); }
+			else{ /* we got a standalone thing; let's wrap it in list */ grpList.append(slaves[i]); }
+			vector&lt;shared_ptr&lt;Engine&gt; &gt; grpVec;
+			anyEngines_set(grpVec,grpList);
+			me-&gt;slaves.push_back(grpVec);
+		}
+	}
+	python::list slaves_get(void){	
+		ensureAcc(); shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
+		python::list ret;
+		FOREACH(vector&lt;shared_ptr&lt;Engine &gt; &gt;&amp; grp, me-&gt;slaves){
+			python::list rret=anyEngines_get(grp);
+			if(python::len(rret)==1){ ret.append(rret[0]); } else ret.append(rret);
+		}
+		return ret;
+	}
+BASIC_PY_PROXY_TAIL;
+
+
+BASIC_PY_PROXY_HEAD(pyEngineUnit,EngineUnit)
+	python::list bases_get(void){ python::list ret; vector&lt;string&gt; t=proxee-&gt;getFunctorTypes(); for(size_t i=0; i&lt;t.size(); i++) ret.append(t[i]); return ret; }
+	python::object timingDeltas_get(){return proxee-&gt;timingDeltas?python::object(pyTimingDeltas(proxee-&gt;timingDeltas)):python::object();}
+BASIC_PY_PROXY_TAIL;
+
+BASIC_PY_PROXY_HEAD(pyMetaEngine,MetaEngine)
+		// additional constructor
+		pyMetaEngine(string clss, python::list functors){init(clss); functors_set(functors);}
+		python::list functors_get(void){
+			ensureAcc(); shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine (?!)&quot;); python::list ret;
+			/* garbage design: functorArguments are instances of EngineUnits, but they may not be present; therefore, only use them if they exist; our pyMetaEngine, however, will always have both names and EnguneUnit objects in the same count */
+			for(size_t i=0; i&lt;me-&gt;functorNames.size(); i++){
+				shared_ptr&lt;EngineUnit&gt; eu;
+				string functorName(*(me-&gt;functorNames[i].rbegin()));
+				if(i&lt;=me-&gt;functorArguments.size()){ /* count i-th list member */ size_t j=0;
+					for(list&lt;shared_ptr&lt;EngineUnit&gt; &gt;::iterator I=me-&gt;functorArguments.begin(); I!=me-&gt;functorArguments.end(); I++, j++) { if(j==i) { eu=(*I); break;}}
+				}
+				if(!eu) /* either list was shorter or empty pointer in the functorArguments list */ { eu=dynamic_pointer_cast&lt;EngineUnit&gt;(ClassFactory::instance().createShared(functorName)); if(!eu) throw runtime_error(&quot;Unable to construct `&quot;+string(*(me-&gt;functorNames[i].rbegin()))+&quot;' EngineUnit&quot;); }
+				assert(eu);
+				ret.append(pyEngineUnit(eu));
+			}
+			return ret;
+		}
+		void functors_set(python::list ftrs){
+			ensureAcc(); shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine. (?!)&quot;);
+			me-&gt;clear(); int len=python::len(ftrs);
+			for(int i=0; i&lt;len; i++){
+				python::extract&lt;pyEngineUnit&gt; euEx(ftrs[i]); if(!euEx.check()) throw invalid_argument(&quot;Unable to extract type EngineUnit from sequence.&quot;);
+				bool ok=false;
+				/* FIXME: casting engine unit to the right type via dynamic_cast doesn't work (always unusuccessful),
+				 * do static_cast and if the EngineUnit is of wrong type, it will crash badly immediately. */
+				#define TRY_ADD_FUNCTOR(P,Q) {shared_ptr&lt;P&gt; p(dynamic_pointer_cast&lt;P&gt;(me)); shared_ptr&lt;EngineUnit&gt; eu(euEx().proxee); if(p&amp;&amp;eu){p-&gt;add(static_pointer_cast&lt;Q&gt;(eu)); ok=true; }}
+				// shared_ptr&lt;Q&gt; q(dynamic_pointer_cast&lt;Q&gt;(eu)); cerr&lt;&lt;#P&lt;&lt;&quot; &quot;&lt;&lt;#Q&lt;&lt;&quot;:&quot;&lt;&lt;(bool)p&lt;&lt;&quot; &quot;&lt;&lt;(bool)q&lt;&lt;endl;
+				TRY_ADD_FUNCTOR(BoundingVolumeMetaEngine,BoundingVolumeEngineUnit);
+				TRY_ADD_FUNCTOR(GeometricalModelMetaEngine,GeometricalModelEngineUnit);
+				TRY_ADD_FUNCTOR(InteractingGeometryMetaEngine,InteractingGeometryEngineUnit);
+				TRY_ADD_FUNCTOR(InteractionGeometryMetaEngine,InteractionGeometryEngineUnit);
+				TRY_ADD_FUNCTOR(InteractionPhysicsMetaEngine,InteractionPhysicsEngineUnit);
+				TRY_ADD_FUNCTOR(PhysicalParametersMetaEngine,PhysicalParametersEngineUnit);
+				TRY_ADD_FUNCTOR(PhysicalActionDamper,PhysicalActionDamperUnit);
+				TRY_ADD_FUNCTOR(PhysicalActionApplier,PhysicalActionApplierUnit);
+				TRY_ADD_FUNCTOR(ConstitutiveLawDispatcher,ConstitutiveLaw);
+				if(!ok) throw runtime_error(string(&quot;Unable to cast to suitable MetaEngine type when adding functor (MetaEngine: &quot;)+me-&gt;getClassName()+&quot;, functor: &quot;+euEx().proxee-&gt;getClassName()+&quot;)&quot;);
+				#undef TRY_ADD_FUNCTOR
+			}
+		}
+	PY_PROXY_TIMING
+BASIC_PY_PROXY_TAIL;
+
+BASIC_PY_PROXY_HEAD(pyInteractionDispatchers,InteractionDispatchers)
+	pyInteractionDispatchers(python::list geomFunctors, python::list physFunctors, python::list constLawFunctors){
+		init(&quot;InteractionDispatchers&quot;);
+		pyMetaEngine(proxee-&gt;geomDispatcher).functors_set(geomFunctors);
+		pyMetaEngine(proxee-&gt;physDispatcher).functors_set(physFunctors);
+		pyMetaEngine(proxee-&gt;constLawDispatcher).functors_set(constLawFunctors);
+	}
+	pyMetaEngine geomDispatcher_get(void){ return pyMetaEngine(proxee-&gt;geomDispatcher);}
+	pyMetaEngine physDispatcher_get(void){ return pyMetaEngine(proxee-&gt;physDispatcher);}
+	pyMetaEngine constLawDispatcher_get(void){ return pyMetaEngine(proxee-&gt;constLawDispatcher);}
+	PY_PROXY_TIMING
+BASIC_PY_PROXY_TAIL;
+
+python::list anyEngines_get(const vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp; engContainer){
+	python::list ret; 
+	FOREACH(const shared_ptr&lt;Engine&gt;&amp; eng, engContainer){
+		#define APPEND_ENGINE_IF_POSSIBLE(engineType,pyEngineType) { shared_ptr&lt;engineType&gt; e=dynamic_pointer_cast&lt;engineType&gt;(eng); if(e) { ret.append(pyEngineType(e)); continue; } }
+		APPEND_ENGINE_IF_POSSIBLE(InteractionDispatchers,pyInteractionDispatchers); APPEND_ENGINE_IF_POSSIBLE(MetaEngine,pyMetaEngine); APPEND_ENGINE_IF_POSSIBLE(StandAloneEngine,pyStandAloneEngine); APPEND_ENGINE_IF_POSSIBLE(DeusExMachina,pyDeusExMachina); APPEND_ENGINE_IF_POSSIBLE(ParallelEngine,pyParallelEngine); 
+		throw std::runtime_error(&quot;Unknown engine type: `&quot;+eng-&gt;getClassName()+&quot;' (only MetaEngine, StandAloneEngine, DeusExMachina and ParallelEngine are supported)&quot;);
+	}
+	return ret;
+}
+
+void anyEngines_set(vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp; engContainer, python::object egs){
+	int len=python::len(egs);
+	//const shared_ptr&lt;MetaBody&gt;&amp; rootBody=OMEGA.getRootBody(); rootBody-&gt;engines.clear();
+	engContainer.clear();
+	for(int i=0; i&lt;len; i++){
+		#define PUSH_BACK_ENGINE_IF_POSSIBLE(pyEngineType) if(python::extract&lt;pyEngineType&gt;(PySequence_GetItem(egs.ptr(),i)).check()){ pyEngineType e=python::extract&lt;pyEngineType&gt;(PySequence_GetItem(egs.ptr(),i)); engContainer.push_back(e.proxee); /* cerr&lt;&lt;&quot;added &quot;&lt;&lt;e.pyStr()&lt;&lt;&quot;, a &quot;&lt;&lt;#pyEngineType&lt;&lt;endl; */ continue; }
+		PUSH_BACK_ENGINE_IF_POSSIBLE(pyStandAloneEngine); PUSH_BACK_ENGINE_IF_POSSIBLE(pyMetaEngine); PUSH_BACK_ENGINE_IF_POSSIBLE(pyDeusExMachina); PUSH_BACK_ENGINE_IF_POSSIBLE(pyParallelEngine); PUSH_BACK_ENGINE_IF_POSSIBLE(pyInteractionDispatchers);
+		throw std::runtime_error(&quot;Encountered unknown engine type (unable to extract from python object)&quot;);
+	}
+}
+
+
+
+BASIC_PY_PROXY_HEAD(pyInteraction,Interaction)
+	NONPOD_ATTRIBUTE_ACCESS(geom,pyInteractionGeometry,interactionGeometry);
+	NONPOD_ATTRIBUTE_ACCESS(phys,pyInteractionPhysics,interactionPhysics);
+	/* shorthands */ unsigned id1_get(void){ensureAcc(); return proxee-&gt;getId1();} unsigned id2_get(void){ensureAcc(); return proxee-&gt;getId2();}
+	bool isReal_get(void){ensureAcc(); return proxee-&gt;isReal(); }
+BASIC_PY_PROXY_TAIL;
+
+BASIC_PY_PROXY_HEAD(pyBody,Body)
+	NONPOD_ATTRIBUTE_ACCESS(shape,pyGeometricalModel,geometricalModel);
+	NONPOD_ATTRIBUTE_ACCESS(mold,pyInteractingGeometry,interactingGeometry);
+	NONPOD_ATTRIBUTE_ACCESS(bound,pyBoundingVolume,boundingVolume);
+	NONPOD_ATTRIBUTE_ACCESS(phys,pyPhysicalParameters,physicalParameters);
+	unsigned id_get(){ensureAcc(); return proxee-&gt;getId();}
+	int mask_get(){ensureAcc(); return proxee-&gt;groupMask;}
+	void mask_set(int m){ensureAcc(); proxee-&gt;groupMask=m;}
+	bool dynamic_get(){ensureAcc(); return proxee-&gt;isDynamic;} void dynamic_set(bool dyn){ensureAcc(); proxee-&gt;isDynamic=dyn;}
+	bool isStandalone(){ensureAcc(); return proxee-&gt;isStandalone();} bool isClumpMember(){ensureAcc(); return proxee-&gt;isClumpMember();} bool isClump(){ensureAcc(); return proxee-&gt;isClump();}
+BASIC_PY_PROXY_TAIL;
+
+class pyBodyContainer{
+	public:
+	const shared_ptr&lt;BodyContainer&gt; proxee;
+	pyBodyContainer(const shared_ptr&lt;BodyContainer&gt;&amp; _proxee): proxee(_proxee){}
+	pyBody pyGetitem(unsigned id){
+		if(id&gt;=proxee-&gt;size()){ PyErr_SetString(PyExc_IndexError, &quot;Body id out of range.&quot;); python::throw_error_already_set(); /* make compiler happy; never reached */ return pyBody(); }
+		else return pyBody(proxee-&gt;operator[](id));
+	}
+	body_id_t insert(pyBody b){return proxee-&gt;insert(b.proxee);}
+	python::list insertList(python::list bb){python::list ret; for(int i=0; i&lt;len(bb); i++){ret.append(insert(python::extract&lt;pyBody&gt;(bb[i])()));} return ret;}
+		python::tuple insertClump(python::list bb){/*clump: first add constitutents, then add clump, then add constitutents to the clump, then update clump props*/
+		python::list ids=insertList(bb);
+		shared_ptr&lt;Clump&gt; clump=shared_ptr&lt;Clump&gt;(new Clump());
+		shared_ptr&lt;Body&gt; clumpAsBody=static_pointer_cast&lt;Body&gt;(clump);
+		clump-&gt;isDynamic=true;
+		proxee-&gt;insert(clumpAsBody);
+		for(int i=0; i&lt;len(ids); i++){clump-&gt;add(python::extract&lt;body_id_t&gt;(ids[i])());}
+		clump-&gt;updateProperties(false);
+		return python::make_tuple(clump-&gt;getId(),ids);
+	}
+	python::list replace(python::list bb){proxee-&gt;clear(); return insertList(bb);}
+	long length(){return proxee-&gt;size();}
+	void clear(){proxee-&gt;clear();}
+};
+
+
+class pyTags{
+	public:
+		pyTags(const shared_ptr&lt;MetaBody&gt; _mb): mb(_mb){}
+		const shared_ptr&lt;MetaBody&gt; mb;
+		bool hasKey(string key){ FOREACH(string val, mb-&gt;tags){ if(algorithm::starts_with(val,key+&quot;=&quot;)){ return true;} } return false; }
+		string getItem(string key){
+			FOREACH(string&amp; val, mb-&gt;tags){
+				if(algorithm::starts_with(val,key+&quot;=&quot;)){ string val1(val); algorithm::erase_head(val1,key.size()+1); algorithm::replace_all(val1,&quot;~&quot;,&quot; &quot;); return val1;}
+			}
+			PyErr_SetString(PyExc_KeyError, &quot;Invalid key.&quot;);
+			python::throw_error_already_set(); /* make compiler happy; never reached */ return string();
+		}
+		void setItem(string key,string newVal){
+			string item=algorithm::replace_all_copy(key+&quot;=&quot;+newVal,&quot; &quot;,&quot;~&quot;);
+			FOREACH(string&amp; val, mb-&gt;tags){if(algorithm::starts_with(val,key+&quot;=&quot;)){ val=item; return; } }
+			mb-&gt;tags.push_back(item);
+			}
+		python::list keys(){
+			python::list ret;
+			FOREACH(string val, mb-&gt;tags){
+				size_t i=val.find(&quot;=&quot;);
+				if(i==string::npos) throw runtime_error(&quot;Tags must be in the key=value format&quot;);
+				algorithm::erase_tail(val,val.size()-i); ret.append(val);
+			}
+			return ret;
+		}
+};
+
+class pyInteractionIterator{
+	InteractionContainer::iterator I, Iend;
+	public:
+	pyInteractionIterator(const shared_ptr&lt;InteractionContainer&gt;&amp; ic){ I=ic-&gt;begin(); Iend=ic-&gt;end(); }
+	pyInteractionIterator pyIter(){return *this;}
+	pyInteraction pyNext(){ if(!(I!=Iend)){ PyErr_SetNone(PyExc_StopIteration); python::throw_error_already_set(); }
+		InteractionContainer::iterator ret=I; ++I; return pyInteraction(*ret); }
+};
+
+class pyInteractionContainer{
+	public:
+		const shared_ptr&lt;InteractionContainer&gt; proxee;
+		pyInteractionContainer(const shared_ptr&lt;InteractionContainer&gt;&amp; _proxee): proxee(_proxee){}
+		pyInteractionIterator pyIter(){return pyInteractionIterator(proxee);}
+		pyInteraction pyGetitem(python::object id12){
+			if(!PySequence_Check(id12.ptr())) throw invalid_argument(&quot;Key must be a tuple&quot;);
+			if(python::len(id12)!=2) throw invalid_argument(&quot;Key must be a 2-tuple: id1,id2.&quot;);
+			python::extract&lt;body_id_t&gt; id1_(PySequence_GetItem(id12.ptr(),0)), id2_(PySequence_GetItem(id12.ptr(),1));
+			if(!id1_.check()) throw invalid_argument(&quot;Could not extract id1&quot;);
+			if(!id2_.check()) throw invalid_argument(&quot;Could not extract id2&quot;);
+			shared_ptr&lt;Interaction&gt; i=proxee-&gt;find(id1_(),id2_());
+			if(i) return pyInteraction(i); else throw invalid_argument(&quot;No such interaction.&quot;);
+		}
+		/* return nth _real_ iteration from the container (0-based index); this is to facilitate picking random interaction */
+		pyInteraction pyNth(long n){
+			long i=0; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(!I-&gt;isReal()) continue; if(i++==n) return pyInteraction(I); }
+			throw invalid_argument(string(&quot;Interaction number out of range (&quot;)+lexical_cast&lt;string&gt;(n)+&quot;&gt;=&quot;+lexical_cast&lt;string&gt;(i)+&quot;).&quot;);
+		}
+		long len(){return proxee-&gt;size();}
+		void clear(){proxee-&gt;clear();}
+		python::list withBody(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;isReal() &amp;&amp; (I-&gt;getId1()==id || I-&gt;getId2()==id)) ret.append(pyInteraction(I));} return ret;}
+		python::list withBodyAll(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;getId1()==id || I-&gt;getId2()==id) ret.append(pyInteraction(I));} return ret; }
+};
+
+Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
+
+class pyBexContainer{
+	public:
+		pyBexContainer(){}
+		python::tuple force_get(long id){  MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r f=rb-&gt;bex.getForce(id); return python::make_tuple(f[0],f[1],f[2]); }
+		python::tuple torque_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getTorque(id); return python::make_tuple(m[0],m[1],m[2]);}
+		python::tuple move_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getMove(id); return python::make_tuple(m[0],m[1],m[2]);}
+		python::tuple rot_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getRot(id); return python::make_tuple(m[0],m[1],m[2]);}
+		void force_add(long id, const Vector3r&amp; f){  MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addForce (id,f); }
+		void torque_add(long id, const Vector3r&amp; t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addTorque(id,t);}
+		void move_add(long id, const Vector3r&amp; t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addMove(id,t);}
+		void rot_add(long id, const Vector3r&amp; t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addRot(id,t);}
+};
+
+class pyOmega{
+	private:
+		// can be safely removed now, since pyOmega makes an empty rootBody in the constructor, if there is none
+		void assertRootBody(){if(!OMEGA.getRootBody()) throw std::runtime_error(&quot;No root body.&quot;); }
+		Omega&amp; OMEGA;
+	public:
+	pyOmega(): OMEGA(Omega::instance()){
+		shared_ptr&lt;MetaBody&gt; rb=OMEGA.getRootBody();
+		assert(rb);
+		if(!rb-&gt;physicalParameters){rb-&gt;physicalParameters=shared_ptr&lt;PhysicalParameters&gt;(new ParticleParameters);} /* PhysicalParameters crashes PhysicalParametersMetaEngine... why? */
+		if(!rb-&gt;boundingVolume){rb-&gt;boundingVolume=shared_ptr&lt;AABB&gt;(new AABB);}
+		// initialized in constructor now: rb-&gt;boundingVolume-&gt;diffuseColor=Vector3r(1,1,1); 
+		if(!rb-&gt;interactingGeometry){rb-&gt;interactingGeometry=shared_ptr&lt;MetaInteractingGeometry&gt;(new MetaInteractingGeometry);}
+		//if(!OMEGA.getRootBody()){shared_ptr&lt;MetaBody&gt; mb=Shop::rootBody(); OMEGA.setRootBody(mb);}
+		/* this is not true if another instance of Omega is created; flag should be stored inside the Omega singleton for clean solution. */
+		if(!OMEGA.hasSimulationLoop()){
+			OMEGA.createSimulationLoop();
+		}
+	};
+	/* Create variables in python's __builtin__ namespace that correspond to labeled objects. At this moment, only engines can be labeled. */
+	void mapLabeledEntitiesToVariables(){
+		FOREACH(const shared_ptr&lt;Engine&gt;&amp; e, OMEGA.getRootBody()-&gt;engines){
+			if(!e-&gt;label.empty()){
+				PyGILState_STATE gstate; gstate = PyGILState_Ensure();
+				PyRun_SimpleString((&quot;__builtins__.&quot;+e-&gt;label+&quot;=Omega().labeledEngine('&quot;+e-&gt;label+&quot;')&quot;).c_str());
+				PyGILState_Release(gstate);
+			}
+			if(isChildClassOf(e-&gt;getClassName(),&quot;MetaEngine&quot;)){
+				shared_ptr&lt;MetaEngine&gt; ee=dynamic_pointer_cast&lt;MetaEngine&gt;(e);
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; f, ee-&gt;functorArguments){
+					if(!f-&gt;label.empty()){
+						PyGILState_STATE gstate; gstate = PyGILState_Ensure(); PyRun_SimpleString((&quot;__builtins__.&quot;+f-&gt;label+&quot;=Omega().labeledEngine('&quot;+f-&gt;label+&quot;')&quot;).c_str()); PyGILState_Release(gstate);
+					}
+				}
+			}
+			if(e-&gt;getClassName()==&quot;InteractionDispatchers&quot;){
+				shared_ptr&lt;InteractionDispatchers&gt; ee=dynamic_pointer_cast&lt;InteractionDispatchers&gt;(e);
+				list&lt;shared_ptr&lt;EngineUnit&gt; &gt; eus;
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;geomDispatcher-&gt;functorArguments) eus.push_back(eu);
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;physDispatcher-&gt;functorArguments) eus.push_back(eu);
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;constLawDispatcher-&gt;functorArguments) eus.push_back(eu);
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,eus){
+					if(!eu-&gt;label.empty()){
+						PyGILState_STATE gstate; gstate = PyGILState_Ensure(); PyRun_SimpleString((&quot;__builtins__.&quot;+eu-&gt;label+&quot;=Omega().labeledEngine('&quot;+eu-&gt;label+&quot;')&quot;).c_str()); PyGILState_Release(gstate);
+					}
+				}
+			}
+		}
+	}
+
+	long iter(){ return OMEGA.getCurrentIteration();}
+	double simulationTime(){return OMEGA.getSimulationTime();}
+	double realTime(){ return OMEGA.getComputationTime(); }
+	// long realTime(){return OMEGA(get...);}
+	double dt_get(){return OMEGA.getTimeStep();}
+	void dt_set(double dt){OMEGA.skipTimeStepper(true); OMEGA.setTimeStep(dt);}
+
+	long stopAtIter_get(){return OMEGA.getRootBody()-&gt;stopAtIteration; }
+	void stopAtIter_set(long s){OMEGA.getRootBody()-&gt;stopAtIteration=s; }
+
+	bool usesTimeStepper_get(){return OMEGA.timeStepperActive();}
+	void usesTimeStepper_set(bool use){OMEGA.skipTimeStepper(!use);}
+
+	bool timingEnabled_get(){return TimingInfo::enabled;}
+	void timingEnabled_set(bool enabled){TimingInfo::enabled=enabled;}
+	unsigned long bexSyncCount_get(){ return OMEGA.getRootBody()-&gt;bex.syncCount;}
+	void bexSyncCount_set(unsigned long count){ OMEGA.getRootBody()-&gt;bex.syncCount=count;}
+
+	void run(long int numIter=-1,bool doWait=false){
+		if(numIter&gt;0) OMEGA.getRootBody()-&gt;stopAtIteration=OMEGA.getCurrentIteration()+numIter;
+		OMEGA.startSimulationLoop();
+		LOG_DEBUG(&quot;RUN&quot;&lt;&lt;((OMEGA.getRootBody()-&gt;stopAtIteration-OMEGA.getCurrentIteration())&gt;0?string(&quot; (&quot;+lexical_cast&lt;string&gt;(OMEGA.getRootBody()-&gt;stopAtIteration-OMEGA.getCurrentIteration())+&quot; to go)&quot;):string(&quot;&quot;))&lt;&lt;&quot;!&quot;);
+		if(doWait) wait();
+	}
+	void pause(){Py_BEGIN_ALLOW_THREADS; OMEGA.stopSimulationLoop(); Py_END_ALLOW_THREADS; LOG_DEBUG(&quot;PAUSE!&quot;);}
+	void step() { LOG_DEBUG(&quot;STEP!&quot;); run(1); wait();  }
+	void wait(){ if(OMEGA.isRunning()){LOG_DEBUG(&quot;WAIT!&quot;);} else return; timespec t1,t2; t1.tv_sec=0; t1.tv_nsec=40000000; /* 40 ms */ Py_BEGIN_ALLOW_THREADS; while(OMEGA.isRunning()) nanosleep(&amp;t1,&amp;t2); Py_END_ALLOW_THREADS; }
+
+	void load(std::string fileName) {
+		Py_BEGIN_ALLOW_THREADS; OMEGA.joinSimulationLoop(); Py_END_ALLOW_THREADS; 
+		OMEGA.setSimulationFileName(fileName);
+		OMEGA.loadSimulation();
+		OMEGA.createSimulationLoop();
+		mapLabeledEntitiesToVariables();
+		LOG_DEBUG(&quot;LOAD!&quot;);
+	}
+	void reload(){	load(OMEGA.getSimulationFileName());}
+	void saveTmp(string mark=&quot;&quot;){ save(&quot;:memory:&quot;+mark);}
+	void loadTmp(string mark=&quot;&quot;){ load(&quot;:memory:&quot;+mark);}
+	void tmpToFile(string mark, string filename){
+		if(OMEGA.memSavedSimulations.count(&quot;:memory:&quot;+mark)==0) throw runtime_error(&quot;No memory-saved simulation named &quot;+mark);
+		iostreams::filtering_ostream out;
+		if(boost::algorithm::ends_with(filename,&quot;.bz2&quot;)) out.push(iostreams::bzip2_compressor());
+		out.push(iostreams::file_sink(filename));
+		if(!out.good()) throw runtime_error(&quot;Error while opening file `&quot;+filename+&quot;' for writing.&quot;);
+		LOG_INFO(&quot;Saving :memory:&quot;&lt;&lt;mark&lt;&lt;&quot; to &quot;&lt;&lt;filename);
+		out&lt;&lt;OMEGA.memSavedSimulations[&quot;:memory:&quot;+mark];
+	}
+
+
+
+	void reset(){Py_BEGIN_ALLOW_THREADS; OMEGA.reset(); Py_END_ALLOW_THREADS; }
+	void resetTime(){ OMEGA.getRootBody()-&gt;currentIteration=0; OMEGA.getRootBody()-&gt;simulationTime=0; OMEGA.timeInit(); }
+	void switchWorld(){ std::swap(OMEGA.rootBody,OMEGA.rootBodyAnother); }
+
+	void save(std::string fileName){
+		assertRootBody();
+		OMEGA.saveSimulation(fileName);
+		OMEGA.setSimulationFileName(fileName);
+		LOG_DEBUG(&quot;SAVE!&quot;);
+	}
+
+	void saveSpheres(std::string fileName){ Shop::saveSpheresToFile(fileName); }
+
+	python::list miscParams_get(){
+		python::list ret;
+		FOREACH(shared_ptr&lt;Serializable&gt;&amp; s, OMEGA.getRootBody()-&gt;miscParams){
+			ret.append(pyGeneric(s));
+		}
+		return ret;
+	}
+
+	void miscParams_set(python::list l){
+		int len=python::len(l);
+		vector&lt;shared_ptr&lt;Serializable&gt; &gt;&amp; miscParams=OMEGA.getRootBody()-&gt;miscParams;
+		miscParams.clear();
+		for(int i=0; i&lt;len; i++){
+			if(python::extract&lt;pyGeneric&gt;(PySequence_GetItem(l.ptr(),i)).check()){ pyGeneric g=python::extract&lt;pyGeneric&gt;(PySequence_GetItem(l.ptr(),i)); miscParams.push_back(g.proxee); }
+			else throw std::invalid_argument(&quot;Unable to extract `Generic' from item #&quot;+lexical_cast&lt;string&gt;(i)+&quot;.&quot;);
+		}
+	}
+
+	python::list engines_get(void){assertRootBody(); return anyEngines_get(OMEGA.getRootBody()-&gt;engines);}
+	void engines_set(python::object egs){assertRootBody(); anyEngines_set(OMEGA.getRootBody()-&gt;engines,egs); mapLabeledEntitiesToVariables(); }
+	python::list initializers_get(void){assertRootBody(); return anyEngines_get(OMEGA.getRootBody()-&gt;initializers);}
+	void initializers_set(python::object egs){assertRootBody(); anyEngines_set(OMEGA.getRootBody()-&gt;initializers,egs); OMEGA.getRootBody()-&gt;needsInitializers=true; }
+
+	python::object labeled_engine_get(string label){
+		FOREACH(const shared_ptr&lt;Engine&gt;&amp; eng, OMEGA.getRootBody()-&gt;engines){
+			if(eng-&gt;label==label){
+				#define RETURN_ENGINE_IF_POSSIBLE(engineType,pyEngineType) { shared_ptr&lt;engineType&gt; e=dynamic_pointer_cast&lt;engineType&gt;(eng); if(e) return python::object(pyEngineType(e)); }
+				RETURN_ENGINE_IF_POSSIBLE(MetaEngine,pyMetaEngine);
+				RETURN_ENGINE_IF_POSSIBLE(StandAloneEngine,pyStandAloneEngine);
+				RETURN_ENGINE_IF_POSSIBLE(DeusExMachina,pyDeusExMachina);
+				RETURN_ENGINE_IF_POSSIBLE(ParallelEngine,pyParallelEngine);
+				throw std::runtime_error(&quot;Unable to cast engine to MetaEngine, StandAloneEngine, DeusExMachina or ParallelEngine? ??&quot;);
+			}
+			shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(eng);
+			if(me){
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu, me-&gt;functorArguments){
+					if(eu-&gt;label==label) return python::object(pyEngineUnit(eu));
+				}
+			}
+			shared_ptr&lt;InteractionDispatchers&gt; ee=dynamic_pointer_cast&lt;InteractionDispatchers&gt;(eng);
+			if(ee){
+				list&lt;shared_ptr&lt;EngineUnit&gt; &gt; eus;
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;geomDispatcher-&gt;functorArguments) eus.push_back(eu);
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;physDispatcher-&gt;functorArguments) eus.push_back(eu);
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,ee-&gt;constLawDispatcher-&gt;functorArguments) eus.push_back(eu);
+				FOREACH(const shared_ptr&lt;EngineUnit&gt;&amp; eu,eus){
+					if(eu-&gt;label==label) return python::object(pyEngineUnit(eu));
+				}
+			}
+		}
+		throw std::invalid_argument(string(&quot;No engine labeled `&quot;)+label+&quot;'&quot;);
+	}
+	
+	pyBodyContainer bodies_get(void){assertRootBody(); return pyBodyContainer(OMEGA.getRootBody()-&gt;bodies); }
+	pyInteractionContainer interactions_get(void){assertRootBody(); return pyInteractionContainer(OMEGA.getRootBody()-&gt;interactions); }
+	
+	pyBexContainer bex_get(void){return pyBexContainer();}
+	
+
+	boost::python::list listChildClasses(const string&amp; base){
+		boost::python::list ret;
+		for(map&lt;string,DynlibDescriptor&gt;::const_iterator di=Omega::instance().getDynlibsDescriptor().begin();di!=Omega::instance().getDynlibsDescriptor().end();++di) if (Omega::instance().isInheritingFrom((*di).first,base)) ret.append(di-&gt;first);
+		return ret;
+	}
+
+	bool isChildClassOf(const string&amp; child, const string&amp; base){
+		return (Omega::instance().isInheritingFrom(child,base));
+	}
+
+	boost::python::list plugins_get(){
+		const map&lt;string,DynlibDescriptor&gt;&amp; plugins=Omega::instance().getDynlibsDescriptor();
+		std::pair&lt;string,DynlibDescriptor&gt; p; boost::python::list ret;
+		FOREACH(p, plugins) ret.append(p.first);
+		return ret;
+	}
+
+	pyTags tags_get(void){assertRootBody(); return pyTags(OMEGA.getRootBody());}
+
+	void interactionContainer_set(string clss){
+		MetaBody* rb=OMEGA.getRootBody().get();
+		if(rb-&gt;interactions-&gt;size()&gt;0) throw std::runtime_error(&quot;Interaction container not empty, will not change its class.&quot;);
+		shared_ptr&lt;InteractionContainer&gt; ic=dynamic_pointer_cast&lt;InteractionContainer&gt;(ClassFactory::instance().createShared(clss));
+		rb-&gt;interactions=ic;
+	}
+	string interactionContainer_get(string clss){ return OMEGA.getRootBody()-&gt;interactions-&gt;getClassName(); }
+
+	void bodyContainer_set(string clss){
+		MetaBody* rb=OMEGA.getRootBody().get();
+		if(rb-&gt;bodies-&gt;size()&gt;0) throw std::runtime_error(&quot;Body container not empty, will not change its class.&quot;);
+		shared_ptr&lt;BodyContainer&gt; bc=dynamic_pointer_cast&lt;BodyContainer&gt;(ClassFactory::instance().createShared(clss));
+		rb-&gt;bodies=bc;
+	}
+	string bodyContainer_get(string clss){ return OMEGA.getRootBody()-&gt;bodies-&gt;getClassName(); }
+	#ifdef YADE_OPENMP
+		int numThreads_get(){ return omp_get_max_threads();}
+		void numThreads_set(int n){ int bcn=OMEGA.getRootBody()-&gt;bex.getNumAllocatedThreads(); if(bcn&lt;n) LOG_WARN(&quot;BexContainer has only &quot;&lt;&lt;bcn&lt;&lt;&quot; threads allocated. Changing thread number to on &quot;&lt;&lt;bcn&lt;&lt;&quot; instead of &quot;&lt;&lt;n&lt;&lt;&quot; requested.&quot;); omp_set_num_threads(min(n,bcn)); LOG_WARN(&quot;BUG: Omega().numThreads=n doesn't work as expected (number of threads is not changed globally). Set env var OMP_NUM_THREADS instead.&quot;); }
+	#else
+		int numThreads_get(){return 1;}
+		void numThreads_set(int n){ LOG_WARN(&quot;Yade was compiled without openMP support, changing number of threads will have no effect.&quot;); }
+	#endif
+
+};
+BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_run_overloads,run,0,2);
+BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_saveTmp_overloads,saveTmp,0,1);
+BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_loadTmp_overloads,loadTmp,0,1);
+
+BASIC_PY_PROXY_HEAD(pyFileGenerator,FileGenerator)
+	void generate(string outFile){ensureAcc(); proxee-&gt;setFileName(outFile); proxee-&gt;setSerializationLibrary(&quot;XMLFormatManager&quot;); bool ret=proxee-&gt;generateAndSave(); LOG_INFO((ret?&quot;SUCCESS:\n&quot;:&quot;FAILURE:\n&quot;)&lt;&lt;proxee-&gt;message); if(ret==false) throw runtime_error(&quot;Generator reported error: &quot;+proxee-&gt;message); };
+	void load(){ ensureAcc(); char tmpnam_str [L_tmpnam]; char* result=tmpnam(tmpnam_str); if(result!=tmpnam_str) throw runtime_error(__FILE__ &quot;: tmpnam(char*) failed!&quot;);  string xml(tmpnam_str+string(&quot;.xml.bz2&quot;)); LOG_DEBUG(&quot;Using temp file &quot;&lt;&lt;xml); this-&gt;generate(xml); pyOmega().load(xml); }
+BASIC_PY_PROXY_TAIL;
+
+class pySTLImporter : public STLImporter {
+    public:
+	void py_import(pyBodyContainer bc, unsigned int begin=0, bool noInteractingGeometry=false) { import(bc.proxee,begin,noInteractingGeometry); }
+};
+BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(STLImporter_import_overloads,py_import,1,3);
+
+
+// automatic conversion of Vector3r and 3-tuple
+// this doesn't create any new class in python
+struct custom_Vector3r_to_tuple{
+	static PyObject* convert(Vector3r const&amp; v){
+		return python::incref(python::make_tuple(v[0],v[1],v[2]).ptr());
+	}
+};
+struct custom_Vector3r_from_tuple{
+	custom_Vector3r_from_tuple(){
+		python::converter::registry::push_back(&amp;convertible,&amp;construct,python::type_id&lt;Vector3r&gt;());
+	}
+	static void* convertible(PyObject* obj_ptr){
+		if(!PySequence_Check(obj_ptr) || PySequence_Size(obj_ptr)!=3) return 0;
+		return obj_ptr;
+	}
+	static void construct(PyObject* obj_ptr, python::converter::rvalue_from_python_stage1_data* data){
+		void* storage=((python::converter::rvalue_from_python_storage&lt;Vector3r&gt;*)(data))-&gt;storage.bytes;
+		new (storage) Vector3r(python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,0)),python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,1)),python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,2)));
+		data-&gt;convertible=storage;
+	}
+};
+
+
+BOOST_PYTHON_MODULE(wrapper)
+{
+
+	//python::to_python_converter&lt;Vector3r,custom_Vector3r_to_tuple&gt;();
+	//custom_Vector3r_from_tuple();
+
+	boost::python::class_&lt;pyOmega&gt;(&quot;Omega&quot;)
+		.add_property(&quot;iter&quot;,&amp;pyOmega::iter)
+		.add_property(&quot;stopAtIter&quot;,&amp;pyOmega::stopAtIter_get,&amp;pyOmega::stopAtIter_set)
+		.add_property(&quot;time&quot;,&amp;pyOmega::simulationTime)
+		.add_property(&quot;realtime&quot;,&amp;pyOmega::realTime)
+		.add_property(&quot;dt&quot;,&amp;pyOmega::dt_get,&amp;pyOmega::dt_set)
+		.add_property(&quot;usesTimeStepper&quot;,&amp;pyOmega::usesTimeStepper_get,&amp;pyOmega::usesTimeStepper_set)
+		.def(&quot;load&quot;,&amp;pyOmega::load)
+		.def(&quot;reload&quot;,&amp;pyOmega::reload)
+		.def(&quot;save&quot;,&amp;pyOmega::save)
+		.def(&quot;loadTmp&quot;,&amp;pyOmega::loadTmp,omega_loadTmp_overloads(python::args(&quot;mark&quot;)))
+		.def(&quot;saveTmp&quot;,&amp;pyOmega::saveTmp,omega_saveTmp_overloads(python::args(&quot;mark&quot;)))
+		.def(&quot;tmpToFile&quot;,&amp;pyOmega::tmpToFile)
+		.def(&quot;saveSpheres&quot;,&amp;pyOmega::saveSpheres)
+		.def(&quot;run&quot;,&amp;pyOmega::run,omega_run_overloads())
+		.def(&quot;pause&quot;,&amp;pyOmega::pause)
+		.def(&quot;step&quot;,&amp;pyOmega::step)
+		.def(&quot;wait&quot;,&amp;pyOmega::wait)
+		.def(&quot;reset&quot;,&amp;pyOmega::reset)
+		.def(&quot;switchWorld&quot;,&amp;pyOmega::switchWorld)
+		.def(&quot;labeledEngine&quot;,&amp;pyOmega::labeled_engine_get)
+		.def(&quot;resetTime&quot;,&amp;pyOmega::resetTime)
+		.def(&quot;plugins&quot;,&amp;pyOmega::plugins_get)
+		.add_property(&quot;engines&quot;,&amp;pyOmega::engines_get,&amp;pyOmega::engines_set)
+		.add_property(&quot;miscParams&quot;,&amp;pyOmega::miscParams_get,&amp;pyOmega::miscParams_set)
+		.add_property(&quot;initializers&quot;,&amp;pyOmega::initializers_get,&amp;pyOmega::initializers_set)
+		.add_property(&quot;bodies&quot;,&amp;pyOmega::bodies_get)
+		.add_property(&quot;interactions&quot;,&amp;pyOmega::interactions_get)
+		.add_property(&quot;actions&quot;,&amp;pyOmega::bex_get)
+		.add_property(&quot;bex&quot;,&amp;pyOmega::bex_get)
+		.add_property(&quot;tags&quot;,&amp;pyOmega::tags_get)
+		.def(&quot;childClasses&quot;,&amp;pyOmega::listChildClasses)
+		.def(&quot;isChildClassOf&quot;,&amp;pyOmega::isChildClassOf)
+		.add_property(&quot;bodyContainer&quot;,&amp;pyOmega::bodyContainer_get,&amp;pyOmega::bodyContainer_set)
+		.add_property(&quot;interactionContainer&quot;,&amp;pyOmega::interactionContainer_get,&amp;pyOmega::interactionContainer_set)
+		.add_property(&quot;timingEnabled&quot;,&amp;pyOmega::timingEnabled_get,&amp;pyOmega::timingEnabled_set)
+		.add_property(&quot;bexSyncCount&quot;,&amp;pyOmega::bexSyncCount_get,&amp;pyOmega::bexSyncCount_set)
+		.add_property(&quot;numThreads&quot;,&amp;pyOmega::numThreads_get,&amp;pyOmega::numThreads_set)
+		;
+	boost::python::class_&lt;pyTags&gt;(&quot;TagsWrapper&quot;,python::init&lt;pyTags&amp;&gt;())
+		.def(&quot;__getitem__&quot;,&amp;pyTags::getItem)
+		.def(&quot;__setitem__&quot;,&amp;pyTags::setItem)
+		.def(&quot;keys&quot;,&amp;pyTags::keys);
+	
+	boost::python::class_&lt;pyBodyContainer&gt;(&quot;BodyContainer&quot;,python::init&lt;pyBodyContainer&amp;&gt;())
+		.def(&quot;__getitem__&quot;,&amp;pyBodyContainer::pyGetitem)
+		.def(&quot;__len__&quot;,&amp;pyBodyContainer::length)
+		.def(&quot;append&quot;,&amp;pyBodyContainer::insert)
+		.def(&quot;append&quot;,&amp;pyBodyContainer::insertList)
+		.def(&quot;appendClumped&quot;,&amp;pyBodyContainer::insertClump)
+		.def(&quot;clear&quot;, &amp;pyBodyContainer::clear)
+		.def(&quot;replace&quot;,&amp;pyBodyContainer::replace);
+	boost::python::class_&lt;pyInteractionContainer&gt;(&quot;InteractionContainer&quot;,python::init&lt;pyInteractionContainer&amp;&gt;())
+		.def(&quot;__iter__&quot;,&amp;pyInteractionContainer::pyIter)
+		.def(&quot;__getitem__&quot;,&amp;pyInteractionContainer::pyGetitem)
+		.def(&quot;__len__&quot;,&amp;pyInteractionContainer::len)
+		.def(&quot;nth&quot;,&amp;pyInteractionContainer::pyNth)
+		.def(&quot;withBody&quot;,&amp;pyInteractionContainer::withBody)
+		.def(&quot;withBodyAll&quot;,&amp;pyInteractionContainer::withBodyAll)
+		.def(&quot;nth&quot;,&amp;pyInteractionContainer::pyNth)
+		.def(&quot;clear&quot;,&amp;pyInteractionContainer::clear);
+	boost::python::class_&lt;pyInteractionIterator&gt;(&quot;InteractionIterator&quot;,python::init&lt;pyInteractionIterator&amp;&gt;())
+		.def(&quot;__iter__&quot;,&amp;pyInteractionIterator::pyIter)
+		.def(&quot;next&quot;,&amp;pyInteractionIterator::pyNext);
+
+	boost::python::class_&lt;pyBexContainer&gt;(&quot;BexContainer&quot;,python::init&lt;pyBexContainer&amp;&gt;())
+		.def(&quot;f&quot;,&amp;pyBexContainer::force_get)
+		.def(&quot;t&quot;,&amp;pyBexContainer::torque_get)
+		.def(&quot;m&quot;,&amp;pyBexContainer::torque_get) // for compatibility with ActionContainer
+		.def(&quot;move&quot;,&amp;pyBexContainer::move_get)
+		.def(&quot;rot&quot;,&amp;pyBexContainer::rot_get)
+		.def(&quot;addF&quot;,&amp;pyBexContainer::force_add)
+		.def(&quot;addT&quot;,&amp;pyBexContainer::torque_add)
+		.def(&quot;addMove&quot;,&amp;pyBexContainer::move_add)
+		.def(&quot;addRot&quot;,&amp;pyBexContainer::rot_add);
+
+	boost::python::class_&lt;pyTimingDeltas&gt;(&quot;TimingDeltas&quot;,python::init&lt;pyTimingDeltas&amp;&gt;())
+		.def(&quot;reset&quot;,&amp;pyTimingDeltas::reset)
+		.add_property(&quot;data&quot;,&amp;pyTimingDeltas::data_get);
+
+	#define TIMING_PROPS(class) .add_property(&quot;execTime&quot;,&amp;class::execTime_get,&amp;class::execTime_set).add_property(&quot;execCount&quot;,&amp;class::execCount_get,&amp;class::execCount_set).add_property(&quot;timingDeltas&quot;,&amp;class::timingDeltas_get)
+
+	BASIC_PY_PROXY_WRAPPER(pyStandAloneEngine,&quot;StandAloneEngine&quot;)
+		TIMING_PROPS(pyStandAloneEngine);
+	BASIC_PY_PROXY_WRAPPER(pyMetaEngine,&quot;MetaEngine&quot;)
+		.add_property(&quot;functors&quot;,&amp;pyMetaEngine::functors_get,&amp;pyMetaEngine::functors_set)
+		TIMING_PROPS(pyMetaEngine)
+		.def(python::init&lt;string,python::list&gt;());
+	BASIC_PY_PROXY_WRAPPER(pyParallelEngine,&quot;ParallelEngine&quot;)
+		.add_property(&quot;slaves&quot;,&amp;pyParallelEngine::slaves_get,&amp;pyParallelEngine::slaves_set)
+		.def(python::init&lt;python::list&gt;());
+	BASIC_PY_PROXY_WRAPPER(pyDeusExMachina,&quot;DeusExMachina&quot;)
+		TIMING_PROPS(pyDeusExMachina);
+	BASIC_PY_PROXY_WRAPPER(pyInteractionDispatchers,&quot;InteractionDispatchers&quot;)
+		.def(python::init&lt;python::list,python::list,python::list&gt;())
+		.add_property(&quot;geomDispatcher&quot;,&amp;pyInteractionDispatchers::geomDispatcher_get)
+		.add_property(&quot;physDispatcher&quot;,&amp;pyInteractionDispatchers::physDispatcher_get)
+		.add_property(&quot;constLawDispatcher&quot;,&amp;pyInteractionDispatchers::constLawDispatcher_get)
+		TIMING_PROPS(pyInteractionDispatchers);
+	BASIC_PY_PROXY_WRAPPER(pyEngineUnit,&quot;EngineUnit&quot;)
+		.add_property(&quot;timingDeltas&quot;,&amp;pyEngineUnit::timingDeltas_get)
+		.add_property(&quot;bases&quot;,&amp;pyEngineUnit::bases_get);
+
+	#undef TIMING_PROPS
+
+	BASIC_PY_PROXY_WRAPPER(pyGeometricalModel,&quot;GeometricalModel&quot;);
+	BASIC_PY_PROXY_WRAPPER(pyInteractingGeometry,&quot;InteractingGeometry&quot;);
+	BASIC_PY_PROXY_WRAPPER(pyPhysicalParameters,&quot;PhysicalParameters&quot;)	
+		.add_property(&quot;blockedDOFs&quot;,&amp;pyPhysicalParameters::blockedDOFs_get,&amp;pyPhysicalParameters::blockedDOFs_set)
+		.add_property(&quot;pos&quot;,&amp;pyPhysicalParameters::pos_get,&amp;pyPhysicalParameters::pos_set)
+		.add_property(&quot;ori&quot;,&amp;pyPhysicalParameters::ori_get,&amp;pyPhysicalParameters::ori_set)
+		.add_property(&quot;refPos&quot;,&amp;pyPhysicalParameters::refPos_get,&amp;pyPhysicalParameters::refPos_set)
+		.add_property(&quot;displ&quot;,&amp;pyPhysicalParameters::displ_get)
+		.add_property(&quot;rot&quot;,&amp;pyPhysicalParameters::rot_get)
+		;
+	BASIC_PY_PROXY_WRAPPER(pyBoundingVolume,&quot;BoundingVolume&quot;);
+	BASIC_PY_PROXY_WRAPPER(pyInteractionGeometry,&quot;InteractionGeometry&quot;);
+	BASIC_PY_PROXY_WRAPPER(pyInteractionPhysics,&quot;InteractionPhysics&quot;);
+
+	BASIC_PY_PROXY_WRAPPER(pyGeneric,&quot;Generic&quot;);
+
+	BASIC_PY_PROXY_WRAPPER(pyBody,&quot;Body&quot;)
+		.add_property(&quot;shape&quot;,&amp;pyBody::shape_get,&amp;pyBody::shape_set)
+		.add_property(&quot;mold&quot;,&amp;pyBody::mold_get,&amp;pyBody::mold_set)
+		.add_property(&quot;bound&quot;,&amp;pyBody::bound_get,&amp;pyBody::bound_set)
+		.add_property(&quot;phys&quot;,&amp;pyBody::phys_get,&amp;pyBody::phys_set)
+		.add_property(&quot;dynamic&quot;,&amp;pyBody::dynamic_get,&amp;pyBody::dynamic_set)
+		.add_property(&quot;id&quot;,&amp;pyBody::id_get)
+		.add_property(&quot;mask&quot;,&amp;pyBody::mask_get,&amp;pyBody::mask_set)
+		.add_property(&quot;isStandalone&quot;,&amp;pyBody::isStandalone)
+		.add_property(&quot;isClumpMember&quot;,&amp;pyBody::isClumpMember)
+		.add_property(&quot;isClump&quot;,&amp;pyBody::isClump);
+
+	BASIC_PY_PROXY_WRAPPER(pyInteraction,&quot;Interaction&quot;)
+		.add_property(&quot;phys&quot;,&amp;pyInteraction::phys_get,&amp;pyInteraction::phys_set)
+		.add_property(&quot;geom&quot;,&amp;pyInteraction::geom_get,&amp;pyInteraction::geom_set)
+		.add_property(&quot;id1&quot;,&amp;pyInteraction::id1_get)
+		.add_property(&quot;id2&quot;,&amp;pyInteraction::id2_get)
+		.add_property(&quot;isReal&quot;,&amp;pyInteraction::isReal_get);
+
+	BASIC_PY_PROXY_WRAPPER(pyFileGenerator,&quot;Preprocessor&quot;)
+		.def(&quot;generate&quot;,&amp;pyFileGenerator::generate)
+		.def(&quot;load&quot;,&amp;pyFileGenerator::load);
+
+	boost::python::class_&lt;pySTLImporter&gt;(&quot;STLImporter&quot;)
+	    .def(&quot;open&quot;,&amp;pySTLImporter::open)
+	    .add_property(&quot;number_of_facets&quot;,&amp;pySTLImporter::number_of_facets)
+	    .def_readwrite(&quot;wire&quot;,&amp;pySTLImporter::wire)
+	    .def(&quot;import_geometry&quot;,&amp;pySTLImporter::py_import,STLImporter_import_overloads());
+	
+}
+


Property changes on: trunk/py/yadeWrapper/yadeWrapper.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/scripts/test/gts-triax-pack.py
===================================================================
--- trunk/scripts/test/gts-triax-pack.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/scripts/test/gts-triax-pack.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -32,7 +32,7 @@
 # parameters (or parameters that can be scaled to the same one),
 # it will load the packing instead of running the triaxial compaction again.
 # Try running for the second time to see the speed difference!
-O.bodies.append(pack.triaxialPack(pack.inGtsSurface(surf),radius=5e-4,radiusStDev=1e-4,memoizeDb='/tmp/gts-triax-packings.sqlite'))
+O.bodies.append(pack.triaxialPack(pack.inGtsSurface(surf),radius=15e-4,radiusStDev=1e-4,memoizeDb='/tmp/gts-triax-packings.sqlite'))
 # We could also fill the horse with triaxial packing, but have nice approximation, the triaxial would run terribly long,
 # since horse discard most volume of its bounding box
 # Here, we would use a very crude one, however

Modified: trunk/scripts/test/shear.py
===================================================================
--- trunk/scripts/test/shear.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/scripts/test/shear.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -8,21 +8,13 @@
 	utils.sphere([0,0,1],.5000001,dynamic=True,color=(0,0,1))
 ])
 O.engines=[
-	MetaEngine('BoundingVolumeMetaEngine',[
-		EngineUnit('InteractingSphere2AABB'),
-		EngineUnit('InteractingFacet2AABB'),
-	]),
-	StandAloneEngine('PersistentSAPCollider',{'haveDistantTransient':True}),
-	MetaEngine('InteractionGeometryMetaEngine',[
-		EngineUnit('InteractingSphere2InteractingSphere4SpheresContactGeometry'),
-	]),
-	MetaEngine('InteractionPhysicsMetaEngine',[
-		EngineUnit('SimpleElasticRelationships')
-	]),
-	DeusExMachina('RotationEngine',{'rotationAxis':[1,1,0],'angularVelocity':.001,'subscribedBodies':[1]}),
-	StandAloneEngine('ElasticContactLaw',{'useShear':False}),
-	StandAloneEngine('PeriodicPythonRunner',{'iterPeriod':10000,'command':'interInfo()'}),
-	#DeusExMachina('NewtonsDampedLaw',{'damping':0})
+	BoundingVolumeMetaEngine([InteractingSphere2AABB(),InteractingFacet2AABB()]),
+	InsertionSortCollider(),
+	InteractionGeometryMetaEngine([InteractingSphere2InteractingSphere4SpheresContactGeometry()]),
+	InteractionPhysicsMetaEngine([SimpleElasticRelationships()]),
+	RotationEngine(rotationAxis=[1,1,0],angularVelocity=.001,subscribedBodies=[1]),
+	ElasticContactLaw(useShear=False,label='elasticLaw'),
+	PeriodicPythonRunner(iterPeriod=10000,command='interInfo()'),
 ]
 O.miscParams=[
 	Generic('GLDrawSphere',{'glutUse':True})
@@ -47,7 +39,6 @@
 nIter=O.iter
 print '============= shear ============='
 O.loadTmp('init')
-ecl=[e for e in O.engines if e.name=='ElasticContactLaw'][0]
-ecl['useShear']=True
+elasticLaw['useShear']=True
 O.run(nIter,True)
 quit()

Modified: trunk/scripts/test/triax-identical-results.py
===================================================================
--- trunk/scripts/test/triax-identical-results.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/scripts/test/triax-identical-results.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -15,10 +15,10 @@
 inSph='%s-in.spheres'%sph
 if exists(inSph): print &quot;Using existing initial configuration&quot;,inSph
 else:
-	Preprocessor('TriaxialTest').load()
+	TriaxialTest(noFiles=True).load()
 	print &quot;Using new initial configuration in&quot;,inSph
 	utils.spheresToFile(inSph)
-Preprocessor('TriaxialTest',{'importFilename':inSph}).load()
+TriaxialTest(importFilename=inSph,noFiles=True).load()
 O.usesTimeStepper=False
 O.dt=utils.PWaveTimeStep()
 #
@@ -26,7 +26,10 @@
 #
 [e for e in O.engines if e.name=='ElasticContactLaw'][0]['useShear']=True
 if 1:
+	#for i in range(0,100):
+	#	#	O.save('/tmp/a.%03d.xml'%O.iter)
+	#	O.step()
 	O.run(2000,True)
 	utils.spheresToFile(outSph)
 	print &quot;Results saved to&quot;,outSph
-	quit()
+	#quit()

Added: trunk/scripts/test/wm3-wrap.py
===================================================================
--- trunk/scripts/test/wm3-wrap.py	2009-07-06 15:22:39 UTC (rev 1840)
+++ trunk/scripts/test/wm3-wrap.py	2009-07-07 11:54:14 UTC (rev 1841)
@@ -0,0 +1,27 @@
+# constructors, constants as static objects
+x,y,z,one=Vector3.UNIT_X,Vector3.UNIT_Y,Vector3.UNIT_Z,Vector3.ONE
+x2=Vector3(x)
+# conversions to sequence types
+list(x2)
+tuple(x2)
+# operations and operators
+x+y+z==one
+x.Dot(y)==z
+x.Cross(y)==0
+# methods
+one.Length()
+
+# quaternions
+# construction (implicit conversion of 3-tuple or list of length 3 to Vector3)
+q1=Quaternion((0,0,1),pi/2)
+q2=Quaternion(Vector3(0,0,1),pi/2)
+q1==q2
+# rotating vector
+q1*x==y # almost, due to rounding 
+# rotation composition
+q1*q1*x 
+# inverse rotation
+q1.Conjugate()
+# convert to axis-angle representation
+axis,angle=q1.ToAxisAngle()
+


_______________________________________________
Mailing list: <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
Post to     : <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">yade-dev at lists.launchpad.net</A>
Unsubscribe : <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
More help   : <A HREF="https://help.launchpad.net/ListHelp">https://help.launchpad.net/ListHelp</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001138.html">[deprecated list] [Yade-dev] WARNING: file %s skipped while	scanning for headers (no	module)
</A></li>
	<LI>Next message: <A HREF="001140.html">[deprecated list] [Yade-dev] [svn] r1843 - trunk/core
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1139">[ date ]</a>
              <a href="thread.html#1139">[ thread ]</a>
              <a href="subject.html#1139">[ subject ]</a>
              <a href="author.html#1139">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-dev">More information about the yade-dev
mailing list</a><br>
</body></html>
