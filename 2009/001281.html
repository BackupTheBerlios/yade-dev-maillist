<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [deprecated list] [Yade-dev] [svn] r1875 - in trunk: . core extra/tetra gui/py gui/qt3 lib lib/multimethods lib/py lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing lib/serialization lib/serialization-qt pkg/common/DataClass/BoundingVolume pkg/common/DataClass/GeometricalModel pkg/common/DataClass/InteractingGeometry pkg/common/DataClass/InteractionGeometry pkg/common/DataClass/PhysicalParameters pkg/common/DataClass/Widgets pkg/common/Engine pkg/common/Engine/DeusExMachina pkg/common/Engine/EngineUnit pkg/common/Engine/FilterEngine pkg/common/Engine/StandAloneEngine pkg/common/RenderingEngine/GLDrawGeometricalModel pkg/common/RenderingEngine/OpenGLRenderingEngine pkg/dem pkg/dem/DataClass/InteractingGeometry pkg/dem/DataClass/InteractionGeometry pkg/dem/DataClass/InteractionPhysics pkg/dem/DataClass/PhysicalParameters pkg/dem/Engine/DeusExMachina pkg/dem/Engin! e/EngineUnit pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry pkg/fem/DataClass/PhysicalParameters pkg/fem/Engine/EngineUnit pkg/fem/Engine/StandAloneEngine pkg/fem/PreProcessor pkg/lattice/DataClass/GeometricalModel pkg/lattice/DataClass/InteractionPhysics pkg/lattice/DataClass/PhysicalParameters pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor pkg/mass-spring/DataClass/InteractionGeometry pkg/mass-spring/DataClass/InteractionPhysics pkg/mass-spring/Engine/StandAloneEngine pkg/mass-spring/PreProcessor pkg/realtime-rigidbody/Engine/StandAloneEngine pkg/realtime-rigidbody/PreProcessor pkg/snow/DataClass pkg/snow/Engine pkg/snow/PreProcessor py py/yadeWrapper scripts/test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-dev/2009/index.html" >
   <LINK REL="made" HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1875%20-%20in%20trunk%3A%20.%20core%0A%20extra/tetra%20gui/py%20gui/qt3%20lib%20lib/multimethods%20lib/py%0A%20lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders%0A%20lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite%0A%20lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing%0A%20lib/serialization%20lib/serialization-qt%20pkg/common/DataClass/BoundingVolume%0A%20pkg/common/DataClass/GeometricalModel%0A%20pkg/common/DataClass/InteractingGeometry%0A%20pkg/common/DataClass/InteractionGeometry%0A%20pkg/common/DataClass/PhysicalParameters%20pkg/common/DataClass/Widgets%0A%20pkg/common/Engine%20pkg/common/Engine/DeusExMachina%0A%20pkg/common/Engine/EngineUnit%20pkg/common/Engine/FilterEngine%0A%20pkg/common/Engine/StandAloneEngine%0A%20pkg/common/RenderingEngine/GLDrawGeometricalModel%0A%20pkg/common/RenderingEngine/OpenGLRenderingEngine%20pkg/dem%0A%20pkg/dem/DataClass/InteractingGeometry%20pkg/dem/DataClass/InteractionGeometry%0A%20pkg/dem/DataClass/InteractionPhysics%20pkg/dem/DataClass/PhysicalParameters%0A%20pkg/dem/Engine/DeusExMachina%20pkg/dem/Engin%21%20e/EngineUnit%0A%20pkg/dem/Engine/StandAloneEngine%20pkg/dem/PreProcessor%0A%20pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry%0A%20pkg/fem/DataClass/PhysicalParameters%20pkg/fem/Engine/EngineUnit%0A%20pkg/fem/Engine/StandAloneEngine%20pkg/fem/PreProcessor%0A%20pkg/lattice/DataClass/GeometricalModel%0A%20pkg/lattice/DataClass/InteractionPhysics%0A%20pkg/lattice/DataClass/PhysicalParameters%0A%20pkg/lattice/Engine/StandAloneEngine%20pkg/lattice/PreProcessor%0A%20pkg/mass-spring/DataClass/InteractionGeometry%0A%20pkg/mass-spring/DataClass/InteractionPhysics%0A%20pkg/mass-spring/Engine/StandAloneEngine%20pkg/mass-spring/PreProcessor%0A%20pkg/realtime-rigidbody/Engine/StandAloneEngine%0A%20pkg/realtime-rigidbody/PreProcessor%20pkg/snow/DataClass%20pkg/snow/Engine%0A%20pkg/snow/PreProcessor%20py%20py/yadeWrapper%20scripts/test&In-Reply-To=%3C200907172151.n6HLp904002530%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001245.html">
   <LINK REL="Next"  HREF="001246.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[deprecated list] [Yade-dev] [svn] r1875 - in trunk: . core extra/tetra gui/py gui/qt3 lib lib/multimethods lib/py lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing lib/serialization lib/serialization-qt pkg/common/DataClass/BoundingVolume pkg/common/DataClass/GeometricalModel pkg/common/DataClass/InteractingGeometry pkg/common/DataClass/InteractionGeometry pkg/common/DataClass/PhysicalParameters pkg/common/DataClass/Widgets pkg/common/Engine pkg/common/Engine/DeusExMachina pkg/common/Engine/EngineUnit pkg/common/Engine/FilterEngine pkg/common/Engine/StandAloneEngine pkg/common/RenderingEngine/GLDrawGeometricalModel pkg/common/RenderingEngine/OpenGLRenderingEngine pkg/dem pkg/dem/DataClass/InteractingGeometry pkg/dem/DataClass/InteractionGeometry pkg/dem/DataClass/InteractionPhysics pkg/dem/DataClass/PhysicalParameters pkg/dem/Engine/DeusExMachina pkg/dem/Engin! e/EngineUnit pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry pkg/fem/DataClass/PhysicalParameters pkg/fem/Engine/EngineUnit pkg/fem/Engine/StandAloneEngine pkg/fem/PreProcessor pkg/lattice/DataClass/GeometricalModel pkg/lattice/DataClass/InteractionPhysics pkg/lattice/DataClass/PhysicalParameters pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor pkg/mass-spring/DataClass/InteractionGeometry pkg/mass-spring/DataClass/InteractionPhysics pkg/mass-spring/Engine/StandAloneEngine pkg/mass-spring/PreProcessor pkg/realtime-rigidbody/Engine/StandAloneEngine pkg/realtime-rigidbody/PreProcessor pkg/snow/DataClass pkg/snow/Engine pkg/snow/PreProcessor py py/yadeWrapper scripts/test</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1875%20-%20in%20trunk%3A%20.%20core%0A%20extra/tetra%20gui/py%20gui/qt3%20lib%20lib/multimethods%20lib/py%0A%20lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders%0A%20lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite%0A%20lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing%0A%20lib/serialization%20lib/serialization-qt%20pkg/common/DataClass/BoundingVolume%0A%20pkg/common/DataClass/GeometricalModel%0A%20pkg/common/DataClass/InteractingGeometry%0A%20pkg/common/DataClass/InteractionGeometry%0A%20pkg/common/DataClass/PhysicalParameters%20pkg/common/DataClass/Widgets%0A%20pkg/common/Engine%20pkg/common/Engine/DeusExMachina%0A%20pkg/common/Engine/EngineUnit%20pkg/common/Engine/FilterEngine%0A%20pkg/common/Engine/StandAloneEngine%0A%20pkg/common/RenderingEngine/GLDrawGeometricalModel%0A%20pkg/common/RenderingEngine/OpenGLRenderingEngine%20pkg/dem%0A%20pkg/dem/DataClass/InteractingGeometry%20pkg/dem/DataClass/InteractionGeometry%0A%20pkg/dem/DataClass/InteractionPhysics%20pkg/dem/DataClass/PhysicalParameters%0A%20pkg/dem/Engine/DeusExMachina%20pkg/dem/Engin%21%20e/EngineUnit%0A%20pkg/dem/Engine/StandAloneEngine%20pkg/dem/PreProcessor%0A%20pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry%0A%20pkg/fem/DataClass/PhysicalParameters%20pkg/fem/Engine/EngineUnit%0A%20pkg/fem/Engine/StandAloneEngine%20pkg/fem/PreProcessor%0A%20pkg/lattice/DataClass/GeometricalModel%0A%20pkg/lattice/DataClass/InteractionPhysics%0A%20pkg/lattice/DataClass/PhysicalParameters%0A%20pkg/lattice/Engine/StandAloneEngine%20pkg/lattice/PreProcessor%0A%20pkg/mass-spring/DataClass/InteractionGeometry%0A%20pkg/mass-spring/DataClass/InteractionPhysics%0A%20pkg/mass-spring/Engine/StandAloneEngine%20pkg/mass-spring/PreProcessor%0A%20pkg/realtime-rigidbody/Engine/StandAloneEngine%0A%20pkg/realtime-rigidbody/PreProcessor%20pkg/snow/DataClass%20pkg/snow/Engine%0A%20pkg/snow/PreProcessor%20py%20py/yadeWrapper%20scripts/test&In-Reply-To=%3C200907172151.n6HLp904002530%40sheep.berlios.de%3E"
       TITLE="[deprecated list] [Yade-dev] [svn] r1875 - in trunk: . core extra/tetra gui/py gui/qt3 lib lib/multimethods lib/py lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing lib/serialization lib/serialization-qt pkg/common/DataClass/BoundingVolume pkg/common/DataClass/GeometricalModel pkg/common/DataClass/InteractingGeometry pkg/common/DataClass/InteractionGeometry pkg/common/DataClass/PhysicalParameters pkg/common/DataClass/Widgets pkg/common/Engine pkg/common/Engine/DeusExMachina pkg/common/Engine/EngineUnit pkg/common/Engine/FilterEngine pkg/common/Engine/StandAloneEngine pkg/common/RenderingEngine/GLDrawGeometricalModel pkg/common/RenderingEngine/OpenGLRenderingEngine pkg/dem pkg/dem/DataClass/InteractingGeometry pkg/dem/DataClass/InteractionGeometry pkg/dem/DataClass/InteractionPhysics pkg/dem/DataClass/PhysicalParameters pkg/dem/Engine/DeusExMachina pkg/dem/Engin! e/EngineUnit pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry pkg/fem/DataClass/PhysicalParameters pkg/fem/Engine/EngineUnit pkg/fem/Engine/StandAloneEngine pkg/fem/PreProcessor pkg/lattice/DataClass/GeometricalModel pkg/lattice/DataClass/InteractionPhysics pkg/lattice/DataClass/PhysicalParameters pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor pkg/mass-spring/DataClass/InteractionGeometry pkg/mass-spring/DataClass/InteractionPhysics pkg/mass-spring/Engine/StandAloneEngine pkg/mass-spring/PreProcessor pkg/realtime-rigidbody/Engine/StandAloneEngine pkg/realtime-rigidbody/PreProcessor pkg/snow/DataClass pkg/snow/Engine pkg/snow/PreProcessor py py/yadeWrapper scripts/test">eudoxos at mail.berlios.de
       </A><BR>
    <I>Fri Jul 17 23:51:09 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001245.html">[deprecated list] [Yade-dev] yade crash launching xml
</A></li>
        <LI>Next message: <A HREF="001246.html">[deprecated list] [Yade-dev] small changes in lots of code	(attribute registration)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1281">[ date ]</a>
              <a href="thread.html#1281">[ thread ]</a>
              <a href="subject.html#1281">[ subject ]</a>
              <a href="author.html#1281">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2009-07-17 23:50:55 +0200 (Fri, 17 Jul 2009)
New Revision: 1875

Added:
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/indexing_slice.cpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/python_iterator.cpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/algorithms.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_proxy.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_suite.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_traits.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/deque.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy_traits.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/int_slice_helper.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_range.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_traits.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/list.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/map.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/methods.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/multimap.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/pair.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/proxy_iterator.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/python_iterator.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/readme.txt
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/set.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/shared_proxy_impl.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice_handler.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/suite_utils.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/value_traits.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/vector.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/visitor.hpp
   trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/workaround.hpp
   trunk/py/yadeWrapper/customConverters.cpp
   trunk/scripts/test/gts-triax-pack-obb.py
Modified:
   trunk/SConstruct
   trunk/core/InteractingGeometry.cpp
   trunk/core/InteractingGeometry.hpp
   trunk/core/InteractionContainer.cpp
   trunk/core/InteractionGeometry.hpp
   trunk/core/InteractionPhysics.hpp
   trunk/core/TimeStepper.cpp
   trunk/core/TimeStepper.hpp
   trunk/extra/tetra/Tetra.hpp
   trunk/extra/tetra/TetraTestGen.hpp
   trunk/gui/py/PythonUI_rc.py
   trunk/gui/py/pyAttrUtils.hpp
   trunk/gui/qt3/QtGUIPreferences.cpp
   trunk/gui/qt3/QtGUIPreferences.hpp
   trunk/gui/qt3/SnapshotEngine.hpp
   trunk/lib/SConscript
   trunk/lib/multimethods/DynLibDispatcher.hpp
   trunk/lib/py/README
   trunk/lib/serialization-qt/QtGUIGenerator.cpp
   trunk/lib/serialization/MultiTypeHandler.tpp
   trunk/lib/serialization/Serializable.hpp
   trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.cpp
   trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.hpp
   trunk/pkg/common/DataClass/GeometricalModel/Box.cpp
   trunk/pkg/common/DataClass/GeometricalModel/Box.hpp
   trunk/pkg/common/DataClass/GeometricalModel/BshTube.cpp
   trunk/pkg/common/DataClass/GeometricalModel/BshTube.hpp
   trunk/pkg/common/DataClass/GeometricalModel/Facet.cpp
   trunk/pkg/common/DataClass/GeometricalModel/Facet.hpp
   trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.cpp
   trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.hpp
   trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.cpp
   trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.hpp
   trunk/pkg/common/DataClass/GeometricalModel/Sphere.cpp
   trunk/pkg/common/DataClass/GeometricalModel/Sphere.hpp
   trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.cpp
   trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.hpp
   trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.cpp
   trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.hpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.cpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.hpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.cpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.hpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.cpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.hpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.cpp
   trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.hpp
   trunk/pkg/common/DataClass/InteractionGeometry/ClosestFeatures.cpp
   trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.cpp
   trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.hpp
   trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.cpp
   trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.hpp
   trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.cpp
   trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.hpp
   trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.cpp
   trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.hpp
   trunk/pkg/common/DataClass/Widgets/ColorScale.cpp
   trunk/pkg/common/DataClass/Widgets/ColorScale.hpp
   trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/GravityEngines.hpp
   trunk/pkg/common/Engine/DeusExMachina/JumpChangeSe3.hpp
   trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/RotationEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/RotationEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.hpp
   trunk/pkg/common/Engine/EngineUnit/CundallNonViscousDamping.hpp
   trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp
   trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.hpp
   trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.cpp
   trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.hpp
   trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.cpp
   trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.hpp
   trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.cpp
   trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.hpp
   trunk/pkg/common/Engine/FilterEngine/FilterEngine.hpp
   trunk/pkg/common/Engine/FilterEngine/PythonRunnerFilter.hpp
   trunk/pkg/common/Engine/ParallelEngine.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PeriodicEngines.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.hpp
   trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.cpp
   trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.hpp
   trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.hpp
   trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.hpp
   trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp
   trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp
   trunk/pkg/dem/ConcretePM.cpp
   trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.cpp
   trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.hpp
   trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.cpp
   trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.hpp
   trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp
   trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp
   trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.hpp
   trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.hpp
   trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.hpp
   trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp
   trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.hpp
   trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.cpp
   trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.hpp
   trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.cpp
   trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.hpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp
   trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp
   trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp
   trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp
   trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.hpp
   trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.hpp
   trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.hpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.hpp
   trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.hpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.hpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.hpp
   trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp
   trunk/pkg/dem/PreProcessor/DirectShearCis.cpp
   trunk/pkg/dem/PreProcessor/DirectShearCis.hpp
   trunk/pkg/dem/PreProcessor/Funnel.cpp
   trunk/pkg/dem/PreProcessor/Funnel.hpp
   trunk/pkg/dem/PreProcessor/HydraulicTest.cpp
   trunk/pkg/dem/PreProcessor/HydraulicTest.hpp
   trunk/pkg/dem/PreProcessor/MembraneTest.cpp
   trunk/pkg/dem/PreProcessor/MembraneTest.hpp
   trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.hpp
   trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp
   trunk/pkg/dem/PreProcessor/SDECImpactTest.hpp
   trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp
   trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.hpp
   trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp
   trunk/pkg/dem/PreProcessor/SDECMovingWall.hpp
   trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp
   trunk/pkg/dem/PreProcessor/SDECSpheresPlane.hpp
   trunk/pkg/dem/PreProcessor/STLImporterTest.cpp
   trunk/pkg/dem/PreProcessor/STLImporterTest.hpp
   trunk/pkg/dem/PreProcessor/SimpleScene.hpp
   trunk/pkg/dem/PreProcessor/SimpleShear.cpp
   trunk/pkg/dem/PreProcessor/SimpleShear.hpp
   trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp
   trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.hpp
   trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp
   trunk/pkg/dem/PreProcessor/TetrahedronsTest.hpp
   trunk/pkg/dem/PreProcessor/ThreePointBending.cpp
   trunk/pkg/dem/PreProcessor/ThreePointBending.hpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.hpp
   trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp
   trunk/pkg/dem/PreProcessor/UniaxialStrainerGen.hpp
   trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.hpp
   trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.cpp
   trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.hpp
   trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.cpp
   trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.hpp
   trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.cpp
   trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.hpp
   trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp
   trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.hpp
   trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.cpp
   trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.hpp
   trunk/pkg/fem/PreProcessor/FEMBeam.cpp
   trunk/pkg/fem/PreProcessor/FEMBeam.hpp
   trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.cpp
   trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.hpp
   trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.cpp
   trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.hpp
   trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.cpp
   trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.hpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.cpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.hpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.cpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.hpp
   trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.hpp
   trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.hpp
   trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.hpp
   trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.hpp
   trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.hpp
   trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.hpp
   trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.hpp
   trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExample.hpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.hpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.hpp
   trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.cpp
   trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.hpp
   trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.cpp
   trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.hpp
   trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp
   trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.hpp
   trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp
   trunk/pkg/mass-spring/PreProcessor/HangingCloth.hpp
   trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp
   trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.hpp
   trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp
   trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.hpp
   trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp
   trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.hpp
   trunk/pkg/snow/DataClass/BshSnowGrain.cpp
   trunk/pkg/snow/DataClass/BshSnowGrain.hpp
   trunk/pkg/snow/DataClass/BssSnowGrain.cpp
   trunk/pkg/snow/DataClass/BssSnowGrain.hpp
   trunk/pkg/snow/DataClass/IstSnowLayersContact.cpp
   trunk/pkg/snow/DataClass/IstSnowLayersContact.hpp
   trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.cpp
   trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.hpp
   trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp
   trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.hpp
   trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp
   trunk/pkg/snow/Engine/ElawSnowLayersDeformation.hpp
   trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp
   trunk/pkg/snow/PreProcessor/SnowCreepTest.hpp
   trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp
   trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.hpp
   trunk/py/SConscript
   trunk/py/utils.py
   trunk/py/yadeWrapper/yadeWrapper.cpp
   trunk/scripts/test/facet-sphere.py
Log:
1. Do not use REGISTER_ATTRIBUTE anymore, use REGISTER_ATTRIBUTES instead everywhere. This generates (in addition to serialization code) also some python code and makes python independent on the yade serialization framework (Janek, if you want to try boost::serialization, I have no objections now).

	Please check your code that it works. I was moving attribute registration to .hpp files and hopefully nothing broke. Sorry for inconvenience.

2. As said, python is now completely independent of serialization and passes value not by strings, but by real variables, doing appropriate conversions thanks to boost::python magic. This should make it also faster and much more robust.
3. Custom coverters handle vector&lt;int&gt;, vector&lt;Vector3r&gt;, vector&lt;Real&gt;, vector&lt;string&gt; and other can be added easily.
4. All fundamental types are converted automatically.
5. Add conversions for se3 as tuple of Vector3,Quaternion
6. Add non-standard boost::python indexing suite version 2 to our code (although it is not used ATM).



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/SConstruct	2009-07-17 21:50:55 UTC (rev 1875)
@@ -469,6 +469,7 @@
 				except ValueError: pass
 			# exclude non-lib directories (like doc, scripts, ...)
 			if not re.match(r'\.[/\\](core|lib|pkg|gui|extra)[/\\]?.*',root): continue
+			if 'noSymlinkHeaders' in root: continue
 			# exclude headers from excluded stuff
 			if re.match(r'^.*/('+'|'.join(env['exclude'])+')/',root): continue
 			for f in files:
@@ -507,15 +508,16 @@
 	installHeaders() # install to buildDir always
 	if 0: # do not install headers
 		installHeaders(env.subst('$PREFIX')) # install to $PREFIX if specifically requested: like &quot;scons /usr/local/include&quot;
+	boostDir=buildDir+'/include/yade-'+env['version']+'/boost'
+	if not exists(boostDir): os.makedirs(boostDir)
+	def mkSymlink(link,target):
+		if not exists(link):
+			if lexists(link): os.remove(link) # remove dangling symlink
+			os.symlink(relpath(link,target),link)
 	if not env['haveForeach']:
-		boostDir=buildDir+'/include/yade-'+env['version']+'/boost'
-		foreachLink=boostDir+'/foreach.hpp'
-		foreachTarget='extra/foreach.hpp_local'
-		if not exists(boostDir): os.makedirs(boostDir)
-		if not exists(foreachLink): 
-			if lexists(foreachLink): os.remove(foreachLink) # broken symlink: remove it
-			os.symlink(relpath(foreachLink,foreachTarget),foreachLink)
-		env.InstallAs(env['PREFIX']+'/include/yade-'+env['version']+'/boost/foreach.hpp',foreachTarget)
+		mkSymlink(boostDir+'/foreach.hpp','extra/foreach.hpp_local')
+	mkSymlink(boostDir+'/python','lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders')
+	#env.InstallAs(env['PREFIX']+'/include/yade-'+env['version']+'/boost/foreach.hpp',foreachTarget)
 	env.Default(env.Alias('install',instDirs)) # build and install everything that should go to instDirs, which are $PREFIX/{bin,lib} (uses scons' Install)
 
 env.Export('env');

Modified: trunk/core/InteractingGeometry.cpp
===================================================================
--- trunk/core/InteractingGeometry.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/core/InteractingGeometry.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -9,4 +9,3 @@
 *************************************************************************/
 
 #include &quot;InteractingGeometry.hpp&quot;
-

Modified: trunk/core/InteractingGeometry.hpp
===================================================================
--- trunk/core/InteractingGeometry.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/core/InteractingGeometry.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -32,7 +32,7 @@
 		#ifdef BV_FUNCTOR_CACHE
 			shared_ptr&lt;BoundingVolumeEngineUnit&gt; boundFunctor;
 		#endif
-	
+
 /// Serialization
 	REGISTER_ATTRIBUTES(/*no base*/,(diffuseColor));
 	REGISTER_CLASS_AND_BASE(InteractingGeometry,Serializable Indexable);

Modified: trunk/core/InteractionContainer.cpp
===================================================================
--- trunk/core/InteractionContainer.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/core/InteractionContainer.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -26,7 +26,7 @@
 		// shadow this-&gt;pendingErase by the local variable, to share code
 		FOREACH(list&lt;bodyIdPair&gt;&amp; pendingErase, threadsPendingErase){
 	#endif
-			if(pendingErase.size()&gt;0){
+			if(!pendingErase.empty()){
 				FOREACH(const bodyIdPair&amp; p, pendingErase){ ret++; erase(p[0],p[1]); }
 				pendingErase.clear();
 			}

Modified: trunk/core/InteractionGeometry.hpp
===================================================================
--- trunk/core/InteractionGeometry.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/core/InteractionGeometry.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,6 +17,7 @@
 	REGISTER_CLASS_NAME(InteractionGeometry);
 	REGISTER_BASE_CLASS_NAME(Serializable Indexable);
 	REGISTER_INDEX_COUNTER(InteractionGeometry);
+	REGISTER_ATTRIBUTES(/* no base class*/,/*no attributes either*/); // keep this line here
 };
 
 REGISTER_SERIALIZABLE(InteractionGeometry);

Modified: trunk/core/InteractionPhysics.hpp
===================================================================
--- trunk/core/InteractionPhysics.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/core/InteractionPhysics.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -16,10 +16,9 @@
 {
 	REGISTER_CLASS_NAME(InteractionPhysics);
 	REGISTER_BASE_CLASS_NAME(Serializable Indexable);
-
 	REGISTER_INDEX_COUNTER(InteractionPhysics);
+	REGISTER_ATTRIBUTES(/* no base for attributes */,/* no attributes either */);
 };
-
 REGISTER_SERIALIZABLE(InteractionPhysics);
 
 

Modified: trunk/core/TimeStepper.cpp
===================================================================
--- trunk/core/TimeStepper.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/core/TimeStepper.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,14 +25,7 @@
 }
 
 
-void TimeStepper::registerAttributes()
-{
-	StandAloneEngine::registerAttributes();
-	REGISTER_ATTRIBUTE(active);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-}
 
-
 void TimeStepper::setActive(bool a, int nb)
 {
 	active = a; 

Modified: trunk/core/TimeStepper.hpp
===================================================================
--- trunk/core/TimeStepper.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/core/TimeStepper.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,8 +27,7 @@
 		virtual void action(MetaBody* b) { computeTimeStep(b);} ;
 		void setActive(bool a, int nb=-1);
 
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(StandAloneEngine,(active)(timeStepUpdateInterval));
 	REGISTER_CLASS_AND_BASE(TimeStepper,StandAloneEngine);
 };
 

Modified: trunk/extra/tetra/Tetra.hpp
===================================================================
--- trunk/extra/tetra/Tetra.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/extra/tetra/Tetra.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,9 +31,8 @@
 		TetraMold(Vector3r v0, Vector3r v1, Vector3r v2, Vector3r v3){createIndex(); v.resize(4); v[0]=v0; v[1]=v1; v[2]=v2; v[3]=v3; }
 		virtual ~TetraMold (){};
 	protected:
-		void registerAttributes(){InteractingGeometry::registerAttributes(); REGISTER_ATTRIBUTE(v);}
-		REGISTER_CLASS_NAME(TetraMold);
-		REGISTER_BASE_CLASS_NAME(InteractingGeometry);
+		REGISTER_ATTRIBUTES(InteractingGeometry,(v));
+		REGISTER_CLASS_AND_BASE(TetraMold,InteractingGeometry);
 		REGISTER_CLASS_INDEX(TetraMold,InteractingGeometry);
 };
 REGISTER_SERIALIZABLE(TetraMold);
@@ -55,15 +54,9 @@
 		TetraBang(): InteractionGeometry(){};
 		virtual ~TetraBang(){};
 	protected:
-		void registerAttributes(){ InteractionGeometry::registerAttributes();
-			REGISTER_ATTRIBUTE(penetrationVolume); REGISTER_ATTRIBUTE(equivalentCrossSection);
-			REGISTER_ATTRIBUTE(contactPoint); REGISTER_ATTRIBUTE(normal);
-			REGISTER_ATTRIBUTE(equivalentPenetrationDepth);
-			REGISTER_ATTRIBUTE(maxPenetrationDepthA); REGISTER_ATTRIBUTE(maxPenetrationDepthB);
-		}
+		REGISTER_ATTRIBUTES(InteractionGeometry,(penetrationVolume)(equivalentCrossSection)(contactPoint)(normal)(equivalentPenetrationDepth)(maxPenetrationDepthA)(maxPenetrationDepthB));
 		FUNCTOR2D(TetraMold,TetraMold);
-		REGISTER_CLASS_NAME(TetraBang);
-		REGISTER_BASE_CLASS_NAME(InteractionGeometry);
+		REGISTER_CLASS_AND_BASE(TetraBang,InteractionGeometry);
 };
 REGISTER_SERIALIZABLE(TetraBang);
 
@@ -136,11 +129,10 @@
 
 		void action(MetaBody*);
 
-		DECLARE_LOGGER;
-	protected:
-		void registerAttributes(){InteractionSolver::registerAttributes(); /* &#8230; */ }
-		REGISTER_CLASS_NAME(TetraLaw);
-		REGISTER_BASE_CLASS_NAME(InteractionSolver);
+	DECLARE_LOGGER;
+	REGISTER_ATTRIBUTES(InteractionSolver,/* nothing*/);
+	REGISTER_CLASS_NAME(TetraLaw);
+	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };
 REGISTER_SERIALIZABLE(TetraLaw);
 

Modified: trunk/extra/tetra/TetraTestGen.hpp
===================================================================
--- trunk/extra/tetra/TetraTestGen.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/extra/tetra/TetraTestGen.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -14,9 +14,8 @@
 		bool generate();
 	protected :
 		virtual void postProcessAttributes(bool deserializing){};
-		void registerAttributes(){FileGenerator::registerAttributes(); REGISTER_ATTRIBUTE(gridSize);}
-		REGISTER_CLASS_NAME(TetraTestGen);
-		REGISTER_BASE_CLASS_NAME(FileGenerator);
+		REGISTER_ATTRIBUTES(FileGenerator,(gridSize));
+		REGISTER_CLASS_AND_BASE(TetraTestGen,FileGenerator);
 };
 REGISTER_SERIALIZABLE(TetraTestGen);
 

Modified: trunk/gui/py/PythonUI_rc.py
===================================================================
--- trunk/gui/py/PythonUI_rc.py	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/gui/py/PythonUI_rc.py	2009-07-17 21:50:55 UTC (rev 1875)
@@ -10,6 +10,7 @@
 from math import *
 from miniWm3Wrap import *
 from yade.wrapper import *
+from yade._customConverters import *
 from yade import runtime
 from yade import utils
 __builtins__.O=Omega()

Modified: trunk/gui/py/pyAttrUtils.hpp
===================================================================
--- trunk/gui/py/pyAttrUtils.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/gui/py/pyAttrUtils.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -1,4 +1,4 @@
-// 2007,2008 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
+// 2007,2008,2009 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
 #include&lt;sstream&gt;
 #include&lt;boost/any.hpp&gt;
 #include&lt;map&gt;
@@ -16,60 +16,48 @@
 using namespace std;
 using namespace boost;
 
-/*! Define inline proxy functions that access attributes of some object associated with this class.
- * \param accessor is an shared_ptr&lt;AttrAccess&gt; (or AttrAccess*), properly initialized and associated with the object of your choice
- * \param ensureFunc is member function called before every attribute access. It typically would check whether acessor is not NULL, otherwise instantiate it.
+/*! Define proxy functions that access attributes of the proxee object associated with this class.
  */
-#define ATTR_ACCESS_CXX(accessor,ensureFunc) \
-	boost::python::object wrappedPyGet(const std::string&amp; key){ensureFunc();return accessor-&gt;pyGet(key);} \
-	void wrappedPySet(const std::string&amp; key, const python::object&amp; val){ensureFunc(); accessor-&gt;pySet(key,val);} \
-	string wrappedGetAttrStr(const std::string&amp; key){ensureFunc();vector&lt;string&gt; a=accessor-&gt;getAttrStr(key); string ret(&quot;[&quot;); FOREACH(string s, a) ret+=s+&quot; &quot;; return ret+&quot;]&quot;;} \
-	void wrappedSetAttrStr(const std::string&amp; key, const std::string&amp; val){ensureFunc();return accessor-&gt;setAttrStr(key,val);} \
-	boost::python::list wrappedPyKeys(){ensureFunc(); return accessor-&gt;pyKeys();} \
-	boost::python::dict wrappedPyDict(){ensureFunc(); return accessor-&gt;pyDict();} \
-	bool wrappedPyHasKey(const std::string&amp; key){ensureFunc(); return accessor-&gt;descriptors.find(key)!=accessor-&gt;descriptors.end();} \
-	python::list wrappedUpdateExistingAttrs(const python::dict&amp; d){ python::list ret; ensureFunc(); python::list keys=d.keys(); size_t ll=python::len(keys); for(size_t i=0; i&lt;ll; i++){ string key=python::extract&lt;string&gt;(keys[i]); if(wrappedPyHasKey(key)) accessor-&gt;pySet(key,d[keys[i]]); else ret.append(key); } return ret; } \
-	void wrappedUpdateAttrs(const python::dict&amp; d){ ensureFunc(); python::list keys=d.keys(); size_t ll=python::len(keys); for(size_t i=0; i&lt;ll; i++){ string key=python::extract&lt;string&gt;(keys[i]); accessor-&gt;pySet(key,d[keys[i]]); } }
+#define ATTR_ACCESS_CXX() \
+	python::object wrappedPyGetAttr2(const string&amp; key) const {return proxee-&gt;pyGetAttr(key);}\
+	void wrappedPySetAttr2(const string&amp; key, const python::object&amp; value){proxee-&gt;pySetAttr(key,value);}\
+	python::list wrappedPyKeys2() const {return proxee-&gt;pyKeys();}\
+	bool wrappedPyHasKey2(const string&amp; key) const {return proxee-&gt;pyHasKey(key);}\
+	python::dict wrappedPyDict2() const {return proxee-&gt;pyDict();}  \
+	python::list wrappedUpdateExistingAttrs2(const python::dict&amp; d){ python::list ret; python::list l=d.items(); size_t ll=python::len(l); for(size_t i=0; i&lt;ll; i++){ python::tuple t=python::extract&lt;python::tuple&gt;(l[i]); string key=python::extract&lt;string&gt;(t[0]); if(wrappedPyHasKey2(key)) wrappedPySetAttr2(key,t[1]); else ret.append(t[0]); } return ret; } \
+	void wrappedUpdateAttrs2(const python::dict&amp; d){ python::list l=d.items(); size_t ll=python::len(l); for(size_t i=0; i&lt;ll; i++){ python::tuple t=python::extract&lt;python::tuple&gt;(l[i]); string key=python::extract&lt;string&gt;(t[0]); wrappedPySetAttr2(key,t[1]); } }
 	
-	
-	//boost::python::object wrappedPyGet_throw(std::string key){ensureFunc(); if(wrappedPyHasKey(key)) return accessor-&gt;pyGet(key); PyErr_SetString(PyExc_AttributeError, &quot;No such attribute.&quot;); boost::python::throw_error_already_set(); /* make compiler happy*/ return boost::python::object(); }
 
-
 /*! Python special functions complementing proxies defined by ATTR_ACCESS_CXX, to be used with boost::python::class_&lt;&gt;.
  *
  * They define python special functions that support dictionary operations on this object and calls proxies for them. */
 #define ATTR_ACCESS_PY(cxxClass) \
-	def(&quot;__getitem__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setitem__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;keys&quot;,&amp;cxxClass::wrappedPyKeys).def(&quot;has_key&quot;,&amp;cxxClass::wrappedPyHasKey).def(&quot;dict&quot;,&amp;cxxClass::wrappedPyDict) \
-	.def(&quot;getRaw&quot;,&amp;cxxClass::wrappedGetAttrStr).def(&quot;setRaw&quot;,&amp;cxxClass::wrappedSetAttrStr).def(&quot;updateExistingAttrs&quot;,&amp;cxxClass::wrappedUpdateExistingAttrs,&quot;Update attributes from given dictionary, but skpping attribues that do not exist in the wrapped class; return list of names of attributes that were not set.&quot;).def(&quot;updateAttrs&quot;,&amp;cxxClass::wrappedUpdateAttrs,&quot;Update attributes from given dictionary; all attributes must exist.&quot;)
-	//def(&quot;__getattr__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setattr__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;attrs&quot;,&amp;cxxClass::wrappedPyKeys)
+	def(&quot;__getitem__&quot;,&amp;cxxClass::wrappedPyGetAttr2).def(&quot;__setitem__&quot;,&amp;cxxClass::wrappedPySetAttr2).def(&quot;keys&quot;,&amp;cxxClass::wrappedPyKeys2).def(&quot;has_key&quot;,&amp;cxxClass::wrappedPyHasKey2).def(&quot;dict&quot;,&amp;cxxClass::wrappedPyDict2).def(&quot;updateExistingAttrs&quot;,&amp;cxxClass::wrappedUpdateExistingAttrs2).def(&quot;updateAttrs&quot;,&amp;cxxClass::wrappedUpdateAttrs2)
 
-	//.def(&quot;__getattribute__&quot;,&amp;cxxClass::wrappedPyGet_throw)
-
 #define BASIC_PY_PROXY_HEAD(pyClass,yadeClass) \
-class pyClass{shared_ptr&lt;AttrAccess&gt; accessor; \
+class pyClass{ \
 	private: void init(string clss){ proxee=dynamic_pointer_cast&lt;yadeClass&gt;(ClassFactory::instance().createShared(clss.empty()? #yadeClass : clss)); if(!proxee) throw runtime_error(&quot;Invalid class `&quot;+clss+&quot;': either nonexistent, or unable to cast to `&quot;+#yadeClass+&quot;'&quot;); } \
 	public: shared_ptr&lt;yadeClass&gt; proxee; \
-		void ensureAcc(void){ if(!proxee) throw runtime_error(string(&quot;No proxied `&quot;)+#yadeClass+&quot;'.&quot;); if(!accessor) accessor=shared_ptr&lt;AttrAccess&gt;(new AttrAccess(proxee));} \
-		pyClass(string clss=&quot;&quot;, python::dict attrs=python::dict()){ init(clss); python::list l=attrs.items(); int len=PySequence_Size(l.ptr()); for(int i=0; i&lt;len; i++){ python::extract&lt;python::tuple&gt; t(l[i]); python::extract&lt;string&gt; keyEx(t()[0]); if(!keyEx.check()) throw invalid_argument(&quot;Attribute keys must be strings.&quot;); wrappedPySet(keyEx(),t()[1]); } } \
+		/* void ensureProxee(){ if(!proxee) throw runtime_error(string(&quot;No proxied `&quot;)+#yadeClass+&quot;' (programming error, please report!)&quot;); } */ \
+		pyClass(string clss=&quot;&quot;, python::dict attrs=python::dict()){ init(clss); python::list l=attrs.items(); int len=PySequence_Size(l.ptr()); for(int i=0; i&lt;len; i++){ python::extract&lt;python::tuple&gt; t(l[i]); python::extract&lt;string&gt; keyEx(t()[0]); if(!keyEx.check()) throw invalid_argument(&quot;Attribute keys must be strings.&quot;); wrappedPySetAttr2(keyEx(),t()[1]); } } \
 		pyClass(const shared_ptr&lt;yadeClass&gt;&amp; _proxee): proxee(_proxee) {} \
-		std::string pyStr(void){ ensureAcc(); return string(proxee-&gt;getClassName()==#yadeClass ? &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot;&gt;&quot; : &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot; &quot;+ #yadeClass +&quot;&gt;&quot;); } \
-		string className(void){ ensureAcc(); return proxee-&gt;getClassName(); } \
-		void postProcessAttributes(void){ensureAcc(); static_pointer_cast&lt;Serializable&gt;(proxee)-&gt;/*<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">__HACK__D at _N</A>@T_ABUSE_*/postProcessAttributes(/*deserializing*/ true); } \
-		ATTR_ACCESS_CXX(accessor,ensureAcc);
+		std::string pyStr(void){ return string(proxee-&gt;getClassName()==#yadeClass ? &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot;&gt;&quot; : &quot;&lt;&quot;+proxee-&gt;getClassName()+&quot; &quot;+ #yadeClass +&quot;&gt;&quot;); } \
+		string className(void){ return proxee-&gt;getClassName(); } \
+		void postProcessAttributes(void){ static_pointer_cast&lt;Serializable&gt;(proxee)-&gt;postProcessAttributes(/*deserializing*/ true); } \
+		ATTR_ACCESS_CXX();
 
 #define BASIC_PY_PROXY_TAIL };
 /*! Basic implementation of python proxy class that provides:
  * 1. constructor with (optional) class name and (optional) dictionary of attributes
  * 2. copy constructor from another proxy class
  * 3. className() returning proxy class name as string 
- * 4. ensureAcc() that makes sure we have proxy _and_ attribute access things ready
  */
 #define BASIC_PY_PROXY(pyClass,yadeClass) BASIC_PY_PROXY_HEAD(pyClass,yadeClass) BASIC_PY_PROXY_TAIL
 
 /* Read-write access to some attribute that is not basic-serializable, i.e. must be exported as instance.attribute (not instance['attribute']. That attribute is wrapped in given python class before it is returned. */
 #define NONPOD_ATTRIBUTE_ACCESS(pyName,pyClass,yadeName) \
-	python::object pyName##_get(void){ensureAcc(); return proxee-&gt;yadeName ? python::object(pyClass(proxee-&gt;yadeName)) : python::object(); } \
-	void pyName##_set(pyClass proxy){ensureAcc(); proxee-&gt;yadeName=proxy.proxee; }
+	python::object pyName##_get(void){ return proxee-&gt;yadeName ? python::object(pyClass(proxee-&gt;yadeName)) : python::object(); } \
+	void pyName##_set(pyClass proxy){ proxee-&gt;yadeName=proxy.proxee; }
 /*! Boost.python's definition of python object corresponding to BASIC_PY_PROXY */
 #define BASIC_PY_PROXY_WRAPPER(pyClass,pyName)  \
 	boost::python::class_&lt;pyClass&gt;(pyName,python::init&lt;python::optional&lt;string,python::dict&gt; &gt;()) \
@@ -78,8 +66,8 @@
 	.add_property(&quot;name&quot;,&amp;pyClass::className) \
 	.def(&quot;postProcessAttributes&quot;,&amp;pyClass::postProcessAttributes)
 
-
-
+/********** THE FOLLOWING CAN BE DELETED AFTER A FEW WEEKS (17.7.2009) *********/
+#if 0
 /*! Helper class for accessing registered attributes through the serialization interface.
  *
  * 4 possible types of attributes are supported: bool, string, number and arrays (homogeneous) of any of them.
@@ -138,7 +126,7 @@
 		}
 		
 		//! Return serialized attribute by its name, as vector of strings
-		vector&lt;string&gt; getAttrStr(string name){
+		vector&lt;string&gt; getAttrStr(const string&amp; name) {
 			vector&lt;string&gt; ret;
 			shared_ptr&lt;Archive&gt; arch=descriptors[name].archive;
 			stringstream stream;
@@ -147,29 +135,29 @@
 			return ret;
 		}
 		//! name, values and types of given attribute, on one line as string
-		string dumpAttr(string name){
+		string dumpAttr(const string&amp; name) {
 			string vals,types; AttrDesc desc=descriptors[name]; vector&lt;string&gt; values=getAttrStr(name);
 			for(size_t i=0; i&lt;values.size(); i++) vals+=(i&gt;0?&quot; &quot;:&quot;&quot;)+values[i];
 			string typeDesc(desc.type==BOOL?&quot;BOOL&quot;:(desc.type==STRING?&quot;STRING&quot;:(desc.type==FLOAT?&quot;FLOAT&quot;:(desc.type==INTEGER?&quot;INTEGER&quot;:(desc.type==SEQ_FLOAT?&quot;SEQ_FLOAT&quot;:(desc.type==SEQ_STRING?&quot;SEQ_STRING&quot;:(desc.type==VEC_VEC?&quot;VEC_VEC&quot;:&quot;&lt;unknown&gt;&quot;)))))));
 			return name+&quot; =\t&quot;+vals+&quot;\t (&quot;+typeDesc+&quot;)&quot;;
 		}
 		//! call dumpAttr for all attributes (used for debugging)
-		string dumpAttrs(){ string ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++) ret+=dumpAttr(I-&gt;first)+&quot;\n&quot;; return ret;}
+		string dumpAttrs() { string ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++) ret+=dumpAttr(I-&gt;first)+&quot;\n&quot;; return ret;}
 		//! set attribute by name from its serialized value
-		void setAttrStr(string name, string value){
+		void setAttrStr(const string&amp; name, const string&amp; value){
 			LOG_DEBUG(&quot;Will set `&quot;&lt;&lt;name&lt;&lt;&quot;' to `&quot;&lt;&lt;value&lt;&lt;&quot;'.&quot;);
 			stringstream voidStream;
 			descriptors[name].archive-&gt;deserialize(voidStream,*(descriptors[name].archive),value);
 		}
 
 		//! return dictionary of attributes and their python values (debugging mosly)
-		boost::python::dict pyDict(){boost::python::dict ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret[I-&gt;first]=pyGet(I-&gt;first); return ret; }
+		boost::python::dict pyDict() {boost::python::dict ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret[I-&gt;first]=pyGet(I-&gt;first); return ret; }
 		//! return python list of keys (attribute names)
-		boost::python::list pyKeys(){boost::python::list ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret.append(I-&gt;first); return ret;}
+		boost::python::list pyKeys() {boost::python::list ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret.append(I-&gt;first); return ret;}
 
 
 		//! return attribute value as python object
-		boost::python::object pyGet(std::string key){
+		boost::python::object pyGet(const string&amp; key) {
 			DescriptorMap::iterator I=descriptors.find(key);
 			if(I==descriptors.end()) throw std::invalid_argument(string(&quot;Invalid key: `&quot;)+key+&quot;'.&quot;);
 			vector&lt;string&gt; raw=getAttrStr(key);
@@ -193,7 +181,7 @@
 			}
 		}
 		//! set attribute value from python object
-		void pySet(std::string key, python::object val){
+		void pySet(const string&amp; key, const python::object&amp; val){
 			DescriptorMap::iterator I=descriptors.find(key);
 			if(I==descriptors.end()) throw std::invalid_argument(string(&quot;Invalid key: `&quot;)+key+&quot;'.&quot;);
 			#define SAFE_EXTRACT(from,to,type) python::extract&lt;type&gt; to(from); if(!to.check()) throw invalid_argument(string(&quot;Could not extract type &quot;)+#type);
@@ -222,4 +210,4 @@
 };
 
 CREATE_LOGGER(AttrAccess);
-
+#endif

Modified: trunk/gui/qt3/QtGUIPreferences.cpp
===================================================================
--- trunk/gui/qt3/QtGUIPreferences.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/gui/qt3/QtGUIPreferences.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -12,14 +12,3 @@
 {
 	version = 1;
 }
-
-
-void QtGUIPreferences::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(version);
-	REGISTER_ATTRIBUTE(mainWindowPositionX);
-	REGISTER_ATTRIBUTE(mainWindowPositionY);
-	REGISTER_ATTRIBUTE(mainWindowSizeX);
-	REGISTER_ATTRIBUTE(mainWindowSizeY);
-}
-

Modified: trunk/gui/qt3/QtGUIPreferences.hpp
===================================================================
--- trunk/gui/qt3/QtGUIPreferences.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/gui/qt3/QtGUIPreferences.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,13 +23,9 @@
 		QtGUIPreferences ();
 
 /// Serialization										///
-	protected :
-		void registerAttributes();
-	REGISTER_CLASS_NAME(QtGUIPreferences);
-	REGISTER_BASE_CLASS_NAME(Serializable);
-
+	REGISTER_ATTRIBUTES(/* nothing */,(version)(mainWindowPositionX)(mainWindowPositionY)(mainWindowSizeX)(mainWindowSizeY));
+	REGISTER_CLASS_AND_BASE(QtGUIPreferences,Serializable);
 };
-
 REGISTER_SERIALIZABLE(QtGUIPreferences);
 
 

Modified: trunk/gui/qt3/SnapshotEngine.hpp
===================================================================
--- trunk/gui/qt3/SnapshotEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/gui/qt3/SnapshotEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,17 +25,8 @@
 		int msecSleep;
 	SnapshotEngine():counter(0),viewNo(0),ignoreErrors(true),msecSleep(0){}
 	virtual void action(MetaBody*);
-	void registerAttributes(){	
-		PeriodicEngine::registerAttributes();
-		REGISTER_ATTRIBUTE(fileBase);
-		REGISTER_ATTRIBUTE(counter);
-		REGISTER_ATTRIBUTE(viewNo);
-		REGISTER_ATTRIBUTE(ignoreErrors);
-		REGISTER_ATTRIBUTE(savedSnapshots);
-		REGISTER_ATTRIBUTE(msecSleep);
-	}
+	REGISTER_ATTRIBUTES(PeriodicEngine,(fileBase)(counter)(viewNo)(ignoreErrors)(savedSnapshots)(msecSleep));
 	DECLARE_LOGGER;
-	REGISTER_CLASS_NAME(SnapshotEngine);
-	REGISTER_BASE_CLASS_NAME(PeriodicEngine);
+	REGISTER_CLASS_AND_BASE(SnapshotEngine,PeriodicEngine);
 };
 REGISTER_SERIALIZABLE(SnapshotEngine);

Modified: trunk/lib/SConscript
===================================================================
--- trunk/lib/SConscript	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/SConscript	2009-07-17 21:50:55 UTC (rev 1875)
@@ -7,6 +7,9 @@
 		env.SharedLibrary('WeightedAverage2d',['smoothing/WeightedAverage2d.cpp'],SHLIBPREFIX='',
 			LIBS=env['LIBS']+['yade-base']),
 	])
+	env.Install('$PREFIX/lib/yade$SUFFIX/py',[
+		env.SharedLibrary('boost_python_indexing_suite_v2',['py/boost-python-indexing-suite-v2-noSymlinkHeaders/indexing_slice.cpp','py/boost-python-indexing-suite-v2-noSymlinkHeaders/python_iterator.cpp'])
+	])
 
 
 if 'qt3' not in env['exclude']:

Modified: trunk/lib/multimethods/DynLibDispatcher.hpp
===================================================================
--- trunk/lib/multimethods/DynLibDispatcher.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/multimethods/DynLibDispatcher.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -169,9 +169,9 @@
 			
 // 			virtual void registerAttributes()
 // 			{
-// 				REGISTER_ATTRIBUTE(functorNames);
+// 				REGISTER_ATTRIBUTE_(functorNames);
 // 				if(functors.size() != 0)
-// 					REGISTER_ATTRIBUTE(functors);
+// 					REGISTER_ATTRIBUTE_(functors);
 // 			}
 			
  	public  : DynLibDispatcher()

Modified: trunk/lib/py/README
===================================================================
--- trunk/lib/py/README	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/README	2009-07-17 21:50:55 UTC (rev 1875)
@@ -4,3 +4,9 @@
 	license: GNU GPL v2
 	note: the local version is only the 'gts' directory of the source archive (doc, examples, test ommited). Distutils are not used for building either.
 
+boost-python-indexing-suite-v2-noSymlinkHeaders:
+	homepage: <A HREF="http://www.language-binding.net/pyplusplus/pyplusplus.html">http://www.language-binding.net/pyplusplus/pyplusplus.html</A> (part of Py++-1.0.0)
+	documentation: <A HREF="http://www.language-binding.net/pyplusplus/documentation/indexing_suite_v2.html.html">http://www.language-binding.net/pyplusplus/documentation/indexing_suite_v2.html.html</A>
+	license: Boost software license 1.0
+	note: only headers and a few .cpp files making up the indexing suite are copied here
+

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/indexing_slice.cpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/indexing_slice.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/indexing_slice.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,76 @@
+// Module slice.cpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: slice.cpp,v 1.1.2.7 2003/11/24 14:28:32 raoulgough Exp $
+//
+
+#include &lt;boost/python/suite/indexing/slice.hpp&gt;
+#include &lt;algorithm&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// MSVC6 workarounds
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined (BOOST_NO_MEMBER_TEMPLATES)
+namespace boost { namespace python { namespace indexing {
+  slice::slice (::boost::python::handle&lt;&gt; const &amp;p) : object (p) { }
+  slice::slice (::boost::python::detail::borrowed_reference p) : object (p) { }
+  slice::slice (::boost::python::detail::new_reference p) : object (p) { }
+  slice::slice (::boost::python::detail::new_non_null_reference p) : object (p) { }
+} } }
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// slice copy constructor
+/////////////////////////////////////////////////////////////////////////////
+
+boost::python::indexing::slice::slice (slice const &amp;copy)
+  : object (copy)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// integer_slice constructor
+/////////////////////////////////////////////////////////////////////////////
+
+boost::python::indexing::integer_slice
+::integer_slice (slice const &amp;sl, index_type length)
+  : m_slice (sl)
+  // Leave index members uninitialized
+{
+  PySlice_GetIndices(
+      reinterpret_cast&lt;PySliceObject *&gt; (m_slice.ptr()),
+      length,
+      &amp;m_start,
+      &amp;m_stop,
+      &amp;m_step);
+
+  if (m_step == 0)
+    {
+      // Can happen with Python prior to 2.3
+      PyErr_SetString (PyExc_ValueError, &quot;slice step cannot be zero&quot;);
+      boost::python::throw_error_already_set ();
+    }
+
+  m_start = std::max (static_cast&lt;index_type&gt; (0), std::min (length, m_start));
+  m_stop = std::max (static_cast&lt;index_type&gt; (0), std::min (length, m_stop));
+  m_direction = (m_step &gt; 0) ? 1 : -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Check if an index is within the range of this integer_slice
+/////////////////////////////////////////////////////////////////////////////
+
+bool boost::python::indexing::integer_slice::in_range (index_type index)
+{
+  return ((m_stop - index) * m_direction) &gt; 0;
+}

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/python_iterator.cpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/python_iterator.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/python_iterator.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,74 @@
+// -*- mode:c++ -*-
+//
+// Module python_iterator.cpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: python_iterator.cpp,v 1.1.2.5 2003/11/24 16:35:19 raoulgough Exp $
+//
+
+#include &lt;boost/python/suite/indexing/python_iterator.hpp&gt;
+#include &lt;boost/python/handle.hpp&gt;
+
+////////////////////////////////////////////////////////////////////////////
+// python_iterator constructor
+///////////////////////////////////////////////////////////////////////////
+
+boost::python::indexing::python_iterator
+::python_iterator (boost::python::object obj)
+  : m_iter_obj (handle&lt;&gt; (PyObject_GetIter (obj.ptr()))),
+    m_next_method (m_iter_obj.attr (&quot;next&quot;)),
+    m_current()
+{
+}
+
+////////////////////////////////////////////////////////////////////////////
+// Get our next item (if any)
+///////////////////////////////////////////////////////////////////////////
+
+bool boost::python::indexing::python_iterator::next ()
+{
+  bool result = true; // Assume success
+
+  try
+    {
+      m_current = m_next_method ();
+    }
+
+  catch (boost::python::error_already_set const &amp;)
+    {
+      if (PyErr_ExceptionMatches (PyExc_StopIteration))
+        {
+          // Eat this exception
+          PyErr_Clear ();
+          m_current = boost::python::object (); // No current object
+          result = false; // Report failure via return value only
+        }
+
+      else
+        {
+          // Pass it up the line
+          throw;
+        }
+    }
+
+  return result;
+}
+
+////////////////////////////////////////////////////////////////////////////
+// Return our current item
+///////////////////////////////////////////////////////////////////////////
+
+boost::python::object
+boost::python::indexing::python_iterator::current () const
+{
+  return m_current;
+}

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/algorithms.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/algorithms.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/algorithms.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,563 @@
+// Header file algorithms.hpp
+//
+// Uniform interface layer for all containers.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 9/11   rmg     File creation from suite_utils.hpp
+// 2003/10/28   rmg     Split container-specific versions into separate headers
+// 2006/10/25   Roman   Adding keys function to assoc_algorithms class
+//
+// $Id: algorithms.hpp,v 1.1.2.15 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ALGORITHMS_HPP
+#define BOOST_PYTHON_INDEXING_ALGORITHMS_HPP
+
+#include &lt;boost/python/suite/indexing/suite_utils.hpp&gt;
+
+#include &lt;boost/type_traits.hpp&gt;
+#include &lt;boost/python/errors.hpp&gt;
+#include &lt;boost/python/suite/indexing/int_slice_helper.hpp&gt;
+#include &lt;boost/python/suite/indexing/slice.hpp&gt;
+#include &lt;boost/mpl/if.hpp&gt;
+#include &lt;boost/limits.hpp&gt;
+#include &lt;algorithm&gt;
+#include &lt;functional&gt;
+#include &lt;stdexcept&gt;
+#include &lt;string&gt;
+#include &lt;set&gt;
+
+namespace boost { namespace python { namespace indexing {
+  template&lt;typename ContainerTraits, typename Ovr = detail::no_override&gt;
+  class default_algorithms
+  {
+    typedef default_algorithms&lt;ContainerTraits, Ovr&gt; self_type;
+    typedef typename detail::maybe_override&lt;self_type, Ovr&gt;
+        ::type most_derived;
+
+  public:
+    typedef ContainerTraits container_traits;
+
+    // Import typedefs from the container_traits for convenience
+    typedef typename ContainerTraits::container   container;
+    typedef typename ContainerTraits::iterator    iterator;
+    typedef typename ContainerTraits::reference   reference;
+    typedef typename ContainerTraits::size_type   size_type;
+    typedef typename ContainerTraits::value_type  value_type;
+    typedef typename ContainerTraits::value_param value_param;
+    typedef typename ContainerTraits::index_param index_param;
+    typedef typename ContainerTraits::key_param   key_param;
+
+    // Defer selection of supported_methods to the ContainerTraits
+    // template argument. This makes sense because default_algorithms
+    // derives all of its other information from this argument, and
+    // can't decide which of the static member functions will
+    // instantiate successfully for the container. Obviously a
+    // custom-written Algorithms implementation could choose to
+    // provide the supported_methods directly.
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = ContainerTraits::supported_methods);
+
+    static size_type size       (container &amp;);
+    static iterator  find       (container &amp;, key_param);
+    static size_type get_index  (container &amp;, key_param);
+    static size_type count      (container &amp;, key_param);
+    static bool      contains   (container &amp;, key_param);
+    static void      reverse    (container &amp;);
+    static reference get        (container &amp;, index_param);
+    static void      assign     (container &amp;, index_param, value_param);
+    static void      insert     (container &amp;, index_param, value_param);
+    static void      erase_one  (container &amp;, index_param);
+    static void      erase_range(container &amp;, index_param, index_param);
+    static void      push_back  (container &amp;, value_param);
+    static void      sort       (container &amp;);
+    //    static void      sort       (container &amp;, PyObject *);
+
+    static iterator  begin      (container &amp;c) { return c.begin(); }
+    static iterator  end        (container &amp;c) { return c.end(); }
+
+    // Reasonable defaults for slice handling
+    typedef int_slice_helper&lt;self_type, integer_slice&gt; slice_helper;
+
+    static slice_helper make_slice_helper (container &amp;c, slice const &amp;);
+
+    // Default visit_container_class
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class(
+        PythonClass &amp;pyClass, Policy const &amp;policy)
+    {
+      container_traits::visit_container_class (pyClass, policy);
+    }
+
+#if BOOST_WORKAROUND(BOOST_MSVC, &lt;= 1300)
+    // MSVC6 and 7.0 seem to complain about most_derived::bounds_check
+    // for an instantiation of list_algorithms.
+  public:
+#else
+  private:
+#endif
+    static size_type bounds_check(
+        container &amp;, index_param, char const *msg,
+        bool one_past = false,
+        bool truncate = false);
+    // Throws std::out_of_range if necessary. If one_past is set, then
+    // indexes up to container.size() *inclusive* are allowed. If
+    // truncate is set, then out of bounds values are reset to the
+    // nearest in-bound value (and if none exists, throws an
+    // exception). If truncate is *not* set, then negative values index
+    // from the upper bound backwards and are bounds-checked.
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Base class for associative containers
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr = detail::no_override&gt;
+  class assoc_algorithms
+    : public default_algorithms
+        &lt;ContainerTraits,
+        BOOST_DEDUCED_TYPENAME detail::maybe_override
+            &lt;assoc_algorithms&lt;ContainerTraits, Ovr&gt;, Ovr&gt;
+          ::type&gt;
+  {
+    typedef assoc_algorithms&lt;ContainerTraits, Ovr&gt; self_type;
+    typedef typename detail::maybe_override&lt;self_type, Ovr&gt;
+        ::type most_derived;
+    typedef default_algorithms&lt;ContainerTraits, most_derived&gt; Parent;
+
+  public:
+    typedef typename Parent::iterator iterator;
+    typedef typename Parent::size_type size_type;
+    typedef typename Parent::container container;
+    typedef typename Parent::reference reference;
+    typedef typename Parent::key_param key_param;
+    typedef typename Parent::value_param value_param;
+    typedef typename Parent::index_param index_param;
+
+    static reference get        (container &amp;, index_param);
+
+    // Use member functions for the following (hiding base class versions)
+    static void      erase_one (container &amp;, key_param);
+    static iterator  find      (container &amp;, key_param);
+    static size_type count     (container &amp;, key_param);
+    static bool      contains  (container &amp;, key_param);
+
+    // Default visit_container_class
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class( PythonClass &amp;pyClass, Policy const &amp;policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+    }
+
+  
+  protected:
+    static iterator  find_or_throw (container &amp;, index_param);
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Get the size of a container
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME default_algorithms&lt;ContainerTraits, Ovr&gt;::size_type
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::size (container &amp;c)
+  {
+    return c.size();
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Range check an index and throw out_of_range if necessary
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME default_algorithms&lt;ContainerTraits, Ovr&gt;::size_type
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::bounds_check(
+      container &amp;c,
+      index_param ix,
+      char const *msg,
+      bool one_past,
+      bool truncate)
+  {
+    size_type bound = most_derived::size(c) + (one_past ? 1 : 0);
+    size_type result;
+
+    if (truncate)
+      {
+        if (ix &lt; 0)
+          {
+            result = 0;
+          }
+
+        else
+          {
+            result = ix;
+
+            if ((result &gt;= bound) &amp;&amp; (bound &gt; 0))
+              {
+                result = bound - 1;
+              }
+          }
+      }
+
+    else if (ix &lt; 0)
+      {
+        if (size_type(-ix) &gt; bound)
+          {
+            throw std::out_of_range (msg);
+          }
+  
+        result = bound + ix;
+      }
+
+    else
+      {
+        result = ix;
+      }
+
+    if (result &gt;= bound)
+      {
+        throw std::out_of_range (msg);
+      }
+
+    return result;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME default_algorithms&lt;ContainerTraits, Ovr&gt;::iterator
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::find(
+      container &amp;c, key_param key)
+  {
+    typedef typename container_traits::value_traits_type vtraits;
+    typedef typename vtraits::equal_to comparison;
+
+    return std::find_if(
+        most_derived::begin(c),
+        most_derived::end(c),
+        std::bind1st (comparison(), key));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element and return its index (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME default_algorithms&lt;ContainerTraits, Ovr&gt;::size_type
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::get_index(
+      container &amp;c, key_param key)
+  {
+    iterator found (most_derived::find (c, key));
+
+    if (found == most_derived::end(c))
+      {
+        PyErr_SetString(
+            PyExc_ValueError, &quot;get_index: element not found&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+
+    iterator start (most_derived::begin (c));
+    return std::distance (start, found);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Count occurances of an element in a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME default_algorithms&lt;ContainerTraits, Ovr&gt;::size_type
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::count(
+      container &amp;c, key_param key)
+  {
+    typedef typename container_traits::value_traits_type vtraits;
+    typedef typename vtraits::equal_to comparison;
+
+    return std::count_if(
+        most_derived::begin(c),
+        most_derived::end(c),
+        std::bind1st (comparison(), key));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Check whether a container contains the given element (std algo ver)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  bool
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::contains(
+      container &amp;c, key_param key)
+  {
+    return most_derived::find (c, key) != most_derived::end(c);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME default_algorithms&lt;ContainerTraits, Ovr&gt;::reference
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::get(
+      container &amp;c, index_param ix)
+  {
+    return c[most_derived::bounds_check (c, ix, &quot;get&quot;)];
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Assign a value at a particular index (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::assign(
+      container &amp;c, index_param ix, value_param val)
+  {
+    c[most_derived::bounds_check (c, ix, &quot;assign&quot;)] = val;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert at end of a container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::push_back(
+      container &amp;c, value_param v)
+  {
+    c.push_back (v);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert at an index in the container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::insert(
+      container &amp;c, index_param i, value_param v)
+  {
+    iterator insert_pos (most_derived::begin(c));
+
+    // Index may range up to c.size() inclusive to allow inserting at end
+    std::advance(
+        insert_pos, most_derived::bounds_check (c, i, &quot;insert&quot;, true, true));
+
+    c.insert (insert_pos, v);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Erase between given indexes in the container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::erase_range(
+      container &amp;c, index_param from, index_param to)
+  {
+    iterator start (most_derived::begin(c));
+    iterator finish (most_derived::begin(c));
+
+    // Start index must be properly in bounds
+    std::advance
+      (start, most_derived::bounds_check (c, from, &quot;erase_range (from)&quot;));
+
+    // End index is one-past-the-end, so may range up to c.size() inclusive
+    std::advance
+      (finish, most_derived::bounds_check (c, to, &quot;erase_range (to)&quot;, true));
+
+    c.erase (start, finish);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Erase one element at the given index in the container (generic version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  default_algorithms&lt;ContainerTraits, Ovr&gt;::erase_one(
+      container &amp;c, index_param ix)
+  {
+    iterator iter (most_derived::begin(c));
+    std::advance (iter, most_derived::bounds_check (c, ix, &quot;erase_one&quot;));
+    c.erase (iter);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Reverse the contents of a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void default_algorithms&lt;ContainerTraits, Ovr&gt;::reverse (container &amp;c)
+  {
+    std::reverse (most_derived::begin(c), most_derived::end(c));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Sort the contents of a container (std algorithm version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void default_algorithms&lt;ContainerTraits, Ovr&gt;::sort (container &amp;c)
+  {
+    typedef typename container_traits::value_traits_type vtraits;
+    typedef typename vtraits::less comparison;
+    std::sort (most_derived::begin(c), most_derived::end(c), comparison());
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // slice_helper factory function (default version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME default_algorithms&lt;ContainerTraits, Ovr&gt;::slice_helper
+  default_algorithms&lt;ContainerTraits, Ovr&gt;
+  ::make_slice_helper (container &amp;c, slice const &amp;sl)
+  {
+    return slice_helper (c, integer_slice (sl, most_derived::size (c)));
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (associative version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME assoc_algorithms&lt;ContainerTraits, Ovr&gt;::reference
+  assoc_algorithms&lt;ContainerTraits, Ovr&gt;::get (container &amp;c, index_param ix)
+  {
+    return *most_derived::find_or_throw (c, ix);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Erase elements with the given key (associative version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  assoc_algorithms&lt;ContainerTraits, Ovr&gt;::erase_one(
+      container &amp;c, key_param key)
+  {
+    if (c.erase (key) == 0)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, &quot;Container does not hold value to be erased&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in an associative container
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME assoc_algorithms&lt;ContainerTraits, Ovr&gt;::iterator
+  assoc_algorithms&lt;ContainerTraits, Ovr&gt;
+  ::find (container &amp;c, key_param key)
+  {
+    return c.find (key);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in an associative container
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  bool
+  assoc_algorithms&lt;ContainerTraits, Ovr&gt;::contains(
+      container &amp;c, key_param key)
+  {
+    return most_derived::find (c, key) != most_derived::end(c);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Find an element in an associative container - throw an exception if
+  // not found
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME assoc_algorithms&lt;ContainerTraits, Ovr&gt;::iterator
+  assoc_algorithms&lt;ContainerTraits, Ovr&gt;::find_or_throw(
+      container &amp;c, index_param ix)
+  {
+    iterator iter = most_derived::find (c, ix);
+
+    if (iter == most_derived::end(c))
+      {
+        PyErr_SetString(
+            PyExc_ValueError, &quot;associative container: key not found&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+
+    return iter;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Count occurances of an element in a container (associative version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME assoc_algorithms&lt;ContainerTraits, Ovr&gt;::size_type
+  assoc_algorithms&lt;ContainerTraits, Ovr&gt;::count(
+      container &amp;c, key_param key)
+  {
+    return c.count (key);
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Some meta-information to select algorithms for const and
+  // non-const qualified containers. All algorithms_selector specializations
+  // include two publically accessible typedefs, called
+  // mutable_algorithms and const_algorithms.  This saves having to
+  // have separate partial specializations of algorithms for
+  // const and non-const containers. Client code should probably
+  // specialize algorithms directly.
+  /////////////////////////////////////////////////////////////////////////
+
+  namespace detail {
+    template&lt;typename Container&gt; class algorithms_selector
+# if defined(BOOST_MPL_MSVC_ETI_BUG)
+    {
+      // Bogus types to prevent compile errors due to ETI
+      typedef algorithms_selector&lt;Container&gt; mutable_algorithms;
+      typedef algorithms_selector&lt;Container&gt; const_algorithms;
+    }
+# endif
+    ;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms selection for mutable containers
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Container&gt;
+  struct algorithms
+    : public detail::algorithms_selector&lt;Container&gt;::mutable_algorithms
+  {
+  };
+
+# if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms selection for const-qualified containers
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Container&gt;
+  struct algorithms&lt;Container const&gt;
+    : public detail::algorithms_selector&lt;Container&gt;::const_algorithms
+  {
+  };
+# endif
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ALGORITHMS_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_proxy.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_proxy.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_proxy.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,737 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file container_proxy.hpp
+//
+// A container-wrapper that provides Python-style reference semantics
+// for values stored in vector-like containers via element proxies.
+//
+// Class invariant:
+//   size() == m_proxies.size()
+//   for 0 &lt;= i &lt; size()
+//     m_proxies[i].get() != 0
+//     m_proxies[i]-&gt;owner() == this
+//     m_proxies[i]-&gt;index() == i
+//     m_proxies[i]-&gt;m_element_ptr.get() == 0
+//
+// History
+// =======
+// 2003/ 8/26   rmg     File creation
+// 2003/10/23   rmg     Change pointer container from map to sequence
+//
+// $Id: container_proxy.hpp,v 1.1.2.28 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_CONTAINER_PROXY_HPP
+#define BOOST_PYTHON_INDEXING_CONTAINER_PROXY_HPP
+
+#include &lt;boost/python/suite/indexing/proxy_iterator.hpp&gt;
+#include &lt;boost/python/suite/indexing/shared_proxy_impl.hpp&gt;
+#include &lt;boost/python/suite/indexing/element_proxy.hpp&gt;
+#include &lt;boost/python/suite/indexing/element_proxy_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/workaround.hpp&gt;
+#include &lt;boost/python/suite/indexing/methods.hpp&gt;
+
+#include &lt;vector&gt;
+#include &lt;cassert&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/mpl/apply.hpp&gt;
+#include &lt;boost/iterator/iterator_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+
+  template&lt;typename T&gt; struct identity {
+    typedef T held_type;
+
+    static T &amp;       get(T &amp;       obj) { return obj; }
+    static T const &amp; get(T const &amp; obj) { return obj; }
+
+    static T    create ()                     { return T(); }
+    static T    copy   (T const &amp;copy)        { return copy; }
+    static void assign (T &amp;to, T const &amp;from) { to = from; }
+    static void pre_destruction (T &amp;)         { }
+    static void swap   (T &amp;one, T &amp;two)       { std::swap (one, two); }
+  };
+
+  template&lt;typename P&gt; struct deref {
+    typedef P held_type;
+
+    typedef typename boost::iterator_value&lt;P&gt;::type     value;
+
+    static value &amp;       get (P &amp;       ptr)  { return *ptr; }
+    static value const &amp; get (P const &amp; ptr)  { return *ptr; }
+
+    static P    create ()                     { return P(); }
+    static P    copy   (P const &amp;copy)        { return copy; }
+    static void assign (P &amp;to, P const &amp;from) { to = from; }
+    static void pre_destruction (P &amp;)         { }
+    static void swap   (P &amp;one, P &amp;two)       { std::swap (one, two); }
+  };
+
+  struct vector_generator {
+    // Generates vector type for any element type with default allocator
+    template&lt;typename Element&gt; struct apply {
+      typedef std::vector&lt;Element&gt; type;
+    };
+  };
+
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+  // Early template instantiation (ETI) workaround
+  namespace detail {
+    template&lt;typename Container&gt; struct msvc6_iterator {
+      typedef Container::iterator type;
+    };
+
+    template&lt;&gt; struct msvc6_iterator&lt;int&gt; {
+      typedef int *type;
+    };
+  }
+#endif
+
+  template&lt;class Container,
+           class Holder = identity&lt;Container&gt;,
+           class Generator = vector_generator&gt;
+  class container_proxy
+  {
+    typedef container_proxy&lt;Container, Holder, Generator&gt; self_type;
+    typedef typename Container::iterator raw_iterator;
+    typedef ::boost::detail::iterator_traits&lt;raw_iterator&gt; raw_iterator_traits;
+
+#if !defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    template&lt;class C&gt; friend class shared_proxy_impl;
+    template&lt;class C, typename E, typename T, typename S, typename I&gt;
+        friend class proxy_iterator;
+#endif
+
+  public:
+    typedef typename Holder::held_type held_type;
+
+    typedef typename Container::size_type size_type;
+    typedef typename Container::difference_type difference_type;
+
+    typedef shared_proxy_impl&lt;self_type&gt; shared_proxy;
+
+    typedef typename Container::value_type raw_value_type;
+
+    typedef element_proxy&lt;self_type&gt; value_type;
+    typedef value_type               reference;  // Already has ref. semantics
+
+    typedef const_element_proxy&lt;self_type&gt; const_value_type;
+    typedef const_value_type               const_reference; // Ref. semantics
+
+    typedef proxy_iterator &lt;self_type, value_type, raw_iterator_traits,
+        size_type, raw_iterator&gt; iterator;
+    typedef iterator const_iterator; // No const_iterator yet implemented
+
+  public:
+    // Constructors
+    template&lt;typename Iter&gt; container_proxy (Iter start, Iter finish)
+      // Define inline for MSVC6 compatibility
+      : m_held_obj (Holder::create()),
+      m_proxies ()
+    {
+      insert (begin(), start, finish);
+    }
+
+    container_proxy ();
+    explicit container_proxy (held_type const &amp;h);
+
+    container_proxy (container_proxy const &amp;);
+    container_proxy &amp;operator= (container_proxy const &amp;);
+    ~container_proxy ();
+
+    Container const &amp;raw_container() const;   // OK to expose const reference
+
+    reference       at (size_type index);
+    const_reference at (size_type index) const;
+
+    reference       operator[] (size_type index)       { return at(index); }
+    const_reference operator[] (size_type index) const { return at(index); }
+
+    size_type size ()     const { return raw_container().size(); }
+    size_type capacity () const { return raw_container().capacity(); }
+    void reserve (size_type s);
+
+  public:
+    iterator begin() { return iterator (this, static_cast&lt;size_type&gt;(0)); }
+    iterator end() { return iterator (this, raw_container().size()); }
+
+    iterator erase (iterator);
+    iterator erase (iterator, iterator);
+    iterator insert (iterator, raw_value_type const &amp;);
+
+    template&lt;typename Iter&gt; void insert (iterator iter, Iter from, Iter to)
+      // Define here for MSVC6 compatibility
+    {
+      // Forward insertion to the right overloaded version
+      typedef typename BOOST_ITERATOR_CATEGORY&lt;Iter&gt;::type category;
+      insert (iter, from, to, category());
+    }
+
+    void push_back (raw_value_type const &amp;copy) { insert (end(), copy); }
+
+    value_type pop_back () {
+      value_type result = at (size() - 1);
+      erase (end() - 1);
+      return result;
+    }
+
+  public:
+    // These functions are useful only when client code has direct
+    // non-const acccess to the raw container (e.g. via an indirect
+    // holder supplied to our constructor). Any code that directly
+    // modifies the contents of the raw container (by replacing,
+    // inserting or erasing elements) must notify the container_proxy.
+
+    void detach_proxy (size_type index);
+    void detach_proxies (size_type from, size_type to);
+    // Call before overwriting element(s) in the raw container
+
+    void prepare_erase (size_type from, size_type to);
+    // Call before erasing elements directly from the raw container
+
+    void notify_insertion (size_type from, size_type to);
+    // Call after inserting elements directly into the raw container
+
+  public:
+    // Convenient replacement of elements (automatic proxy detachment)
+    void replace (size_type index, raw_value_type const &amp;);
+    //    template&lt;typename Iter&gt; void replace (size_type index, Iter, Iter);
+
+    void swap_elements (size_type index1, size_type index2);
+
+    bool is_valid () const; // Check the class invariant (for testing purposes)
+
+  private:
+    // Overloads for insertions with/without useful std::distance
+    template&lt;typename Iter&gt;
+    void insert (iterator iter, Iter from, Iter to, std::forward_iterator_tag)
+      // Define here for MSVC6 compatibility
+    {
+      assert (iter.ptr == this);
+      size_type count = std::distance (from, to);
+
+      // Add empty proxy pointers for the new value(s) (could throw)
+      m_proxies.insert (m_proxies.begin() + iter.index, count, pointer_impl());
+
+      try
+        {
+          // Insert the new element(s) into the real container (could throw)
+          raw_container().insert(
+              raw_container().begin() + iter.index,
+              from,
+              to);
+
+          try
+            {
+              // Create new proxies for the new elements (could throw)
+              write_proxies (iter.index, iter.index + count);
+            }
+
+          catch (...)
+            {
+              raw_container().erase(
+                  raw_container().begin() + iter.index,
+                  raw_container().begin() + iter.index + count);
+
+              throw;
+            }
+        }
+
+      catch (...)
+        {
+          m_proxies.erase(
+              m_proxies.begin() + iter.index,
+              m_proxies.begin() + iter.index + count);
+
+          throw;
+        }
+
+      // Adjust any proxies after the inserted elements (nothrow)
+      adjust_proxies(
+          m_proxies.begin() + iter.index + count,
+          m_proxies.end(),
+          static_cast&lt;difference_type&gt; (count));
+    }
+
+    template&lt;typename Iter&gt;
+    void insert (iterator iter, Iter from, Iter to, std::input_iterator_tag)
+      // Define here for MSVC6 compatibility
+    {
+      // insert overload for iterators where we *can't* get distance()
+      // so just insert elements one at a time
+      while (from != to)
+        {
+          iter = insert (iter, *from++) + 1;
+        }
+    }
+
+  private:
+    typedef boost::shared_ptr&lt;shared_proxy&gt; pointer_impl;
+
+    typedef typename mpl::apply1&lt;Generator, pointer_impl&gt;::type
+      pointer_container;
+
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+    typedef detail::msvc6_iterator&lt;pointer_container&gt;::type pointer_iterator;
+#else
+    typedef typename pointer_container::iterator pointer_iterator;
+#endif
+
+#if defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    // Proxies need mutable access, and can't be friends with MSVC6
+  public:
+#endif
+    Container &amp;raw_container();
+
+  private:
+    void adjust_proxies (pointer_iterator, pointer_iterator, difference_type);
+    void write_proxies (size_type, size_type);
+    bool clear_proxy (pointer_impl &amp;);         // detach and do not reset
+    void clear_proxies (size_type, size_type); // detach and do not reset
+    void claim_all_proxies (); // Makes all proxies point at this object
+
+  private:
+    held_type m_held_obj;
+    pointer_container m_proxies;
+  };
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::container_proxy ()
+    : m_held_obj (Holder::create()),
+    m_proxies ()
+  {
+    // Container is empty - no further processing
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::container_proxy (held_type const &amp;held)
+    : m_held_obj (Holder::copy (held)),
+    m_proxies (size())
+  {
+    write_proxies (0, size());
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::container_proxy (container_proxy const &amp;copy)
+    : m_held_obj (Holder::copy (copy.m_held_obj)),
+    m_proxies (size())
+  {
+    write_proxies (0, size()); // Create our own proxies for the copied values
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  container_proxy&lt;Container, Holder, Generator&gt; &amp;
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::operator= (container_proxy const &amp;copy)
+  {
+    container_proxy&lt;Container, Holder, Generator&gt; temp (copy);
+    // This could throw, but none of the remaining operations can
+
+    Holder::swap (m_held_obj, temp.m_held_obj);
+    std::swap (m_proxies, temp.m_proxies);
+
+    claim_all_proxies ();
+    temp.claim_all_proxies ();  // Prepare for detach
+
+    return *this;
+    // temp destruction detaches any proxies that used to belong to us
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::~container_proxy ()
+  {
+    // Copy original values into any proxies being shared by external pointers
+    clear_proxies (0, size());
+    Holder::pre_destruction (m_held_obj);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  Container &amp;
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::raw_container ()
+  {
+    return Holder::get (m_held_obj);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  Container const &amp;
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::raw_container () const
+  {
+    return Holder::get (m_held_obj);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;::reserve (size_type size)
+  {
+    raw_container().reserve (size);
+    m_proxies.reserve (size);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  BOOST_DEDUCED_TYPENAME container_proxy&lt;Container, Holder, Generator&gt;::reference
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::at (size_type index)
+  {
+    pointer_impl const &amp;ptr = m_proxies.BOOST_PYTHON_INDEXING_AT (index);
+    assert (ptr-&gt;owner() == this);
+    assert (ptr-&gt;index() == index);
+    return reference (ptr);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  BOOST_DEDUCED_TYPENAME container_proxy&lt;Container, Holder, Generator&gt;::const_reference
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::at (size_type index) const
+  {
+    pointer_impl const &amp;ptr = m_proxies.BOOST_PYTHON_INDEXING_AT (index);
+    assert (ptr-&gt;owner() == this);
+    assert (ptr-&gt;index() == index);
+    return const_reference (ptr);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::replace (size_type index, raw_value_type const &amp;copy)
+  {
+    detach_proxy (index);
+    raw_container().BOOST_PYTHON_INDEXING_AT (index) = copy;
+    write_proxies (index, index + 1);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void
+  container_proxy&lt;Container, Holder, Generator&gt;
+  ::swap_elements (size_type index1, size_type index2)
+  {
+    pointer_impl &amp;ptr1 = m_proxies[index1];
+    pointer_impl &amp;ptr2 = m_proxies[index2];
+
+    assert (ptr1-&gt;owner() == this);
+    assert (ptr2-&gt;owner() == this);
+    assert (ptr1-&gt;index() == index1);
+    assert (ptr2-&gt;index() == index2);
+
+    // Swap produces the diagrammed transformation. Any external
+    // pointers that refer to proxy1 or proxy2 will end up still
+    // pointing to their original (now relocated) values.
+    //
+    // .. ptr1 .. ptr2 ..     .. ptr1 .. ptr2  ..  (m_proxies)
+    //      |      |                 \  /
+    //      |      |                  \/
+    //      |      |                  /\.
+    //      V      V                 /  \.
+    //   proxy1  proxy2  --&gt;    proxy1  proxy2
+    //      |      |                 \  /
+    //      |      |                  \/
+    //      |      |                  /\.
+    //      V      V                 /  \.
+    //  .. v1 ... v2 ..         .. v2 .. v1 ..  (raw_container)
+
+    std::swap (ptr1-&gt;m_index, ptr2-&gt;m_index);
+    std::swap (ptr1, ptr2);
+    std::swap (raw_container()[index1], raw_container()[index2]);
+
+    assert (m_proxies[index1]-&gt;index() == index1);
+    assert (m_proxies[index2]-&gt;index() == index2);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  BOOST_DEDUCED_TYPENAME container_proxy&lt;Container, Holder, Generator&gt;::iterator
+  container_proxy&lt;Container, Holder, Generator&gt;::erase (iterator iter)
+  {
+    return erase (iter, iter + 1);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  BOOST_DEDUCED_TYPENAME container_proxy&lt;Container, Holder, Generator&gt;::iterator
+  container_proxy&lt;Container, Holder, Generator&gt;::erase(
+      iterator from, iterator to)
+  {
+    assert (from.ptr == this);
+    assert (to.ptr == this);
+
+    // Detach and remove the proxies for the about-to-be-erased elements
+    prepare_erase (from.index, to.index);
+
+    // Erase the elements from the real container
+    raw_iterator result
+      = raw_container().erase(
+          raw_container().begin() + from.index,
+          raw_container().begin() + to.index);
+
+    return iterator (this, result);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  BOOST_DEDUCED_TYPENAME container_proxy&lt;Container, Holder, Generator&gt;::iterator
+  container_proxy&lt;Container, Holder, Generator&gt;::insert(
+      iterator iter, raw_value_type const &amp;copy)
+  {
+    // Use the iterator-based version by treating the value as an
+    // array of size one (see section 5.7/4 of the C++98 standard)
+    insert (iter, &amp;copy, (&amp;copy) + 1, std::random_access_iterator_tag());
+
+    return iter;
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  bool container_proxy&lt;Container, Holder, Generator&gt;::clear_proxy(
+      pointer_impl &amp;ptr)
+  {
+    // Warning - this can break the class invariant. Use only when the
+    // pointer is about to be overwritten or removed from m_proxies
+
+    assert (ptr-&gt;owner() == this);
+
+    if (!ptr.unique())
+      {
+        ptr-&gt;detach (); // Cause proxy to copy element value
+        return true;
+      }
+
+    else
+      {
+        // If the pointer isn't shared, don't bother causing a copy of
+        // the container element, since the proxy is about to be
+        // deleted or reused.
+        return false;
+      }
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;::clear_proxies(
+      size_type from_index, size_type to_index)
+  {
+    while (from_index != to_index)
+      {
+        clear_proxy (m_proxies[from_index]);
+        ++from_index;
+      }
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;
+  ::detach_proxy (size_type index)
+  {
+    pointer_impl &amp;ptr = m_proxies[index];
+
+    assert (ptr-&gt;index() == index);
+
+    if (clear_proxy (ptr))
+      {
+        // To maintain class invariant
+        ptr.reset (new shared_proxy (this, index));
+      }
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;::detach_proxies(
+      size_type from_index, size_type to_index)
+  {
+    while (from_index != to_index)
+      {
+        detach_proxy (from_index);
+        ++from_index;
+      }
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;
+  ::prepare_erase (size_type from_index, size_type to_index)
+  {
+    difference_type deleting = to_index - from_index;
+    pointer_iterator erase_begin = m_proxies.begin() + from_index;
+    pointer_iterator erase_end = m_proxies.begin() + to_index;
+
+    // Adjust the indexes of any trailing proxies
+    adjust_proxies (erase_end, m_proxies.end(), -deleting);
+
+    // Detach any proxies without updating our pointers to them
+    clear_proxies (from_index, to_index);
+
+    // Remove the pointers
+    m_proxies.erase (erase_begin, erase_end);
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;::notify_insertion(
+      size_type from_index, size_type to_index)
+  {
+    size_type count = to_index - from_index;
+
+    m_proxies.insert(
+        m_proxies.begin() + from_index, count, pointer_impl());
+
+    try
+      {
+        write_proxies (from_index, to_index); // Could throw
+      }
+
+    catch (...)
+      {
+        m_proxies.erase(
+            m_proxies.begin() + from_index,
+            m_proxies.begin() + to_index);
+
+        throw;
+      }
+
+    // Adjust any proxies after the inserted elements (nothrow)
+    adjust_proxies(
+        m_proxies.begin() + to_index,
+        m_proxies.end(),
+        static_cast&lt;difference_type&gt; (count));
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;::adjust_proxies(
+      pointer_iterator from,
+      pointer_iterator to,
+      difference_type offset)
+  {
+    while (from != to)
+      {
+        (*from)-&gt;m_index += offset;
+        ++from;
+      }
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;::write_proxies(
+      size_type from, size_type to)
+  {
+    // (over)write proxy pointers in the given range. Re-uses existing
+    // shared_proxy objects where possible. Does not call detach_proxy
+    // since it is assumed that the original values could have already
+    // been modified and copying them now would be wrong.
+
+    while (from != to)
+      {
+        pointer_impl &amp;ptr = m_proxies[from];
+
+        if ((ptr.get() == 0) || (!ptr.unique()))
+          {
+            // Either no proxy yet allocated here, or there is one
+            // but it is being shared by an external pointer.
+            ptr.reset (new shared_proxy (this, from));
+          }
+
+        else
+          {
+            // Re-use the existing object since we have the only pointer to it
+            assert (ptr-&gt;owner() == this);
+            ptr-&gt;m_index = from;
+          }
+
+        ++from;
+      }
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  void container_proxy&lt;Container, Holder, Generator&gt;::claim_all_proxies ()
+  {
+    for (pointer_iterator iter = m_proxies.begin();
+         iter != m_proxies.end();
+         ++iter)
+      {
+        (*iter)-&gt;m_owner_ptr = this;
+      }
+  }
+
+  template&lt;class Container, class Holder, class Generator&gt;
+  bool container_proxy&lt;Container, Holder, Generator&gt;::is_valid () const
+  {
+    bool ok = size() == m_proxies.size(); // Sizes must match
+
+    for (size_type count = 0; ok &amp;&amp; (count &lt; size()); ++count)
+      {
+        pointer_impl const &amp;ptr = m_proxies[count];
+
+        ok = ptr.get() &amp;&amp; (ptr-&gt;owner() == this) &amp;&amp; (ptr-&gt;index() == count)
+          &amp;&amp; !ptr-&gt;m_element_ptr.get();
+      }
+
+    return ok;
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for container_proxy instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Container&gt;
+  struct container_proxy_traits : random_access_sequence_traits&lt;Container&gt;
+  {
+    typedef Container container;
+    typedef typename container::raw_value_type value_type; // insert, ...
+    typedef typename container::raw_value_type key_type;   // find, count, ...
+    typedef typename container::reference reference;  // return values
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;value_type&gt;::param_type
+        value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;key_type&gt;::param_type
+        key_param;
+
+#if defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+    // value_traits for the reference type (i.e. our element_proxy
+    // instance) supplies a custom visit_container_class. Compilers
+    // without partial specialization need help here.
+
+    typedef element_proxy_traits&lt;Container&gt; value_traits_type;
+
+    // Hide base class visit_container_class, which would call the
+    // unspecialized value_traits version
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class(
+        PythonClass &amp;pyClass, Policy const &amp;policy)
+    {
+      value_traits_type::visit_container_class (pyClass, policy);
+    }
+#endif
+  };
+
+#if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for container_proxy instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;typename RawContainer, typename Holder, typename Generator&gt;
+    class algorithms_selector&lt;container_proxy&lt;RawContainer, Holder, Generator&gt; &gt;
+    {
+      typedef container_proxy&lt;RawContainer, Holder, Generator&gt; Container;
+
+      typedef container_proxy_traits&lt;Container&gt;       mutable_traits;
+      typedef container_proxy_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef default_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef default_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+  }
+#endif
+  template&lt;
+      class Container,
+      method_set_type MethodMask = all_methods,
+      class Traits = container_proxy_traits&lt;Container&gt;
+  &gt;
+  struct container_proxy_suite
+    : container_suite&lt;Container, MethodMask, default_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_CONTAINER_PROXY_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_suite.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_suite.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_suite.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,53 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file container_suite.hpp
+//
+// Top-level interface to the container suite.
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation
+// 2003/ 9/ 8   rmg     Extracted trait facilities into container_traits.hpp
+//
+// $Id: container_suite.hpp,v 1.1.2.7 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP
+#define BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP
+
+#include &lt;boost/python/suite/indexing/methods.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;boost/python/suite/indexing/visitor.hpp&gt;
+
+#include &lt;boost/python/return_by_value.hpp&gt;
+#include &lt;boost/python/return_value_policy.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  typedef boost::python::return_value_policy&lt;boost::python::return_by_value&gt;
+  default_container_policies;
+
+  template&lt;
+      class Container,
+      method_set_type MethodMask = all_methods,  // All supported by algorithms
+      class Algorithms
+          = algorithms&lt;Container&gt;
+  &gt;
+  struct container_suite
+    : public visitor&lt;Algorithms, default_container_policies, MethodMask&gt;
+  {
+    typedef Algorithms algorithms;
+
+    template&lt;typename Policy&gt;
+    static visitor&lt;Algorithms, Policy, MethodMask&gt;
+    with_policies (Policy const &amp;policy)
+    {
+      return visitor &lt;Algorithms, Policy, MethodMask&gt; (policy);
+    }
+  };
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_traits.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_traits.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/container_traits.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,159 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file container_traits.hpp
+//
+// Traits information about entire containers for use in determining
+// what Python methods to provide.
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation as container_suite.hpp
+// 2003/ 9/ 8   rmg     Renamed container_traits.hpp
+// 2003/10/28   rmg     Split container-specific versions into separate headers
+// 2004/ 1/28   rmg     Convert to bitset-based feature selection
+//
+// $Id: container_traits.hpp,v 1.1.2.15 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_CONTAINER_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_CONTAINER_TRAITS_HPP
+
+#include &lt;boost/python/suite/indexing/suite_utils.hpp&gt;
+#include &lt;boost/python/suite/indexing/methods.hpp&gt;
+#include &lt;boost/python/suite/indexing/value_traits.hpp&gt;
+
+#include &lt;boost/type_traits.hpp&gt;
+#include &lt;boost/call_traits.hpp&gt;
+#include &lt;boost/mpl/if.hpp&gt;
+#include &lt;boost/type_traits/ice.hpp&gt;
+#include &lt;boost/iterator/iterator_traits.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+#if BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1200)
+  // MSVC6 has problems with get_signature if parameter types have
+  // top-level const qualification (e.g. int const). Unfortunately,
+  // this is exactly what happens with boost::call_traits, so we
+  // substitute a really dumb version of it instead.
+
+  template&lt;typename T&gt; struct broken_call_traits {
+    typedef T const &amp; param_type;
+  };
+# define BOOST_PYTHON_INDEXING_CALL_TRAITS broken_call_traits
+#else
+# define BOOST_PYTHON_INDEXING_CALL_TRAITS ::boost::call_traits
+#endif
+
+  /////////////////////////////////////////////////////////////////////////
+  // Lowest common denominator traits - applicable to real containers
+  // and iterator pairs
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Container, typename ValueTraits = detail::no_override&gt;
+  struct base_container_traits
+  {
+    typedef base_container_traits&lt;Container, ValueTraits&gt; self_type;
+
+  protected:
+    BOOST_STATIC_CONSTANT(
+        bool, is_mutable = ! boost::is_const&lt;Container&gt;::value);
+
+  public:
+    typedef Container container;
+
+    typedef BOOST_DEDUCED_TYPENAME container::value_type value_type;
+
+    typedef BOOST_DEDUCED_TYPENAME mpl::if_&lt;
+        is_const&lt;container&gt;,
+        BOOST_DEDUCED_TYPENAME container::const_iterator,
+        BOOST_DEDUCED_TYPENAME container::iterator
+      &gt;::type iterator;
+
+    typedef typename ::boost::iterator_reference&lt;iterator&gt;::type reference;
+
+    typedef value_type key_type; // Used for find, etc.
+    typedef typename container::size_type size_type;
+    typedef typename make_signed&lt;size_type&gt;::type index_type;
+    // at(), operator[]. Signed to support Python -ve indexes
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS&lt;value_type&gt;::param_type
+        value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS&lt;key_type&gt;::param_type
+        key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS&lt;index_type&gt;::param_type
+        index_param;
+
+    // Allow client code to replace the default value traits via our
+    // second (optional) template parameter
+    typedef value_traits&lt;value_type&gt; default_value_traits;
+    typedef typename detail::maybe_override&lt;
+        default_value_traits, ValueTraits&gt;::type value_traits_type;
+
+    // Forward visit_container_class to value_traits_type
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class(
+        PythonClass &amp;pyClass, Policy const &amp;policy)
+    {
+      value_traits_type::visit_container_class (pyClass, policy);
+    }
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits for sequences with random access - std::vector,
+  // std::deque and the like
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Container, typename ValueTraits = detail::no_override&gt;
+  class random_access_sequence_traits
+    : public base_container_traits&lt;Container, ValueTraits&gt;
+  {
+    typedef base_container_traits&lt;Container, ValueTraits&gt; base_class;
+
+  public:
+    typedef typename base_class::value_traits_type value_traits_type;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_len
+            | method_getitem
+            | method_getitem_slice
+
+            | detail::method_set_if&lt;
+                  value_traits_type::equality_comparable,
+                    method_index
+                  | method_contains
+                  | method_count
+              &gt;::value
+
+            | detail::method_set_if&lt;
+                  base_class::is_mutable,
+                    method_setitem
+                  | method_setitem_slice
+                  | method_delitem
+                  | method_delitem_slice
+                  | method_reverse
+                  | method_append
+                  | method_insert
+                  | method_extend
+              &gt;::value
+
+            | detail::method_set_if&lt;
+                  type_traits::ice_and&lt;
+                      base_class::is_mutable,
+                      value_traits_type::less_than_comparable
+                  &gt;::value,
+                  method_sort
+              &gt;::value
+
+        ));
+
+        // Not supported: method_iter, method_has_key
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_CONTAINER_SUITE_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/deque.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/deque.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/deque.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,60 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file deque.hpp
+//
+// Indexing algorithms support for std::deque instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: deque.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_DEQUE_HPP
+#define BOOST_PYTHON_INDEXING_DEQUE_HPP
+
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;deque&gt;
+
+namespace boost { namespace python { namespace indexing {
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::deque instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;class T, class Allocator&gt;
+    class algorithms_selector&lt;std::deque&lt;T, Allocator&gt; &gt;
+    {
+      typedef std::deque&lt;T, Allocator&gt; Container;
+
+      typedef random_access_sequence_traits&lt;Container&gt;       mutable_traits;
+      typedef random_access_sequence_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef default_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef default_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+  }
+#endif
+
+  template&lt;
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = random_access_sequence_traits&lt;Container&gt;
+  &gt;
+  struct deque_suite
+    : container_suite&lt;Container, MethodMask, default_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_DEQUE_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,187 @@
+// Header file element_proxy.hpp
+//
+// Proxy objects for invidivual elements in a container wrapped by
+// container_proxy
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 9/15   rmg     File creation from container_proxy.hpp
+//
+// $Id: element_proxy.hpp,v 1.1.2.10 2003/12/03 12:18:51 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ELEMENT_PROXY_HPP
+#define BOOST_PYTHON_INDEXING_ELEMENT_PROXY_HPP
+
+#include &lt;boost/python/suite/indexing/shared_proxy_impl.hpp&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/get_pointer.hpp&gt;
+#include &lt;boost/utility/addressof.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  template&lt;typename ContainerProxy&gt;
+  class element_proxy
+  {
+  public:
+    typedef typename ContainerProxy::shared_proxy proxy_type;
+    typedef typename ContainerProxy::raw_value_type raw_value_type;
+    typedef typename ContainerProxy::size_type size_type;
+    typedef boost::shared_ptr&lt;proxy_type&gt; proxy_pointer;
+
+    typedef typename proxy_type::value_type value_type;
+    typedef typename proxy_type::reference reference;
+    typedef typename proxy_type::pointer pointer;
+    typedef typename proxy_type::iterator_category iterator_category;
+    typedef typename proxy_type::difference_type difference_type;
+
+    typedef value_type element_type;      // Alias for register_ptr_to_python
+
+    element_proxy () : m_ptr () { }
+    explicit element_proxy (proxy_type *ptr) : m_ptr (ptr) { }
+    explicit element_proxy (proxy_pointer const &amp;ptr) : m_ptr (ptr) { }
+
+    explicit element_proxy (raw_value_type const &amp;val)
+      : m_ptr (new proxy_type(val))
+    {
+      // Create new standalone value (i.e. detached)
+    }
+
+    reference operator* () const { return m_ptr-&gt;operator*(); }
+    pointer operator-&gt; () const { return (*m_ptr).operator-&gt;(); }
+    pointer get () const { return operator-&gt;(); }  // Alias for pointer_holder
+
+    // Implicit conversion to raw_value_type
+    operator reference () const { return operator*(); }
+
+#if BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1200)
+    // The implicit conversion doesn't work on MSVC6, so help it along
+    // a little.
+    bool operator== (value_type const &amp;val) const { return (**this) == val; }
+    bool operator!= (value_type const &amp;val) const { return (**this) != val; }
+    bool operator&lt; (value_type const &amp;val) const { return (**this) &lt; val; }
+    bool operator&gt; (value_type const &amp;val) const { return (**this) &gt; val; }
+#endif
+
+    element_proxy &amp;operator= (value_type const &amp;copy)
+    {
+      proxy_type &amp;proxy = *m_ptr;
+      ContainerProxy *container = proxy.owner();
+      size_type index = proxy.index();
+
+      if (container)
+        {
+          container-&gt;replace (index, copy);
+          // Proxy was attached before, but is now detached. Make sure
+          // we now refer to the new element, instead of the detached
+          // copy of the old element
+          m_ptr = container-&gt;at (index).m_ptr;
+
+          // Note: in the special case that this we and the container
+          // proxy itself have the only references to the
+          // shared_proxy_impl, it is not necessary to first detach
+          // the proxy. Maybe best to implement when changing to
+          // intrusive_ptr instead of shared_ptr.
+        }
+
+      else
+        {
+          *proxy = copy;
+        }
+
+      return *this;
+    }
+
+    element_proxy &amp;operator= (element_proxy const &amp;copy)
+    {
+      // Required to make sorting a container_proxy work
+      return (*this) = *copy;
+    }
+
+    size_t use_count() const { return m_ptr.use_count(); } // For debugging
+
+  private:
+    proxy_pointer m_ptr;
+  };
+
+  template&lt;typename ContainerProxy&gt;
+  class const_element_proxy
+  {
+  public:
+    typedef element_proxy&lt;ContainerProxy&gt; base_type;
+    typedef typename base_type::proxy_type proxy_type;
+    typedef typename base_type::proxy_pointer proxy_pointer;
+    typedef typename base_type::raw_value_type raw_value_type;
+
+    typedef typename proxy_type::value_type const value_type;
+    typedef value_type &reference;
+    typedef value_type *pointer;
+    typedef typename base_type::iterator_category iterator_category;
+    typedef typename base_type::difference_type difference_type;
+
+    const_element_proxy () : m_base () { }
+    explicit const_element_proxy (proxy_type *ptr) : m_base (ptr) { }
+
+    explicit const_element_proxy (proxy_pointer const &amp;ptr) : m_base (ptr) {}
+
+    const_element_proxy (const_element_proxy&lt;ContainerProxy&gt; const &amp;copy)
+      : m_base (copy.m_base)
+    {
+    }
+
+    const_element_proxy (element_proxy&lt;ContainerProxy&gt; const &amp;copy)
+      : m_base (copy)
+    {
+    }
+
+    explicit const_element_proxy (raw_value_type const &amp;val)
+      : m_base (new proxy_type(val))
+    {
+    }
+
+    reference operator* () const { return *m_base; }
+    pointer operator-&gt; () const { return m_base.operator-&gt;(); }
+
+    // Implicit conversion to raw_value_type const &amp;
+    operator reference () const { return *m_base; }
+
+#if BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1200)
+    // The implicit conversion doesn't work on MSVC6, so help it along
+    // a little.
+    bool operator== (value_type const &amp;val) const { return m_base == val; }
+    bool operator!= (value_type const &amp;val) const { return m_base != val; }
+    bool operator&lt; (value_type const &amp;val) const { return m_base &lt; val; }
+    bool operator&gt; (value_type const &amp;val) const { return m_base &gt; val; }
+#endif
+
+    size_t use_count() const { return m_base.use_count(); } // For debugging
+
+  private:
+    base_type m_base;
+  };
+
+#ifdef BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+}} // namespace python::indexing
+#endif 
+
+  template&lt;typename ContainerProxy&gt;
+  typename ContainerProxy::raw_value_type *
+  get_pointer (python::indexing::element_proxy&lt;ContainerProxy&gt; const &amp;proxy)
+  {
+    return ::boost::addressof (*proxy);
+  }
+
+#ifndef BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+    // Don't hide these other get_pointer overloads
+    using boost::get_pointer;
+}} // namespace python::indexing
+#endif 
+}
+
+#endif // BOOST_PYTHON_INDEXING_ELEMENT_PROXY_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy_traits.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy_traits.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/element_proxy_traits.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,89 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file element_proxy_traits.hpp
+//
+// Note: element_proxy.hpp must be included before this header
+//
+// This is a separate header so that element_proxy.hpp is not
+// dependant on register_ptr_to_python.hpp. This avoids a problem with
+// two-phase name lookup, where register_ptr_to_python must be
+// included *after* the element_proxy overload of boost::get_pointer
+// is declared.
+//
+// History
+// =======
+// 2003/10/23   rmg     File creation
+//
+// $Id: element_proxy_traits.hpp,v 1.1.2.5 2003/12/05 17:36:14 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ELEMENT_PROXY_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_ELEMENT_PROXY_TRAITS_HPP
+
+#include &lt;boost/python/suite/indexing/element_proxy.hpp&gt;
+#include &lt;boost/python/suite/indexing/value_traits.hpp&gt;
+#include &lt;boost/python/register_ptr_to_python.hpp&gt;
+#include &lt;boost/python/implicit.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  template&lt;typename ContainerProxy&gt;
+  struct element_proxy_traits
+    : public value_traits&lt;
+          BOOST_DEDUCED_TYPENAME ContainerProxy::raw_value_type&gt;
+  {
+    typedef element_proxy&lt;ContainerProxy&gt; element_proxy_type;
+    typedef typename ContainerProxy::raw_value_type raw_value_type;
+    typedef value_traits&lt;raw_value_type&gt; base_type;
+
+    // Wrap the base class versions of the comparisons using
+    // indirection
+    struct less
+      : std::binary_function&lt;element_proxy_type, element_proxy_type, bool&gt;
+    {
+      typename base_type::less m_base_compare;
+
+      bool operator()(
+          element_proxy_type const &amp;p1, element_proxy_type const &amp;p2) const
+      {
+        return m_base_compare (*p1, *p2);
+      }
+    };
+
+    struct equal_to
+      : std::binary_function&lt;raw_value_type, element_proxy_type, bool&gt;
+    {
+      // First param is raw_value_type to interface smoothly with the
+      // bind1st used in default_algorithms::find
+
+      typename base_type::equal_to m_base_compare;
+
+      bool operator()(
+          raw_value_type const &amp;v, element_proxy_type const &amp;p) const
+      {
+        return m_base_compare (v, *p);
+      }
+    };
+
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class (PythonClass &amp;, Policy const &amp;)
+    {
+      register_ptr_to_python&lt;element_proxy_type&gt;();
+      implicitly_convertible&lt;raw_value_type, element_proxy_type&gt;();
+    }
+  };
+
+#if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  // value_traits partial specialization for element_proxy instances
+  template&lt;typename ContainerProxy&gt;
+  struct value_traits&lt;element_proxy&lt;ContainerProxy&gt; &gt;
+    : element_proxy_traits&lt;ContainerProxy&gt;
+  {
+  };
+#endif
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ELEMENT_PROXY_TRAITS_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/int_slice_helper.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/int_slice_helper.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/int_slice_helper.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,251 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file int_slice_helper.hpp
+//
+// History
+// =======
+// 2003/10/13   rmg     File creation
+//
+// $Id: int_slice_helper.hpp,v 1.1.2.10 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_INT_SLICE_HELPER_HPP
+#define BOOST_PYTHON_INDEXING_INT_SLICE_HELPER_HPP
+
+# include &lt;boost/python/errors.hpp&gt;
+# include &lt;boost/python/suite/indexing/workaround.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  template&lt;typename Algorithms, typename SliceType&gt;
+  struct int_slice_helper
+  {
+    // Works with a SliceType that provides an int-like index_type
+    // that is convertible to the algorithm's index_param
+
+    typedef Algorithms algorithms_type;
+    typedef SliceType slice_type;
+
+    typedef typename algorithms_type::container container;
+    typedef typename algorithms_type::reference reference;
+    typedef typename algorithms_type::value_param value_param;
+    typedef typename algorithms_type::container_traits container_traits;
+    typedef typename slice_type::index_type index_type;
+
+    int_slice_helper (container &amp;c, slice_type const &amp;);
+
+    bool next();
+
+    reference current () const;
+    void write (value_param val);
+    void erase_remaining () const;
+
+  private:
+    void assign (value_param val) const;
+    void insert (value_param val);
+
+  private:
+    slice_type m_slice;
+    container *m_ptr;
+    index_type m_pos;
+  };
+
+  template&lt;typename Algorithms, typename SliceType&gt;
+  int_slice_helper&lt;Algorithms, SliceType&gt;
+  ::int_slice_helper (container &amp;c, slice_type const &amp;sl)
+    : m_slice (sl),
+    m_ptr (&amp;c),
+    m_pos (-1)
+  {
+  }
+
+  template&lt;typename Algorithms, typename SliceType&gt;
+  bool
+  int_slice_helper&lt;Algorithms, SliceType&gt;::next()
+  {
+    bool result = false; // Assume the worst
+
+    if (m_pos == -1)
+      {
+        // First time call - get to start of the slice (if any)
+        m_pos = m_slice.start();
+        result = m_slice.in_range (m_pos);
+      }
+
+    else if (m_slice.in_range (m_pos))
+      {
+        // Subsequent calls - advance by the slice's stride
+        m_pos += m_slice.step();
+        result = m_slice.in_range (m_pos);
+      }
+
+    return result;
+  }
+
+  template&lt;typename Algorithms, typename SliceType&gt;
+  typename int_slice_helper&lt;Algorithms, SliceType&gt;::reference
+  int_slice_helper&lt;Algorithms, SliceType&gt;::current () const
+  {
+    return algorithms_type::get (*m_ptr, m_pos);
+  }
+
+  template&lt;typename Algorithms, typename SliceType&gt;
+  void int_slice_helper&lt;Algorithms, SliceType&gt;::write (value_param val)
+  {
+    if (next())
+      {
+        assign (val);
+      }
+
+    else
+      {
+        insert (val);
+      }
+  }
+
+  template&lt;typename Algorithms, typename SliceType&gt;
+  void int_slice_helper&lt;Algorithms, SliceType&gt;::assign (value_param val) const
+  {
+    algorithms_type::assign (*m_ptr, m_pos, val);
+  }
+
+  namespace detail {
+    template&lt;bool doit&gt; struct maybe_insert {
+
+      // NOTE: use the name &quot;apply_&quot; instead of &quot;apply&quot; to avoid
+      // weirdo compiler crash in mpl/aux_/apply.hpp on MSVC7. Don't
+      // even ask how I arrived at this fix :-)
+
+      template&lt;class Algorithms&gt;
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        &amp;&amp; defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          // Can't explicitly instantiate member function - must let
+          // the compiler deduce the argument type from a dummy
+          // parameter. Same applies throughout
+          Algorithms *,
+# endif
+          typename Algorithms::container &amp;,
+          typename Algorithms::index_param,
+          typename Algorithms::value_param)
+      {
+        PyErr_SetString(
+            PyExc_TypeError,
+            &quot;container does not support insertion into slice&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+    };
+
+    template&lt;&gt; struct maybe_insert&lt;true&gt; {
+      template&lt;class Algorithms&gt;
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        &amp;&amp; defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          Algorithms *,
+# endif
+          typename Algorithms::container &amp;c,
+          typename Algorithms::index_param i,
+          typename Algorithms::value_param v)
+      {
+        Algorithms::insert (c, i, v);
+      }
+    };
+  }
+
+  template&lt;typename Algorithms, typename SliceType&gt;
+  void int_slice_helper&lt;Algorithms, SliceType&gt;::insert (value_param val)
+  {
+    if (m_slice.step() != 1)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, &quot;attempt to insert via extended slice&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+
+    else
+      {
+        detail::maybe_insert&lt;
+          detail::is_member&lt;
+            container_traits::supported_methods, method_insert&gt;::value&gt;::
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+  &amp;&amp; defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          apply_ (static_cast&lt;Algorithms *&gt;(0),
+# else
+          BOOST_NESTED_TEMPLATE apply_ &lt;Algorithms&gt;(
+# endif
+              *m_ptr, m_pos, val);
+
+        ++m_pos;  // Advance for any subsequent inserts
+      }
+  }
+
+  namespace detail {
+    template&lt;bool doit&gt; struct maybe_erase {
+      template&lt;class Algorithms&gt;
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        &amp;&amp; defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          Algorithms *,
+# endif
+          typename Algorithms::container &amp;,
+          typename Algorithms::index_param,
+          typename Algorithms::index_param)
+      {
+        PyErr_SetString(
+            PyExc_TypeError, &quot;container does not support item deletion&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+    };
+
+    template&lt;&gt; struct maybe_erase&lt;true&gt; {
+      template&lt;class Algorithms&gt;
+      static void apply_(
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+        &amp;&amp; defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          Algorithms *,
+# endif
+          typename Algorithms::container &amp;c,
+          typename Algorithms::index_param from,
+          typename Algorithms::index_param to)
+      {
+        Algorithms::erase_range (c, from, to);
+      }
+    };
+  }
+
+  template&lt;typename Algorithms, typename SliceType&gt;
+  void int_slice_helper&lt;Algorithms, SliceType&gt;::erase_remaining () const
+  {
+    if (m_slice.step() != 1)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, &quot;attempt to delete via extended slice&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+
+    else
+      {
+        detail::maybe_erase&lt;
+          detail::is_member&lt;
+            container_traits::supported_methods, method_delitem&gt;::value&gt;::
+
+# if defined (BOOST_NO_MEMBER_TEMPLATES) \
+  &amp;&amp; defined (BOOST_MSVC6_MEMBER_TEMPLATES)
+          apply_ (static_cast&lt;Algorithms *&gt;(0),
+# else
+          BOOST_NESTED_TEMPLATE apply_ &lt;Algorithms&gt;(
+# endif
+              *m_ptr, m_pos, m_slice.stop());
+      }
+  }
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_INT_SLICE_HELPER_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_range.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_range.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_range.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,260 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file iterator_range.hpp
+//
+// Emulate an STL container using a pair of iterators. Doesn't support
+// insertion or deletion, for the obvious reasons.
+//
+// History
+// =======
+// 2003/ 9/ 9   rmg     File creation as iterator_pair.hpp
+// 2003/10/27   rmg     Renamed iterator_range.hpp
+//
+// $Id: iterator_range.hpp,v 1.1.2.7 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ITERATOR_RANGE_HPP
+#define BOOST_PYTHON_INDEXING_ITERATOR_RANGE_HPP
+
+#include &lt;stdexcept&gt;
+#include &lt;algorithm&gt;
+#include &lt;utility&gt;
+#include &lt;boost/type_traits.hpp&gt;
+#include &lt;boost/type_traits/ice.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+#include &lt;boost/iterator/iterator_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;boost/python/suite/indexing/iterator_traits.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  template&lt;typename Iterator&gt;
+  class iterator_range
+  {
+  private:
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;Iterator&gt;::param_type
+        iterator_param;
+
+    typedef ::boost::detail::iterator_traits&lt;Iterator&gt; std_traits;
+
+  public:
+    typedef typename std_traits::reference       reference;
+    typedef Iterator                             iterator;
+    typedef typename std_traits::difference_type size_type;
+    typedef typename std_traits::difference_type difference_type;
+    typedef typename std_traits::value_type      value_type;
+    typedef typename std_traits::pointer         pointer;
+
+    typedef iterator                             const_iterator;
+    // Can't tell what the const version of our iterator should
+    // be. The client code will have to instantiate iterator_range
+    // directly with a const_iterator if that's what it wants.
+
+    // Also can't provide: allocator_type, reverse_iterator or
+    // const_reverse_iterator. Could probably provide (but don't)
+    // const_reference and const_pointer. These would be the same as
+    // reference and pointer if Iterator is itself a const_iterator.
+
+  public:
+    iterator_range (iterator_param, iterator_param);
+    iterator_range (std::pair&lt;iterator, iterator&gt; const &amp;);
+
+    iterator begin() const;
+    iterator end() const;
+
+  public:
+    // Only sensible for random_access iterators
+    size_type size () const;
+    reference operator[] (size_type) const;
+    reference at (size_type) const;
+
+  private:
+    iterator m_begin;
+    iterator m_end;
+  };
+
+  // Array support function(s).
+  template&lt;typename T&gt; iterator_range&lt;T *&gt; make_iterator_range (T *, T*);
+
+#if !BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1200)
+  template&lt;typename T, std::size_t N&gt; iterator_range&lt;T *&gt; make_iterator_range(
+      T (&amp;array)[N]);
+
+  template&lt;typename T, std::size_t N&gt; T *begin (T (&amp;array)[N]);
+  template&lt;typename T, std::size_t N&gt; T *end   (T (&amp;array)[N]);
+
+# define BOOST_MAKE_ITERATOR_RANGE \
+      ::boost::python::indexing::make_iterator_range
+
+#else
+  // For compilers that can't deduce template argument array bounds
+# define BOOST_MAKE_ITERATOR_RANGE(array) \
+      ::boost::python::indexing::make_iterator_range ( \
+          (array), ((array) + sizeof(array) / sizeof((array)[0])))
+#endif
+
+  template&lt;typename Iterator&gt;
+  iterator_range&lt;Iterator&gt;::iterator_range(
+      iterator_param begin, iterator_param end)
+    : m_begin (begin),
+    m_end (end)
+  {
+  }
+
+  template&lt;typename Iterator&gt;
+  iterator_range&lt;Iterator&gt;
+  ::iterator_range (std::pair&lt;iterator, iterator&gt; const &amp;pair)
+    : m_begin (pair.first),
+    m_end (pair.second)
+  {
+  }
+
+  template&lt;typename Iterator&gt;
+  typename iterator_range&lt;Iterator&gt;::iterator
+  iterator_range&lt;Iterator&gt;::begin() const
+  {
+    return m_begin;
+  }
+
+  template&lt;typename Iterator&gt;
+  typename iterator_range&lt;Iterator&gt;::iterator
+  iterator_range&lt;Iterator&gt;::end() const
+  {
+    return m_end;
+  }
+
+  template&lt;typename Iterator&gt;
+  typename iterator_range&lt;Iterator&gt;::size_type
+  iterator_range&lt;Iterator&gt;::size() const
+  {
+    return std::distance (begin(), end());
+  }
+
+  template&lt;typename Iterator&gt;
+  typename iterator_range&lt;Iterator&gt;::reference
+  iterator_range&lt;Iterator&gt;::operator[](size_type index) const
+  {
+    iterator temp (begin());
+    std::advance (temp, index);
+    return *temp;
+  }
+
+  template&lt;typename Iterator&gt;
+  typename iterator_range&lt;Iterator&gt;::reference
+  iterator_range&lt;Iterator&gt;::at (size_type index) const
+  {
+    if (index &gt;= size())
+      {
+        throw std::out_of_range
+          (std::string (&quot;iterator_range: index out of range&quot;));
+      }
+
+    else
+      {
+        return (*this)[index];
+      }
+  }
+
+  template&lt;typename T&gt; iterator_range&lt;T *&gt; make_iterator_range (T *p1, T* p2)
+  {
+    return iterator_range&lt;T *&gt; (p1, p2);
+  }
+
+#if !BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1200)
+  template&lt;typename T, std::size_t N&gt;
+  T *begin (T (&amp;array)[N]) {
+    return array;
+  }
+
+  template&lt;typename T, std::size_t N&gt;
+  T *end (T (&amp;array)[N]) {
+    return array + N;
+  }
+
+  template&lt;typename T, std::size_t N&gt;
+  iterator_range&lt;T *&gt; make_iterator_range (T (&amp;array)[N]) {
+    return iterator_range&lt;T *&gt;(begin (array), end (array));
+  }
+#endif
+
+  template&lt;typename Container, typename ValueTraits = detail::no_override&gt;
+  class iterator_range_traits
+    : public base_container_traits&lt;Container, ValueTraits&gt;
+  {
+    typedef base_container_traits&lt;Container, ValueTraits&gt; base_class;
+
+    typedef ::boost::python::indexing::iterator_traits&lt;
+      typename Container::iterator
+    &gt; iterator_traits_type;
+
+  public:
+    typedef typename base_class::value_traits_type value_traits_type;
+
+  private:
+    // Methods that we *can't* support because of our value type
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        disabled_methods = (
+            detail::method_set_if&lt;
+               type_traits::ice_not&lt;
+                   value_traits_type::equality_comparable
+               &gt;::value,
+                 method_index      // Impossible if !equality_comparable
+               | method_contains   // Impossible if !equality_comparable
+               | method_count      // Impossible if !equality_comparable
+            &gt;::value
+
+          | detail::method_set_if&lt;
+               type_traits::ice_not&lt;
+                   value_traits_type::less_than_comparable
+               &gt;::value,
+               method_sort         // Impossible if !less_than_comparable
+            &gt;::value
+        ));
+
+  public:
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods =
+        iterator_traits_type::supported_methods &amp; ~disabled_methods);
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for iterator_range instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;typename Iterator&gt;
+    class algorithms_selector&lt;iterator_range&lt;Iterator&gt; &gt;
+    {
+      typedef iterator_range&lt;Iterator&gt; Container;
+
+      typedef iterator_range_traits&lt;Container&gt;       mutable_traits;
+      typedef iterator_range_traits&lt;Container const&gt; const_traits; // ?
+
+    public:
+      typedef default_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef default_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+  }
+#endif
+
+  template&lt;
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = iterator_range_traits&lt;Container&gt;
+  &gt;
+  struct iterator_range_suite
+    : container_suite&lt;Container, MethodMask, default_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ITERATOR_RANGE_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_traits.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_traits.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/iterator_traits.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,211 @@
+// -*- mode:c++ -*-
+//
+// Header file iterator_traits.hpp
+//
+// Traits information about iterators for use in determining what
+// Python methods to support for a container.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation as iterator_suite.hpp
+// 2003/ 9/12   rmg     Renamed iterator_traits.hpp
+//
+// $Id: iterator_traits.hpp,v 1.1.2.14 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_ITERATOR_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_ITERATOR_TRAITS_HPP
+
+#include &lt;boost/python/suite/indexing/suite_utils.hpp&gt;
+#include &lt;boost/python/suite/indexing/methods.hpp&gt;
+//#include &lt;boost/python/suite/indexing/workaround.hpp&gt;
+
+//#include &lt;boost/call_traits.hpp&gt;
+//#include &lt;boost/type_traits.hpp&gt;
+#include &lt;boost/iterator/iterator_traits.hpp&gt;
+#include &lt;boost/iterator/iterator_categories.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits common base class
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Iterator&gt;
+  struct base_iterator_traits
+  {
+  private:
+    typedef ::boost::detail::iterator_traits&lt;Iterator&gt; std_traits;
+    typedef typename std_traits::reference reference;
+
+  public:
+    //    typedef Iterator                             iterator;
+    //    typedef typename std_traits::value_type      value_type;
+    //    typedef typename std_traits::difference_type difference_type;
+
+    BOOST_STATIC_CONSTANT(
+        bool, has_mutable_ref = is_mutable_ref&lt;reference&gt;::value);
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for input iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Iterator&gt;
+  struct input_iterator_traits : base_iterator_traits&lt;Iterator&gt;
+  {
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+            method_iter
+        ));
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for forward iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Iterator&gt;
+  struct forward_iterator_traits
+    : public base_iterator_traits&lt;Iterator&gt;
+  {
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_len
+            | method_iter
+        ));
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for bidirectional iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Iterator&gt;
+  struct bidirectional_iterator_traits
+    : public forward_iterator_traits&lt;Iterator&gt;
+  {
+    typedef forward_iterator_traits&lt;Iterator&gt; base_class;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              base_class::supported_methods
+
+            | detail::method_set_if&lt;
+                  base_class::has_mutable_ref,
+                  method_reverse
+              &gt;::value
+        ));
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Indexing traits for random access iterators
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Iterator&gt;
+  struct random_access_iterator_traits
+    : public bidirectional_iterator_traits&lt;Iterator&gt;
+  {
+    typedef bidirectional_iterator_traits&lt;Iterator&gt; base_class;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+            (base_class::supported_methods &amp; ~method_iter)
+
+            | method_getitem
+            | method_getitem_slice
+
+            | detail::method_set_if&lt;
+                  base_class::has_mutable_ref,
+                  method_setitem
+                | method_setitem_slice
+              &gt;::value
+
+            | method_index     // Assumes value is equality_comparable
+            | method_contains  // Assumes value is equality_comparable
+            | method_count     // Assumes value is equality_comparable
+
+            | detail::method_set_if&lt;
+                  base_class::has_mutable_ref,
+                  method_sort
+              &gt;::value         // Assumes value is less_than_comparable
+
+        ));
+  };
+
+  namespace iterator_detail {
+    // Some meta-progamming machinery to select the right
+    // indexing::iterator_traits template on the basis of
+    // BOOST_ITERATOR_CATEGORY
+
+    typedef char basic_iter_sizer[1];
+    typedef char forward_iter_sizer[2];
+    typedef char bidirectional_iter_sizer[3];
+    typedef char random_access_iter_sizer[4];
+
+    basic_iter_sizer         &amp;sizer (void *);
+    forward_iter_sizer       &amp;sizer (std::forward_iterator_tag *);
+    bidirectional_iter_sizer &amp;sizer (std::bidirectional_iterator_tag *);
+    random_access_iter_sizer &amp;sizer (std::random_access_iterator_tag *);
+  
+    template&lt;size_t Size&gt; struct traits_by_size {
+      // Default implementation gives only the most basic support
+      template&lt;typename Iterator&gt;
+        struct traits {
+          typedef input_iterator_traits&lt;Iterator&gt; type;
+        };
+    };
+
+    template&lt;&gt;
+    struct traits_by_size&lt;sizeof(forward_iter_sizer)&gt; {
+      template&lt;typename Iterator&gt;
+        struct traits {
+          typedef forward_iterator_traits&lt;Iterator&gt; type;
+        };
+    };
+
+    template&lt;&gt;
+    struct traits_by_size&lt;sizeof(bidirectional_iter_sizer)&gt; {
+      template&lt;typename Iterator&gt;
+        struct traits {
+          typedef bidirectional_iterator_traits&lt;Iterator&gt; type;
+        };
+    };
+
+    template&lt;&gt;
+    struct traits_by_size&lt;sizeof(random_access_iter_sizer)&gt; {
+      template&lt;typename Iterator&gt;
+        struct traits {
+          typedef random_access_iterator_traits&lt;Iterator&gt; type;
+        };
+    };
+
+    template&lt;typename Iterator&gt;
+    class deduced_traits {
+      typedef typename ::boost::BOOST_ITERATOR_CATEGORY&lt;Iterator&gt;::type
+          category;
+
+      BOOST_STATIC_CONSTANT(
+          size_t, sizer_result = sizeof (sizer (new category)));
+
+    public:
+      typedef typename traits_by_size&lt;sizer_result&gt;
+        ::BOOST_NESTED_TEMPLATE traits&lt;Iterator&gt;::type type;
+    };
+  }
+
+  template&lt;typename Iterator&gt;
+  struct iterator_traits
+    : public iterator_detail::deduced_traits&lt;Iterator&gt;::type
+  {
+  };
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_ITERATOR_TRAITS_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/list.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/list.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/list.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,167 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file list.hpp
+//
+// Indexing algorithms support for std::list instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: list.hpp,v 1.1.2.7 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_LIST_HPP
+#define BOOST_PYTHON_INDEXING_LIST_HPP
+
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;list&gt;
+
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+# include &lt;boost/static_assert.hpp&gt;
+# include &lt;boost/type_traits.hpp&gt;
+#endif
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::list instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Container, typename ValueTraits = detail::no_override&gt;
+  class list_traits
+    : public base_container_traits&lt;Container, ValueTraits&gt;
+  {
+    typedef base_container_traits&lt;Container, ValueTraits&gt; base_class;
+
+  public:
+    typedef typename base_class::value_traits_type value_traits_type;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_len
+            | method_iter
+
+            | detail::method_set_if&lt;
+                  value_traits_type::equality_comparable,
+                    method_contains
+                  | method_count
+              &gt;::value
+
+            | detail::method_set_if&lt;
+                  base_class::is_mutable,
+                  method_reverse
+                  | method_append
+              &gt;::value
+
+            | detail::method_set_if&lt;
+                  type_traits::ice_and&lt;
+                      base_class::is_mutable,
+                      value_traits_type::less_than_comparable
+                  &gt;::value,
+                  method_sort
+              &gt;::value
+
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::list instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr = detail::no_override&gt;
+  class list_algorithms
+    : public default_algorithms
+        &lt;ContainerTraits,
+        typename detail::maybe_override
+            &lt;list_algorithms&lt;ContainerTraits, Ovr&gt;, Ovr&gt;
+          ::type&gt;
+  {
+    typedef list_algorithms&lt;ContainerTraits, Ovr&gt; self_type;
+    typedef typename detail::maybe_override&lt;self_type, Ovr&gt;::type most_derived;
+    typedef default_algorithms&lt;ContainerTraits, most_derived&gt; Parent;
+
+  public:
+    typedef typename Parent::container container;
+
+    // Use member functions for the following (hiding base class versions)
+    static void      reverse    (container &amp;);
+    static void      sort       (container &amp;);
+    //    static void      sort       (container &amp;, PyObject *);
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::list instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;class T, class Allocator&gt;
+    class algorithms_selector&lt;std::list&lt;T, Allocator&gt; &gt;
+    {
+      typedef std::list&lt;T, Allocator&gt; Container;
+
+      typedef list_traits&lt;Container&gt;       mutable_traits;
+      typedef list_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef list_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef list_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+  }
+#endif
+
+  template&lt;
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = list_traits&lt;Container&gt;
+  &gt;
+  struct list_suite
+    : container_suite&lt;Container, MethodMask, list_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Reverse the contents of a list (using member function)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void list_algorithms&lt;ContainerTraits, Ovr&gt;::reverse (container &amp;c)
+  {
+    c.reverse();
+  }
+
+  /////////////////////////////////////////////////////////////////////////
+  // Sort the contents of a list (using member function)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void list_algorithms&lt;ContainerTraits, Ovr&gt;::sort (container &amp;c)
+  {
+    typedef typename self_type::container_traits::value_traits_type
+      vtraits;
+
+    typedef typename vtraits::less comparison;
+#if BOOST_WORKAROUND (BOOST_MSVC, == 1200)
+    // MSVC6 doesn't have a templated sort member in list, so we just
+    // use the parameterless version. This gives the correct behaviour
+    // provided that value_traits_type::less is exactly
+    // std::less&lt;value_type&gt;. It would be possible to support
+    // std::greater&lt;T&gt; (the only other overload of list::sort in
+    // MSVC6) with some additional work.
+    BOOST_STATIC_ASSERT(
+        (::boost::is_same&lt;comparison, std::less&lt;value_type&gt; &gt;::value));
+    c.sort ();
+#else
+    c.sort (comparison());
+#endif
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_LIST_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/map.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/map.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/map.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,238 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file map.hpp
+//
+// Indexing algorithms support for std::map instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: map.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_MAP_HPP
+#define BOOST_PYTHON_INDEXING_MAP_HPP
+
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+#include &lt;map&gt;
+#include &lt;boost/python/suite/indexing/pair.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::map instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Container&gt;
+  class map_traits : public base_container_traits&lt;Container&gt;
+  {
+    typedef base_container_traits&lt;Container&gt; base_class;
+
+  public:
+# if BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1200)
+    // MSVC6 has a nonstandard name for mapped_type in std::map
+    typedef typename Container::referent_type value_type;
+# else
+    typedef typename Container::mapped_type value_type;
+# endif
+    typedef value_type &amp;                    reference;
+    typedef typename Container::key_type    index_type; // operator[]
+    typedef typename Container::key_type    key_type;   // find, count, ...
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;value_type&gt;::param_type
+      value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;key_type&gt;::param_type
+      key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;index_type&gt;::param_type
+      index_param;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_iter
+
+            | method_getitem
+            | method_contains
+            | method_count
+            | method_has_key
+
+            | detail::method_set_if&lt;
+                  base_class::is_mutable,
+                    method_setitem
+                  | method_delitem
+                  | method_insert
+              &gt;::value
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::map instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr = detail::no_override&gt;
+  class map_algorithms
+    : public assoc_algorithms
+        &lt;ContainerTraits,
+        typename detail::maybe_override
+            &lt;map_algorithms&lt;ContainerTraits, Ovr&gt;, Ovr&gt;
+          ::type&gt;
+  {
+    typedef map_algorithms&lt;ContainerTraits, Ovr&gt; self_type;
+    typedef typename detail::maybe_override&lt;self_type, Ovr&gt;::type most_derived;
+    typedef assoc_algorithms&lt;ContainerTraits, most_derived&gt; Parent;
+
+  public:
+    typedef typename Parent::container container;
+    typedef typename Parent::reference reference;
+    typedef typename Parent::index_param index_param;
+    typedef typename Parent::value_param value_param;
+
+    static reference get (container &amp;, index_param);
+    // Version to return only the mapped type
+
+    static boost::python::list keys( container &amp; );
+  
+    static void      assign     (container &amp;, index_param, value_param);
+    static void      insert     (container &amp;, index_param, value_param);
+  
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class( PythonClass &amp;pyClass, Policy const &amp;policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+      pyClass.def( &quot;keys&quot;, &amp;self_type::keys );     
+        
+      typedef BOOST_DEDUCED_TYPENAME most_derived::container::value_type value_type;
+      mapping::register_value_type&lt; PythonClass, value_type, Policy &gt;( pyClass );
+      //now we can expose iterators functionality
+      pyClass.def( &quot;__iter__&quot;, python::iterator&lt; BOOST_DEDUCED_TYPENAME most_derived::container &gt;() );
+    }  
+  
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::map instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;class Key, class T, class Compare, class Allocator&gt;
+    class algorithms_selector&lt;std::map&lt;Key, T, Compare, Allocator&gt; &gt;
+    {
+      typedef std::map&lt;Key, T, Compare, Allocator&gt; Container;
+
+      typedef map_traits&lt;Container&gt;       mutable_traits;
+      typedef map_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef map_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef map_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::multimap instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;class Key, class T, class Compare, class Allocator&gt;
+    class algorithms_selector&lt;std::multimap&lt;Key, T, Compare, Allocator&gt; &gt;
+    {
+      typedef std::multimap&lt;Key, T, Compare, Allocator&gt; Container;
+
+      typedef map_traits&lt;Container&gt;       mutable_traits;
+      typedef map_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef map_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef map_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+  }
+#endif
+
+  template&lt;
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = map_traits&lt;Container&gt;
+  &gt;
+  struct map_suite
+    : container_suite&lt;Container, MethodMask, map_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (map version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  BOOST_DEDUCED_TYPENAME map_algorithms&lt;ContainerTraits, Ovr&gt;::reference
+  map_algorithms&lt;ContainerTraits, Ovr&gt;::get (container &amp;c, index_param ix)
+  {
+    return most_derived::find_or_throw (c, ix)-&gt;second;
+  }
+
+  
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  boost::python::list
+  map_algorithms&lt;ContainerTraits, Ovr&gt;::keys( container &amp;c )
+  {
+    boost::python::list _keys;
+    //For some reason code with set could not be compiled
+    //std::set&lt; key_param &gt; unique_keys;
+    typedef BOOST_DEDUCED_TYPENAME container::iterator iter_type;
+    for( iter_type index = most_derived::begin(c); index != most_derived::end(c); ++index ){
+        //if( unique_keys.end() == unique_keys.find( index-&gt;first ) ){
+        //    unique_keys.insert( index-&gt;first );
+        if( !_keys.count( index-&gt;first ) ){
+            _keys.append( index-&gt;first );
+        }
+        //}
+    }
+        
+    return _keys;
+  }
+  
+  /////////////////////////////////////////////////////////////////////////
+  // Assign a value at a particular index (map version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  map_algorithms&lt;ContainerTraits, Ovr&gt;::assign(
+      container &amp;c, index_param ix, value_param val)
+  {
+    c[ix] = val;   // Handles overwrite and insert
+  }
+
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert a new key, value pair into a map
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  map_algorithms&lt;ContainerTraits, Ovr&gt;::insert(
+      container &amp;c, index_param ix, value_param val)
+  {
+    typedef std::pair
+      &lt;BOOST_DEDUCED_TYPENAME self_type::container_traits::index_type,
+      BOOST_DEDUCED_TYPENAME self_type::container_traits::value_type&gt;
+      pair_type;
+
+    // Can't use std::make_pair, because param types may be references
+
+    if (!c.insert (pair_type (ix, val)).second)
+      {
+        PyErr_SetString(
+            PyExc_ValueError, &quot;Map already holds value for insertion&quot;);
+
+        boost::python::throw_error_already_set ();
+      }
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_MAP_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/methods.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/methods.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/methods.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,113 @@
+// Copyright (c) 2004 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file methods.hpp
+//
+// Methods (and sets of methods) that containers can provide.
+//
+// History
+// =======
+// 2004/ 1/11   rmg     File creation
+//
+// $Id: methods.hpp,v 1.1.2.1 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_METHODS_HPP
+#define BOOST_PYTHON_INDEXING_METHODS_HPP
+
+#include &lt;boost/config.hpp&gt;
+#include &lt;boost/mpl/if.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+
+  typedef unsigned long method_set_type;
+
+  enum methods_enum {
+    method_len            = 1UL &lt;&lt;  0,
+    method_iter           = 1UL &lt;&lt;  1,
+    method_getitem        = 1UL &lt;&lt;  2,
+    method_getitem_slice  = 1UL &lt;&lt;  3,
+    method_index          = 1UL &lt;&lt;  4,
+    method_contains       = 1UL &lt;&lt;  5,
+    method_count          = 1UL &lt;&lt;  6,
+    method_has_key        = 1UL &lt;&lt;  7,
+    method_setitem        = 1UL &lt;&lt;  8,
+    method_setitem_slice  = 1UL &lt;&lt;  9,
+    method_delitem        = 1UL &lt;&lt; 10,
+    method_delitem_slice  = 1UL &lt;&lt; 11,
+    method_reverse        = 1UL &lt;&lt; 12,
+    method_append         = 1UL &lt;&lt; 13,
+    method_insert         = 1UL &lt;&lt; 14,
+    method_extend         = 1UL &lt;&lt; 15,
+    method_sort           = 1UL &lt;&lt; 16
+  };
+
+  // Some sets of methods that could be useful for disabling expensive
+  // features. e.g. something &amp; ~(slice_methods | search_methods)
+
+  enum {
+    slice_methods
+      = method_getitem_slice | method_setitem_slice | method_delitem_slice
+  };
+
+  enum {
+    search_methods
+      = method_index | method_contains | method_count | method_has_key
+  };
+
+  enum {
+    reorder_methods
+      = method_sort | method_reverse
+  };
+
+  enum {
+    insert_methods
+      = method_append | method_insert | method_extend
+  };
+
+  enum {
+    all_methods = ~0UL
+  };
+
+  namespace detail {
+    // Compile-time constant selection:
+    //
+    // method_set_if&lt;c, t, f&gt;::value == (c ? t : f)
+    //
+    // where c is convertible to bool, and t and f are convertible to
+    // method_set_type. This gives a compile-time constant reliably on
+    // all supported compilers.
+
+    template&lt;
+        bool Cond, method_set_type TrueValue, method_set_type FalseValue = 0&gt;
+
+    struct method_set_if {
+      struct true_type {
+        BOOST_STATIC_CONSTANT(method_set_type, value = TrueValue);
+      };
+
+      struct false_type {
+        BOOST_STATIC_CONSTANT(method_set_type, value = FalseValue);
+      };
+
+      typedef typename mpl::if_c&lt;Cond, true_type, false_type&gt;::type
+          result_type;
+
+      BOOST_STATIC_CONSTANT(method_set_type, value = result_type::value);
+    };
+
+    // Compile-time set membership test:
+    // is_member&lt;set, mem&gt;::value == (bool) set &amp; mem
+    template&lt;method_set_type Set, method_set_type Member&gt;
+    struct is_member {
+      // Use a cast to prevent MSVC truncation warning C4305
+      BOOST_STATIC_CONSTANT (bool, value = (bool) (Set &amp; Member));
+    };
+  }
+
+} } } // boost::python::indexing
+
+#endif // BOOST_PYTHON_INDEXING_METHODS_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/multimap.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/multimap.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/multimap.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,203 @@
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file multimap.hpp
+//
+// Indexing algorithms support for std::multimap instances
+//
+// History
+// =======
+// 2006/10/27   Roman     File creation from map.hpp
+//
+
+#ifndef BOOST_PYTHON_INDEXING_MULTIMAP_HPP
+#define BOOST_PYTHON_INDEXING_MULTIMAP_HPP
+
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+#include &lt;functional&gt;
+#include &lt;map&gt;
+#include &lt;boost/python/suite/indexing/pair.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::map instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Container&gt;
+  class multimap_traits : public base_container_traits&lt;Container&gt;
+  {
+    typedef base_container_traits&lt;Container&gt; base_class;
+
+  public:
+# if BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1200)
+    // MSVC6 has a nonstandard name for mapped_type in std::multimap
+    typedef typename Container::referent_type value_type;
+# else
+    typedef typename Container::mapped_type value_type;
+# endif
+    typedef value_type &amp;                    reference;
+    typedef typename Container::key_type    index_type; // operator[]
+    typedef typename Container::key_type    key_type;   // find, count, ...
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;value_type&gt;::param_type
+      value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;key_type&gt;::param_type
+      key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;index_type&gt;::param_type
+      index_param;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_iter
+
+            | method_getitem
+            | method_contains
+            | method_count
+            | method_has_key
+
+            | detail::method_set_if&lt;
+                  base_class::is_mutable,
+                    method_setitem
+                  | method_delitem
+                  | method_insert
+              &gt;::value
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::multimap instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr = detail::no_override&gt;
+  class multimap_algorithms
+    : public assoc_algorithms
+        &lt;ContainerTraits,
+        typename detail::maybe_override
+            &lt;multimap_algorithms&lt;ContainerTraits, Ovr&gt;, Ovr&gt;
+          ::type&gt;
+  {
+    typedef multimap_algorithms&lt;ContainerTraits, Ovr&gt; self_type;
+    typedef typename detail::maybe_override&lt;self_type, Ovr&gt;::type most_derived;
+    typedef assoc_algorithms&lt;ContainerTraits, most_derived&gt; Parent;
+
+  public:
+    typedef typename Parent::container container;
+    typedef typename Parent::reference reference;
+    typedef typename Parent::index_param index_param;
+    typedef typename Parent::value_param value_param;
+
+    static boost::python::list get (container &amp;, index_param);
+    // Version to return only the mapped type
+
+    static boost::python::list keys( container &amp; );
+  
+    static void      assign     (container &amp;, index_param, value_param);
+    static void      insert     (container &amp;, index_param, value_param);
+  
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class( PythonClass &amp;pyClass, Policy const &amp;policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+      pyClass.def( &quot;keys&quot;, &amp;self_type::keys );        
+
+      typedef BOOST_DEDUCED_TYPENAME most_derived::container::value_type value_type;
+      mapping::register_value_type&lt; PythonClass, value_type, Policy &gt;( pyClass );
+      //now we can expose iterators functionality
+      pyClass.def( &quot;__iter__&quot;, python::iterator&lt; BOOST_DEDUCED_TYPENAME most_derived::container &gt;() );
+        
+    }  
+
+  };
+
+  template&lt;
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = multimap_traits&lt;Container&gt;
+  &gt;
+  struct multimap_suite
+    : container_suite&lt;Container, MethodMask, multimap_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Index into a container (multimap version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  boost::python::list
+  multimap_algorithms&lt;ContainerTraits, Ovr&gt;::get (container &amp;c, index_param ix)
+  {
+    boost::python::list l;
+    typedef BOOST_DEDUCED_TYPENAME container::iterator iter_type;
+    for( iter_type index = c.lower_bound( ix ); index != c.upper_bound( ix ); ++index ){
+        boost::python::object v( index-&gt;second );
+        l.append( v );
+    }
+    return l;
+  }
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  boost::python::list
+  multimap_algorithms&lt;ContainerTraits, Ovr&gt;::keys( container &amp;c )
+  {
+    boost::python::list _keys;
+    //For some reason code with set could not be compiled
+    //std::set&lt; key_param &gt; unique_keys;
+    typedef BOOST_DEDUCED_TYPENAME container::iterator iter_type;
+    for( iter_type index = most_derived::begin(c); index != most_derived::end(c); ++index ){
+        //if( unique_keys.end() == unique_keys.find( index-&gt;first ) ){
+        //    unique_keys.insert( index-&gt;first );
+        if( !_keys.count( index-&gt;first ) ){
+            _keys.append( index-&gt;first );
+        }
+        //}
+    }
+        
+    return _keys;
+  }
+  
+  
+  /////////////////////////////////////////////////////////////////////////
+  // Assign a value at a particular index (map version)
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  multimap_algorithms&lt;ContainerTraits, Ovr&gt;::assign(
+      container &amp;c, index_param ix, value_param val)
+  {
+    typedef std::pair&lt;
+        BOOST_DEDUCED_TYPENAME self_type::container_traits::index_type
+        , BOOST_DEDUCED_TYPENAME self_type::container_traits::value_type&gt;
+    pair_type;
+
+    // Can't use std::make_pair, because param types may be references
+    c.insert (pair_type (ix, val));
+  }
+
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert a new key, value pair into a map
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  multimap_algorithms&lt;ContainerTraits, Ovr&gt;::insert(
+      container &amp;c, index_param ix, value_param val)
+  {
+    typedef std::pair
+      &lt;BOOST_DEDUCED_TYPENAME self_type::container_traits::index_type,
+      BOOST_DEDUCED_TYPENAME self_type::container_traits::value_type&gt;
+      pair_type;
+
+    // Can't use std::make_pair, because param types may be references
+    c.insert (pair_type (ix, val) );
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_MULTIMAP_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/pair.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/pair.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/pair.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,98 @@
+// Header file pair.hpp
+//
+// Exposes std::pair&lt; key, value &gt; class
+//
+// Copyright (c) 2007 Roman Yakovenko  
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2007/2/11   rmg     File creation
+//
+
+#ifndef BOOST_PYTHON_STD_PAIR_KEY_VALUE_11_02_2007_HPP
+#define BOOST_PYTHON_STD_PAIR_KEY_VALUE_11_02_2007_HPP
+
+#include &lt;boost/config.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+namespace boost { namespace python { namespace indexing { namespace mapping{
+
+namespace details{
+    
+template&lt; typename TValueType, typename TValueCallPolicies &gt;
+struct pair_exposer_t{
+
+    typedef TValueType pair_type;   
+    typedef BOOST_DEDUCED_TYPENAME pair_type::first_type key_type;
+    typedef BOOST_DEDUCED_TYPENAME pair_type::second_type mapped_type;
+    typedef pair_exposer_t&lt; TValueType, TValueCallPolicies &gt; exposer_type;
+    
+    pair_exposer_t(const std::string&amp; name){
+        class_&lt; pair_type &gt;( name.c_str() )
+            .def( &quot;__len__&quot;, &amp;exposer_type::len )
+            .def( &quot;__getitem__&quot;, &amp;exposer_type::get_item )
+            .add_property( &quot;key&quot;, &amp;exposer_type::get_key )
+            .add_property( &quot;value&quot;, &amp;exposer_type::get_mapped );
+    }
+    
+private:
+
+    static size_t len( const pair_type&amp; ){
+        return 2;
+    }
+
+    static object get_item( pair_type&amp; p, size_t index ){
+        switch( index ){
+            case 0:{
+                return get_key( p );
+            }
+            case 1:{
+                return get_mapped( p );
+            }
+            case 2:{
+                objects::stop_iteration_error();
+                return object(); //will not reach this line
+            }
+            default:{
+                PyErr_SetString( PyExc_IndexError, &quot;the only valid index numbers are: 0 and 1&quot;);
+                throw_error_already_set();
+                return object(); //will not reach this line
+            }
+        }
+    }
+    
+    static object get_key( const pair_type&amp; p ){
+        return object( p.first );
+    }
+    
+    static object get_mapped( pair_type&amp; p ){
+        typedef BOOST_DEDUCED_TYPENAME TValueCallPolicies::result_converter rc_type;
+        typedef BOOST_DEDUCED_TYPENAME rc_type:: template apply&lt; mapped_type &gt;::type converter_type;
+        converter_type converter;
+        return object( handle&lt;&gt;( converter( p.second ) ) );
+    }
+    
+};
+} //details
+    
+template&lt; typename TPythonClass, typename TValueType, typename TValueCallPolicies &gt;
+inline void register_value_type(TPythonClass &amp;pyClass){ 
+    typedef details::pair_exposer_t&lt; TValueType, TValueCallPolicies &gt; exposer_type;
+    
+    object class_name(pyClass.attr(&quot;__name__&quot;));
+    extract&lt;std::string&gt; class_name_extractor(class_name);
+    std::string pair_name = class_name_extractor() + &quot;_entry&quot;;
+    
+    exposer_type expose( pair_name );
+}
+    
+} } } }
+
+#endif // BOOST_PYTHON_STD_PAIR_KEY_VALUE_11_02_2007_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/proxy_iterator.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/proxy_iterator.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/proxy_iterator.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,163 @@
+
+// Header file proxy_iterator.hpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/10/ 8   rmg     File creation
+//
+// $Id: proxy_iterator.hpp,v 1.1.2.8 2003/12/05 17:36:14 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_PROXY_ITERATOR_HPP
+#define BOOST_PYTHON_INDEXING_PROXY_ITERATOR_HPP
+
+#include &lt;iterator&gt;
+#include &lt;boost/config.hpp&gt;
+#include &lt;boost/iterator.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+
+  template &lt;class ContainerProxy, typename ElementProxy, typename Traits,
+      typename Size, typename Iter&gt;
+  class proxy_iterator
+    : public boost::iterator&lt;
+          std::random_access_iterator_tag,
+          ElementProxy,
+          typename Traits::difference_type,
+          ElementProxy *,
+          ElementProxy // Already has reference semantics
+      &gt;
+  {
+#if !defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    template&lt;class C, class H, class G&gt; friend class container_proxy;
+#endif
+
+    typedef boost::iterator&lt;
+        std::random_access_iterator_tag,
+        ElementProxy,
+        typename Traits::difference_type,
+        ElementProxy *,
+        ElementProxy
+    &gt; base_type;
+
+  public:
+    typedef ContainerProxy container_proxy_type;
+
+    typedef Iter raw_iterator;
+    typedef Traits raw_iterator_traits;
+    typedef Size size_type;
+    typedef typename base_type::value_type value_type;
+    typedef typename base_type::difference_type difference_type;
+
+    typedef value_type *pointer;
+    typedef value_type reference; // Already has reference semantics
+
+    proxy_iterator (container_proxy_type *p, size_type i)
+      : ptr (p), index (i)
+    {
+    }
+ 
+    proxy_iterator (container_proxy_type *p, raw_iterator iter)
+      : ptr (p), index (iter - p-&gt;raw_container().begin())
+    {
+    }
+
+    reference operator*() const { return ptr-&gt;at(index); }
+    pointer operator-&gt;() const { return &amp;ptr-&gt;at(index); }
+    reference operator[](size_type s) { return ptr-&gt;at (index + s); }
+
+    proxy_iterator &amp;operator++ () { ++index; return *this; }
+    proxy_iterator &amp;operator+= (size_type s) { index += s; return *this; }
+
+    proxy_iterator &amp;operator-- () { --index; return *this; }
+
+    proxy_iterator operator++ (int) {
+      proxy_iterator temp(*this);
+      ++index;
+      return temp;
+    }
+
+    proxy_iterator operator-- (int) {
+      proxy_iterator temp(*this);
+      --index;
+      return temp;
+    }
+
+    proxy_iterator &amp;operator-= (size_type s) { index -= s; return *this; }
+
+    proxy_iterator operator+ (size_type s) const {
+      return proxy_iterator(*this) += s;
+    }
+
+    proxy_iterator operator- (size_type s) const {
+      return proxy_iterator(*this) -= s;
+    }
+
+    difference_type operator- (proxy_iterator i) const {
+      return index - i.index;
+    }
+
+    bool operator== (proxy_iterator const &amp;other) const {
+      return (ptr == other.ptr) &amp;&amp; (index == other.index);
+    }
+
+    bool operator!= (proxy_iterator const &amp;other) const {
+      return !(*this == other);
+    }
+
+    bool operator&lt; (proxy_iterator const &amp;other) const {
+      return index &lt; other.index;
+    }
+
+    bool operator&lt;= (proxy_iterator const &amp;other) const {
+      return index &lt;= other.index;
+    }
+
+    bool operator&gt; (proxy_iterator const &amp;other) const {
+      return index &gt; other.index;
+    }
+
+    bool operator&gt;= (proxy_iterator const &amp;other) const {
+      return index &gt;= other.index;
+    }
+
+    void iter_swap (proxy_iterator const &amp;other) const {
+      ptr-&gt;swap_elements (index, other.index);
+    }
+
+    //  public:
+    // Extensions to the normal iterator interface
+    //    void replace (value_type const &amp;copy) { ptr-&gt;replace (index, copy); }
+
+#if defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+    // Can't declare container_proxy as friend, so make data public
+  public:
+#else
+  private:
+#endif
+    container_proxy_type *ptr;
+    size_type index;
+  };
+} } }
+
+#if !BOOST_WORKAROUND (BOOST_MSVC, == 1300)
+// MSVC7.0 can't decide between this and the unspecialized version
+namespace std {
+  template &lt;class C, typename E, typename T, typename S, typename I&gt;
+  void iter_swap(
+      boost::python::indexing::proxy_iterator&lt;C, E, T, S, I&gt; const &amp;first,
+      boost::python::indexing::proxy_iterator&lt;C, E, T, S, I&gt; const &amp;second)
+  {
+    first.iter_swap (second);
+  }
+}
+#endif
+
+#endif // BOOST_PYTHON_INDEXING_PROXY_ITERATOR_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/python_iterator.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/python_iterator.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/python_iterator.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,45 @@
+// -*- mode:c++ -*-
+//
+// Header file python_iterator.hpp
+//
+// Handy Python iterable iterators
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: python_iterator.hpp,v 1.1.2.5 2003/11/24 16:35:09 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_PYTHON_ITERATOR_HPP
+#define BOOST_PYTHON_INDEXING_PYTHON_ITERATOR_HPP
+
+#include &lt;boost/python/object.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  struct BOOST_PYTHON_DECL python_iterator
+  {
+    python_iterator (boost::python::object);
+    // Sets a python type exception and calls throw_error_already_set if
+    // the passed object is not iterable via PyObject_GetIter
+
+    bool next ();
+    // Get the next item from the iterator, returning true for success
+
+    boost::python::object current() const;
+    // Callable only after a successful next()
+
+  private:
+    ::boost::python::object m_iter_obj;
+    ::boost::python::object m_next_method;
+    ::boost::python::object m_current;
+  };
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_PYTHON_ITERATOR_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/readme.txt
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/readme.txt	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/readme.txt	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,2 @@
+Installation tip: 
+    copy the content of this directory to &quot;.../boost/python/suite/indexing&quot; directory.
\ No newline at end of file

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/set.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/set.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/set.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,167 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file set.hpp
+//
+// Indexing algorithms support for std::set instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: set.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SET_HPP
+#define BOOST_PYTHON_INDEXING_SET_HPP
+
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;boost/type_traits/is_const.hpp&gt;
+#include &lt;set&gt;
+
+namespace boost { namespace python { namespace indexing {
+  /////////////////////////////////////////////////////////////////////////
+  // ContainerTraits implementation for std::set instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename Container&gt;
+  class set_traits : public base_container_traits&lt;Container&gt;
+  {
+    typedef base_container_traits&lt;Container&gt; base_class;
+
+  public:
+    typedef typename Container::key_type value_type; // probably unused
+    typedef typename Container::key_type index_type; // operator[]
+    typedef typename Container::key_type key_type;   // find, count, ...
+
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;value_type&gt;::param_type
+        value_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;key_type&gt;::param_type
+        key_param;
+    typedef typename BOOST_PYTHON_INDEXING_CALL_TRAITS &lt;index_type&gt;::param_type
+        index_param;
+
+    BOOST_STATIC_CONSTANT(
+        method_set_type,
+        supported_methods = (
+              method_iter
+            | method_getitem
+            | method_contains
+            | method_count
+            | method_has_key
+
+            | detail::method_set_if&lt;
+                  base_class::is_mutable,
+                    method_delitem
+                  | method_insert
+              &gt;::value
+        ));
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Algorithms implementation for std::set instances
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr = detail::no_override&gt;
+  class set_algorithms
+    : public assoc_algorithms
+        &lt;ContainerTraits,
+        typename detail::maybe_override
+            &lt;set_algorithms&lt;ContainerTraits, Ovr&gt;, Ovr&gt;
+          ::type&gt;
+  {
+    typedef set_algorithms&lt;ContainerTraits, Ovr&gt; self_type;
+    typedef typename detail::maybe_override&lt;self_type, Ovr&gt;::type most_derived;
+    typedef assoc_algorithms&lt;ContainerTraits, most_derived&gt; Parent;
+
+  public:
+    typedef typename Parent::container container;
+    typedef typename Parent::value_param value_param;
+    typedef typename Parent::index_param index_param;
+
+    static void      insert     (container &amp;, index_param);
+  
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class( PythonClass &amp;pyClass, Policy const &amp;policy)
+    {
+      ContainerTraits::visit_container_class (pyClass, policy);
+      pyClass.def( &quot;add&quot;, &amp;self_type::insert );        
+    }  
+
+  };
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::set instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;class Key, class Compare, class Allocator&gt;
+    class algorithms_selector&lt;std::set&lt;Key, Compare, Allocator&gt; &gt;
+    {
+      typedef std::set&lt;Key, Compare, Allocator&gt; Container;
+
+      typedef set_traits&lt;Container&gt;       mutable_traits;
+      typedef set_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef set_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef set_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::multiset instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;class Key, class Compare, class Allocator&gt;
+    class algorithms_selector&lt;std::multiset&lt;Key, Compare, Allocator&gt; &gt;
+    {
+      typedef std::multiset&lt;Key, Compare, Allocator&gt; Container;
+
+      typedef set_traits&lt;Container&gt;       mutable_traits;
+      typedef set_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef set_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef set_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+  }
+#endif
+
+  template&lt;
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = set_traits&lt;Container&gt;
+  &gt;
+  struct set_suite
+    : container_suite&lt;Container, MethodMask, set_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+  /////////////////////////////////////////////////////////////////////////
+  // Insert an element into a set
+  /////////////////////////////////////////////////////////////////////////
+
+  template&lt;typename ContainerTraits, typename Ovr&gt;
+  void
+  set_algorithms&lt;ContainerTraits, Ovr&gt;::insert(
+      container &amp;c, index_param ix)
+  {
+    c.insert (ix);
+    //~ Python set does not raise exception in this situation
+    //~ if (!c.insert (ix).second)
+      //~ {
+        //~ PyErr_SetString(
+            //~ PyExc_ValueError, &quot;Set already holds value for insertion&quot;);
+
+        //~ boost::python::throw_error_already_set ();
+      //~ }
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SET_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/shared_proxy_impl.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/shared_proxy_impl.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/shared_proxy_impl.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,105 @@
+//
+// Header file shared_proxy_impl.hpp
+//
+// The shared implementation of the element proxy (const and non-const
+// versions).  Multiple proxy pointers can refer to the same shared
+// implementation, meaning that only one object requires updating to
+// affect all proxy pointers that ultimately refer to the same index
+// in the container.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 8/29   rmg     File creation from container_proxy.hh
+//
+// $Id: shared_proxy_impl.hpp,v 1.1.2.8 2003/11/24 14:28:31 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SHARED_PROXY_IMPL_HPP
+#define BOOST_PYTHON_INDEXING_SHARED_PROXY_IMPL_HPP
+
+#include &lt;memory&gt;
+#include &lt;boost/python/suite/indexing/workaround.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  template&lt;class ContainerProxy&gt;
+  class shared_proxy_impl
+  {
+  public:
+    typedef typename ContainerProxy::raw_value_type value_type;
+    typedef value_type &reference;
+    typedef value_type *pointer;
+    typedef void iterator_category;  // Fudge for boost::indirect_iterator
+    typedef void difference_type;    // Fudge for boost::indirect_iterator
+
+    reference operator*() const;
+    pointer operator-&gt;() const { return &amp;(**this); }
+
+    ContainerProxy *owner() const { return m_owner_ptr; }
+    size_t index() const { return m_index; }
+
+    shared_proxy_impl (value_type const &amp;copy);
+    // Creates value-only (detached) proxy
+
+#if defined (BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+  public:
+#else
+  private:
+    template&lt;class C, class A, class G&gt; friend class container_proxy;
+#endif
+
+    shared_proxy_impl (ContainerProxy *, size_t);
+    void detach ();
+
+    ContainerProxy *m_owner_ptr;             // When attached
+    size_t m_index;                          // When attached
+    std::auto_ptr&lt;value_type&gt; m_element_ptr; // When detached
+
+  private:
+    // Not implemented
+    shared_proxy_impl (shared_proxy_impl const &amp;);
+    shared_proxy_impl &amp;operator= (shared_proxy_impl const &amp;);
+  };
+
+  template&lt;class ContainerProxy&gt;
+  shared_proxy_impl&lt;ContainerProxy&gt;::shared_proxy_impl (ContainerProxy *owner,
+                                                        size_t index)
+    : m_owner_ptr (owner),
+    m_index (index),
+    m_element_ptr ()
+  {
+  }
+
+  template&lt;class ContainerProxy&gt;
+  shared_proxy_impl&lt;ContainerProxy&gt;::shared_proxy_impl (value_type const &amp;val)
+    : m_owner_ptr (0),
+    m_index (static_cast&lt;size_t&gt;(-1)),
+    m_element_ptr (new value_type (val))
+  {
+  }
+
+  template&lt;class ContainerProxy&gt;
+  typename shared_proxy_impl&lt;ContainerProxy&gt;::reference
+  shared_proxy_impl&lt;ContainerProxy&gt;::operator* () const
+  {
+    return m_owner_ptr
+      ? m_owner_ptr-&gt;raw_container().BOOST_PYTHON_INDEXING_AT (m_index)
+      : *m_element_ptr;
+  }
+
+  template&lt;class ContainerProxy&gt;
+  void shared_proxy_impl&lt;ContainerProxy&gt;::detach ()
+  {
+    BOOST_PYTHON_INDEXING_RESET_AUTO_PTR(
+        m_element_ptr, new value_type (**this));
+    m_owner_ptr = 0;
+    m_index = static_cast&lt;size_t&gt;(-1);
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SHARED_PROXY_IMPL_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,103 @@
+// Header file slice.hpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 9/10   rmg     File creation
+//
+// $Id: slice.hpp,v 1.1.2.10 2003/11/24 14:28:31 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SLICE_HPP
+#define BOOST_PYTHON_INDEXING_SLICE_HPP
+
+#include &lt;boost/python/object.hpp&gt;
+#include &lt;boost/python/errors.hpp&gt;
+#include &lt;boost/python/converter/pytype_object_mgr_traits.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  struct BOOST_PYTHON_DECL slice : public boost::python::object
+  {
+    // This is just a thin wrapper around boost::python::object
+    // so that it is possible to register a special converter for
+    // PySlice_Type and overload C++ functions on slice
+
+#if defined (BOOST_NO_MEMBER_TEMPLATES)
+    // MSVC6 doesn't seem to be able to invoke the templated
+    // constructor, so provide explicit overloads to match the
+    // (currently) known boost::python::object constructors
+    explicit slice (::boost::python::handle&lt;&gt; const&amp;);
+    explicit slice (::boost::python::detail::borrowed_reference);
+    explicit slice (::boost::python::detail::new_reference);
+    explicit slice (::boost::python::detail::new_non_null_reference);
+#else
+    // Better compilers make life easier
+    template&lt;typename T&gt; inline slice (T const &amp;ref);
+#endif
+
+    slice (slice const &amp;); // Copy constructor
+  };
+
+  struct BOOST_PYTHON_DECL integer_slice
+  {
+    // This class provides a convenient interface to Python slice
+    // objects that contain integer bound and stride values.
+
+    #if PY_VERSION_HEX &lt; 0x02050000
+        typedef int index_type;
+    #else
+        typedef Py_ssize_t index_type;
+    #endif
+
+    integer_slice (slice const &amp;, index_type length);
+    // integer_slice must know how big the container is so it can
+    // adjust for negative indexes, etc...
+
+    index_type start() const { return m_start; }
+    index_type step() const  { return m_step; }
+    index_type stop() const  { return m_stop; }
+
+    index_type size() const { return (m_stop - m_start) / m_step; }
+
+    bool in_range (index_type index);
+
+  private:
+    slice m_slice;
+    index_type m_start;
+    index_type m_step;
+    index_type m_stop;
+    index_type m_direction;
+  };
+} } }
+
+#if !defined (BOOST_NO_MEMBER_TEMPLATES)
+template&lt;typename T&gt;
+boost::python::indexing::slice::slice (T const &amp;ref)
+  : boost::python::object (ref)
+{
+  if (!PySlice_Check (this-&gt;ptr()))
+    {
+      PyErr_SetString(
+          PyExc_TypeError, &quot;slice constructor: passed a non-slice object&quot;);
+
+      boost::python::throw_error_already_set();
+    }
+}
+#endif
+
+namespace boost { namespace python { namespace converter {
+  // Specialized converter to handle PySlice_Type objects
+  template&lt;&gt;
+  struct object_manager_traits&lt;boost::python::indexing::slice&gt;
+    : pytype_object_manager_traits&lt;
+         &amp;PySlice_Type, ::boost::python::indexing::slice&gt;
+  {
+  };
+}}}
+
+#endif // BOOST_PYTHON_INDEXING_SLICE_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice_handler.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice_handler.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/slice_handler.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,297 @@
+// -*- mode:c++ -*-
+//
+// Header file slice_handler.hpp
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 9/ 9   rmg     File creation
+//
+// $Id: slice_handler.hpp,v 1.1.2.10 2003/11/24 16:35:52 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SLICE_HANDLER_HPP
+#define BOOST_PYTHON_INDEXING_SLICE_HANDLER_HPP
+
+#include &lt;boost/python/handle.hpp&gt;
+#include &lt;boost/python/object.hpp&gt;
+#include &lt;boost/python/list.hpp&gt;
+#include &lt;boost/python/extract.hpp&gt;
+#include &lt;boost/python/make_function.hpp&gt;
+#include &lt;boost/mpl/apply.hpp&gt;
+#include &lt;algorithm&gt;
+
+#include &lt;boost/python/suite/indexing/slice.hpp&gt;
+#include &lt;boost/python/suite/indexing/python_iterator.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+  template&lt;class Algorithms, class Policy&gt;
+  struct slice_handler
+  {
+    static boost::python::object make_getitem (Policy const &amp;);
+    static boost::python::object make_setitem (Policy const &amp;);
+    static boost::python::object make_delitem (Policy const &amp;);
+    static boost::python::object make_extend  (Policy const &amp;);
+
+  private:
+    typedef typename Algorithms::container container;
+    typedef typename Algorithms::reference reference;
+    typedef typename Algorithms::slice_helper slice_helper;
+
+    static boost::python::list get_slice (container &amp;, slice);
+    static void set_slice (container &amp;, slice, boost::python::object);
+    static void del_slice (container &amp;, slice);
+    static void extend (container &amp;, boost::python::object);
+  };
+
+  namespace detail {
+    template&lt;typename Policy&gt;
+    struct postcall_override
+    {
+      // This class overrides the Policy's postcall function and
+      // result_conveter to handle the list returned from get_slice.
+      // The Policy's result_converter is removed, since it gets
+      // applied within get_slice. Our postcall override applies the
+      // original postcall to each element of the Python list returned
+      // from get_slice.
+
+      typedef boost::python::default_result_converter result_converter;
+      typedef typename Policy::argument_package argument_package;
+
+      postcall_override (Policy const &amp;p);
+
+      bool precall (PyObject *args);
+      PyObject* postcall (PyObject *args, PyObject *result);
+
+    private:
+      Policy m_base;
+    };
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements the slice version of __getitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  boost::python::object
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::make_getitem (Policy const &amp;policy)
+  {
+    return
+      boost::python::make_function(
+          get_slice, detail::postcall_override&lt;Policy&gt; (policy));
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements the slice version of __setitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  boost::python::object
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::make_setitem (Policy const &amp;policy)
+  {
+    // should we try to get funky with policy::precall?
+    return boost::python::make_function (set_slice, policy);
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements the slice version of __delitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  boost::python::object
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::make_delitem (Policy const &amp;policy)
+  {
+    // should we try to get funky with policy::precall?
+    return boost::python::make_function (del_slice, policy);
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Return a function object that implements extend
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  boost::python::object
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::make_extend (Policy const &amp;policy)
+  {
+    // should we try to get funky with policy::precall?
+    return boost::python::make_function (extend, policy);
+  }
+
+  namespace detail {
+    ////////////////////////////////////////////////////////////////////////
+    // postcall_override constructor
+    ////////////////////////////////////////////////////////////////////////
+
+    template&lt;class Policy&gt;
+    postcall_override&lt;Policy&gt;::postcall_override (Policy const &amp;p)
+      : m_base (p)
+    {
+    }
+
+    ////////////////////////////////////////////////////////////////////////
+    // precall forwarder
+    ////////////////////////////////////////////////////////////////////////
+
+    template&lt;class Policy&gt;
+    bool postcall_override&lt;Policy&gt;::precall (PyObject *args)
+    {
+      return m_base.precall (args);
+    }
+
+    ////////////////////////////////////////////////////////////////////////
+    // Apply base postcall to each element of the list returend by get_slice
+    ////////////////////////////////////////////////////////////////////////
+
+    template&lt;class Policy&gt;
+    PyObject *
+    postcall_override&lt;Policy&gt;::postcall (PyObject *args, PyObject *result)
+    {
+      int size = PyList_Size (result);
+
+      for (int count = 0; count &lt; size; ++count)
+        {
+          m_base.postcall (args, PyList_GetItem (result, count));
+        }
+
+      return result;
+    }
+  } // namespace detail
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation for the slice version of __getitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  boost::python::list
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::get_slice (container &amp;c, slice sl)
+  {
+    typedef typename Policy::result_converter converter_type;
+    typedef typename Algorithms::reference reference;
+
+    typename boost::mpl::apply1&lt;converter_type, reference&gt;::type
+      converter;
+
+    boost::python::list result;
+
+    slice_helper helper (Algorithms::make_slice_helper (c, sl));
+
+    while (helper.next())
+      {
+        // Apply the result converter (only) to each element before
+        // appending. postcall is done in postcall_override
+
+        result.append (boost::python::handle&lt;&gt; (converter (helper.current())));
+      }
+
+    return result;
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation for the slice version of __setitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  void
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::set_slice (container &amp;c, slice sl, boost::python::object values)
+  {
+    python_iterator value_iter (values);
+
+    // Try two kinds of extractors - the first is more efficient (using
+    // a reference to existing object, if possible and sensible) and the
+    // second allowing implicit conversions.
+
+    typedef boost::python::extract&lt;
+        BOOST_DEDUCED_TYPENAME Algorithms::value_param&gt; extractor1;
+
+    typedef boost::python::extract&lt;
+        BOOST_DEDUCED_TYPENAME Algorithms::value_type&gt; extractor2;
+
+    // Note: any error during this operation will probably leave the
+    // container partially updated. This can occur (for example) if the
+    // replacement sequence is of a different length to the original
+    // slice and the container does not support insertion/deletion.
+    // This could be prevented if the length of the replacement sequence
+    // is known in advance (via __len__, for example) but not otherwise.
+
+    slice_helper write_helper (Algorithms::make_slice_helper (c, sl));
+
+    // Overwrite and/or insert elements
+    while (value_iter.next())
+      {
+        extractor1 ex1 (value_iter.current());
+
+        if (ex1.check())
+          {
+            write_helper.write (ex1);
+          }
+
+        else
+          {
+            write_helper.write (extractor2 (value_iter.current()));
+          }
+      }
+
+    if (write_helper.next())
+      {
+        // We've run out of elements to read, but write_helper is not
+        // finished. Erase the remaining element(s) in the slice
+        write_helper.erase_remaining();
+      }
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation for the slice version of __delitem__
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  void
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::del_slice (container &amp;c, slice sl)
+  {
+    slice_helper helper (Algorithms::make_slice_helper (c, sl));
+
+    if (helper.next())
+      {
+        helper.erase_remaining();
+      }
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Implementation of extend
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy&gt;
+  void
+  slice_handler&lt;Algorithms, Policy&gt;
+  ::extend (container &amp;c, boost::python::object values)
+  {
+    // Set up a slice at the tail end of the container, and use
+    // set_slice to do all the hard work.
+
+    boost::python::object length
+      ((boost::python::handle&lt;&gt;
+        (PyInt_FromLong (Algorithms::size (c)))));
+
+    slice sl
+      ((boost::python::handle&lt;&gt;
+        (PySlice_New
+         (length.ptr(),
+          boost::python::object().ptr(),
+          boost::python::object().ptr()))));
+
+    set_slice (c, sl, values);
+  }
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SLICE_HANDLER_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/suite_utils.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/suite_utils.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/suite_utils.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,110 @@
+// Header file suite_utils.hpp
+//
+// Shared utilities for the indexing suite.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/ 8/23   rmg     File creation
+//
+// $Id: suite_utils.hpp,v 1.1.2.7 2003/11/24 14:28:31 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_SUITE_UTILS_HPP
+#define BOOST_PYTHON_INDEXING_SUITE_UTILS_HPP
+
+#include &lt;boost/type_traits.hpp&gt;
+
+namespace boost { namespace python { namespace indexing {
+#if BOOST_WORKAROUND (BOOST_MSVC, BOOST_TESTED_AT (1310)) \
+  || (defined (__GNUC__) &amp;&amp; (__GNUC__ &lt; 3))
+  // MSVC and GCC 2.96 seem to have problems comparing enumerated
+  // values in a static constant expression, and don't believe that an
+  // expression like (traits::index_style &gt;= index_style_nonlinear) is
+  // a compile-time constant. However, the problem doesn't exist for
+  // int.
+  typedef int index_style_t;
+  index_style_t const index_style_none = 0;
+  index_style_t const index_style_nonlinear = 1;
+  index_style_t const index_style_linear = 2;
+#else
+  enum index_style_t {
+    index_style_none,         // No random access (iteration only)
+    index_style_nonlinear,  // Random access by key (no slicing)
+    index_style_linear     // Random access by integer index (allows slicing)
+  };
+#endif
+
+  template&lt;typename T&gt;
+  class is_mutable_ref
+  {
+    typedef typename boost::remove_reference&lt;T&gt;::type maybe_const;
+
+  public:
+    BOOST_STATIC_CONSTANT (bool, value = !boost::is_const&lt;maybe_const&gt;::value);
+  };
+
+  // make_signed attempts to identify the signed version of any
+  // numeric type (useful in this case because Python container
+  // indexes can be negative).
+  template&lt;typename T&gt; struct make_signed {
+    typedef T type;
+  };
+
+  template&lt;&gt; struct make_signed&lt;char&gt; {
+    // Raw &quot;char&quot; could be signed or unsigned. &quot;signed char&quot;
+    // guarantess signedness
+    typedef signed char type;
+  };
+
+  template&lt;&gt; struct make_signed&lt;unsigned char&gt; {
+    typedef signed char type;
+  };
+
+  template&lt;&gt; struct make_signed&lt;unsigned short&gt; {
+    typedef short type;
+  };
+
+  template&lt;&gt; struct make_signed&lt;unsigned int&gt; {
+    typedef int type;
+  };
+
+  template&lt;&gt; struct make_signed&lt;unsigned long&gt; {
+    typedef long type;
+  };
+
+#if defined (BOOST_HAS_LONG_LONG)
+  template&lt;&gt; struct make_signed&lt;unsigned long long&gt; {
+    typedef long long type;
+  };
+#elif defined (BOOST_HAS_MS_INT64)
+  template&lt;&gt; struct make_signed&lt;unsigned __int64&gt; {
+    typedef __int64 type;
+  };
+#endif
+
+  namespace detail {
+    struct no_override { };
+
+    template&lt;typename Base, typename Override&gt;
+    struct maybe_override
+    {
+      // Probably need to disable this if there is no partial
+      // specialization support, because Override is almost certain to
+      // be an incomplete type. If that is right, the workaround
+      // version would just have to do &quot;typedef Base type;&quot;
+
+      typedef typename mpl::if_
+        &lt;is_same &lt;Override, no_override&gt;, Base, Override&gt;
+        ::type type;
+    };
+  }
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_SUITE_UTILS_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/value_traits.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/value_traits.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/value_traits.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,84 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file value_traits.hpp:
+//
+// Traits information for use in determining which Python methods to
+// support for a container with elements of a given type.
+//
+// History
+// =======
+// 2003/ 9/12   rmg     File creation
+//
+// $Id: value_traits.hpp,v 1.1.2.6 2003/12/05 17:36:12 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_VALUE_TRAITS_HPP
+#define BOOST_PYTHON_INDEXING_VALUE_TRAITS_HPP
+
+#include &lt;boost/config.hpp&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;functional&gt;
+
+namespace boost { namespace python { namespace indexing {
+  // The default_value_traits template is used by all ContainerTraits
+  // templates. It can be overridden by specialization or by supplying
+  // the optional ValueTraits parameter to a container traits
+  // template.
+  template&lt;typename T&gt; struct value_traits;
+
+  // Implementation for default use. Providing this in a separate
+  // template allows specializations of value_traits to make use of
+  // it.
+  template&lt;typename T&gt;
+  struct simple_value_traits {
+    BOOST_STATIC_CONSTANT (bool, equality_comparable = true);
+    typedef std::equal_to&lt;T&gt; equal_to;
+
+    BOOST_STATIC_CONSTANT (bool, less_than_comparable = true);
+    typedef std::less&lt;T&gt; less;
+
+    // Default, do-nothing, version of visit_container_class
+    template&lt;typename PythonClass, typename Policy&gt;
+    static void visit_container_class (PythonClass &amp;, Policy const &amp;) { }
+  };
+
+  // Implementation using pointer indirection
+  template &lt;typename Ptr&gt;
+  struct indirect_value_traits : simple_value_traits&lt;Ptr&gt; {
+    // Hide the base class versions of the comparisons, using these
+    // indirect versions
+    struct less : std::binary_function&lt;Ptr, Ptr, bool&gt; {
+      bool operator() (Ptr const &amp;p1, Ptr const &amp;p2) const {
+        return *p1 &lt; *p2;
+      }
+    };
+
+    struct equal_to : std::binary_function&lt;Ptr, Ptr, bool&gt; {
+      bool operator() (Ptr const &amp;p1, Ptr const &amp;p2) const {
+        return *p1 == *p2;
+      }
+    };
+  };
+
+  // Default implementation selection. It's basically just a typedef
+  // for simple_value_traits
+  template&lt;typename T&gt;
+  struct value_traits : simple_value_traits&lt;T&gt;
+  {
+  };
+
+#if !defined (BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  // Partial specialization for instances of boost::shared_ptr
+  template&lt;typename T&gt;
+  struct value_traits&lt; ::boost::shared_ptr&lt;T&gt; &gt;
+    : indirect_value_traits&lt; ::boost::shared_ptr&lt;T&gt; &gt;
+  {
+  };
+#endif
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_VALUE_TRAITS_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/vector.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/vector.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/vector.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,60 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file vector.hpp
+//
+// Indexing algorithms support for std::vector instances
+//
+// History
+// =======
+// 2003/10/28   rmg     File creation from algo_selector.hpp
+//
+// $Id: vector.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_VECTOR_HPP
+#define BOOST_PYTHON_INDEXING_VECTOR_HPP
+
+#include &lt;boost/python/suite/indexing/container_traits.hpp&gt;
+#include &lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include &lt;boost/python/suite/indexing/algorithms.hpp&gt;
+#include &lt;vector&gt;
+
+namespace boost { namespace python { namespace indexing {
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+  namespace detail {
+    ///////////////////////////////////////////////////////////////////////
+    // algorithms support for std::vector instances
+    ///////////////////////////////////////////////////////////////////////
+
+    template &lt;class T, class Allocator&gt;
+    class algorithms_selector&lt;std::vector&lt;T, Allocator&gt; &gt;
+    {
+      typedef std::vector&lt;T, Allocator&gt; Container;
+
+      typedef random_access_sequence_traits&lt;Container&gt;       mutable_traits;
+      typedef random_access_sequence_traits&lt;Container const&gt; const_traits;
+
+    public:
+      typedef default_algorithms&lt;mutable_traits&gt; mutable_algorithms;
+      typedef default_algorithms&lt;const_traits&gt;   const_algorithms;
+    };
+  }
+#endif
+
+  template&lt;
+    class Container,
+    method_set_type MethodMask = all_methods,
+    class Traits = random_access_sequence_traits&lt;Container&gt;
+  &gt;
+  struct vector_suite
+    : container_suite&lt;Container, MethodMask, default_algorithms&lt;Traits&gt; &gt;
+  {
+  };
+
+} } }
+
+#endif // BOOST_PYTHON_INDEXING_VECTOR_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/visitor.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/visitor.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/visitor.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,271 @@
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// Header file visitor.hpp:
+//
+// def_visitor implementation to install the container_suite's Python
+// methods in an object of a boost::python::class_&lt;&gt; instance.
+//
+// History
+// =======
+// 2003/ 9/11   rmg     File creation from container_suite.hpp
+//
+// $Id: visitor.hpp,v 1.1.2.16 2004/02/08 18:57:42 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_VISITOR_HPP
+#define BOOST_PYTHON_INDEXING_VISITOR_HPP
+
+#include &lt;boost/python/suite/indexing/slice_handler.hpp&gt;
+#include &lt;boost/python/suite/indexing/suite_utils.hpp&gt; // Get index_style_t
+
+#include &lt;boost/python/def_visitor.hpp&gt;
+#include &lt;boost/python/iterator.hpp&gt;
+#include &lt;boost/python/default_call_policies.hpp&gt;
+#include &lt;boost/type_traits/ice.hpp&gt;
+#include &lt;boost/bind.hpp&gt;
+#include &lt;functional&gt;
+
+namespace boost { namespace python { namespace indexing {
+  //////////////////////////////////////////////////////////////////////////
+  // Policy override template that masks everything except the precall
+  // functions. i.e. it uses default policies for everything except
+  // precall, which must be provided by the template argument.
+  //////////////////////////////////////////////////////////////////////////
+
+  namespace detail {
+    template&lt;typename PrecallPolicy&gt;
+    struct precall_only : public boost::python::default_call_policies
+    {
+      precall_only () : m_precall () { }
+      explicit precall_only (PrecallPolicy const &amp;copy) : m_precall (copy) { }
+
+      bool precall (PyObject *args) { return m_precall.precall (args); }
+      bool precall (PyObject *args) const { return m_precall.precall (args); }
+
+    private:
+      PrecallPolicy m_precall;
+    };
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Ugly macro to define a template that optionally adds a method to
+  // a Python class. This version (OPTIONAL_ALGO_SUPPORT) works with
+  // static functions in an Algorithms class.
+  //
+  // This macro is #undef'd at the end of this header
+  //////////////////////////////////////////////////////////////////////////
+
+#define OPTIONAL_ALGO_SUPPORT(ADDER_NAME, METHOD_NAME, ALGO_FN) \
+  template&lt;bool doit&gt;  \
+  struct ADDER_NAME {  \
+    template&lt;class PythonClass, class Algorithms, class Policy&gt;  \
+    static void apply (PythonClass &amp;, Algorithms const &amp;, Policy const &amp;)  \
+    {  \
+    }  \
+  };  \
+\
+  template&lt;&gt;  \
+  struct ADDER_NAME&lt;true&gt; {  \
+    template&lt;class PythonClass, class Algorithms, class Policy&gt;  \
+    static void apply(  \
+        PythonClass &amp;pyClass,  \
+        Algorithms const &amp;,  \
+        Policy const &amp;policy)  \
+    {  \
+      pyClass.def (METHOD_NAME, &amp;Algorithms::ALGO_FN, policy);  \
+    }  \
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // Ugly macro to define a template that optionally adds a method to
+  // a Python class. This version (OPTIONAL_SLICE_SUPPORT) works with
+  // static functions in the slice_handler template.
+  //
+  // This macro is #undef'd at the end of this header
+  //////////////////////////////////////////////////////////////////////////
+
+#define OPTIONAL_SLICE_SUPPORT(ADDER_NAME, METHOD_NAME, SLICE_HANDLER_FN) \
+  template&lt;bool doit&gt;  \
+  struct ADDER_NAME {  \
+    template&lt;class PythonClass, class Algorithms, class Policy&gt;  \
+    static void apply (PythonClass &amp;, Algorithms const &amp;, Policy const &amp;)  \
+    {  \
+    }  \
+  };  \
+\
+  template&lt;&gt;  \
+  struct ADDER_NAME&lt;true&gt; {  \
+    template&lt;class PythonClass, class Algorithms, class Policy&gt;  \
+    static void apply(  \
+        PythonClass &amp;pyClass,  \
+        Algorithms const &amp;,  \
+        Policy const &amp;policy)  \
+    {  \
+      pyClass.def ( \
+          METHOD_NAME, \
+          slice_handler&lt;Algorithms, Policy&gt;::SLICE_HANDLER_FN (policy));  \
+    }  \
+  }
+
+  //////////////////////////////////////////////////////////////////////////
+  // __iter__ is a special case not handled by the above macros. First
+  // the unspecialized (do-nothing) version
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;bool doit&gt;
+  struct maybe_add_iter {
+    template&lt;class PythonClass, class Algorithms, class Policy&gt;
+    static void apply (PythonClass &amp;, Algorithms const &amp;, Policy const &amp;) { }
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // Specialization with the real implementation of __iter__
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;&gt;
+  struct maybe_add_iter&lt;true&gt; {
+    template&lt;class PythonClass, class Algorithms, class Policy&gt;
+    static void apply(
+        PythonClass &amp;pyClass,
+        Algorithms const &amp;,
+        Policy const &amp;)
+    {
+      // Should maybe separate precall and postcall portions of the
+      // policy (precall when generating the range object, postcall
+      // when returing from range.next())?
+
+      pyClass.def(
+          &quot;__iter__&quot;,
+          boost::python::range&lt;Policy&gt;(
+              Algorithms::begin,
+              Algorithms::end));
+    }
+  };
+
+  //////////////////////////////////////////////////////////////////////////
+  // All other optional methods are covered by the two OPTIONAL_*
+  // macros
+  //////////////////////////////////////////////////////////////////////////
+
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_len, &quot;__len__&quot;, size);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_getitem, &quot;__getitem__&quot;, get);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_setitem, &quot;__setitem__&quot;, assign);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_delitem, &quot;__delitem__&quot;, erase_one);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_getslice, &quot;__getitem__&quot;, make_getitem);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_setslice, &quot;__setitem__&quot;, make_setitem);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_delslice, &quot;__delitem__&quot;, make_delitem);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_sort, &quot;sort&quot;, sort);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_reverse, &quot;reverse&quot;, reverse);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_append, &quot;append&quot;, push_back);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_insert, &quot;insert&quot;, insert);
+  OPTIONAL_SLICE_SUPPORT (maybe_add_extend, &quot;extend&quot;, make_extend);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_index, &quot;index&quot;, get_index);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_count, &quot;count&quot;, count);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_contains, &quot;__contains__&quot;, contains);
+  OPTIONAL_ALGO_SUPPORT  (maybe_add_has_key, &quot;has_key&quot;, contains);
+
+  //////////////////////////////////////////////////////////////////////////
+  // Do-all visitor
+  //////////////////////////////////////////////////////////////////////////
+
+  template&lt;class Algorithms, class Policy, method_set_type MethodMask&gt;
+  class visitor
+    : public def_visitor&lt; visitor&lt; Algorithms, Policy, MethodMask &gt; &gt;
+  {
+    Policy m_policy;
+
+    BOOST_STATIC_CONSTANT (
+        method_set_type,
+        enabled_methods = Algorithms::supported_methods &amp; MethodMask);
+
+  public:
+    typedef Algorithms algorithms_type;
+
+    explicit visitor (Policy const &amp;policy = Policy()) : m_policy (policy) { }
+
+  public:
+    template &lt;class PythonClass&gt;
+    void visit (PythonClass &amp;pyClass) const
+    {
+      detail::precall_only&lt;Policy&gt; precallPolicy (m_policy);
+
+      maybe_add_len&lt;detail::is_member&lt;enabled_methods, method_len&gt;::value&gt;
+        ::apply(pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_getitem&lt;
+        detail::is_member&lt;enabled_methods, method_getitem&gt;::value
+      &gt;::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_getslice&lt;
+          detail::is_member&lt;enabled_methods, method_getitem_slice&gt;::value
+      &gt;::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_setitem&lt;
+        detail::is_member&lt;enabled_methods, method_setitem&gt;::value
+      &gt;::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_setslice&lt;
+          detail::is_member&lt;enabled_methods, method_setitem_slice&gt;::value
+      &gt;::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_delitem&lt;
+        detail::is_member&lt;enabled_methods, method_delitem&gt;::value
+      &gt;::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_delslice&lt;
+          detail::is_member&lt;enabled_methods, method_delitem_slice&gt;::value
+      &gt;::apply(pyClass, algorithms_type(), m_policy);
+
+      maybe_add_iter&lt;
+        detail::is_member&lt;enabled_methods, method_iter&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), m_policy);
+
+      maybe_add_sort&lt;
+        detail::is_member&lt;enabled_methods, method_sort&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_reverse&lt;
+        detail::is_member&lt;enabled_methods, method_reverse&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_append&lt;
+        detail::is_member&lt;enabled_methods, method_append&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_insert&lt;
+        detail::is_member&lt;enabled_methods, method_insert&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_extend&lt;
+        detail::is_member&lt;enabled_methods, method_extend&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_index&lt;
+        detail::is_member&lt;enabled_methods, method_index&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_count&lt;
+        detail::is_member&lt;enabled_methods, method_count&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_contains&lt;
+        detail::is_member&lt;enabled_methods, method_contains&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      maybe_add_has_key&lt;
+        detail::is_member&lt;enabled_methods, method_has_key&gt;::value
+      &gt;::apply (pyClass, algorithms_type(), precallPolicy);
+
+      Algorithms::visit_container_class (pyClass, m_policy);
+    }
+  };
+} } }
+
+#undef OPTIONAL_SLICE_SUPPORT
+#undef OPTIONAL_ALGO_SUPPORT
+
+#endif // BOOST_PYTHON_INDEXING_VISITOR_HPP

Added: trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/workaround.hpp
===================================================================
--- trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/workaround.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/py/boost-python-indexing-suite-v2-noSymlinkHeaders/suite/indexing/workaround.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,46 @@
+// Header file workaround.hpp
+//
+// Indexing-specific workarounds for compiler problems.
+//
+// Copyright (c) 2003 Raoul M. Gough
+//
+// Use, modification and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
+// at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+//
+// History
+// =======
+// 2003/10/21   rmg     File creation
+//
+// $Id: workaround.hpp,v 1.1.2.3 2003/11/17 19:27:13 raoulgough Exp $
+//
+
+#ifndef BOOST_PYTHON_INDEXING_WORKAROUND_HPP
+#define BOOST_PYTHON_INDEXING_WORKAROUND_HPP
+
+#include &lt;boost/config.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+# if (BOOST_WORKAROUND (__GNUC__, &lt; 3))
+#   // gcc versions before 3 (like 2.95.3) don't have the &quot;at&quot; member
+#   // function in std::vector or std::deque
+#   define BOOST_PYTHON_INDEXING_AT operator[]
+# else
+#   define BOOST_PYTHON_INDEXING_AT at
+# endif
+
+# if BOOST_WORKAROUND (BOOST_MSVC, &lt;= 1300)
+// Workaround the lack of a reset member function in std::auto_ptr
+namespace boost { namespace python { namespace indexing {
+template&lt;typename T&gt; void reset_auto_ptr (T &amp;aptr, T::element_type *pptr) {
+ aptr = T (pptr);
+}
+} } }
+#   define BOOST_PYTHON_INDEXING_RESET_AUTO_PTR \
+        ::boost::python::indexing::reset_auto_ptr
+# else
+#   define BOOST_PYTHON_INDEXING_RESET_AUTO_PTR( aptr, pptr ) \
+        (aptr).reset(pptr)
+# endif
+
+#endif // BOOST_PYTHON_INDEXING_WORKAROUND_HPP

Modified: trunk/lib/serialization/MultiTypeHandler.tpp
===================================================================
--- trunk/lib/serialization/MultiTypeHandler.tpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/serialization/MultiTypeHandler.tpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -52,8 +52,8 @@
 	};
 	public : void registerAttributes()
 	{
-		REGISTER_ATTRIBUTE(first);
-		REGISTER_ATTRIBUTE(second);
+		REGISTER_ATTRIBUTE_(first);
+		REGISTER_ATTRIBUTE_(second);
 	};
 	public : void deserialize(any&amp; a)
 	{
@@ -155,7 +155,7 @@
 	public 	: virtual string getClassName() const {return myName();};
 	public : void registerAttributes()
 	{
-		REGISTER_ATTRIBUTE(first);
+		REGISTER_ATTRIBUTE_(first);
 	};
 	public : void deserialize(any&amp; a)
 	{
@@ -249,8 +249,8 @@
 	public 	: virtual string getClassName() const {return myName();};
 	public : void registerAttributes()
 	{
-		REGISTER_ATTRIBUTE(first);
-		REGISTER_ATTRIBUTE(second);
+		REGISTER_ATTRIBUTE_(first);
+		REGISTER_ATTRIBUTE_(second);
 	};
 	public : void deserialize(any&amp; a)
 	{
@@ -351,9 +351,9 @@
 	public 	: virtual string getClassName() const {return myName();};
 	public : void registerAttributes()
 	{
-		REGISTER_ATTRIBUTE(first);
-		REGISTER_ATTRIBUTE(second);
-		REGISTER_ATTRIBUTE(third);
+		REGISTER_ATTRIBUTE_(first);
+		REGISTER_ATTRIBUTE_(second);
+		REGISTER_ATTRIBUTE_(third);
 	};
 	public : void deserialize(any&amp; a)
 	{
@@ -460,10 +460,10 @@
 	public 	: virtual string getClassName() const {return myName();};	//
 	public : void registerAttributes()				//
 	{								//
-		REGISTER_ATTRIBUTE(first);
-		REGISTER_ATTRIBUTE(second);
-		REGISTER_ATTRIBUTE(third);
-		REGISTER_ATTRIBUTE(fourth);
+		REGISTER_ATTRIBUTE_(first);
+		REGISTER_ATTRIBUTE_(second);
+		REGISTER_ATTRIBUTE_(third);
+		REGISTER_ATTRIBUTE_(fourth);
 	};								//
 	public : void deserialize(any&amp; a)				//
 	{								//
@@ -577,11 +577,11 @@
 	public 	: virtual string getClassName() const {return myName();};	//
 	public : void registerAttributes()				//
 	{								//
-		REGISTER_ATTRIBUTE(first);
-		REGISTER_ATTRIBUTE(second);
-		REGISTER_ATTRIBUTE(third);
-		REGISTER_ATTRIBUTE(fourth);
-		REGISTER_ATTRIBUTE(fifth);
+		REGISTER_ATTRIBUTE_(first);
+		REGISTER_ATTRIBUTE_(second);
+		REGISTER_ATTRIBUTE_(third);
+		REGISTER_ATTRIBUTE_(fourth);
+		REGISTER_ATTRIBUTE_(fifth);
 	};								//
 	public : void deserialize(any&amp; a)				//
 	{								//

Modified: trunk/lib/serialization/Serializable.hpp
===================================================================
--- trunk/lib/serialization/Serializable.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/serialization/Serializable.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,17 +19,20 @@
 #	include&lt;memory&gt;
 	using std::shared_ptr;
 #endif
-#include &lt;boost/type_traits.hpp&gt;
-#include &lt;boost/lexical_cast.hpp&gt;
+#ifdef EMBED_PYTHON
+	#include&lt;boost/python.hpp&gt;
+#endif
+#include&lt;boost/type_traits.hpp&gt;
+#include&lt;boost/lexical_cast.hpp&gt;
 #include&lt;boost/preprocessor.hpp&gt;
-#include &lt;list&gt;
-#include &lt;map&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
+#include&lt;list&gt;
+#include&lt;map&gt;
+#include&lt;string&gt;
+#include&lt;vector&gt;
+#include&lt;iostream&gt;
 #include&lt;yade/lib-factory/Factorable.hpp&gt;
-#include &quot;SerializationExceptions.hpp&quot;
-#include &quot;Archive.hpp&quot;
+#include&quot;SerializationExceptions.hpp&quot;
+#include&quot;Archive.hpp&quot;
 
 using namespace boost;
 using namespace std;
@@ -38,7 +41,7 @@
 #define DECLARE_POINTER_TO_MY_CUSTOM_CLASS(Type,attribute,any)		\
 	Type * attribute=any_cast&lt; Type * &gt;(any);
 
-#define REGISTER_ATTRIBUTE(attribute)                                   \
+#define REGISTER_ATTRIBUTE_(attribute)                                   \
                 registerAttribute( #attribute, attribute );
 
 
@@ -52,9 +55,39 @@
 //! create member function that register attributes; must be parenthesized, without commas: (attr1) (attr2) (attr3) ...
 //#define REGISTER_ATTRIBUTES(attrs) protected: void registerAttributes(){ REGISTER_ATTRIBUTES_MANY(attrs) }
 //! Same as REGISTER_ATTRIBUTES, but with first argument of base class, of which registerAttributes will be called first
-#define REGISTER_ATTRIBUTES(baseClass,attrs) protected: void registerAttributes(){ baseClass::registerAttributes(); REGISTER_ATTRIBUTES_MANY(attrs) }
+#ifndef EMBED_PYTHON
+	#define REGISTER_ATTRIBUTES(baseClass,attrs) protected: void registerAttributes(){ baseClass::registerAttributes(); REGISTER_ATTRIBUTES_MANY(attrs); }
+#else
+	#include&lt;boost/python.hpp&gt;
 
+	namespace{
+		boost::python::object pyGetAttr(const std::string&amp; key){ PyErr_SetString(PyExc_KeyError,(std::string(&quot;No such attribute: &quot;)+key+&quot;.&quot;).c_str()); boost::python::throw_error_already_set(); /*never reached; avoids warning*/ throw; }
+		void pySetAttr(const std::string&amp; key, const boost::python::object&amp; value){ PyErr_SetString(PyExc_KeyError,(std::string(&quot;No such attribute: &quot;)+key+&quot;.&quot;).c_str()); boost::python::throw_error_already_set(); }
+		boost::python::list pyKeys(){ return boost::python::list();}
+		bool pyHasKey(const std::string&amp; key) { return false; }
+		boost::python::dict pyDict() { return boost::python::dict(); }
+	};
 
+	#define _PYGET_ATTR(x,y,z) if(key==BOOST_PP_STRINGIZE(z)) return boost::python::object(z);
+	#define _PYSET_ATTR(x,y,z) if(key==BOOST_PP_STRINGIZE(z)) {z=boost::python::extract&lt;typeof(z)&gt;(value); return; }
+	#define _PYKEYS_ATTR(x,y,z) ret.append(BOOST_PP_STRINGIZE(z));
+	#define _PYHASKEY_ATTR(x,y,z) if(key==BOOST_PP_STRINGIZE(z)) return true;
+	#define _PYDICT_ATTR(x,y,z) ret[BOOST_PP_STRINGIZE(z)]=boost::python::object(z);
+	#define PYGET_MANY(attrs) BOOST_PP_SEQ_FOR_EACH(_PYGET_ATTR,~,attrs)
+	#define PYSET_MANY(attrs) BOOST_PP_SEQ_FOR_EACH(_PYSET_ATTR,~,attrs)
+	#define PYKEYS_MANY(attrs) BOOST_PP_SEQ_FOR_EACH(_PYKEYS_ATTR,~,attrs)
+	#define PYHASKEY_MANY(attrs) BOOST_PP_SEQ_FOR_EACH(_PYHASKEY_ATTR,~,attrs)
+	#define PYDICT_MANY(attrs) BOOST_PP_SEQ_FOR_EACH(_PYDICT_ATTR,~,attrs)
+
+	#define REGISTER_ATTRIBUTES(baseClass,attrs) protected: void registerAttributes(){ baseClass::registerAttributes(); REGISTER_ATTRIBUTES_MANY(attrs); } \
+		public: boost::python::object pyGetAttr(const std::string&amp; key) const{ PYGET_MANY(attrs); return baseClass::pyGetAttr(key); } \
+		void pySetAttr(const std::string&amp; key, const boost::python::object&amp; value){ PYSET_MANY(attrs); baseClass::pySetAttr(key,value); } \
+		boost::python::list pyKeys() const { boost::python::list ret; PYKEYS_MANY(attrs); ret.extend(baseClass::pyKeys()); return ret; } \
+		bool pyHasKey(const std::string&amp; key) const { PYHASKEY_MANY(attrs); return baseClass::pyHasKey(key); } \
+		boost::python::dict pyDict() const { boost::python::dict ret; PYDICT_MANY(attrs); ret.update(baseClass::pyDict()); return ret; }
+#endif
+
+
 // for both fundamental and non-fundamental cases
 #define REGISTER_SERIALIZABLE_GENERIC(name,isFundamental) 						\
 	REGISTER_FACTORABLE(name);								\
@@ -87,6 +120,14 @@
 
 		virtual void postProcessAttributes(bool /*deserializing*/) {};
 
+	#ifdef EMBED_PYTHON
+		virtual boost::python::object pyGetAttr(const std::string&amp; key) const { return ::pyGetAttr(key); }
+		virtual void pySetAttr(const std::string&amp; key, const boost::python::object&amp; value){ ::pySetAttr(key,value); };
+		virtual boost::python::list pyKeys() const {return ::pyKeys(); };
+		virtual bool pyHasKey(const std::string&amp; key) const {return ::pyHasKey(key);}
+		virtual boost::python::dict pyDict() const { return ::pyDict(); }
+	#endif
+
 	private :
 		Archives				archives;
 		friend class Archive;

Modified: trunk/lib/serialization-qt/QtGUIGenerator.cpp
===================================================================
--- trunk/lib/serialization-qt/QtGUIGenerator.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/lib/serialization-qt/QtGUIGenerator.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -96,7 +96,7 @@
 	// is that a number?
 	try
 	{
-		Real v = boost::lexical_cast&lt;Real&gt;(num);
+		boost::lexical_cast&lt;Real&gt;(num);
 	}
 	catch(std::bad_cast&amp;)
 	{

Modified: trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.cpp
===================================================================
--- trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,13 +17,6 @@
 {
 }
 
-void BoundingSphere::registerAttributes() // FIXME - remove that function, dispatcher shoul take care of that
-{
-	BoundingVolume::registerAttributes();
-	REGISTER_ATTRIBUTE(radius);
-	REGISTER_ATTRIBUTE(center);
-}
-
 // void BoundingSphere::update(Se3r&amp; se3)
 // {
 // 	Vector3r v(radius,radius,radius);

Modified: trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.hpp
===================================================================
--- trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/BoundingVolume/BoundingSphere.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,16 +19,10 @@
 		BoundingSphere();
 		virtual ~BoundingSphere();
 
-/// Serialization
-		void registerAttributes();
-
-	REGISTER_CLASS_NAME(BoundingSphere);
-	REGISTER_BASE_CLASS_NAME(BoundingVolume);
-	
-/// Indexable
+	REGISTER_ATTRIBUTES(BoundingVolume,(radius)(center));
+	REGISTER_CLASS_AND_BASE(BoundingSphere,BoundingVolume);
 	REGISTER_CLASS_INDEX(BoundingSphere,BoundingVolume);
 };
-
 REGISTER_SERIALIZABLE(BoundingSphere);
 
 

Modified: trunk/pkg/common/DataClass/GeometricalModel/Box.cpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Box.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Box.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -5,25 +5,7 @@
 *  This program is free software; it is licensed under the terms of the  *
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
-
 #include &quot;Box.hpp&quot;
-#include &lt;iostream&gt;
-
-Box::Box () : GeometricalModel()
-{		
-	createIndex();
-}
-
-
-Box::~Box ()
-{		
-}
-
-
-void Box::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(extents);
-}
-
+Box::Box () : GeometricalModel() { createIndex(); }
+Box::~Box (){}
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/GeometricalModel/Box.hpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Box.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Box.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -12,25 +12,14 @@
 #include&lt;yade/core/GeometricalModel.hpp&gt;
 
 
-class Box : public GeometricalModel
-{
-	public :
+class Box: public GeometricalModel{
+	public:
 		Vector3r extents;
-
-		Box ();
-		virtual ~Box ();
-	
-/// Serialization
-	
-	REGISTER_CLASS_NAME(Box);
-	REGISTER_BASE_CLASS_NAME(GeometricalModel);
-
-	public : void registerAttributes();
-	
-/// Indexable
-	
+		Box();
+		virtual ~Box();
+	REGISTER_ATTRIBUTES(GeometricalModel,(extents));
+	REGISTER_CLASS_AND_BASE(Box,GeometricalModel);
 	REGISTER_CLASS_INDEX(Box,GeometricalModel);
-
 };
 
 REGISTER_SERIALIZABLE(Box);

Modified: trunk/pkg/common/DataClass/GeometricalModel/BshTube.cpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/BshTube.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/BshTube.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -8,7 +8,6 @@
 
 
 #include &quot;BshTube.hpp&quot;
-#include &lt;iostream&gt;
 
 BshTube::BshTube () : GeometricalModel()
 {		
@@ -20,12 +19,4 @@
 {		
 }
 
-
-void BshTube::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(radius);
-        REGISTER_ATTRIBUTE(half_height);
-}
-
 YADE_PLUGIN(&quot;BshTube&quot;);

Modified: trunk/pkg/common/DataClass/GeometricalModel/BshTube.hpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/BshTube.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/BshTube.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,17 +22,10 @@
 		BshTube ();
 		virtual ~BshTube ();
 	
-/// Serialization
-	
 	REGISTER_CLASS_NAME(BshTube);
 	REGISTER_BASE_CLASS_NAME(GeometricalModel);
-
-	public : void registerAttributes();
-	
-/// Indexable
-	
+	REGISTER_ATTRIBUTES(GeometricalModel,(radius)(half_height));
 	REGISTER_CLASS_INDEX(BshTube,GeometricalModel);
-
 };
 
 REGISTER_SERIALIZABLE(BshTube);

Modified: trunk/pkg/common/DataClass/GeometricalModel/Facet.cpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Facet.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Facet.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,11 +18,4 @@
 {
 }
 
-
-void Facet::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(vertices);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/GeometricalModel/Facet.hpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Facet.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Facet.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -11,17 +11,14 @@
 #include&lt;yade/core/GeometricalModel.hpp&gt;
 
 class Facet : public GeometricalModel {
-    public :
+	public :
 	vector&lt;Vector3r&gt; vertices;
-
 	Facet ();
 	virtual ~Facet ();
 
-    protected :
-	    void registerAttributes();
-    REGISTER_CLASS_NAME(Facet);
-    REGISTER_BASE_CLASS_NAME(GeometricalModel);
-    REGISTER_CLASS_INDEX(Facet,GeometricalModel);
+	REGISTER_ATTRIBUTES(GeometricalModel,(vertices))
+	REGISTER_CLASS_AND_BASE(Facet,GeometricalModel);
+	REGISTER_CLASS_INDEX(Facet,GeometricalModel);
 };
 
 REGISTER_SERIALIZABLE(Facet);

Modified: trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.cpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -42,13 +42,6 @@
 }
 
 
-void Mesh2D::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(vertices);
-	REGISTER_ATTRIBUTE(edges);
-	REGISTER_ATTRIBUTE(faces);
-}
 
 
 

Modified: trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.hpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Mesh2D.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,16 +23,10 @@
 
 	protected :
 		virtual void postProcessAttributes(bool) {};
-		void registerAttributes()
-		{
-			REGISTER_ATTRIBUTE(first);
-			REGISTER_ATTRIBUTE(second);
-		};
+	REGISTER_ATTRIBUTES(Serializable,(first)(second));
 	REGISTER_CLASS_NAME(Edge);
 	REGISTER_BASE_CLASS_NAME(Serializable);
-
 };
-
 REGISTER_SERIALIZABLE_FUNDAMENTAL(Edge);
 
 class Mesh2D : public GeometricalModel
@@ -53,7 +47,7 @@
 /// Serialization
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(GeometricalModel,(vertices)(edges)(faces));
 	REGISTER_CLASS_NAME(Mesh2D);
 	REGISTER_BASE_CLASS_NAME(Serializable);
 

Modified: trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.cpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,22 +29,6 @@
 	#undef Q
 }
 
-Quadrilateral::~Quadrilateral()
-{
-}
+Quadrilateral::~Quadrilateral(){}
 
-void Quadrilateral::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(n1);
-	REGISTER_ATTRIBUTE(n2);
-	REGISTER_ATTRIBUTE(n3);
-	REGISTER_ATTRIBUTE(n4);
-	
-	REGISTER_ATTRIBUTE(i1);
-	REGISTER_ATTRIBUTE(i2);
-	REGISTER_ATTRIBUTE(i3);
-	REGISTER_ATTRIBUTE(i4);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.hpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Quadrilateral.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,8 +25,7 @@
 		Quadrilateral(int p1,int p2,int p3,int p4,MetaBody* mb);
 		virtual ~Quadrilateral();
 
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(GeometricalModel,(n1)(n2)(n3)(n4)(i1)(i2)(i3)(i4));
 	REGISTER_CLASS_NAME(Quadrilateral);
 	REGISTER_BASE_CLASS_NAME(GeometricalModel);
 	REGISTER_CLASS_INDEX(Quadrilateral,GeometricalModel);

Modified: trunk/pkg/common/DataClass/GeometricalModel/Sphere.cpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Sphere.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Sphere.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,10 +19,4 @@
 }
 
 
-void Sphere::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(radius);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/GeometricalModel/Sphere.hpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Sphere.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Sphere.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,10 +18,8 @@
 		Sphere ();
 		virtual ~Sphere ();
 
-	protected :
-		void registerAttributes();
-	REGISTER_CLASS_NAME(Sphere);
-	REGISTER_BASE_CLASS_NAME(GeometricalModel);
+	REGISTER_ATTRIBUTES(GeometricalModel,(radius));
+	REGISTER_CLASS_AND_BASE(Sphere,GeometricalModel);
 	REGISTER_CLASS_INDEX(Sphere,GeometricalModel);
 };
 

Modified: trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.cpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -30,10 +30,4 @@
 {
 }
 
-void Tetrahedron::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	// FIXME
-	REGISTER_ATTRIBUTE(v);
-}
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.hpp
===================================================================
--- trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/GeometricalModel/Tetrahedron.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,8 +25,7 @@
 		void dump(void) const{std::cerr&lt;&lt;&quot;[&quot;; for(int i=0; i&lt;4; i++){ std::cerr&lt;&lt;&quot;(&quot;; for(int j=0; j&lt;3; j++) std::cerr&lt;&lt;v[i][j]&lt;&lt;&quot;,&quot;; std::cerr&lt;&lt;&quot;)&quot;;} std::cerr&lt;&lt;&quot;]&quot;&lt;&lt;std::endl;}
 		virtual ~Tetrahedron();
 
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(GeometricalModel,(v));
 	REGISTER_CLASS_NAME(Tetrahedron);
 	REGISTER_BASE_CLASS_NAME(GeometricalModel);
 	REGISTER_CLASS_INDEX(Tetrahedron,GeometricalModel);

Modified: trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.cpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,13 +20,4 @@
 {		
 }
 
-void BssSweptSphereLineSegment::registerAttributes()
-{
-	InteractingGeometry::registerAttributes();
-	REGISTER_ATTRIBUTE(radius);
-        REGISTER_ATTRIBUTE(length);
-        REGISTER_ATTRIBUTE(position);
-        REGISTER_ATTRIBUTE(orientation);
-}
-
 YADE_PLUGIN(&quot;BssSweptSphereLineSegment&quot;);

Modified: trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.hpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/BssSweptSphereLineSegment.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,14 +23,10 @@
                 BssSweptSphereLineSegment ();
                 virtual ~BssSweptSphereLineSegment ();	
 	
-	protected :
-		void registerAttributes();
-	
-        REGISTER_CLASS_INDEX(BssSweptSphereLineSegment,InteractingGeometry);
-        REGISTER_CLASS_NAME(BssSweptSphereLineSegment);
+	REGISTER_ATTRIBUTES(InteractingGeometry,(radius)(length)(position)(orientation));
+	REGISTER_CLASS_INDEX(BssSweptSphereLineSegment,InteractingGeometry);
+	REGISTER_CLASS_NAME(BssSweptSphereLineSegment);
 	REGISTER_BASE_CLASS_NAME(InteractingGeometry);
-
-
 };
 
 REGISTER_SERIALIZABLE(BssSweptSphereLineSegment);

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.cpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,10 +18,4 @@
 {		
 }
 
-void InteractingBox::registerAttributes()
-{
-	InteractingGeometry::registerAttributes();
-	REGISTER_ATTRIBUTE(extents);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.hpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingBox.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,9 +20,7 @@
 		InteractingBox ();
 		virtual ~InteractingBox ();	
 	
-	protected :
-		void registerAttributes();
-	
+	REGISTER_ATTRIBUTES(InteractingGeometry,(extents));
 	REGISTER_CLASS_INDEX(InteractingBox,InteractingGeometry);
 	REGISTER_CLASS_NAME(InteractingBox);
 	REGISTER_BASE_CLASS_NAME(InteractingGeometry);

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.cpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,15 +22,6 @@
 {
 }
 
-void InteractingFacet::registerAttributes()
-{
-    InteractingGeometry::registerAttributes();
-    REGISTER_ATTRIBUTE(vertices);
-	#ifdef FACET_TOPO
-		REGISTER_ATTRIBUTE(edgeAdjIds);
-		REGISTER_ATTRIBUTE(edgeAdjHalfAngle);
-	#endif
-}
 
 void InteractingFacet::postProcessAttributes(bool deserializing)
 {

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.hpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingFacet.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -47,9 +47,12 @@
 
 	DECLARE_LOGGER;
 
-	protected:
-
-	void registerAttributes(); void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(InteractingGeometry,(vertices)
+		#ifdef FACET_TOPO
+			(edgeAdjIds)(edgeAdjHalfAngle)
+		#endif
+	);
+	protected: void postProcessAttributes(bool deserializing);
 	REGISTER_CLASS_NAME(InteractingFacet);
 	REGISTER_BASE_CLASS_NAME(InteractingGeometry);
 

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.cpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,10 +17,5 @@
 {
 }
 
-void InteractingNode::registerAttributes()
-{
-	InteractingGeometry::registerAttributes();
-}
 
-
 YADE_PLUGIN(&quot;InteractingNode&quot;);

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.hpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingNode.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,8 +17,7 @@
 		virtual ~InteractingNode ();
 
 /// Serialization
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractingGeometry,/* */);
 	REGISTER_CLASS_NAME(InteractingNode);
 	REGISTER_BASE_CLASS_NAME(InteractingGeometry);
 

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.cpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,11 +17,5 @@
 {
 }
 
-void InteractingSphere::registerAttributes()
-{
-	InteractingGeometry::registerAttributes();
-	REGISTER_ATTRIBUTE(radius);
-}
 
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.hpp
===================================================================
--- trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractingGeometry/InteractingSphere.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,13 +18,9 @@
 		InteractingSphere ();
 		virtual ~InteractingSphere ();
 
-/// Serialization
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractingGeometry,(radius));
 	REGISTER_CLASS_NAME(InteractingSphere);
 	REGISTER_BASE_CLASS_NAME(InteractingGeometry);
-
-/// Indexable
 	REGISTER_CLASS_INDEX(InteractingSphere,InteractingGeometry);
 };
 

Modified: trunk/pkg/common/DataClass/InteractionGeometry/ClosestFeatures.cpp
===================================================================
--- trunk/pkg/common/DataClass/InteractionGeometry/ClosestFeatures.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/InteractionGeometry/ClosestFeatures.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,9 +27,5 @@
 // 
 // }
 // 
-// void ClosestFeatures::registerAttributes()
-// {
-// 
-// }
 
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.cpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,12 +20,4 @@
 {
 }
 
-
-void BcpConnection::registerAttributes()
-{
-	SimpleViscoelasticBodyParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(id1);
-	REGISTER_ATTRIBUTE(id2);
-}
-
 YADE_PLUGIN(&quot;BcpConnection&quot;);

Modified: trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.hpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/BcpConnection.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,8 +24,7 @@
 		virtual ~BcpConnection();
 
 /// Serializable
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(SimpleViscoelasticBodyParameters,(id1)(id2));
 	REGISTER_CLASS_NAME(BcpConnection);
 	REGISTER_BASE_CLASS_NAME(SimpleViscoelasticBodyParameters);
 

Modified: trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.cpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,10 +17,4 @@
 {
 }
 
-void ElasticBodyParameters::registerAttributes()
-{
-	RigidBodyParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(young);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.hpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/ElasticBodyParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,12 +21,9 @@
 		ElasticBodyParameters ();
 		virtual ~ElasticBodyParameters ();
 
-/// Serialization
+	REGISTER_ATTRIBUTES(RigidBodyParameters,(young));
 	REGISTER_CLASS_NAME(ElasticBodyParameters);
 	REGISTER_BASE_CLASS_NAME(RigidBodyParameters);
-
-	public : void registerAttributes();
-
 /// Indexable
 	REGISTER_CLASS_INDEX(ElasticBodyParameters,RigidBodyParameters);
 };

Modified: trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.cpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,12 +23,4 @@
 {
 }
 
-
-void ParticleParameters::registerAttributes()
-{
-	PhysicalParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(mass);
-	REGISTER_ATTRIBUTE(velocity);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.hpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/ParticleParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,8 +27,7 @@
 		virtual ~ParticleParameters();
 
 /// Serializable
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(PhysicalParameters,(mass)(velocity));
 	REGISTER_CLASS_NAME(ParticleParameters);
 	REGISTER_BASE_CLASS_NAME(PhysicalParameters);
 

Modified: trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.cpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,11 +22,4 @@
 {
 }
 
-void RigidBodyParameters::registerAttributes()
-{
-	ParticleParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(inertia);
-	REGISTER_ATTRIBUTE(angularVelocity);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.hpp
===================================================================
--- trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/PhysicalParameters/RigidBodyParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,8 +25,7 @@
 		virtual ~RigidBodyParameters ();
 
 /// Serialization										///
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(ParticleParameters,(inertia)(angularVelocity));
 	REGISTER_CLASS_NAME(RigidBodyParameters);
 	REGISTER_BASE_CLASS_NAME(ParticleParameters);
 	

Modified: trunk/pkg/common/DataClass/Widgets/ColorScale.cpp
===================================================================
--- trunk/pkg/common/DataClass/Widgets/ColorScale.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/Widgets/ColorScale.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,15 +24,4 @@
 }
 
 
-void ColorScale::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(posX);
-	REGISTER_ATTRIBUTE(posY);
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(title);
-}
-
-
 YADE_PLUGIN();

Modified: trunk/pkg/common/DataClass/Widgets/ColorScale.hpp
===================================================================
--- trunk/pkg/common/DataClass/Widgets/ColorScale.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/DataClass/Widgets/ColorScale.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -11,9 +11,9 @@
 #include&lt;yade/core/GeometricalModel.hpp&gt;
 
 class ColorScale : public GeometricalModel {
-    public :
-    Real posX,posY;
-    Real width,height;
+   public :
+   Real posX,posY;
+   Real width,height;
 	string title;
 
 	vector&lt;Vector3r&gt; colors;
@@ -22,11 +22,10 @@
 	ColorScale ();
 	virtual ~ColorScale ();
 
-    protected :
-	    void registerAttributes();
-    REGISTER_CLASS_NAME(ColorScale);
-    REGISTER_BASE_CLASS_NAME(GeometricalModel);
-    REGISTER_CLASS_INDEX(ColorScale,GeometricalModel);
+	REGISTER_ATTRIBUTES(GeometricalModel,(posX)(posY)(width)(height)(title));
+   REGISTER_CLASS_NAME(ColorScale);
+   REGISTER_BASE_CLASS_NAME(GeometricalModel);
+   REGISTER_CLASS_INDEX(ColorScale,GeometricalModel);
 };
 
 REGISTER_SERIALIZABLE(ColorScale);

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -41,30 +41,6 @@
 }
 
 
-void CinemCNCEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(shearSpeed);
-	REGISTER_ATTRIBUTE(gammalim);
-	REGISTER_ATTRIBUTE(prevF_sup);
-	REGISTER_ATTRIBUTE(firstRun);
-	REGISTER_ATTRIBUTE(id_boxhaut);
-	REGISTER_ATTRIBUTE(id_boxbas);
-	REGISTER_ATTRIBUTE(id_boxleft);
-	REGISTER_ATTRIBUTE(id_boxright);
-	REGISTER_ATTRIBUTE(id_boxfront);
-	REGISTER_ATTRIBUTE(id_boxback);
-	REGISTER_ATTRIBUTE(Y0);
-	REGISTER_ATTRIBUTE(F_0);
-	REGISTER_ATTRIBUTE(k);
-	REGISTER_ATTRIBUTE(max_vel);
-	REGISTER_ATTRIBUTE(wallDamping);
-	REGISTER_ATTRIBUTE(Key);
-	REGISTER_ATTRIBUTE(LOG);
-	REGISTER_ATTRIBUTE(coeff_dech);
-}
-
-
 void CinemCNCEngine::applyCondition(Body * body)
 {
 	if(LOG)	cout &lt;&lt; &quot;debut applyCondi !!&quot; &lt;&lt; endl;

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -84,7 +84,7 @@
 
 
 	protected :
-		void registerAttributes();
+		REGISTER_ATTRIBUTES(DeusExMachina,(shearSpeed)(gammalim)(prevF_sup)(firstRun)(id_boxhaut)(id_boxbas)(id_boxleft)(id_boxright)(id_boxfront)(id_boxback)(Y0)(F_0)(k)(max_vel)(wallDamping)(Key)(LOG)(coeff_dech));
 		void letMove(Body* body);
 		void computeDu(MetaBody* ncb);
 		void stopMovement();		// to cancel all the velocities when gammalim is reached

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,15 +24,6 @@
 }
 
 
-void CinemCisEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(shearSpeed);
-	REGISTER_ATTRIBUTE(rotationAxis);
-	REGISTER_ATTRIBUTE(theta);
-	REGISTER_ATTRIBUTE(thetalim);
-	REGISTER_ATTRIBUTE(id_boxhaut);
-}
 
 
 void CinemCisEngine::applyCondition(MetaBody * body)

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemCisEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -34,12 +34,9 @@
 			;
 		body_id_t id_boxhaut;	// the id of the upper wall : defined in the constructor
 		Vector3r rotationAxis;	// defined in the constructor
-
-
-	protected :
-		void registerAttributes();
 		void applyRotTranslation(MetaBody *);	// to let move (rotation combined with translation) the lateral walls
 		void applyTranslation(MetaBody *);	// to let move (translation) the upper wall
+	REGISTER_ATTRIBUTES(DeusExMachina,(shearSpeed)(rotationAxis)(theta)(thetalim)(id_boxhaut));
 	REGISTER_CLASS_NAME(CinemCisEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,17 +24,6 @@
 }
 
 
-void CinemDNCEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(shearSpeed);
-	REGISTER_ATTRIBUTE(rotationAxis);
-	REGISTER_ATTRIBUTE(theta);
-	REGISTER_ATTRIBUTE(thetalim);
-	REGISTER_ATTRIBUTE(id_boxhaut);
-}
-
-
 void CinemDNCEngine::applyCondition(MetaBody * body)
 {
 	if(theta&lt;=thetalim)

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemDNCEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,9 +37,9 @@
 
 
 	protected :
-		void registerAttributes();
 		void applyRotTranslation(MetaBody *);	// to let move (rotation combined with translation) the lateral walls
 		void applyTranslation(MetaBody *);	// to let move (translation) the upper wall
+	REGISTER_ATTRIBUTES(DeusExMachina,(shearSpeed)(rotationAxis)(theta)(thetalim)(id_boxhaut));
 	REGISTER_CLASS_NAME(CinemDNCEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,30 +37,6 @@
 }
 
 
-void CinemKNCEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(shearSpeed);
-	REGISTER_ATTRIBUTE(gammalim);
-	REGISTER_ATTRIBUTE(prevF_sup);
-	REGISTER_ATTRIBUTE(firstRun);
-	REGISTER_ATTRIBUTE(id_boxhaut);
-	REGISTER_ATTRIBUTE(id_boxbas);
-	REGISTER_ATTRIBUTE(id_boxleft);
-	REGISTER_ATTRIBUTE(id_boxright);
-	REGISTER_ATTRIBUTE(id_boxfront);
-	REGISTER_ATTRIBUTE(id_boxback);
-	REGISTER_ATTRIBUTE(Y0);
-	REGISTER_ATTRIBUTE(F_0);
-	REGISTER_ATTRIBUTE(KnC);
-	REGISTER_ATTRIBUTE(max_vel);
-	REGISTER_ATTRIBUTE(Key);
-	REGISTER_ATTRIBUTE(LOG);
-	REGISTER_ATTRIBUTE(coeff_dech);
-	REGISTER_ATTRIBUTE(wallDamping);
-}
-
-
 void CinemKNCEngine::applyCondition(Body * body)
 {
 	if(LOG) cerr &lt;&lt; &quot;debut applyCondi !!&quot; &lt;&lt; endl;

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -79,9 +79,8 @@
 		string Key;
 		
 
-
+	REGISTER_ATTRIBUTES(DeusExMachina,(shearSpeed)(gammalim)(prevF_sup)(firstRun)(id_boxhaut)(id_boxbas)(id_boxleft)(id_boxright)(id_boxfront)(id_boxback)(Y0)(F_0)(KnC)(max_vel)(Key)(LOG)(coeff_dech)(wallDamping));
 	protected :
-		void registerAttributes();
 		void letMove(Body* body);
 		void computeDu(MetaBody* ncb);
 		void stopMovement();		// to cancel all the velocities when gammalim is reached

Modified: trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -14,30 +14,11 @@
 	if(deserializing)
 	{
 		translationAxis.Normalize();
-
-	/*	
-		if(displacement==0)
-			displacement=6e-9;
-		else
-			displacement=0;
-			//displacement=3e-8;
-		
-		//displacement *= 20.0;
-	*/
-	//	std::cerr &lt;&lt; &quot;displacement 0.00000000375*2: &quot; &lt;&lt; displacement &lt;&lt; &quot;\n&quot;;
 		std::cerr &lt;&lt; &quot;displacement: &quot; &lt;&lt; displacement &lt;&lt; &quot;\n&quot;;
 	}
 }
 
 
-void DisplacementEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(displacement);
-	REGISTER_ATTRIBUTE(translationAxis);
-	REGISTER_ATTRIBUTE(active);
-}
-
 bool DisplacementEngine::isActivated(MetaBody*)
 {
    return active;

Modified: trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,7 +24,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(displacement)(translationAxis)(active));
 	REGISTER_CLASS_NAME(DisplacementEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -38,16 +38,7 @@
 }
 
 
-void DisplacementToForceEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(displacement);
-	REGISTER_ATTRIBUTE(translationAxis);
-	REGISTER_ATTRIBUTE(targetForce);
-	REGISTER_ATTRIBUTE(targetForceMask);
-}
 
-
 void DisplacementToForceEngine::applyCondition(MetaBody * ncb)
 {
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;

Modified: trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,7 +28,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(displacement)(translationAxis)(targetForce)(targetForceMask));
 	REGISTER_CLASS_NAME(DisplacementToForceEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,13 +24,7 @@
 }
 
 
-void FixedOrientationEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(fixedOrientation);
-}
 
-
 void FixedOrientationEngine::applyCondition(MetaBody * ncb)
 {
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;

Modified: trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,7 +22,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(fixedOrientation));
 	REGISTER_CLASS_NAME(FixedOrientationEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,13 +17,7 @@
 
 void FixedPositionEngine::postProcessAttributes(bool deserializing){}
 
-void FixedPositionEngine::registerAttributes(){
-	DeusExMachina::registerAttributes(); // for subscribedBodies
-	REGISTER_ATTRIBUTE(fixedPosition);
-	REGISTER_ATTRIBUTE(mask);
-}
 
-
 void FixedPositionEngine::applyCondition(MetaBody * ncb){
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
 	FOREACH(int id, subscribedBodies){

Modified: trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,7 +22,7 @@
 		FixedPositionEngine();
 	protected:
 		virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(fixedPosition)(mask));
 	REGISTER_CLASS_NAME(FixedPositionEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/GravityEngines.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/GravityEngines.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/GravityEngines.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,7 +37,7 @@
 		virtual ~CentralGravityEngine(){};
 		virtual void applyCondition(MetaBody*);
 	protected:
-		virtual void registerAttributes(){DeusExMachina::registerAttributes(); REGISTER_ATTRIBUTE(centralBody); REGISTER_ATTRIBUTE(accel); REGISTER_ATTRIBUTE(reciprocal); }
+		REGISTER_ATTRIBUTES(DeusExMachina,(centralBody)(accel)(reciprocal));
 		REGISTER_CLASS_NAME(CentralGravityEngine);
 		REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };
@@ -59,7 +59,7 @@
 		virtual ~AxialGravityEngine(){};
 		virtual void applyCondition(MetaBody*);
 	protected:
-		virtual void registerAttributes(){DeusExMachina::registerAttributes(); REGISTER_ATTRIBUTE(axisPoint); REGISTER_ATTRIBUTE(axisDirection); REGISTER_ATTRIBUTE(acceleration); }
+		REGISTER_ATTRIBUTES(DeusExMachina,(axisPoint)(axisDirection)(acceleration));
 		REGISTER_CLASS_NAME(AxialGravityEngine);
 		REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/JumpChangeSe3.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/JumpChangeSe3.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/JumpChangeSe3.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -39,11 +39,10 @@
 		}
 		Se3r deltaSe3;
 		bool setVelocities; /* should be bool, but serializer breaks on that */
-	protected:
-		virtual void registerAttributes(){DeusExMachina::registerAttributes();REGISTER_ATTRIBUTE(deltaSe3);REGISTER_ATTRIBUTE(setVelocities);}
-		REGISTER_CLASS_NAME(JumpChangeSe3);
-		REGISTER_BASE_CLASS_NAME(DeusExMachina);
-		DECLARE_LOGGER;
+	REGISTER_ATTRIBUTES(DeusExMachina,(deltaSe3)(setVelocities));
+	REGISTER_CLASS_NAME(JumpChangeSe3);
+	REGISTER_BASE_CLASS_NAME(DeusExMachina);
+	DECLARE_LOGGER;
 };
 REGISTER_SERIALIZABLE(JumpChangeSe3);
 	

Modified: trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,13 +22,7 @@
 }
 
 
-void MomentEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(moment);
-}
 
-
 void MomentEngine::applyCondition(MetaBody* ncb)
 {
 	

Modified: trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,9 +20,7 @@
 		virtual ~MomentEngine();
 	
 		virtual void applyCondition(MetaBody*);
-	
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(moment));
 	REGISTER_CLASS_NAME(MomentEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/RotationEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/RotationEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/RotationEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,7 +28,7 @@
 	angleTurned+=angularVelocity*dt;
 	shared_ptr&lt;BodyContainer&gt; bodies = rb-&gt;bodies;
 	FOREACH(body_id_t id,subscribedBodies){
-		assert(id&lt;bodies-&gt;size());
+		assert(id&lt;(body_id_t)bodies-&gt;size());
 		Body* b=Body::byId(id,rb).get();
 		ParticleParameters* rbp=YADE_CAST&lt;RigidBodyParameters*&gt;(b-&gt;physicalParameters.get());
 		assert(rbp);
@@ -48,14 +48,6 @@
 }
 
 
-void RotationEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(angularVelocity);
-	REGISTER_ATTRIBUTE(rotationAxis);
-	REGISTER_ATTRIBUTE(rotateAroundZero);
-	REGISTER_ATTRIBUTE(zeroPoint);
-}
 
 void RotationEngine::applyCondition(MetaBody *ncb)
 {

Modified: trunk/pkg/common/Engine/DeusExMachina/RotationEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/RotationEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/RotationEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,7 +23,7 @@
 		void applyCondition(MetaBody * );
 
 	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(angularVelocity)(rotationAxis)(rotateAroundZero)(zeroPoint));
 	REGISTER_CLASS_NAME(RotationEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -9,11 +9,6 @@
 #include&quot;StaticAttractionEngine.hpp&quot;
 #include&lt;yade/core/MetaBody.hpp&gt;
 
-void StaticAttractionEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(active);
-}
 
 /*! \brief Compress stuff faster and better!
  *

Modified: trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/DeusExMachina/StaticAttractionEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,8 +23,7 @@
 	protected :
 		virtual Real getMaxDisplacement(MetaBody*) {throw &quot;do not use StaticAttractionEngine directly, use derived classes instead.&quot;;};
 		virtual bool doesItApplyToThisBody(Body*) {throw &quot;do not use StaticAttractionEngine directly, use derived classes instead.&quot;;};
-
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(active));
 	REGISTER_CLASS_NAME(StaticAttractionEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/EngineUnit/CundallNonViscousDamping.hpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/CundallNonViscousDamping.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/EngineUnit/CundallNonViscousDamping.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -6,8 +6,8 @@
 	public:
 		Real damping;
 		CundallNonViscousForceDamping(): damping(0){};
-		virtual void registerAttributes(){PhysicalActionDamperUnit::registerAttributes();REGISTER_ATTRIBUTE(damping);}
-	virtual void go(const shared_ptr&lt;PhysicalParameters&gt;&amp;, const Body*, MetaBody*);
+		virtual void go(const shared_ptr&lt;PhysicalParameters&gt;&amp;, const Body*, MetaBody*);
+	REGISTER_ATTRIBUTES(PhysicalActionDamperUnit,(damping));
 	FUNCTOR1D(ParticleParameters);
 	REGISTER_CLASS_AND_BASE(CundallNonViscousForceDamping,PhysicalActionDamperUnit);
 };
@@ -17,8 +17,8 @@
 	public:
 		Real damping;
 		CundallNonViscousMomentumDamping(): damping(0){};
-		virtual void registerAttributes(){PhysicalActionDamperUnit::registerAttributes();REGISTER_ATTRIBUTE(damping); }
 		virtual void go(const shared_ptr&lt;PhysicalParameters&gt;&amp;, const Body*, MetaBody*);
+	REGISTER_ATTRIBUTES(PhysicalActionDamperUnit,(damping));
 	FUNCTOR1D(RigidBodyParameters);
 	REGISTER_CLASS_AND_BASE(CundallNonViscousMomentumDamping,PhysicalActionDamperUnit);
 };

Modified: trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,8 +29,5 @@
 	}	
 };
 
-void ElasticBodySimpleRelationship::registerAttributes()
-{
-};
 
 YADE_PLUGIN();

Modified: trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.hpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,11 +17,8 @@
 					const shared_ptr&lt;PhysicalParameters&gt;&amp; b2,
 					const shared_ptr&lt;Interaction&gt;&amp; interaction);
 
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(InteractionPhysicsEngineUnit,/* */);
 	FUNCTOR2D(ElasticBodyParameters,ElasticBodyParameters);
-
 	REGISTER_CLASS_NAME(ElasticBodySimpleRelationship);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);
 

Modified: trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.cpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,16 +29,6 @@
 		&amp;&amp; ((Omega::instance().getCurrentIteration() % interval == 0));
 }
 
-void ColorizedLayerFilter::registerAttributes()
-{
-	FilterEngine::registerAttributes();
-	REGISTER_ATTRIBUTE(near);
-	REGISTER_ATTRIBUTE(normal);
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(diffuseColor);
-	REGISTER_ATTRIBUTE(interval);
-}
-
 void ColorizedLayerFilter::postProcessAttributes(bool deserializing)
 {
 	if (deserializing){

Modified: trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.hpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/ColorizedLayerFilter.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -26,8 +26,8 @@
 		virtual bool isActivated(MetaBody*);
 		virtual void applyCondition(MetaBody*);
 	
-		virtual void registerAttributes();
 		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(FilterEngine,(near)(normal)(thickness)(diffuseColor)(interval));
 	REGISTER_CLASS_NAME(ColorizedLayerFilter);
 	REGISTER_BASE_CLASS_NAME(FilterEngine);
 };

Modified: trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.cpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -40,23 +40,6 @@
 	return FilterEngine::isActivated(rootBody);
 }
 
-void ColorizedTimeFilter::registerAttributes()
-{
-	FilterEngine::registerAttributes();
-	REGISTER_ATTRIBUTE(point);
-	REGISTER_ATTRIBUTE(normal);
-	REGISTER_ATTRIBUTE(autoScale);
-	REGISTER_ATTRIBUTE(onlyDynamic);
-	REGISTER_ATTRIBUTE(minValue);
-	REGISTER_ATTRIBUTE(maxValue);
-
-	REGISTER_ATTRIBUTE(posX);
-	REGISTER_ATTRIBUTE(posY);
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(title);
-}
-
 void ColorizedTimeFilter::applyCondition(MetaBody* ncb)
 {
 

Modified: trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.hpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/ColorizedTimeFilter.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -49,8 +49,8 @@
 		virtual bool isActivated(MetaBody*);
 		virtual void applyCondition(MetaBody*);
 	
-		virtual void registerAttributes();
-		DECLARE_LOGGER;
+	DECLARE_LOGGER;
+	REGISTER_ATTRIBUTES(FilterEngine,(point)(normal)(autoScale)(onlyDynamic)(minValue)(maxValue)(posX)(posY)(width)(height)(title));
 	REGISTER_CLASS_NAME(ColorizedTimeFilter);
 	REGISTER_BASE_CLASS_NAME(FilterEngine);
 };

Modified: trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.cpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -40,21 +40,6 @@
 	return FilterEngine::isActivated(rootBody);
 }
 
-void ColorizedVelocityFilter::registerAttributes()
-{
-	FilterEngine::registerAttributes();
-	REGISTER_ATTRIBUTE(autoScale);
-	REGISTER_ATTRIBUTE(onlyDynamic);
-	REGISTER_ATTRIBUTE(minValue);
-	REGISTER_ATTRIBUTE(maxValue);
-
-	REGISTER_ATTRIBUTE(posX);
-	REGISTER_ATTRIBUTE(posY);
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(title);
-}
-
 void ColorizedVelocityFilter::applyCondition(MetaBody* ncb)
 {
 

Modified: trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.hpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/ColorizedVelocityFilter.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -45,8 +45,8 @@
 		virtual bool isActivated(MetaBody*);
 		virtual void applyCondition(MetaBody*);
 	
-		virtual void registerAttributes();
-		DECLARE_LOGGER;
+	DECLARE_LOGGER;
+	REGISTER_ATTRIBUTES(FilterEngine,(autoScale)(onlyDynamic)(minValue)(maxValue)(posX)(posY)(width)(height)(title));
 	REGISTER_CLASS_NAME(ColorizedVelocityFilter);
 	REGISTER_BASE_CLASS_NAME(FilterEngine);
 };

Modified: trunk/pkg/common/Engine/FilterEngine/FilterEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/FilterEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/FilterEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,13 +21,7 @@
 
 		FilterEngine();
 	
-		void registerAttributes()
-		{
-//			REGISTER_ATTRIBUTE(isFiltrationActivated);
-			REGISTER_ATTRIBUTE(isFilterActivated);
-		}
-
-	protected :
+	REGISTER_ATTRIBUTES(FilterEngine,(isFilterActivated));
 	REGISTER_CLASS_NAME(FilterEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/common/Engine/FilterEngine/PythonRunnerFilter.hpp
===================================================================
--- trunk/pkg/common/Engine/FilterEngine/PythonRunnerFilter.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/FilterEngine/PythonRunnerFilter.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,9 +22,7 @@
 				PyRun_SimpleString(command.c_str()); 
 			PyGILState_Release(gstate);
 		}
-		virtual void registerAttributes(){ FilterEngine::registerAttributes(); REGISTER_ATTRIBUTE(command); }
-	protected :
-		virtual void postProcessAttributes(bool deserializing){}
+	REGISTER_ATTRIBUTES(FilterEngine,(command));
 	REGISTER_CLASS_NAME(PythonRunnerFilter);
 	REGISTER_BASE_CLASS_NAME(FilterEngine);
 };

Modified: trunk/pkg/common/Engine/ParallelEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/ParallelEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/ParallelEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -9,8 +9,7 @@
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*){return true;}
 		virtual list&lt;string&gt; getNeededBex();		
-	protected:
-		void registerAttributes(){Engine::registerAttributes(); REGISTER_ATTRIBUTE(slaves); }
+	REGISTER_ATTRIBUTES(Engine,(slaves));
 	REGISTER_CLASS_NAME(ParallelEngine);
 	REGISTER_BASE_CLASS_NAME(Engine);
 };

Modified: trunk/pkg/common/Engine/StandAloneEngine/PeriodicEngines.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PeriodicEngines.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/StandAloneEngine/PeriodicEngines.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -87,14 +87,7 @@
 		&amp;&amp; (iterPeriod&lt;0 || (stretchFactor&gt;1 ? stretchFactor*iterPeriod&lt;=iterLim : stretchFactor*iterPeriod&gt;=iterLim)));
 		return PeriodicEngine::isActivated(rootBody);
 	}
-	protected:
-		void registerAttributes(){ PeriodicEngine::registerAttributes();
-			REGISTER_ATTRIBUTE(realLim);
-			REGISTER_ATTRIBUTE(virtLim);
-			REGISTER_ATTRIBUTE(iterLim);
-			REGISTER_ATTRIBUTE(mayStretch);
-			REGISTER_ATTRIBUTE(stretchFactor);
-		}
+	REGISTER_ATTRIBUTES(PeriodicEngine,(realLim)(virtLim)(iterLim)(mayStretch)(stretchFactor));
 	REGISTER_CLASS_NAME(StretchPeriodicEngine);
 	REGISTER_BASE_CLASS_NAME(PeriodicEngine);
 };
@@ -153,17 +146,7 @@
 				return true;
 			} else return false;
 		}
-		virtual void registerAttributes(){
-			StandAloneEngine::registerAttributes();
-			REGISTER_ATTRIBUTE(virtTimeLim);
-			REGISTER_ATTRIBUTE(realTimeLim);
-			REGISTER_ATTRIBUTE(iterLim);
-			REGISTER_ATTRIBUTE(lastRealTime);
-			REGISTER_ATTRIBUTE(lastVirtTime);
-			REGISTER_ATTRIBUTE(lastIter);
-			REGISTER_ATTRIBUTE(mayDouble);
-			REGISTER_ATTRIBUTE(mayHalve);
-		}
+		REGISTER_ATTRIBUTES(StandAloneEngine,(virtTimeLim)(realTimeLim)(iterLim)(lastRealTime)(lastVirtTime)(lastIter)(mayDouble)(mayHalve));
 	protected :
 		virtual void postProcessAttributes(bool deserializing){}
 	DECLARE_LOGGER;

Modified: trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/StandAloneEngine/PeriodicPythonRunner.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,9 +21,7 @@
 				PyRun_SimpleString(command.c_str()); // this is suboptimal, since it has to be parsed at every execution; critical?
 			PyGILState_Release(gstate);
 		}
-		virtual void registerAttributes(){ StretchPeriodicEngine::registerAttributes(); REGISTER_ATTRIBUTE(command); }
-	protected :
-		virtual void postProcessAttributes(bool deserializing){}
+	REGISTER_ATTRIBUTES(StretchPeriodicEngine,(command));
 	REGISTER_CLASS_NAME(PeriodicPythonRunner);
 	REGISTER_BASE_CLASS_NAME(StretchPeriodicEngine);
 };

Modified: trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -101,12 +101,7 @@
 
 		bool shouldBeErased(body_id_t, body_id_t) const;
 
-		void registerAttributes(){
-			Collider::registerAttributes();
-			REGISTER_ATTRIBUTE(haveDistantTransient);
-			//REGISTER_ATTRIBUTE(ompBodiesMin);
-		}
-
+	REGISTER_ATTRIBUTES(Collider,(haveDistantTransient));
 	DECLARE_LOGGER;
 	REGISTER_CLASS_NAME(PersistentSAPCollider);
 	REGISTER_BASE_CLASS_NAME(Collider);

Modified: trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -113,13 +113,7 @@
 		//! this flag is used to check if the packing has been triangulated
 		bool isTriangulated;
 
-		void registerAttributes(){
-			Collider::registerAttributes();
-			REGISTER_ATTRIBUTE(noTransientIfPersistentExists);
-			REGISTER_ATTRIBUTE(haveDistantTransient);
-		}
-
-
+	REGISTER_ATTRIBUTES(Collider,(noTransientIfPersistentExists)(haveDistantTransient));
 	REGISTER_CLASS_NAME(PersistentTriangulationCollider);
 	REGISTER_BASE_CLASS_NAME(Collider);
 

Modified: trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,15 +24,7 @@
 
 void ResetPositionEngine::postProcessAttributes(bool deserializing){}
 
-void ResetPositionEngine::registerAttributes(){
-	PeriodicEngine::registerAttributes(); // for subscribedBodies
-	REGISTER_ATTRIBUTE(Y_min);
-	REGISTER_ATTRIBUTE(subscribedBodies);
-	REGISTER_ATTRIBUTE(initial_positions);
-	REGISTER_ATTRIBUTE(fileName);
-}
 
-
 void ResetPositionEngine::action(MetaBody * ncb)
 {
 	if (first) { initialize(ncb); return; }

Modified: trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/StandAloneEngine/ResetPositionEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,7 +33,7 @@
 		DECLARE_LOGGER;
 	protected:
 		virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(PeriodicEngine,(Y_min)(subscribedBodies)(initial_positions)(fileName));
 	REGISTER_CLASS_NAME(ResetPositionEngine);
 	REGISTER_BASE_CLASS_NAME(PeriodicEngine);
 	private:

Modified: trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -42,11 +42,7 @@
 	//! Don't break transient interaction once bodies don't overlap anymore; material law will be responsible for breaking it.
 	bool haveDistantTransient;
 
-	void registerAttributes() {
-		Collider::registerAttributes();
-		REGISTER_ATTRIBUTE(haveDistantTransient);
-	}
-
+	REGISTER_ATTRIBUTES(Collider,(haveDistantTransient));
 	DECLARE_LOGGER;
 	REGISTER_CLASS_NAME(SpatialQuickSortCollider);
 	REGISTER_BASE_CLASS_NAME(Collider);

Modified: trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.hpp
===================================================================
--- trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -32,8 +32,7 @@
 /// Serialization
 	protected :
 		virtual void postProcessAttributes(bool deserializing){if(deserializing){first=true;};};
-		virtual void registerAttributes(){REGISTER_ATTRIBUTE(glutUse); REGISTER_ATTRIBUTE(glutNormalize); REGISTER_ATTRIBUTE(glutSlices); REGISTER_ATTRIBUTE(glutStacks); }
-		
+	REGISTER_ATTRIBUTES(/*nothing*/,(glutUse)(glutNormalize)(glutSlices)(glutStacks));
 	RENDERS(Sphere);
 	REGISTER_CLASS_NAME(GLDrawSphere);
 	REGISTER_BASE_CLASS_NAME(GLDrawGeometricalModelFunctor);

Modified: trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp
===================================================================
--- trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -519,43 +519,7 @@
 }
 
 
-void OpenGLRenderingEngine::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(scaleDisplacements);
-	REGISTER_ATTRIBUTE(displacementScale);
-	REGISTER_ATTRIBUTE(scaleRotations);
-	REGISTER_ATTRIBUTE(rotationScale);
 
-	REGISTER_ATTRIBUTE(Light_position);
-	REGISTER_ATTRIBUTE(Background_color);
-	
-	REGISTER_ATTRIBUTE(Body_wire);
-
-	REGISTER_ATTRIBUTE(Show_DOF);
-	REGISTER_ATTRIBUTE(Show_ID);
-	REGISTER_ATTRIBUTE(Body_state);
-	REGISTER_ATTRIBUTE(Body_bounding_volume);
-	REGISTER_ATTRIBUTE(Body_interacting_geom);
-	REGISTER_ATTRIBUTE(Body_geometrical_model);
-	
-	REGISTER_ATTRIBUTE(Interaction_wire);
-	REGISTER_ATTRIBUTE(Interaction_geometry);
-	REGISTER_ATTRIBUTE(Interaction_physics);
-	
-	REGISTER_ATTRIBUTE(Draw_mask);
-	REGISTER_ATTRIBUTE(Draw_inside);
-
-	REGISTER_ATTRIBUTE(Cast_shadows);
-	REGISTER_ATTRIBUTE(Shadow_volumes);
-	REGISTER_ATTRIBUTE(Fast_shadow_volume);
-
-	REGISTER_ATTRIBUTE(clipPlaneSe3);
-	REGISTER_ATTRIBUTE(clipPlaneActive);
-
-	REGISTER_ATTRIBUTE(selectBodyLimit);
-}
-
-
 void OpenGLRenderingEngine::postProcessAttributes(bool deserializing){
 	if(!deserializing) return;
 	for(unsigned int i=0;i&lt;stateFunctorNames.size();i++) stateDispatcher.add1DEntry(stateFunctorNames[i][0],stateFunctorNames[i][1]);

Modified: trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp
===================================================================
--- trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -92,8 +92,10 @@
 	
 	protected :
 		void postProcessAttributes(bool deserializing);
-		void registerAttributes();
-	REGISTER_CLASS_NAME(OpenGLRenderingEngine);
-	REGISTER_BASE_CLASS_NAME(RenderingEngine);
+	REGISTER_ATTRIBUTES(/* no base*/,(scaleDisplacements)(displacementScale)(scaleRotations)(rotationScale)(Light_position)(Background_color)(Body_wire)(Show_DOF)(Show_ID)(Body_state)(Body_bounding_volume)(Body_interacting_geom)(Body_geometrical_model)(Interaction_wire)(Interaction_geometry)(Interaction_physics)(Draw_mask)(Draw_inside)(Cast_shadows)(Shadow_volumes)(Fast_shadow_volume)(clipPlaneSe3)(clipPlaneActive)(selectBodyLimit));
+	REGISTER_CLASS_AND_BASE(OpenGLRenderingEngine,RenderingEngine);
 };
 REGISTER_SERIALIZABLE(OpenGLRenderingEngine);
+
+
+

Modified: trunk/pkg/dem/ConcretePM.cpp
===================================================================
--- trunk/pkg/dem/ConcretePM.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/ConcretePM.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -366,3 +366,4 @@
 		B-&gt;geometricalModel-&gt;diffuseColor=Vector3r(bpp-&gt;normDmg,1-bpp-&gt;normDmg,B-&gt;isDynamic?0:1);
 	}
 }
+

Modified: trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,18 +18,5 @@
 {
 }
 
-void InteractingMyTetrahedron::registerAttributes()
-{
-	InteractingGeometry::registerAttributes();
-	REGISTER_ATTRIBUTE(c1);
-	REGISTER_ATTRIBUTE(c2);
-	REGISTER_ATTRIBUTE(c3);
-	REGISTER_ATTRIBUTE(c4);
-	REGISTER_ATTRIBUTE(r1);
-	REGISTER_ATTRIBUTE(r2);
-	REGISTER_ATTRIBUTE(r3);
-	REGISTER_ATTRIBUTE(r4);
-}
 
-
 YADE_PLUGIN();

Modified: trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractingGeometry/InteractingMyTetrahedron.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -45,11 +45,9 @@
 		virtual ~InteractingMyTetrahedron ();
 
 /// Serialization
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractingGeometry,(c1)(c2)(c3)(c4)(r1)(r2)(r3)(r4));
 	REGISTER_CLASS_NAME(InteractingMyTetrahedron);
 	REGISTER_BASE_CLASS_NAME(InteractingGeometry);
-
 /// Indexable
 	REGISTER_CLASS_INDEX(InteractingMyTetrahedron,InteractingGeometry);
 };

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,10 +19,4 @@
 {
 }
 
-void SDECLinkGeometry::registerAttributes()
-{
-	InteractionGeometry::registerAttributes();
-	REGISTER_ATTRIBUTE(radius1);
-	REGISTER_ATTRIBUTE(radius2);
-}
 YADE_PLUGIN();

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/SDECLinkGeometry.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,10 +25,7 @@
 				,radius2;
 
 		Vector3r	normal;			// new unit normal of the contact plane.
-
-	protected :
-		void registerAttributes();
-
+	REGISTER_ATTRIBUTES(InteractionGeometry,(radius1)(radius2));
 	REGISTER_CLASS_NAME(SDECLinkGeometry);
 	REGISTER_BASE_CLASS_NAME(InteractionGeometry);
 

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,16 +24,4 @@
 // 
 // }
 
-void CapillaryParameters::registerAttributes()
-{
-	ElasticContactInteraction::registerAttributes();
-	REGISTER_ATTRIBUTE(Vmeniscus);
-	REGISTER_ATTRIBUTE(CapillaryPressure);
-	REGISTER_ATTRIBUTE(Fcap);
-	REGISTER_ATTRIBUTE(Delta1);
-	REGISTER_ATTRIBUTE(Delta2);
-	REGISTER_ATTRIBUTE(meniscus);
-	REGISTER_ATTRIBUTE(fusionNumber);
-}
 
-

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,14 +24,10 @@
 				
 		CapillaryParameters();
 		virtual ~CapillaryParameters();
-		
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(ElasticContactInteraction,(Vmeniscus)(CapillaryPressure)(Fcap)(Delta1)(Delta2)(meniscus)(fusionNumber));
 	REGISTER_CLASS_NAME(CapillaryParameters);
 	REGISTER_BASE_CLASS_NAME(ElasticContactInteraction);
 // 	REGISTER_CLASS_INDEX(CapillaryParameters,ElasticContactInteraction);
-
 };
 
 REGISTER_SERIALIZABLE(CapillaryParameters);

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -52,51 +52,4 @@
 // }
 
 
-void CohesiveFrictionalContactInteraction::registerAttributes()
-{
-	NormalInteraction::registerAttributes();
-	REGISTER_ATTRIBUTE(prevNormal);
-	REGISTER_ATTRIBUTE(shearForce);
-	REGISTER_ATTRIBUTE(ks);
-	REGISTER_ATTRIBUTE(initialKn);
-	REGISTER_ATTRIBUTE(initialKs);
-	REGISTER_ATTRIBUTE(tangensOfFrictionAngle);
-	REGISTER_ATTRIBUTE(cohesionDisablesFriction);
-	REGISTER_ATTRIBUTE(fragile);
-	REGISTER_ATTRIBUTE(cohesionBroken);
-	REGISTER_ATTRIBUTE(normalAdhesion);
-	REGISTER_ATTRIBUTE(shearAdhesion);
-
-// FIXME where this?
-	REGISTER_ATTRIBUTE(orientationToContact1);
-	REGISTER_ATTRIBUTE(orientationToContact2);
-	REGISTER_ATTRIBUTE(initialOrientation1);
-	REGISTER_ATTRIBUTE(initialOrientation2);
-	REGISTER_ATTRIBUTE(kr);
-	REGISTER_ATTRIBUTE(currentContactOrientation);
-	REGISTER_ATTRIBUTE(initialContactOrientation);
-	REGISTER_ATTRIBUTE(initialPosition1);
-	REGISTER_ATTRIBUTE(initialPosition2);
-	REGISTER_ATTRIBUTE(twistCreep);
-
-	REGISTER_ATTRIBUTE(moment_twist);
-	REGISTER_ATTRIBUTE(moment_bending);
-
-//	REGISTER_ATTRIBUTE(prevX1);
-//	REGISTER_ATTRIBUTE(prevX2);
-//	REGISTER_ATTRIBUTE(initX1);
-//	REGISTER_ATTRIBUTE(initX2);
-//		Real		 kn				// normal elastic constant.
-//				,ks				// shear elastic constant.
-//				,initialKn			// initial normal elastic constant.
-//				,initialKs			// initial shear elastic constant.
-//				,equilibriumDistance		// equilibrium distance
-//				,initialEquilibriumDistance	// initial equilibrium distance
-//				,frictionAngle 			// angle of friction, according to Coulumb criterion
-//				,tangensOfFrictionAngle;
-//	
-//		Vector3r	prevNormal			// unit normal of the contact plane.
-//				,normalForce			// normal force applied on a DE
-//				,shearForce;			// shear force applied on a DE
-}
 YADE_PLUGIN();

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -32,12 +32,28 @@
 		CohesiveFrictionalContactInteraction();
 		virtual ~CohesiveFrictionalContactInteraction();
 		void SetBreakingState ();
-	protected :
-		virtual void registerAttributes();
 
+	REGISTER_ATTRIBUTES(NormalInteraction,
+		(prevNormal)(shearForce)(ks)(initialKn)(initialKs)(tangensOfFrictionAngle)(cohesionDisablesFriction)(fragile)(cohesionBroken)(normalAdhesion)(shearAdhesion)
+		// FIXME where this?
+		(orientationToContact1)(orientationToContact2)(initialOrientation1)(initialOrientation2)(kr)(currentContactOrientation)(initialContactOrientation)(initialPosition1)(initialPosition2)(twistCreep)
+		(moment_twist)(moment_bending)
+		/* (prevX1)(prevX2)(initX1)(initX2) */
+		//		Real		 kn				// normal elastic constant.
+		//				,ks				// shear elastic constant.
+		//				,initialKn			// initial normal elastic constant.
+		//				,initialKs			// initial shear elastic constant.
+		//				,equilibriumDistance		// equilibrium distance
+		//				,initialEquilibriumDistance	// initial equilibrium distance
+		//				,frictionAngle 			// angle of friction, according to Coulumb criterion
+		//				,tangensOfFrictionAngle;
+		//	
+		//		Vector3r	prevNormal			// unit normal of the contact plane.
+		//				,normalForce			// normal force applied on a DE
+		//				,shearForce;			// shear force applied on a DE
+	);
 	REGISTER_CLASS_NAME(CohesiveFrictionalContactInteraction);
 	REGISTER_BASE_CLASS_NAME(ElasticContactInteraction);
-
 	REGISTER_CLASS_INDEX(CohesiveFrictionalContactInteraction,ElasticContactInteraction);
 
 };

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -46,21 +46,4 @@
 // }
 
 
-void ContactLaw1Interaction::registerAttributes()
-{
-	ElasticContactInteraction::registerAttributes();
-	REGISTER_ATTRIBUTE(unMax);
-	REGISTER_ATTRIBUTE(previousun);
-	REGISTER_ATTRIBUTE(previousFn);
-	REGISTER_ATTRIBUTE(initialOrientation1);
-	REGISTER_ATTRIBUTE(initialOrientation2);
-	REGISTER_ATTRIBUTE(orientationToContact1);
-	REGISTER_ATTRIBUTE(orientationToContact2);
-	REGISTER_ATTRIBUTE(currentContactOrientation);
-	REGISTER_ATTRIBUTE(initialContactOrientation);
-	REGISTER_ATTRIBUTE(initialPosition1);
-	REGISTER_ATTRIBUTE(initialPosition2);
-	REGISTER_ATTRIBUTE(forMaxMoment);
-	REGISTER_ATTRIBUTE(kr);
-}
 YADE_PLUGIN();

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/ContactLaw1Interaction.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -34,9 +34,7 @@
 		ContactLaw1Interaction();
 		virtual ~ContactLaw1Interaction();
 		void SetBreakingState ();
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(ElasticContactInteraction,(unMax)(previousun)(previousFn)(initialOrientation1)(initialOrientation2)(orientationToContact1)(orientationToContact2)(currentContactOrientation)(initialContactOrientation)(initialPosition1)(initialPosition2)(forMaxMoment)(kr));
 	REGISTER_CLASS_NAME(ContactLaw1Interaction);
 	REGISTER_BASE_CLASS_NAME(ElasticContactInteraction);
 

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -9,35 +9,7 @@
 ElasticContactInteraction::~ElasticContactInteraction()
 {
 }
- 
-// void ElasticContactInteraction::postProcessAttributes(bool)
-// {
-// 
-// }
 
-
-void ElasticContactInteraction::registerAttributes()
-{
-	NormalShearInteraction::registerAttributes();
-	REGISTER_ATTRIBUTE(prevNormal);
-	//REGISTER_ATTRIBUTE(initialKn);
-	//REGISTER_ATTRIBUTE(initialKs);
-	REGISTER_ATTRIBUTE(tangensOfFrictionAngle);
-
-
-//		Real		 kn				// normal elastic constant.
-//				,ks				// shear elastic constant.
-//				,initialKn			// initial normal elastic constant.
-//				,initialKs			// initial shear elastic constant.
-//				,equilibriumDistance		// equilibrium distance
-//				,initialEquilibriumDistance	// initial equilibrium distance
-//				,frictionAngle 			// angle of friction, according to Coulumb criterion
-//				,tangensOfFrictionAngle;
-//	
-//		Vector3r	prevNormal			// unit normal of the contact plane.
-//				,normalForce			// normal force applied on a DE
-//				,shearForce;			// shear force applied on a DE
-}
 YADE_PLUGIN();
 
 //YADE_PLUGIN(&quot;ElasticContactInteraction&quot;);

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,15 +18,7 @@
 
 		ElasticContactInteraction();
 		virtual ~ElasticContactInteraction();
-	protected :
-		virtual void registerAttributes();
-// {
-// 			NormalShearInteraction::registerAttributes();
-// 			REGISTER_ATTRIBUTE(prevNormal);
-// 			REGISTER_ATTRIBUTE(initialKn);
-// 			REGISTER_ATTRIBUTE(initialKs);
-// 			REGISTER_ATTRIBUTE(tangensOfFrictionAngle);
-// 		}
+	REGISTER_ATTRIBUTES(NormalShearInteraction,(prevNormal)/*(initialKn)(initialKs)*/(tangensOfFrictionAngle));
 	REGISTER_CLASS_NAME(ElasticContactInteraction);
 	REGISTER_BASE_CLASS_NAME(NormalShearInteraction);
 	REGISTER_CLASS_INDEX(ElasticContactInteraction,NormalShearInteraction);

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -30,15 +30,4 @@
 }
 
 
-void SDECLinkPhysics::registerAttributes()
-{
-	InteractionPhysics::registerAttributes();
-	REGISTER_ATTRIBUTE(initialKn);
-	REGISTER_ATTRIBUTE(initialKs);
-	REGISTER_ATTRIBUTE(initialEquilibriumDistance);
-	REGISTER_ATTRIBUTE(knMax);
-	REGISTER_ATTRIBUTE(ksMax);
-	REGISTER_ATTRIBUTE(heta);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/SDECLinkPhysics.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -42,7 +42,7 @@
 /// Serialization
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionPhysics,(initialKn)(initialKs)(initialEquilibriumDistance)(knMax)(ksMax)(heta));
 	REGISTER_CLASS_NAME(SDECLinkPhysics);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysics);
 

Modified: trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp
===================================================================
--- trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,11 +19,4 @@
 {
 }
 
-void BodyMacroParameters::registerAttributes()
-{
-	ElasticBodyParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(poisson);
-	REGISTER_ATTRIBUTE(frictionAngle);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.hpp
===================================================================
--- trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,9 +27,7 @@
 /// Serialization
 	REGISTER_CLASS_NAME(BodyMacroParameters);
 	REGISTER_BASE_CLASS_NAME(ElasticBodyParameters);
-
-	public : void registerAttributes();
-
+	REGISTER_ATTRIBUTES(ElasticBodyParameters,(poisson)(frictionAngle));
 /// Indexable
 	REGISTER_CLASS_INDEX(BodyMacroParameters,ElasticBodyParameters);
 };

Modified: trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.cpp
===================================================================
--- trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,11 +19,4 @@
 {
 }
 
-void CohesiveFrictionalBodyParameters::registerAttributes()
-{
-	BodyMacroParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(isCohesive);
-	REGISTER_ATTRIBUTE(isBroken);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.hpp
===================================================================
--- trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/PhysicalParameters/CohesiveFrictionalBodyParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,9 +27,7 @@
 /// Serialization
 	REGISTER_CLASS_NAME(CohesiveFrictionalBodyParameters);
 	REGISTER_BASE_CLASS_NAME(BodyMacroParameters);
-
-	public : void registerAttributes();
-
+	REGISTER_ATTRIBUTES(BodyMacroParameters,(isBroken)(isCohesive));
 /// Indexable
 	REGISTER_CLASS_INDEX(CohesiveFrictionalBodyParameters,BodyMacroParameters);
 };

Modified: trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.cpp
===================================================================
--- trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,15 +17,5 @@
 {
 }
 
-void SimpleViscoelasticBodyParameters::registerAttributes()
-{
-	RigidBodyParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(kn);
-	REGISTER_ATTRIBUTE(ks);
-	REGISTER_ATTRIBUTE(cn);
-	REGISTER_ATTRIBUTE(cs);
-	REGISTER_ATTRIBUTE(frictionAngle);
-}
-
 YADE_PLUGIN();
 

Modified: trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.hpp
===================================================================
--- trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/DataClass/PhysicalParameters/SimpleViscoelasticBodyParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,14 +27,9 @@
 	
 		SimpleViscoelasticBodyParameters();
 		virtual ~SimpleViscoelasticBodyParameters();
-
-	protected :
-		/// Serialization
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(RigidBodyParameters,(kn)(ks)(cn)(cs)(frictionAngle));
 	REGISTER_CLASS_NAME(SimpleViscoelasticBodyParameters);
 	REGISTER_BASE_CLASS_NAME(RigidBodyParameters);
-	
-/// Indexable	
 	REGISTER_CLASS_INDEX(SimpleViscoelasticBodyParameters,RigidBodyParameters);
 };
 

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,15 +27,8 @@
 {
 }
 
-void CapillaryPressureEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(PressureVariation);
-	REGISTER_ATTRIBUTE(Pressure);
 
-}
 
-
 void CapillaryPressureEngine::applyCondition(MetaBody * rootBody)
 {		
 	//cerr &lt;&lt; &quot; CapillaryPressure = &quot; &lt;&lt; capillaryCohesiveLaw-&gt;CapillaryPressure &lt;&lt; endl;

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,9 +28,7 @@
 		CapillaryCohesiveLaw* capillaryCohesiveLaw;
 				
 		void applyCondition(MetaBody * body);
-
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(PressureVariation)(Pressure));
 	REGISTER_CLASS_NAME(CapillaryPressureEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,15 +33,7 @@
 }
 
 
-void CapillaryRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(bigBallId);
-}
 
-
 bool CapillaryRecorder::isActivated(MetaBody* rootBody)
 {
 	return ((rootBody-&gt;currentIteration % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,10 +29,9 @@
 
 		CapillaryRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
-
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)(bigBallId));
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
 	REGISTER_CLASS_NAME(CapillaryRecorder);

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -51,31 +51,7 @@
 }
 
 
-void CapillaryStressRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	
-// 	REGISTER_ATTRIBUTE(wall_bottom_id);
-//  	REGISTER_ATTRIBUTE(wall_top_id);
-//  	REGISTER_ATTRIBUTE(wall_left_id);
-//  	REGISTER_ATTRIBUTE(wall_right_id);
-//  	REGISTER_ATTRIBUTE(wall_front_id);
-//  	REGISTER_ATTRIBUTE(wall_back_id);
- 	
-//  	REGISTER_ATTRIBUTE(height);
-// 	REGISTER_ATTRIBUTE(width);
-// 	REGISTER_ATTRIBUTE(depth);
-// 	REGISTER_ATTRIBUTE(thickness);
-	
-// 	REGISTER_ATTRIBUTE(upperCorner);
-// 	REGISTER_ATTRIBUTE(lowerCorner);
-	
 
-}
-
-
 bool CapillaryStressRecorder::isActivated(MetaBody* rootBody)
 {
 	return ((rootBody-&gt;currentIteration % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -39,11 +39,10 @@
 
 		CapillaryStressRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
-		DECLARE_LOGGER;
-
+	DECLARE_LOGGER;
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)/*(wall_bottom_id)(wall_top_id)(wall_left_id)(wall_right_id)(wall_front_id)(wall_back_id)(height)(width)(depth)(thickness)(upperCorner)(lowerCorner)	*/);
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
 	REGISTER_CLASS_NAME(CapillaryStressRecorder);

Modified: trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -55,29 +55,7 @@
 }
 
 
-void ContactStressRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE ( outputFile );
-	REGISTER_ATTRIBUTE ( interval );
 
-	REGISTER_ATTRIBUTE ( wall_bottom_id );
-	REGISTER_ATTRIBUTE ( wall_top_id );
-	REGISTER_ATTRIBUTE ( wall_left_id );
-	REGISTER_ATTRIBUTE ( wall_right_id );
-	REGISTER_ATTRIBUTE ( wall_front_id );
-	REGISTER_ATTRIBUTE ( wall_back_id );
-
-	REGISTER_ATTRIBUTE ( height );
-	REGISTER_ATTRIBUTE ( width );
-	REGISTER_ATTRIBUTE ( depth );
-	REGISTER_ATTRIBUTE ( thickness );
-	REGISTER_ATTRIBUTE ( upperCorner );
-	REGISTER_ATTRIBUTE ( lowerCorner );
-
-}
-
-
 bool ContactStressRecorder::isActivated(MetaBody*)
 {
 	return ( ( Omega::instance().getCurrentIteration() % interval == 0 ) &amp;&amp; ( ofile ) );

Modified: trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -44,12 +44,12 @@
 
 		ContactStressRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(DataRecorder,( outputFile )( interval )( wall_bottom_id )( wall_top_id )( wall_left_id )( wall_right_id )( wall_front_id )( wall_back_id )( height )( width )( depth )( thickness )( upperCorner )( lowerCorner ));
 	DECLARE_LOGGER;
 	REGISTER_CLASS_NAME(ContactStressRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);

Modified: trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,14 +25,6 @@
 }
 
 
-void FlowEngine::registerAttributes()
-{
-// 	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(isActivated);
-	REGISTER_ATTRIBUTE(dummyParameter);
-}
-
-
 void FlowEngine::applyCondition(MetaBody* ncb)
 {
 

Modified: trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/FlowEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,7 +22,7 @@
 		virtual void applyCondition(MetaBody*);
 	
 	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,/*(gravity)*/(isActivated)(dummyParameter));
 	REGISTER_CLASS_NAME(FlowEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,14 +27,7 @@
 }
 
 
-void HydraulicForceEngine::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(isActivated);
-	REGISTER_ATTRIBUTE(dummyParameter);
-}
 
-
 void HydraulicForceEngine::applyCondition(MetaBody* ncb)
 {
 

Modified: trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/HydraulicForceEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,8 +21,7 @@
 	
 		virtual void applyCondition(MetaBody*);
 	
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,(gravity)(isActivated)(dummyParameter));
 	REGISTER_CLASS_NAME(HydraulicForceEngine);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -49,21 +49,7 @@
 {
 }
 
-void SampleCapillaryPressureEngine::registerAttributes()
-{
-	TriaxialStressController::registerAttributes();
-	REGISTER_ATTRIBUTE(PressureVariation);
-	REGISTER_ATTRIBUTE(Pressure);
- 	REGISTER_ATTRIBUTE(UnbalancedForce);
-	REGISTER_ATTRIBUTE(StabilityCriterion);
-	REGISTER_ATTRIBUTE(SigmaPrecision);
-	REGISTER_ATTRIBUTE(pressureVariationActivated);
-	REGISTER_ATTRIBUTE(fusionDetection);
-	REGISTER_ATTRIBUTE(binaryFusion);
-	REGISTER_ATTRIBUTE(pressureIntervalRec);
 
-}
-
 void SampleCapillaryPressureEngine::updateParameters(MetaBody * ncb)
 {
 	//cerr &lt;&lt; &quot;updateParameters&quot; &lt;&lt; endl;

Modified: trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/SampleCapillaryPressureEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -52,9 +52,7 @@
 		virtual void applyCondition(MetaBody * ncb);
 		void updateParameters(MetaBody * ncb);
 		
-
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(TriaxialStressController,(PressureVariation)(Pressure)(UnbalancedForce)(StabilityCriterion)(SigmaPrecision)(pressureVariationActivated)(fusionDetection)(binaryFusion)(pressureIntervalRec));
 	REGISTER_CLASS_NAME(SampleCapillaryPressureEngine);
 	REGISTER_BASE_CLASS_NAME(TriaxialStressController);
 };

Modified: trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -11,14 +11,6 @@
 #include &lt;yade/pkg-common/Sphere.hpp&gt;
 #include &lt;yade/core/MetaBody.hpp&gt;
 
-void StaticSpheresAttractionEngine::registerAttributes()
-{
-	StaticAttractionEngine::registerAttributes();
-	// REGISTER_ATTRIBUTE(applies_to_what);
-	// REGISTER_ATTRIBUTE(divide_radius);
-	REGISTER_ATTRIBUTE(max_displacement);
-}
-
 Real StaticSpheresAttractionEngine::getMaxDisplacement(MetaBody* ncb)
 {
 	// calculation based on max normal force - FIXME not working satifactionary, currently

Modified: trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/StaticSpheresAttractionEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,8 +19,7 @@
 	protected :
 		virtual Real getMaxDisplacement(MetaBody*);
 		virtual bool doesItApplyToThisBody(Body*);
-	
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(StaticAttractionEngine,/*(applies_to_what)(divide_radius)*/(max_displacement));
 	REGISTER_CLASS_NAME(StaticSpheresAttractionEngine);
 	REGISTER_BASE_CLASS_NAME(StaticAttractionEngine);
 };

Modified: trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -83,46 +83,8 @@
 //}
 
 
-void ThreeDTriaxialEngine::registerAttributes()
-{
-	TriaxialStressController::registerAttributes();
-	REGISTER_ATTRIBUTE(strainRate1);
-	REGISTER_ATTRIBUTE(currentStrainRate1);
-	REGISTER_ATTRIBUTE(strainRate2);
-	REGISTER_ATTRIBUTE(currentStrainRate2);
-	REGISTER_ATTRIBUTE(strainRate3);
-	REGISTER_ATTRIBUTE(currentStrainRate3);
-	//REGISTER_ATTRIBUTE(Phase1);
-	REGISTER_ATTRIBUTE(UnbalancedForce);
-	REGISTER_ATTRIBUTE(StabilityCriterion);
-	//REGISTER_ATTRIBUTE(translationAxis);
-	//REGISTER_ATTRIBUTE(compressionActivated);
-	//REGISTER_ATTRIBUTE(autoCompressionActivation);
-	//REGISTER_ATTRIBUTE(autoStopSimulation);
-	REGISTER_ATTRIBUTE(testEquilibriumInterval);
-	//REGISTER_ATTRIBUTE(currentState);
-	//REGISTER_ATTRIBUTE(previousState);
-	//REGISTER_ATTRIBUTE(sigmaIsoCompaction);
-	//REGISTER_ATTRIBUTE(previousSigmaIso);
-	//REGISTER_ATTRIBUTE(sigmaLateralConfinement);
-	REGISTER_ATTRIBUTE(Key);
-	REGISTER_ATTRIBUTE(frictionAngleDegree);
-	REGISTER_ATTRIBUTE(updateFrictionAngle);
-	//REGISTER_ATTRIBUTE(epsilonMax);
-	REGISTER_ATTRIBUTE(uniaxialEpsilonCurr);
- 	//REGISTER_ATTRIBUTE(isotropicCompaction);
- 	REGISTER_ATTRIBUTE(spheresVolume);
- 	//REGISTER_ATTRIBUTE(fixedPorosity);
-	REGISTER_ATTRIBUTE(stressControl_1);
-	REGISTER_ATTRIBUTE(stressControl_2);
-	REGISTER_ATTRIBUTE(stressControl_3);
-	REGISTER_ATTRIBUTE(sigma1);
-	REGISTER_ATTRIBUTE(sigma2);
-	REGISTER_ATTRIBUTE(sigma3);
-}
 
 
-
 void ThreeDTriaxialEngine::applyCondition ( MetaBody * ncb )
 {
 

Modified: trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -86,10 +86,7 @@
 		DECLARE_LOGGER;
 		
 
-	protected :
-		//virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
-		
+	REGISTER_ATTRIBUTES(TriaxialStressController,(strainRate1)(currentStrainRate1)(strainRate2)(currentStrainRate2)(strainRate3)(currentStrainRate3)/*(Phase1)*/(UnbalancedForce)(StabilityCriterion)/*(translationAxis)(compressionActivated)(autoCompressionActivation)(autoStopSimulation)*/(testEquilibriumInterval)/*(currentState)(previousState)(sigmaIsoCompaction)(previousSigmaIso)(sigmaLateralConfinement)*/(Key)(frictionAngleDegree)(updateFrictionAngle)	/*(epsilonMax)*/ (uniaxialEpsilonCurr)/*(isotropicCompaction)*/(spheresVolume)/*(fixedPorosity)*/(stressControl_1)(stressControl_2)(stressControl_3)(sigma1)(sigma2)(sigma3));
 	REGISTER_CLASS_NAME(ThreeDTriaxialEngine);
 	REGISTER_BASE_CLASS_NAME(TriaxialStressController);
 };

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -71,34 +71,6 @@
 }
 
 
-void TriaxialCompressionEngine::registerAttributes()
-{
-	TriaxialStressController::registerAttributes();
-	REGISTER_ATTRIBUTE(strainRate);
-	REGISTER_ATTRIBUTE(currentStrainRate);
-	//REGISTER_ATTRIBUTE(Phase1);
-	REGISTER_ATTRIBUTE(UnbalancedForce);
-	REGISTER_ATTRIBUTE(StabilityCriterion);
-	REGISTER_ATTRIBUTE(translationAxis);
-	//REGISTER_ATTRIBUTE(compressionActivated);
-	REGISTER_ATTRIBUTE(autoCompressionActivation);
-	REGISTER_ATTRIBUTE(autoStopSimulation);
-	REGISTER_ATTRIBUTE(testEquilibriumInterval);
-	REGISTER_ATTRIBUTE(currentState);
-	REGISTER_ATTRIBUTE(previousState);
-	REGISTER_ATTRIBUTE(sigmaIsoCompaction);
-	REGISTER_ATTRIBUTE(previousSigmaIso);
-	REGISTER_ATTRIBUTE(sigmaLateralConfinement);
-	REGISTER_ATTRIBUTE(Key);
-	REGISTER_ATTRIBUTE(noFiles);
-	REGISTER_ATTRIBUTE(frictionAngleDegree);
-	REGISTER_ATTRIBUTE(epsilonMax);
-	REGISTER_ATTRIBUTE(uniaxialEpsilonCurr);
- 	REGISTER_ATTRIBUTE(isotropicCompaction);
- 	REGISTER_ATTRIBUTE(spheresVolume);
- 	REGISTER_ATTRIBUTE(fixedPorosity);
-}
-
 void TriaxialCompressionEngine::doStateTransition(MetaBody * body, stateNum nextState){
 
 	if ( /* currentState==STATE_UNINITIALIZED &amp;&amp; */ nextState==STATE_ISO_COMPACTION){

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -121,16 +121,13 @@
 		///Change physical properties of interactions and/or bodies in the middle of a simulation (change only friction for the moment, complete this function to set cohesion and others before compression test)
 		void setContactProperties(MetaBody * body, Real frictionAngle);
 
-
-		DECLARE_LOGGER;
-		
-
 	protected :
 		virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
-		
+	REGISTER_ATTRIBUTES(TriaxialStressController,(strainRate)(currentStrainRate)/*(Phase1)*/(UnbalancedForce)(StabilityCriterion)(translationAxis)/*(compressionActivated)*/(autoCompressionActivation)(autoStopSimulation)(testEquilibriumInterval)(currentState)(previousState)(sigmaIsoCompaction)(previousSigmaIso)(sigmaLateralConfinement)(Key)(noFiles)(frictionAngleDegree)(epsilonMax)(uniaxialEpsilonCurr)(isotropicCompaction)(spheresVolume)(fixedPorosity));
+
 	REGISTER_CLASS_NAME(TriaxialCompressionEngine);
 	REGISTER_BASE_CLASS_NAME(TriaxialStressController);
+	DECLARE_LOGGER;
 };
 
 REGISTER_SERIALIZABLE(TriaxialCompressionEngine);

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -55,15 +55,7 @@
 }
 
 
-void TriaxialStateRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(porosity);
-}
 
-
 bool TriaxialStateRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -47,10 +47,10 @@
 
 		TriaxialStateRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
-		DECLARE_LOGGER;
+	DECLARE_LOGGER;
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)(porosity));
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -92,61 +92,7 @@
 {	
 }
 
-void TriaxialStressController::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(stiffnessUpdateInterval);
-	REGISTER_ATTRIBUTE(radiusControlInterval);
-	REGISTER_ATTRIBUTE(computeStressStrainInterval);
-	REGISTER_ATTRIBUTE(wallDamping);
-//	REGISTER_ATTRIBUTE(force);
-	
-	//REGISTER_ATTRIBUTE(UnbalancedForce);
-	
-	REGISTER_ATTRIBUTE(stiffness);
- 	REGISTER_ATTRIBUTE(wall_bottom_id);
- 	REGISTER_ATTRIBUTE(wall_top_id);
- 	REGISTER_ATTRIBUTE(wall_left_id);
- 	REGISTER_ATTRIBUTE(wall_right_id);
- 	REGISTER_ATTRIBUTE(wall_front_id);
- 	REGISTER_ATTRIBUTE(wall_back_id);
-//	REGISTER_ATTRIBUTE(wall_id);
-	
-	REGISTER_ATTRIBUTE(wall_bottom_activated);
-	REGISTER_ATTRIBUTE(wall_top_activated);
-	REGISTER_ATTRIBUTE(wall_left_activated);
-	REGISTER_ATTRIBUTE(wall_right_activated);
-	REGISTER_ATTRIBUTE(wall_front_activated);
-	REGISTER_ATTRIBUTE(wall_back_activated);
-	
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(depth);
-	REGISTER_ATTRIBUTE(height0);
-	REGISTER_ATTRIBUTE(width0);
-	REGISTER_ATTRIBUTE(depth0);
-	
-	REGISTER_ATTRIBUTE(sigma_iso);
-	REGISTER_ATTRIBUTE(sigma1);
-	REGISTER_ATTRIBUTE(sigma2);
-	REGISTER_ATTRIBUTE(sigma3);
-	REGISTER_ATTRIBUTE(isTriaxialCompression);
-	REGISTER_ATTRIBUTE(maxMultiplier);
-	REGISTER_ATTRIBUTE(finalMaxMultiplier);
-	REGISTER_ATTRIBUTE(max_vel);
-	REGISTER_ATTRIBUTE(max_vel1);
-	REGISTER_ATTRIBUTE(max_vel2);
-	REGISTER_ATTRIBUTE(max_vel3);
-	REGISTER_ATTRIBUTE(previousStress);
-	REGISTER_ATTRIBUTE(previousMultiplier);
-	REGISTER_ATTRIBUTE(internalCompaction);
 
-	// needed for access from python
-	REGISTER_ATTRIBUTE(meanStress);
-	REGISTER_ATTRIBUTE(volumetricStrain);
-}
-
 void TriaxialStressController::updateStiffness (MetaBody * ncb)
 {
 	for (int i=0; i&lt;6; ++i) stiffness[i] = 0;

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -106,9 +106,56 @@
 
 		DECLARE_LOGGER;
 		
-	
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DeusExMachina,
+		(stiffnessUpdateInterval)
+		(radiusControlInterval)
+		(computeStressStrainInterval)
+		(wallDamping)
+		//	(force)
+		
+		//(UnbalancedForce)
+		(stiffness)
+		(wall_bottom_id)
+		(wall_top_id)
+		(wall_left_id)
+		(wall_right_id)
+		(wall_front_id)
+		(wall_back_id)
+		//	(wall_id)
+		(wall_bottom_activated)
+		(wall_top_activated)
+		(wall_left_activated)
+		(wall_right_activated)
+		(wall_front_activated)
+		(wall_back_activated)
+		
+		(thickness)
+		(height)
+		(width)
+		(depth)
+		(height0)
+		(width0)
+		(depth0)
+		
+		(sigma_iso)
+		(sigma1)
+		(sigma2)
+		(sigma3)
+		(isTriaxialCompression)
+		(maxMultiplier)
+		(finalMaxMultiplier)
+		(max_vel)
+		(max_vel1)
+		(max_vel2)
+		(max_vel3)
+		(previousStress)
+		(previousMultiplier)
+		(internalCompaction)
+
+		// needed for access from python
+		(meanStress)
+		(volumetricStrain)
+	);
 	REGISTER_CLASS_NAME(TriaxialStressController);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 };

Modified: trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -42,27 +42,7 @@
 }
 
 
-void WallStressRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	
-	REGISTER_ATTRIBUTE(wall_bottom_id);
- 	REGISTER_ATTRIBUTE(wall_top_id);
- 	REGISTER_ATTRIBUTE(wall_left_id);
- 	REGISTER_ATTRIBUTE(wall_right_id);
- 	REGISTER_ATTRIBUTE(wall_front_id);
- 	REGISTER_ATTRIBUTE(wall_back_id);
- 	
- 	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(depth);
-	REGISTER_ATTRIBUTE(thickness);
 
-}
-
-
 bool WallStressRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,12 +33,27 @@
 
 		WallStressRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
-
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(DataRecorder,
+		(outputFile)
+		(interval)
+		
+		(wall_bottom_id)
+		(wall_top_id)
+		(wall_left_id)
+		(wall_right_id)
+		(wall_front_id)
+		(wall_back_id)
+		
+		(height)
+		(width)
+		(depth)
+		(thickness)
+	);
+
 	REGISTER_CLASS_NAME(WallStressRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,9 +20,6 @@
 }
 
 
-void BasicViscoelasticRelationships::registerAttributes()
-{
-}
 
 
 void BasicViscoelasticRelationships::go(  const shared_ptr&lt;PhysicalParameters&gt;&amp; b1 // SimpleViscoelasticBodyParameters

Modified: trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,13 +22,10 @@
 					const shared_ptr&lt;PhysicalParameters&gt;&amp; b2,
 					const shared_ptr&lt;Interaction&gt;&amp; interaction);
 
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(InteractionPhysicsEngineUnit,/* */);
 	FUNCTOR2D(SimpleViscoelasticBodyParameters,SimpleViscoelasticBodyParameters);
 	REGISTER_CLASS_NAME(BasicViscoelasticRelationships);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);
-
 };
 
 REGISTER_SERIALIZABLE(BasicViscoelasticRelationships);

Modified: trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,18 +27,11 @@
 }
 
 
-void CL1Relationships::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(betaR);
-	REGISTER_ATTRIBUTE(setCohesionNow);
-	REGISTER_ATTRIBUTE(setCohesionOnNewContacts);	
-}
 
-
 //
 //
 //
-/// Big WHAT THE FUCK? this code below is duplicated THREE times due to some weird IFs !
+/// Big WHAT THE ....? this code below is duplicated THREE times due to some weird IFs !
 /// need to FIXME that.
 /// but from all my testing it works currently. / janek
 //

Modified: trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -34,13 +34,10 @@
 		int cohesionDefinitionIteration;
 		long iter;//REMOVE THIS
 
-	protected :
-		virtual void registerAttributes();
-
 	FUNCTOR2D(CohesiveFrictionalBodyParameters,CohesiveFrictionalBodyParameters);
 	REGISTER_CLASS_NAME(CL1Relationships);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);
-
+	REGISTER_ATTRIBUTES(InteractionPhysicsEngineUnit,(betaR)(setCohesionNow)(setCohesionOnNewContacts));
 };
 
 REGISTER_SERIALIZABLE(CL1Relationships);

Modified: trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,15 +28,7 @@
 }
 
 
-void CohesiveFrictionalRelationships::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(normalCohesion);
-	REGISTER_ATTRIBUTE(shearCohesion);
-	REGISTER_ATTRIBUTE(setCohesionNow);
-	REGISTER_ATTRIBUTE(setCohesionOnNewContacts);	
-}
 
-
 //
 //
 //

Modified: trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,13 +28,10 @@
 		int cohesionDefinitionIteration;
 		long iter;//REMOVE THIS
 
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(InteractionPhysicsEngineUnit,(normalCohesion)(shearCohesion)(setCohesionNow)(setCohesionOnNewContacts));
 	FUNCTOR2D(CohesiveFrictionalBodyParameters,CohesiveFrictionalBodyParameters);
 	REGISTER_CLASS_NAME(CohesiveFrictionalRelationships);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);
-
 };
 
 REGISTER_SERIALIZABLE(CohesiveFrictionalRelationships);

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,12 +20,6 @@
 	shrinkFactor=0;
 }
 
-void InteractingFacet2InteractingSphere4SpheresContactGeometry::registerAttributes()
-{	
-    InteractionGeometryEngineUnit::registerAttributes();
-    REGISTER_ATTRIBUTE(shrinkFactor);
-}
-
 bool InteractingFacet2InteractingSphere4SpheresContactGeometry::go(const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
 							const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
 							const Se3r&amp; se31,

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,6 +29,7 @@
 					
 	REGISTER_CLASS_NAME(InteractingFacet2InteractingSphere4SpheresContactGeometry);
 	REGISTER_BASE_CLASS_NAME(InteractionGeometryEngineUnit);
+	REGISTER_ATTRIBUTES(InteractionGeometryEngineUnit,(shrinkFactor));
 
 	DECLARE_LOGGER;
 
@@ -43,10 +44,6 @@
 	// tile, with a gap between the separate tiles equal to the sphere's radius
 	// multiplied by 2*shrinkFactor. By default shrinkFactor=0.
 	Real shrinkFactor; 
-
-	protected :
-		virtual void registerAttributes();
-		
 };
 
 REGISTER_SERIALIZABLE(InteractingFacet2InteractingSphere4SpheresContactGeometry);

Modified: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -26,14 +26,7 @@
 }
 
 
-void MacroMicroElasticRelationships::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(alpha);
-	REGISTER_ATTRIBUTE(beta);
-	REGISTER_ATTRIBUTE(gamma);
-}
 
-
 void MacroMicroElasticRelationships::go(	  const shared_ptr&lt;PhysicalParameters&gt;&amp; b1 // BodyMacroParameters
 					, const shared_ptr&lt;PhysicalParameters&gt;&amp; b2 // BodyMacroParameters
 					, const shared_ptr&lt;Interaction&gt;&amp; interaction)

Modified: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,13 +23,10 @@
 					const shared_ptr&lt;PhysicalParameters&gt;&amp; b2,
 					const shared_ptr&lt;Interaction&gt;&amp; interaction);
 
-	protected :
-		virtual void registerAttributes();
-
 	FUNCTOR2D(BodyMacroParameters,BodyMacroParameters);
 	REGISTER_CLASS_NAME(MacroMicroElasticRelationships);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);
-
+	REGISTER_ATTRIBUTES(InteractionPhysicsEngineUnit,(alpha)(beta)(gamma));
 };
 
 REGISTER_SERIALIZABLE(MacroMicroElasticRelationships);

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,14 +22,8 @@
 }
 
 
-void SimpleElasticRelationshipsWater::registerAttributes()
-{
-	
-}
 
 
-
-
 void SimpleElasticRelationshipsWater::go( const shared_ptr&lt;PhysicalParameters&gt;&amp; b1 //BodyMacroParameters
 					, const shared_ptr&lt;PhysicalParameters&gt;&amp; b2 // BodyMacroParameters
 					, const shared_ptr&lt;Interaction&gt;&amp; interaction)

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,9 +19,7 @@
 					const shared_ptr&lt;PhysicalParameters&gt;&amp; b2,
 					const shared_ptr&lt;Interaction&gt;&amp; interaction);
 
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(InteractionPhysicsEngineUnit,/* */);
 	FUNCTOR2D(BodyMacroParameters,BodyMacroParameters);
 	REGISTER_CLASS_NAME(SimpleElasticRelationshipsWater);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -19,11 +19,7 @@
 }
 
 
-void SimpleViscoelasticRelationships::registerAttributes()
-{
-}
 
-
 void SimpleViscoelasticRelationships::go(	  const shared_ptr&lt;PhysicalParameters&gt;&amp; b1 // SimpleViscoelasticBodyParameters
 					, const shared_ptr&lt;PhysicalParameters&gt;&amp; b2 // SimpleViscoelasticBodyParameters
 					, const shared_ptr&lt;Interaction&gt;&amp; interaction)

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,9 +22,7 @@
 					const shared_ptr&lt;PhysicalParameters&gt;&amp; b2,
 					const shared_ptr&lt;Interaction&gt;&amp; interaction);
 
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(InteractionPhysicsEngineUnit,/* */)
 	FUNCTOR2D(SimpleViscoelasticBodyParameters,SimpleViscoelasticBodyParameters);
 	REGISTER_CLASS_NAME(SimpleViscoelasticRelationships);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);
@@ -33,4 +31,3 @@
 
 REGISTER_SERIALIZABLE(SimpleViscoelasticRelationships);
 
-

Modified: trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -35,14 +35,7 @@
 }
 
 
-void AveragePositionRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-}
 
-
 bool AveragePositionRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/AveragePositionRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,8 +21,6 @@
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
 	
-		virtual void registerAttributes();
-
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
 
@@ -32,7 +30,7 @@
 		unsigned int interval;
 	private : 
 		std::ofstream ofile;
-	
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval));
 	REGISTER_CLASS_NAME(AveragePositionRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -61,16 +61,7 @@
   capillary-&gt;fill(&quot;M(r=10)&quot;);
 }
 
-void CapillaryCohesiveLaw::registerAttributes()
-{
-        InteractionSolver::registerAttributes();
-        REGISTER_ATTRIBUTE(sdecGroupMask);
-        REGISTER_ATTRIBUTE(CapillaryPressure);
-        REGISTER_ATTRIBUTE(fusionDetection);
-        REGISTER_ATTRIBUTE(binaryFusion);
 
-}
-
 MeniscusParameters::MeniscusParameters()
 {
         V = 0;
@@ -702,10 +693,11 @@
 			//cerr &lt;&lt; &quot;size = &quot;&lt;&lt;interactionsOnBody[i].size() &lt;&lt; &quot; empty=&quot;&lt;&lt;interactionsOnBody[i].empty() &lt;&lt;endl;
 			for ( firstMeniscus=interactionsOnBody[i].begin(); firstMeniscus!=lastMeniscus; ++firstMeniscus )
 			{
-				if ( *firstMeniscus )
+				if ( *firstMeniscus ){
 					if ( firstMeniscus-&gt;get() )
 						cerr &lt;&lt; &quot;(&quot; &lt;&lt; ( *firstMeniscus )-&gt;getId1() &lt;&lt; &quot;, &quot; &lt;&lt; ( *firstMeniscus )-&gt;getId2() &lt;&lt;&quot;) &quot;;
 					else cerr &lt;&lt; &quot;(void)&quot;;
+				}
 			}
 			cerr &lt;&lt; endl;
 		}

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -81,9 +81,7 @@
 						
 		CapillaryCohesiveLaw();
 		void action(MetaBody * ncb);
-
-	protected : 
-		void registerAttributes();
+		REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(CapillaryPressure)(fusionDetection)(binaryFusion));
 		virtual void postProcessAttributes(bool deserializing);
 	REGISTER_CLASS_NAME(CapillaryCohesiveLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,20 +33,6 @@
 }
 
 
-void CohesiveFrictionalContactLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-	REGISTER_ATTRIBUTE(erosionActivated);
-	REGISTER_ATTRIBUTE(detectBrokenBodies);
-	REGISTER_ATTRIBUTE(always_use_moment_law);
-	
-	REGISTER_ATTRIBUTE(shear_creep);
-	REGISTER_ATTRIBUTE(twist_creep);
-	REGISTER_ATTRIBUTE(creep_viscosity);
-}
-
 void out(Quaternionr q)
 {
 	Vector3r axis;

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,8 +27,7 @@
 		CohesiveFrictionalContactLaw();
 		void action(MetaBody*);
 
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(momentRotationLaw)(erosionActivated)(detectBrokenBodies)(always_use_moment_law)(shear_creep)(twist_creep)(creep_viscosity));
 	REGISTER_CLASS_NAME(CohesiveFrictionalContactLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,16 +28,7 @@
 }
 
 
-void ContactLaw1::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-	REGISTER_ATTRIBUTE(coeff_dech);
-	REGISTER_ATTRIBUTE(momentAlwaysElastic);
-}
 
-
 void ContactLaw1::action(MetaBody* ncb)
 {
     shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,9 +37,7 @@
 	
 		ContactLaw1();
 		void action(MetaBody*);
-
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(momentRotationLaw)(coeff_dech)(momentAlwaysElastic));
 	REGISTER_CLASS_NAME(ContactLaw1);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,14 +29,6 @@
 }
 
 
-void ElasticCohesiveLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-}
-
-
 void ElasticCohesiveLaw::action(MetaBody* ncb)
 {
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -26,8 +26,8 @@
 		ElasticCohesiveLaw();
 		void action(MetaBody*);
 
-	protected : 
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(momentRotationLaw));
+
 	REGISTER_CLASS_NAME(ElasticCohesiveLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -30,15 +30,6 @@
 }
 
 
-void ElasticContactLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-	#ifdef SCG_SHEAR
-		REGISTER_ATTRIBUTE(useShear);
-	#endif
-}
 
 
 void ElasticContactLaw::action(MetaBody* rootBody)

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -73,9 +73,11 @@
 
 		shared_ptr&lt;ef2_Spheres_Elastic_ElasticLaw&gt; functor;
 
-	protected :
-		void registerAttributes();
-
+	REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(momentRotationLaw)
+		#ifdef SCG_SHEAR
+			(useShear)
+		#endif
+	);
 	REGISTER_CLASS_NAME(ElasticContactLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,13 +28,7 @@
 }
 
 
-void ElasticCriterionTimeStepper::registerAttributes()
-{
-	TimeStepper::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-}
 
-
 void ElasticCriterionTimeStepper::findTimeStepFromBody(const shared_ptr&lt;Body&gt;&amp; body)
 {
 	BodyMacroParameters * sdec	= dynamic_cast&lt;BodyMacroParameters*&gt;(body-&gt;physicalParameters.get());

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticCriterionTimeStepper.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,10 +31,7 @@
 		virtual ~ElasticCriterionTimeStepper();
 	
 		virtual void computeTimeStep(MetaBody* body);
-
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(TimeStepper,(sdecGroupMask));
 	REGISTER_CLASS_NAME(ElasticCriterionTimeStepper);
 	REGISTER_BASE_CLASS_NAME(TimeStepper);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -49,16 +49,7 @@
 	ofile.open(outputFile.c_str());
 }
 
-void ForceRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(startId);
-	REGISTER_ATTRIBUTE(endId);
-}
 
-
 bool ForceRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ForceRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -30,13 +30,13 @@
 
 		ForceRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
 		void init();
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)(startId)(endId));
 	DECLARE_LOGGER;
 	REGISTER_CLASS_NAME(ForceRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -40,13 +40,6 @@
 }
 
 
-void ForceSnapshot::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(list_id);
-	REGISTER_ATTRIBUTE(i);
-}
 
 bool ForceSnapshot::isActivated(MetaBody*)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,7 +37,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(list_id)(i));
 	REGISTER_CLASS_NAME(ForceSnapshot);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -35,17 +35,7 @@
 }
 
 
-void GlobalStiffnessTimeStepper::registerAttributes()
-{
-	TimeStepper::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(defaultDt);
-	REGISTER_ATTRIBUTE(previousDt);
-	REGISTER_ATTRIBUTE(timestepSafetyCoefficient);
-	REGISTER_ATTRIBUTE(computedOnce);
-}
 
-
 void GlobalStiffnessTimeStepper::findTimeStepFromBody(const shared_ptr&lt;Body&gt;&amp; body, MetaBody * ncb)
 {
 	RigidBodyParameters * sdec	= static_cast&lt;RigidBodyParameters*&gt;(body-&gt;physicalParameters.get());

Modified: trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -51,10 +51,7 @@
 		virtual bool isActivated(MetaBody*);
 		DECLARE_LOGGER;
 
-
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(TimeStepper,(sdecGroupMask)(defaultDt)(previousDt)(timestepSafetyCoefficient)(computedOnce));
 	REGISTER_CLASS_NAME(GlobalStiffnessTimeStepper);
 	REGISTER_BASE_CLASS_NAME(TimeStepper);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -41,13 +41,6 @@
 }
 
 
-void HistoryRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputBase);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(stateId);
-}
 
 bool HistoryRecorder::isActivated(MetaBody*)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/HistoryRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,9 +28,9 @@
 protected :
 
 	virtual void postProcessAttributes(bool deserializing);
-	virtual void registerAttributes();
 	REGISTER_CLASS_NAME(HistoryRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
+	REGISTER_ATTRIBUTES(DataRecorder,(outputBase)(interval)(stateId));
 };
 
 REGISTER_SERIALIZABLE(HistoryRecorder);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,14 +37,6 @@
 }
 
 
-void MGPRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputBase);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(stateId);
-}
-
 bool MGPRecorder::isActivated(MetaBody*)
 {
    return ((Omega::instance().getCurrentIteration() % interval == 0));

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MGPRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -34,7 +34,7 @@
 
 protected :
     virtual void postProcessAttributes(bool deserializing);
-    void registerAttributes();
+	 REGISTER_ATTRIBUTES(DataRecorder,(outputBase)(interval)(stateId));
     REGISTER_CLASS_NAME(MGPRecorder);
     REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,11 +37,6 @@
 }
 
 
-void MicroMacroAnalyser::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(outputFile);
-}
 
 void MicroMacroAnalyser::postProcessAttributes(bool deserializing)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -44,7 +44,7 @@
 	
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(StandAloneEngine,(interval)(outputFile));
 	REGISTER_CLASS_NAME(MicroMacroAnalyser);
 	REGISTER_BASE_CLASS_NAME(StandAloneEngine);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,11 +18,6 @@
 }
 
 
-void MyTetrahedronLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	// ...
-}
 
 
 void MyTetrahedronLaw::action(MetaBody* ncb)

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,10 +31,9 @@
 		MyTetrahedronLaw();
 		void action(MetaBody*);
 
-	protected :
-		void registerAttributes();
 	REGISTER_CLASS_NAME(MyTetrahedronLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
+	REGISTER_ATTRIBUTES(InteractionSolver,/* */);
 };
 
 REGISTER_SERIALIZABLE(MyTetrahedronLaw);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -26,12 +26,6 @@
 }
 PositionOrientationRecorder::~PositionOrientationRecorder (){}
 void PositionOrientationRecorder::postProcessAttributes(bool deserializing){if(deserializing) {}}
-void PositionOrientationRecorder::registerAttributes(){
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(saveRgb);
-}
 
 void PositionOrientationRecorder::action(MetaBody * ncb){
 	if( Omega::instance().getCurrentIteration() % interval == 0 ){

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -32,7 +32,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)(saveRgb));
 	DECLARE_LOGGER;
 	REGISTER_CLASS_NAME(PositionOrientationRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,14 +37,6 @@
 }
 
 
-void PositionRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(startId);
-	REGISTER_ATTRIBUTE(endId);
-}
 
 bool PositionRecorder::isActivated(MetaBody*)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,7 +29,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)(startId)(endId));
 	REGISTER_CLASS_NAME(PositionRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -36,13 +36,6 @@
 }
 
 
-void PositionSnapshot::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(list_id);
-	REGISTER_ATTRIBUTE(i);
-}
 
 bool PositionSnapshot::isActivated(MetaBody*)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionSnapshot.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -35,7 +35,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(list_id)(i));
 	REGISTER_CLASS_NAME(PositionSnapshot);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -32,12 +32,6 @@
 }
 
 
-void RigidBodyRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputBase);
-	REGISTER_ATTRIBUTE(interval);
-}
 
 bool RigidBodyRecorder::isActivated(MetaBody*)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/RigidBodyRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,7 +31,7 @@
 
 protected :
     virtual void postProcessAttributes(bool deserializing);
-    void registerAttributes();
+	 REGISTER_ATTRIBUTES(DataRecorder,(outputBase)(interval));
     REGISTER_CLASS_NAME(RigidBodyRecorder);
     REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -32,12 +32,6 @@
 }
 
 
-void SimpleViscoelasticSpheresInteractionRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputBase);
-	REGISTER_ATTRIBUTE(interval);
-}
 
 bool SimpleViscoelasticSpheresInteractionRecorder::isActivated(MetaBody*)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -35,7 +35,7 @@
 
 protected :
     virtual void postProcessAttributes(bool deserializing);
-    void registerAttributes();
+	 REGISTER_ATTRIBUTES(DataRecorder,(outputBase)(interval));
     REGISTER_CLASS_NAME(SimpleViscoelasticSpheresInteractionRecorder);
     REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,14 +31,7 @@
 }
 
 
-void VelocityRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-}
 
-
 bool VelocityRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/VelocityRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,12 +23,12 @@
 		std::string outputFile;
 		unsigned int interval;
 		VelocityRecorder ();
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
 	
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval));
 	REGISTER_CLASS_NAME(VelocityRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -27,16 +27,7 @@
 }
 
 
-void ViscousForceDamping::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-	REGISTER_ATTRIBUTE(betaNormal);
-	REGISTER_ATTRIBUTE(betaShear);
-}
 
-
 //FIXME : remove bool first !!!!!
 void ViscousForceDamping::action(Body* body)
 {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -30,8 +30,7 @@
 		ViscousForceDamping();
 		void action(Body* body);
 
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(momentRotationLaw)(betaNormal)(betaShear));
 	REGISTER_CLASS_NAME(ViscousForceDamping);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };

Modified: trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,16 +33,8 @@
 }
 
 
-void VolumicContactLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-// 	REGISTER_ATTRIBUTE(compacite_init);
-}
 
 
-
 // void VolumicContactLaw::speedTest(MetaBody* ncb)
 // {
 // //BEGIN SPEED TEST

Modified: trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,9 +33,7 @@
 		VolumicContactLaw();
 		void action(MetaBody*);
 		void speedTest(MetaBody* ncb);
-
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(momentRotationLaw)/*(compacite_init)*/);
 	REGISTER_CLASS_NAME(VolumicContactLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };

Modified: trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -163,83 +163,8 @@
 }
 
 
-void CohesiveTriaxialTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(lowerCorner);
-	REGISTER_ATTRIBUTE(upperCorner);
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(importFilename);
-	//REGISTER_ATTRIBUTE(nlayers);
-	//REGISTER_ATTRIBUTE(boxWalls);
-	REGISTER_ATTRIBUTE(internalCompaction);
-	REGISTER_ATTRIBUTE(maxMultiplier);
-	REGISTER_ATTRIBUTE(finalMaxMultiplier);
 
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(normalCohesion);
-	REGISTER_ATTRIBUTE(shearCohesion);
-	REGISTER_ATTRIBUTE(setCohesionOnNewContacts);
 
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(boxFrictionDeg);
-
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(defaultDt);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-	REGISTER_ATTRIBUTE(timeStepOutputInterval);
-	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
-	REGISTER_ATTRIBUTE(radiusControlInterval);
-	REGISTER_ATTRIBUTE(numberOfGrains);
-	REGISTER_ATTRIBUTE(radiusDeviation);
-	REGISTER_ATTRIBUTE(strainRate);
-	REGISTER_ATTRIBUTE(StabilityCriterion);
-	REGISTER_ATTRIBUTE(autoCompressionActivation);
-//	REGISTER_ATTRIBUTE(wall_top);
-//	REGISTER_ATTRIBUTE(wall_bottom);
-//	REGISTER_ATTRIBUTE(wall_1);
-//	REGISTER_ATTRIBUTE(wall_2);
-//	REGISTER_ATTRIBUTE(wall_3);
-//	REGISTER_ATTRIBUTE(wall_4);
-//	REGISTER_ATTRIBUTE(wall_top_wire);
-//	REGISTER_ATTRIBUTE(wall_bottom_wire);
-//	REGISTER_ATTRIBUTE(wall_1_wire);
-//	REGISTER_ATTRIBUTE(wall_2_wire);
-//	REGISTER_ATTRIBUTE(wall_3_wire);
-//	REGISTER_ATTRIBUTE(wall_4_wire);
-//	REGISTER_ATTRIBUTE(spheresColor);
-//	REGISTER_ATTRIBUTE(spheresRandomColor);
-	REGISTER_ATTRIBUTE(recordBottomForce);
-	REGISTER_ATTRIBUTE(forceRecordFile);
-//	REGISTER_ATTRIBUTE(recordAveragePositions);
-	REGISTER_ATTRIBUTE(positionRecordFile);
-	REGISTER_ATTRIBUTE(velocityRecordFile);
-	REGISTER_ATTRIBUTE(recordIntervalIter);
-	REGISTER_ATTRIBUTE(saveAnimationSnapshots);
-	REGISTER_ATTRIBUTE(AnimationSnapshotsBaseName);
-	REGISTER_ATTRIBUTE(WallStressRecordFile);
-
-//	REGISTER_ATTRIBUTE(gravity);
-	
-	//REGISTER_ATTRIBUTE(bigBall);
-	//REGISTER_ATTRIBUTE(bigBallRadius);
-	//REGISTER_ATTRIBUTE(bigBallDensity);
-	//REGISTER_ATTRIBUTE(bigBallDropTimeSeconds);
-	//REGISTER_ATTRIBUTE(bigBallFrictDeg);
-	//REGISTER_ATTRIBUTE(bigBallYoungModulus);
-	//REGISTER_ATTRIBUTE(bigBallPoissonRatio);
-	//REGISTER_ATTRIBUTE(bigBallDropHeight);
-	REGISTER_ATTRIBUTE(sigma_iso);
-
-}
-
-
 bool CohesiveTriaxialTest::generate()
 {
 //	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2

Modified: trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -125,9 +125,78 @@
 		CohesiveTriaxialTest ();
 		~CohesiveTriaxialTest ();
 		bool generate();
-	
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(lowerCorner)
+		(upperCorner)
+		(thickness)
+		(importFilename)
+		//(nlayers)
+		//(boxWalls)
+		(internalCompaction)
+		(maxMultiplier)
+		(finalMaxMultiplier)
+
+		(sphereYoungModulus)
+		(spherePoissonRatio)
+		(sphereFrictionDeg)
+		(normalCohesion)
+		(shearCohesion)
+		(setCohesionOnNewContacts)
+
+		(boxYoungModulus)
+		(boxPoissonRatio)
+		(boxFrictionDeg)
+
+		(density)
+		(defaultDt)
+		(dampingForce)
+		(dampingMomentum)
+		(rotationBlocked)
+		(timeStepUpdateInterval)
+		(timeStepOutputInterval)
+		(wallStiffnessUpdateInterval)
+		(radiusControlInterval)
+		(numberOfGrains)
+		(radiusDeviation)
+		(strainRate)
+		(StabilityCriterion)
+		(autoCompressionActivation)
+		//	(wall_top)
+		//	(wall_bottom)
+		//	(wall_1)
+		//	(wall_2)
+		//	(wall_3)
+		//	(wall_4)
+		//	(wall_top_wire)
+		//	(wall_bottom_wire)
+		//	(wall_1_wire)
+		//	(wall_2_wire)
+		//	(wall_3_wire)
+		//	(wall_4_wire)
+		//	(spheresColor)
+		//	(spheresRandomColor)
+		(recordBottomForce)
+		(forceRecordFile)
+		//	(recordAveragePositions)
+		(positionRecordFile)
+		(velocityRecordFile)
+		(recordIntervalIter)
+		(saveAnimationSnapshots)
+		(AnimationSnapshotsBaseName)
+		(WallStressRecordFile)
+
+		//	(gravity)
+		
+		//(bigBall)
+		//(bigBallRadius)
+		//(bigBallDensity)
+		//(bigBallDropTimeSeconds)
+		//(bigBallFrictDeg)
+		//(bigBallYoungModulus)
+		//(bigBallPoissonRatio)
+		//(bigBallDropHeight)
+		(sigma_iso)
+	);
 	REGISTER_CLASS_NAME(CohesiveTriaxialTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/DirectShearCis.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/DirectShearCis.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/DirectShearCis.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -109,32 +109,6 @@
 }
 
 
-void DirectShearCis::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(filename);
-	REGISTER_ATTRIBUTE(gravity);
-// 	REGISTER_ATTRIBUTE(nBilles);
-// 	REGISTER_ATTRIBUTE(porosite);
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(profondeur);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(shearSpeed);
-	REGISTER_ATTRIBUTE(gravApplied);
-	REGISTER_ATTRIBUTE(shearApplied);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum );
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval );
-}
-
-
 bool DirectShearCis::generate()
 {
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/dem/PreProcessor/DirectShearCis.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/DirectShearCis.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/DirectShearCis.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -76,7 +76,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(filename)(gravity)/*(nBilles)(porosite)*/(thickness)(width)(height)(profondeur)(density)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(boxYoungModulus)(boxPoissonRatio)(shearSpeed)(gravApplied)(shearApplied)(dampingForce)(dampingMomentum)(timeStepUpdateInterval));
 	REGISTER_CLASS_NAME(DirectShearCis);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/Funnel.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/Funnel.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/Funnel.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -73,26 +73,6 @@
 }
 
 
-void Funnel::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbSpheres);
-	REGISTER_ATTRIBUTE(minRadius);
-	REGISTER_ATTRIBUTE(maxRadius);
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(disorder);
-	REGISTER_ATTRIBUTE(groundSize);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-}
-
-
 bool Funnel::generate()
 {
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/dem/PreProcessor/Funnel.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/Funnel.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/Funnel.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -41,8 +41,8 @@
 		bool generate();
 
 	protected :
-		void registerAttributes();
 		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(FileGenerator,(nbSpheres)(minRadius)(maxRadius)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(gravity)(density)(disorder)(groundSize)(dampingForce)(dampingMomentum)(rotationBlocked)(timeStepUpdateInterval));
 	REGISTER_CLASS_NAME(Funnel);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 

Modified: trunk/pkg/dem/PreProcessor/HydraulicTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/HydraulicTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/HydraulicTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -73,16 +73,6 @@
 }
 
 
-void HydraulicTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	
-	REGISTER_ATTRIBUTE(yadeFileWithSpheres);
-	REGISTER_ATTRIBUTE(file);
-	REGISTER_ATTRIBUTE(radius);
-	//REGISTER_ATTRIBUTE(outputFileName);
-	//REGISTER_ATTRIBUTE(serializationDynlib);
-}
 
 
 bool HydraulicTest::generate()

Modified: trunk/pkg/dem/PreProcessor/HydraulicTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/HydraulicTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/HydraulicTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -47,7 +47,7 @@
 	
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(yadeFileWithSpheres)(file)(radius));
 	REGISTER_CLASS_NAME(HydraulicTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/MembraneTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/MembraneTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/MembraneTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -84,23 +84,6 @@
 }
 
 
-void MembraneTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbX);
-	REGISTER_ATTRIBUTE(nbZ);
-	REGISTER_ATTRIBUTE(XLength);
-	REGISTER_ATTRIBUTE(ZLength);
-	REGISTER_ATTRIBUTE(bigBallRadius);
-	REGISTER_ATTRIBUTE(membraneThickness);
-	REGISTER_ATTRIBUTE(tc);
-	REGISTER_ATTRIBUTE(en);
-	REGISTER_ATTRIBUTE(es);
-	REGISTER_ATTRIBUTE(frictionAngle);
-	REGISTER_ATTRIBUTE(gravity);
-}
-
-
 bool MembraneTest::generate()
 {
 	Omega::instance().setTimeStep(0.04);

Modified: trunk/pkg/dem/PreProcessor/MembraneTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/MembraneTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/MembraneTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -36,7 +36,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(nbX)(nbZ)(XLength)(ZLength)(bigBallRadius)(membraneThickness)(tc)(en)(es)(frictionAngle)(gravity));
 	REGISTER_CLASS_NAME(MembraneTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -171,81 +171,7 @@
 }
 
 
-void ModifiedTriaxialTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(want_2d);
-	REGISTER_ATTRIBUTE(lowerCorner);
-	REGISTER_ATTRIBUTE(upperCorner);
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(importFilename);
-	//REGISTER_ATTRIBUTE(nlayers);
-	//REGISTER_ATTRIBUTE(boxWalls);
-	REGISTER_ATTRIBUTE(internalCompaction);
-	REGISTER_ATTRIBUTE(maxMultiplier);
-	REGISTER_ATTRIBUTE(finalMaxMultiplier);
 
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(boxFrictionDeg);
-
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(defaultDt);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-	REGISTER_ATTRIBUTE(timeStepOutputInterval);
-	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
-	REGISTER_ATTRIBUTE(radiusControlInterval);
-	REGISTER_ATTRIBUTE(numberOfGrains);
-	REGISTER_ATTRIBUTE(strainRate);
-	REGISTER_ATTRIBUTE(StabilityCriterion);
-	REGISTER_ATTRIBUTE(autoCompressionActivation);
-//	REGISTER_ATTRIBUTE(wall_top);
-//	REGISTER_ATTRIBUTE(wall_bottom);
-//	REGISTER_ATTRIBUTE(wall_1);
-//	REGISTER_ATTRIBUTE(wall_2);
-//	REGISTER_ATTRIBUTE(wall_3);
-//	REGISTER_ATTRIBUTE(wall_4);
-//	REGISTER_ATTRIBUTE(wall_top_wire);
-//	REGISTER_ATTRIBUTE(wall_bottom_wire);
-//	REGISTER_ATTRIBUTE(wall_1_wire);
-//	REGISTER_ATTRIBUTE(wall_2_wire);
-//	REGISTER_ATTRIBUTE(wall_3_wire);
-//	REGISTER_ATTRIBUTE(wall_4_wire);
-//	REGISTER_ATTRIBUTE(spheresColor);
-//	REGISTER_ATTRIBUTE(spheresRandomColor);
-	REGISTER_ATTRIBUTE(recordBottomForce);
-	REGISTER_ATTRIBUTE(forceRecordFile);
-//	REGISTER_ATTRIBUTE(recordAveragePositions);
-	REGISTER_ATTRIBUTE(positionRecordFile);
-	REGISTER_ATTRIBUTE(velocityRecordFile);
-	REGISTER_ATTRIBUTE(recordIntervalIter);
-	REGISTER_ATTRIBUTE(saveAnimationSnapshots);
-	REGISTER_ATTRIBUTE(AnimationSnapshotsBaseName);
-	REGISTER_ATTRIBUTE(WallStressRecordFile);
-
-	REGISTER_ATTRIBUTE(gravity);
-//	REGISTER_ATTRIBUTE(hydraulicForce);
-	
-	//REGISTER_ATTRIBUTE(bigBall);
-	//REGISTER_ATTRIBUTE(bigBallRadius);
-	//REGISTER_ATTRIBUTE(bigBallDensity);
-	//REGISTER_ATTRIBUTE(bigBallDropTimeSeconds);
-	//REGISTER_ATTRIBUTE(bigBallFrictDeg);
-	//REGISTER_ATTRIBUTE(bigBallYoungModulus);
-	//REGISTER_ATTRIBUTE(bigBallPoissonRatio);
-	//REGISTER_ATTRIBUTE(bigBallDropHeight);
-	REGISTER_ATTRIBUTE(sigma_iso);
-
-}
-
-
 bool ModifiedTriaxialTest::generate()
 {
 //	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2

Modified: trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -118,8 +118,53 @@
 		~ModifiedTriaxialTest ();
 		bool generate();
 	
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(want_2d)
+		(lowerCorner)
+		(upperCorner)
+		(thickness)
+		(importFilename)
+		/*(nlayers)*/
+		/*(boxWalls)*/
+		(internalCompaction)
+		(maxMultiplier)
+		(finalMaxMultiplier)
+
+		(sphereYoungModulus)
+		(spherePoissonRatio)
+		(sphereFrictionDeg)
+
+		(boxYoungModulus)
+		(boxPoissonRatio)
+		(boxFrictionDeg)
+
+		(density)
+		(defaultDt)
+		(dampingForce)
+		(dampingMomentum)
+		(rotationBlocked)
+		(timeStepUpdateInterval)
+		(timeStepOutputInterval)
+		(wallStiffnessUpdateInterval)
+		(radiusControlInterval)
+		(numberOfGrains)
+		(strainRate)
+		(StabilityCriterion)
+		(autoCompressionActivation)
+		/*(wall_top)(wall_bottom)(wall_1)(wall_2)(wall_3)(wall_4)(wall_top_wire)(wall_bottom_wire)(wall_1_wire)(wall_2_wire)(wall_3_wire)(wall_4_wire)(spheresColor)(spheresRandomColor)*/
+		(recordBottomForce)
+		(forceRecordFile)
+		/*(recordAveragePositions)*/
+		(positionRecordFile)
+		(velocityRecordFile)
+		(recordIntervalIter)
+		(saveAnimationSnapshots)
+		(AnimationSnapshotsBaseName)
+		(WallStressRecordFile)
+		(gravity)
+		/*(hydraulicForce)(bigBall)(bigBallRadius)(bigBallDensity)(bigBallDropTimeSeconds)(bigBallFrictDeg)(bigBallYoungModulus)(bigBallPoissonRatio)(bigBallDropHeight)*/
+		(sigma_iso)
+	);
 	REGISTER_CLASS_NAME(ModifiedTriaxialTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -124,63 +124,8 @@
 }
 
 
-void SDECImpactTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-//	REGISTER_ATTRIBUTE(lowerCorner);
-//	REGISTER_ATTRIBUTE(upperCorner);
-//	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(importFilename);
-	REGISTER_ATTRIBUTE(boxWalls);
 
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
 
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(boxFrictionDeg);
-
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-//	REGISTER_ATTRIBUTE(wall_top);
-//	REGISTER_ATTRIBUTE(wall_bottom);
-//	REGISTER_ATTRIBUTE(wall_1);
-//	REGISTER_ATTRIBUTE(wall_2);
-//	REGISTER_ATTRIBUTE(wall_3);
-//	REGISTER_ATTRIBUTE(wall_4);
-//	REGISTER_ATTRIBUTE(wall_top_wire);
-//	REGISTER_ATTRIBUTE(wall_bottom_wire);
-//	REGISTER_ATTRIBUTE(wall_1_wire);
-//	REGISTER_ATTRIBUTE(wall_2_wire);
-//	REGISTER_ATTRIBUTE(wall_3_wire);
-//	REGISTER_ATTRIBUTE(wall_4_wire);
-//	REGISTER_ATTRIBUTE(spheresColor);
-//	REGISTER_ATTRIBUTE(spheresRandomColor);
-//	REGISTER_ATTRIBUTE(recordBottomForce);
-	REGISTER_ATTRIBUTE(forceRecordFile);
-//	REGISTER_ATTRIBUTE(recordAveragePositions);
-	REGISTER_ATTRIBUTE(positionRecordFile);
-	REGISTER_ATTRIBUTE(velocityRecordFile)
-	REGISTER_ATTRIBUTE(recordIntervalIter);
-
-//	REGISTER_ATTRIBUTE(gravity);
-	
-	REGISTER_ATTRIBUTE(bigBall);
-	REGISTER_ATTRIBUTE(bigBallRadius);
-	REGISTER_ATTRIBUTE(bigBallDensity);
-	REGISTER_ATTRIBUTE(bigBallDropTimeSeconds);
-	REGISTER_ATTRIBUTE(bigBallFrictDeg);
-	REGISTER_ATTRIBUTE(bigBallYoungModulus);
-	REGISTER_ATTRIBUTE(bigBallPoissonRatio);
-	REGISTER_ATTRIBUTE(bigBallDropHeight);
-
-}
-
-
 bool SDECImpactTest::generate()
 {
 	int startId=boost::numeric::bounds&lt;int&gt;::highest(), endId=0; // record forces from group 2

Modified: trunk/pkg/dem/PreProcessor/SDECImpactTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECImpactTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECImpactTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -86,7 +86,7 @@
 		bool generate();
 	
 	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,/*(lowerCorner)(upperCorner)(thickness)*/(importFilename)(boxWalls)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(boxYoungModulus)(boxPoissonRatio)(boxFrictionDeg)(density)(dampingForce)(dampingMomentum)(rotationBlocked)(timeStepUpdateInterval)/*(wall_top)(wall_bottom)(wall_1)(wall_2)(wall_3)(wall_4)(wall_top_wire)(wall_bottom_wire)(wall_1_wire)(wall_2_wire)(wall_3_wire)(wall_4_wire)(spheresColor)(spheresRandomColor)(recordBottomForce)(recordAveragePositions)(gravity)*/(forceRecordFile)(positionRecordFile)(velocityRecordFile)(recordIntervalIter)(bigBall)(bigBallRadius)(bigBallDensity)(bigBallDropTimeSeconds)(bigBallFrictDeg)(bigBallYoungModulus)(bigBallPoissonRatio)(bigBallDropHeight));
 	REGISTER_CLASS_NAME(SDECImpactTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -86,29 +86,7 @@
 }
 
 
-void SDECLinkedSpheres::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbSpheres);
-	REGISTER_ATTRIBUTE(minRadius);
-	REGISTER_ATTRIBUTE(maxRadius);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(disorder);
-	REGISTER_ATTRIBUTE(spacing);
-	REGISTER_ATTRIBUTE(supportSize);
-	REGISTER_ATTRIBUTE(support1);
-	REGISTER_ATTRIBUTE(support2);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-}
 
-
 bool SDECLinkedSpheres::generate()
 {
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -51,7 +51,7 @@
 	
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(nbSpheres)(minRadius)(maxRadius)(density)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(dampingForce)(dampingMomentum)(momentRotationLaw)(gravity)(disorder)(spacing)(supportSize)(support1)(support2)(timeStepUpdateInterval));
 	REGISTER_CLASS_NAME(SDECLinkedSpheres);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -95,40 +95,6 @@
 }
 
 
-void SDECMovingWall::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbSpheres);
-	REGISTER_ATTRIBUTE(minRadius);
-	REGISTER_ATTRIBUTE(maxRadius);
-	REGISTER_ATTRIBUTE(spheresHeight);
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(disorder);
-	REGISTER_ATTRIBUTE(groundSize);
-	REGISTER_ATTRIBUTE(groundPosition);
-	REGISTER_ATTRIBUTE(wallSize);
-	REGISTER_ATTRIBUTE(wallPosition);
-	REGISTER_ATTRIBUTE(wallVelocity);
-	REGISTER_ATTRIBUTE(wallTranslationAxis);
-	REGISTER_ATTRIBUTE(side1Size);
-	REGISTER_ATTRIBUTE(side1Position);
-	REGISTER_ATTRIBUTE(side1wire);
-	REGISTER_ATTRIBUTE(side2Size);
-	REGISTER_ATTRIBUTE(side2Position);
-	REGISTER_ATTRIBUTE(side2wire);
-	REGISTER_ATTRIBUTE(side3Size);
-	REGISTER_ATTRIBUTE(side3Position);
-	REGISTER_ATTRIBUTE(side3wire);
-       	REGISTER_ATTRIBUTE(useSpheresAsGround);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-}
 
 
 bool SDECMovingWall::generate()

Modified: trunk/pkg/dem/PreProcessor/SDECMovingWall.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECMovingWall.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECMovingWall.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -62,8 +62,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
-
+	REGISTER_ATTRIBUTES(FileGenerator,(nbSpheres)(minRadius)(maxRadius)(spheresHeight)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(gravity)(density)(disorder)(groundSize)(groundPosition)(wallSize)(wallPosition)(wallVelocity)(wallTranslationAxis)(side1Size)(side1Position)(side1wire)(side2Size)(side2Position)(side2wire)(side3Size)(side3Position)(side3wire)(useSpheresAsGround)(dampingForce)(dampingMomentum)(rotationBlocked)(timeStepUpdateInterval));
 	REGISTER_CLASS_NAME(SDECMovingWall);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -81,28 +81,7 @@
 }
 
 
-void SDECSpheresPlane::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbSpheres);
-	REGISTER_ATTRIBUTE(minRadius);
-	REGISTER_ATTRIBUTE(maxRadius);
-	REGISTER_ATTRIBUTE(spheresHeight);
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(disorder);
-	REGISTER_ATTRIBUTE(groundSize);
-	REGISTER_ATTRIBUTE(useSpheresAsGround);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-}
 
-
 bool SDECSpheresPlane::generate()
 {
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/dem/PreProcessor/SDECSpheresPlane.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECSpheresPlane.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SDECSpheresPlane.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -47,7 +47,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(nbSpheres)(minRadius)(maxRadius)(spheresHeight)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(gravity)(density)(disorder)(groundSize)(useSpheresAsGround)(dampingForce)(dampingMomentum)(rotationBlocked)(timeStepUpdateInterval));
 	REGISTER_CLASS_NAME(SDECSpheresPlane);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/STLImporterTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/STLImporterTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/STLImporterTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -69,29 +69,6 @@
 }
 
 
-void STLImporterTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbSpheres);
-	REGISTER_ATTRIBUTE(minRadius);
-	REGISTER_ATTRIBUTE(maxRadius);
-	REGISTER_ATTRIBUTE(spheresHeight);
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(disorder);
-	REGISTER_ATTRIBUTE(stlFileName);
-	REGISTER_ATTRIBUTE(wire);
-	REGISTER_ATTRIBUTE(angularVelocity);
-	REGISTER_ATTRIBUTE(rotationAxis);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-}
-
-
 bool STLImporterTest::generate()
 {
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/dem/PreProcessor/STLImporterTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/STLImporterTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/STLImporterTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -46,9 +46,8 @@
 
 	protected :
 		bool generate();
-
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(nbSpheres)(minRadius)(maxRadius)(spheresHeight)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(gravity)(density)(disorder)(stlFileName)(wire)(angularVelocity)(rotationAxis)(dampingForce)(dampingMomentum)(timeStepUpdateInterval));
 	REGISTER_CLASS_NAME(STLImporterTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/SimpleScene.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SimpleScene.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SimpleScene.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -8,8 +8,7 @@
 		SimpleScene(){};
 		~SimpleScene (){};
 		virtual bool generate();
-	protected :
-		void registerAttributes(){ FileGenerator::registerAttributes(); }
+	REGISTER_ATTRIBUTES(FileGenerator,/* */);
 	REGISTER_CLASS_NAME(SimpleScene);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 	DECLARE_LOGGER;

Modified: trunk/pkg/dem/PreProcessor/SimpleShear.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SimpleShear.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SimpleShear.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -101,28 +101,6 @@
 }
 
 
-void SimpleShear::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(filename);
-	REGISTER_ATTRIBUTE(gravity);
-// 	REGISTER_ATTRIBUTE(nBilles);
-// 	REGISTER_ATTRIBUTE(porosite);
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(profondeur);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(shearSpeed);
-	REGISTER_ATTRIBUTE(gravApplied);
-	REGISTER_ATTRIBUTE(shearApplied);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval );
-}
 
 
 bool SimpleShear::generate()

Modified: trunk/pkg/dem/PreProcessor/SimpleShear.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SimpleShear.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/SimpleShear.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -77,7 +77,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(filename)(gravity)(thickness)(width)(height)(profondeur)(density)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(boxYoungModulus)(boxPoissonRatio)(shearSpeed)(gravApplied)(shearApplied)(timeStepUpdateInterval)/*(nBilles)(porosite)*/);
 	REGISTER_CLASS_NAME(SimpleShear);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -60,26 +60,6 @@
 void TestSimpleViscoelastic::postProcessAttributes(bool)
 {}
 
-void TestSimpleViscoelastic::registerAttributes()
-{
-    FileGenerator::registerAttributes();
-    REGISTER_ATTRIBUTE(tc);
-    REGISTER_ATTRIBUTE(en);
-    REGISTER_ATTRIBUTE(es);
-    REGISTER_ATTRIBUTE(frictionAngle);
-    REGISTER_ATTRIBUTE(R);
-    REGISTER_ATTRIBUTE(density);
-    REGISTER_ATTRIBUTE(nbSpheres);
-    REGISTER_ATTRIBUTE(h);
-    REGISTER_ATTRIBUTE(velocity);
-    REGISTER_ATTRIBUTE(angular_vel);
-    REGISTER_ATTRIBUTE(rotationBlocked);
-    REGISTER_ATTRIBUTE(gravity);
-    REGISTER_ATTRIBUTE(groundSize);
-    REGISTER_ATTRIBUTE(outputBase);
-    REGISTER_ATTRIBUTE(interval);
-}
-
 bool TestSimpleViscoelastic::generate()
 {
     rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -57,8 +57,7 @@
 	bool generate();
 
 	virtual void postProcessAttributes(bool deserializing);
-	void registerAttributes();
-
+	REGISTER_ATTRIBUTES(FileGenerator,(tc)(en)(es)(frictionAngle)(R)(density)(nbSpheres)(h)(velocity)(angular_vel)(rotationBlocked)(gravity)(groundSize)(outputBase)(interval));
 	REGISTER_CLASS_NAME(TestSimpleViscoelastic);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -98,24 +98,6 @@
 }
 
 
-void TetrahedronsTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbTetrahedrons);
-	REGISTER_ATTRIBUTE(minSize);
-	REGISTER_ATTRIBUTE(maxSize);
-	REGISTER_ATTRIBUTE(youngModulus);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(disorder);
-	REGISTER_ATTRIBUTE(groundSize);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	//REGISTER_ATTRIBUTE(timeStepUpdateInterval); // not used. But you may want to use it....
-}
-
-
 bool TetrahedronsTest::generate()
 {
 	Omega::instance().setTimeStep(0.04);

Modified: trunk/pkg/dem/PreProcessor/TetrahedronsTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TetrahedronsTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TetrahedronsTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -100,7 +100,7 @@
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(nbTetrahedrons)(minSize)(maxSize)(youngModulus)(gravity)(density)(disorder)(groundSize)(dampingForce)(dampingMomentum)(rotationBlocked));
 	REGISTER_CLASS_NAME(TetrahedronsTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/ThreePointBending.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/ThreePointBending.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/ThreePointBending.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -89,30 +89,7 @@
 }
 
 
-void ThreePointBending::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	
-	REGISTER_ATTRIBUTE(yadeFileWithSpheres);
 
-	REGISTER_ATTRIBUTE(pistonVelocity);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-	REGISTER_ATTRIBUTE(momentRotationLaw);
-	
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	
-	REGISTER_ATTRIBUTE(linkKn);
-	REGISTER_ATTRIBUTE(linkKs);
-	REGISTER_ATTRIBUTE(linkMaxNormalForce);
-	REGISTER_ATTRIBUTE(linkMaxShearForce);
-}
-
-
 bool ThreePointBending::generate()
 {
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/dem/PreProcessor/ThreePointBending.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/ThreePointBending.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/ThreePointBending.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -45,7 +45,7 @@
 	
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(yadeFileWithSpheres)(pistonVelocity)(dampingForce)(dampingMomentum)(timeStepUpdateInterval)(momentRotationLaw)(sphereYoungModulus)(spherePoissonRatio)(sphereFrictionDeg)(linkKn)(linkKs)(linkMaxNormalForce)(linkMaxShearForce));
 	REGISTER_CLASS_NAME(ThreePointBending);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -179,64 +179,7 @@
 }
 
 
-void TriaxialTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(lowerCorner);
-	REGISTER_ATTRIBUTE(upperCorner);
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(importFilename);
-	REGISTER_ATTRIBUTE(outputFileName);
-	//REGISTER_ATTRIBUTE(nlayers);
-	//REGISTER_ATTRIBUTE(boxWalls);
-	REGISTER_ATTRIBUTE(internalCompaction);
-	REGISTER_ATTRIBUTE(biaxial2dTest);
-	REGISTER_ATTRIBUTE(maxMultiplier);
-	REGISTER_ATTRIBUTE(finalMaxMultiplier);
-	REGISTER_ATTRIBUTE(radiusStdDev);
-	REGISTER_ATTRIBUTE(radiusMean);
 
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(compactionFrictionDeg);
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(boxFrictionDeg);
-
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(defaultDt);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-	REGISTER_ATTRIBUTE(timeStepOutputInterval);
-	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
-	REGISTER_ATTRIBUTE(radiusControlInterval);
-	REGISTER_ATTRIBUTE(numberOfGrains);
-	REGISTER_ATTRIBUTE(strainRate);
-	REGISTER_ATTRIBUTE(maxWallVelocity);
-	REGISTER_ATTRIBUTE(StabilityCriterion);
-	REGISTER_ATTRIBUTE(autoCompressionActivation);
-	REGISTER_ATTRIBUTE(autoUnload);
-	REGISTER_ATTRIBUTE(autoStopSimulation);
-	REGISTER_ATTRIBUTE(recordIntervalIter);
-	REGISTER_ATTRIBUTE(saveAnimationSnapshots);
-	REGISTER_ATTRIBUTE(AnimationSnapshotsBaseName);
-	REGISTER_ATTRIBUTE(WallStressRecordFile);
-	REGISTER_ATTRIBUTE(wallOversizeFactor);
-	REGISTER_ATTRIBUTE(sigmaIsoCompaction);
-	REGISTER_ATTRIBUTE(sigmaLateralConfinement);
-	REGISTER_ATTRIBUTE(Key);
-	REGISTER_ATTRIBUTE(isotropicCompaction);
-	REGISTER_ATTRIBUTE(fixedPorosity);
-	REGISTER_ATTRIBUTE(fixedBoxDims);
-	REGISTER_ATTRIBUTE(fast);
-	REGISTER_ATTRIBUTE(noFiles);
-	REGISTER_ATTRIBUTE(facetWalls);
-}
-
-
 bool TriaxialTest::generate()
 {
 //	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -150,8 +150,60 @@
 		~TriaxialTest ();
 		bool generate();
 	
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(lowerCorner)
+		(upperCorner)
+		(thickness)
+		(importFilename)
+		(outputFileName)
+		//(nlayers)
+		//(boxWalls)
+		(internalCompaction)
+		(biaxial2dTest)
+		(maxMultiplier)
+		(finalMaxMultiplier)
+		(radiusStdDev)
+		(radiusMean)
+
+		(sphereYoungModulus)
+		(spherePoissonRatio)
+		(sphereFrictionDeg)
+		(compactionFrictionDeg)
+		(boxYoungModulus)
+		(boxPoissonRatio)
+		(boxFrictionDeg)
+
+		(density)
+		(defaultDt)
+		(dampingForce)
+		(dampingMomentum)
+		(rotationBlocked)
+		(timeStepUpdateInterval)
+		(timeStepOutputInterval)
+		(wallStiffnessUpdateInterval)
+		(radiusControlInterval)
+		(numberOfGrains)
+		(strainRate)
+		(maxWallVelocity)
+		(StabilityCriterion)
+		(autoCompressionActivation)
+		(autoUnload)
+		(autoStopSimulation)
+		(recordIntervalIter)
+		(saveAnimationSnapshots)
+		(AnimationSnapshotsBaseName)
+		(WallStressRecordFile)
+		(wallOversizeFactor)
+		(sigmaIsoCompaction)
+		(sigmaLateralConfinement)
+		(Key)
+		(isotropicCompaction)
+		(fixedPorosity)
+		(fixedBoxDims)
+		(fast)
+		(noFiles)
+		(facetWalls)
+	);
 	REGISTER_CLASS_NAME(TriaxialTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 	DECLARE_LOGGER;

Modified: trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -175,89 +175,7 @@
 }
 
 
-void TriaxialTestWater::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(lowerCorner);
-	REGISTER_ATTRIBUTE(upperCorner);
-	REGISTER_ATTRIBUTE(thickness);
-	REGISTER_ATTRIBUTE(importFilename);
-	REGISTER_ATTRIBUTE(outputFileName);
-	//REGISTER_ATTRIBUTE(nlayers);
-	//REGISTER_ATTRIBUTE(boxWalls);
-	REGISTER_ATTRIBUTE(internalCompaction);
-	REGISTER_ATTRIBUTE(maxMultiplier);
-	REGISTER_ATTRIBUTE(finalMaxMultiplier);
 
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(compactionFrictionDeg);
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(boxFrictionDeg);
-
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(defaultDt);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(rotationBlocked);
-	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-	REGISTER_ATTRIBUTE(timeStepOutputInterval);
-	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
-	REGISTER_ATTRIBUTE(radiusControlInterval);
-	REGISTER_ATTRIBUTE(numberOfGrains);
-	REGISTER_ATTRIBUTE(Rdispersion);
-	REGISTER_ATTRIBUTE(strainRate);
-	REGISTER_ATTRIBUTE(maxWallVelocity);
-	REGISTER_ATTRIBUTE(StabilityCriterion);
-	REGISTER_ATTRIBUTE(autoCompressionActivation);
-//	REGISTER_ATTRIBUTE(wall_top);
-//	REGISTER_ATTRIBUTE(wall_bottom);
-//	REGISTER_ATTRIBUTE(wall_1);
-//	REGISTER_ATTRIBUTE(wall_2);
-//	REGISTER_ATTRIBUTE(wall_3);
-//	REGISTER_ATTRIBUTE(wall_4);
-//	REGISTER_ATTRIBUTE(wall_top_wire);
-//	REGISTER_ATTRIBUTE(wall_bottom_wire);
-//	REGISTER_ATTRIBUTE(wall_1_wire);
-//	REGISTER_ATTRIBUTE(wall_2_wire);
-//	REGISTER_ATTRIBUTE(wall_3_wire);
-//	REGISTER_ATTRIBUTE(wall_4_wire);
-//	REGISTER_ATTRIBUTE(spheresColor);
-//	REGISTER_ATTRIBUTE(spheresRandomColor);
-	REGISTER_ATTRIBUTE(recordIntervalIter);
-	REGISTER_ATTRIBUTE(saveAnimationSnapshots);
-	REGISTER_ATTRIBUTE(AnimationSnapshotsBaseName);
-	REGISTER_ATTRIBUTE(WallStressRecordFile);
-// 	REGISTER_ATTRIBUTE(capillaryStressRecordFile);
-	REGISTER_ATTRIBUTE(contactStressRecordFile);
-
-	REGISTER_ATTRIBUTE(wallOversizeFactor);
-
-//	REGISTER_ATTRIBUTE(gravity);
-	
-	//REGISTER_ATTRIBUTE(bigBall);
-	//REGISTER_ATTRIBUTE(bigBallRadius);
-	//REGISTER_ATTRIBUTE(bigBallDensity);
-	//REGISTER_ATTRIBUTE(bigBallDropTimeSeconds);
-	//REGISTER_ATTRIBUTE(bigBallFrictDeg);
-	//REGISTER_ATTRIBUTE(bigBallYoungModulus);
-	//REGISTER_ATTRIBUTE(bigBallPoissonRatio);
-	//REGISTER_ATTRIBUTE(bigBallDropHeight);
-	//REGISTER_ATTRIBUTE(sigma_iso);
-	REGISTER_ATTRIBUTE(sigmaIsoCompaction);
-	REGISTER_ATTRIBUTE(sigmaLateralConfinement);
-	REGISTER_ATTRIBUTE(Key);
-	
-	REGISTER_ATTRIBUTE(water);
-	REGISTER_ATTRIBUTE(CapillaryPressure);
-	REGISTER_ATTRIBUTE(fusionDetection);
-	REGISTER_ATTRIBUTE(binaryFusion);
-
-}
-
-
 bool TriaxialTestWater::generate()
 {
 //	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2

Modified: trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -137,8 +137,84 @@
 		~TriaxialTestWater ();
 		bool generate();
 	
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(lowerCorner)
+		(upperCorner)
+		(thickness)
+		(importFilename)
+		(outputFileName)
+		//(nlayers)
+		//(boxWalls)
+		(internalCompaction)
+		(maxMultiplier)
+		(finalMaxMultiplier)
+
+		(sphereYoungModulus)
+		(spherePoissonRatio)
+		(sphereFrictionDeg)
+		(compactionFrictionDeg)
+		(boxYoungModulus)
+		(boxPoissonRatio)
+		(boxFrictionDeg)
+
+		(density)
+		(defaultDt)
+		(dampingForce)
+		(dampingMomentum)
+		(rotationBlocked)
+		(timeStepUpdateInterval)
+		(timeStepOutputInterval)
+		(wallStiffnessUpdateInterval)
+		(radiusControlInterval)
+		(numberOfGrains)
+		(Rdispersion)
+		(strainRate)
+		(maxWallVelocity)
+		(StabilityCriterion)
+		(autoCompressionActivation)
+	//	(wall_top)
+	//	(wall_bottom)
+	//	(wall_1)
+	//	(wall_2)
+	//	(wall_3)
+	//	(wall_4)
+	//	(wall_top_wire)
+	//	(wall_bottom_wire)
+	//	(wall_1_wire)
+	//	(wall_2_wire)
+	//	(wall_3_wire)
+	//	(wall_4_wire)
+	//	(spheresColor)
+	//	(spheresRandomColor)
+		(recordIntervalIter)
+		(saveAnimationSnapshots)
+		(AnimationSnapshotsBaseName)
+		(WallStressRecordFile)
+	// 	(capillaryStressRecordFile)
+		(contactStressRecordFile)
+
+		(wallOversizeFactor)
+
+	//	(gravity)
+		
+		//(bigBall)
+		//(bigBallRadius)
+		//(bigBallDensity)
+		//(bigBallDropTimeSeconds)
+		//(bigBallFrictDeg)
+		//(bigBallYoungModulus)
+		//(bigBallPoissonRatio)
+		//(bigBallDropHeight)
+		//(sigma_iso)
+		(sigmaIsoCompaction)
+		(sigmaLateralConfinement)
+		(Key)
+		
+		(water)
+		(CapillaryPressure)
+		(fusionDetection)
+		(binaryFusion)
+	);
 	REGISTER_CLASS_NAME(TriaxialTestWater);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/dem/PreProcessor/UniaxialStrainerGen.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/UniaxialStrainerGen.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/PreProcessor/UniaxialStrainerGen.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,16 +21,7 @@
 		Real strainRate, limitStrain, damping;
 		int axis;
 		long cohesiveThresholdIter;
-	protected :
-		void registerAttributes(){
-			FileGenerator::registerAttributes();
-			REGISTER_ATTRIBUTE(spheresFile);
-			REGISTER_ATTRIBUTE(axis);
-			REGISTER_ATTRIBUTE(strainRate);
-			REGISTER_ATTRIBUTE(limitStrain);
-			REGISTER_ATTRIBUTE(damping);
-			REGISTER_ATTRIBUTE(cohesiveThresholdIter);
-		}
+	REGISTER_ATTRIBUTES(FileGenerator,(spheresFile)(axis)(strainRate)(limitStrain)(damping)(cohesiveThresholdIter));
 	REGISTER_CLASS_AND_BASE(UniaxialStrainerGen,FileGenerator);
 	DECLARE_LOGGER;
 };

Modified: trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.hpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,7 +17,6 @@
 	public :
 		GLDrawSpheresContactGeometry(): midMax(0), forceMax(0){}
 		virtual void go(const shared_ptr&lt;InteractionGeometry&gt;&amp;,const shared_ptr&lt;Interaction&gt;&amp;,const shared_ptr&lt;Body&gt;&amp;,const shared_ptr&lt;Body&gt;&amp;,bool wireFrame);
-		//	virtual void registerAttributes();
 
 	DECLARE_LOGGER;
 	RENDERS(SpheresContactGeometry);

Modified: trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.cpp
===================================================================
--- trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,10 +21,4 @@
 }
 
 
-void FEMNodeData::registerAttributes()
-{
-	ParticleParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(initialPosition);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.hpp
===================================================================
--- trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/DataClass/PhysicalParameters/FEMNodeData.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,8 +22,7 @@
 		virtual ~FEMNodeData();
 
 /// Serialization
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(ParticleParameters,(initialPosition));
 	REGISTER_CLASS_NAME(FEMNodeData);
 	REGISTER_BASE_CLASS_NAME(ParticleParameters);
 	

Modified: trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.cpp
===================================================================
--- trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,11 +23,5 @@
 }
 
 
-void FEMSetParameters::registerAttributes()
-{
-	PhysicalParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(nodeGroupMask);
-	REGISTER_ATTRIBUTE(tetrahedronGroupMask);
-}
 
 YADE_PLUGIN();

Modified: trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.hpp
===================================================================
--- trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/DataClass/PhysicalParameters/FEMSetParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,10 +23,7 @@
 /// Serializable
 	REGISTER_CLASS_NAME(FEMSetParameters);
 	REGISTER_BASE_CLASS_NAME(PhysicalParameters);
-
-/// Indexable
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(PhysicalParameters,(nodeGroupMask)(tetrahedronGroupMask));
 	REGISTER_CLASS_INDEX(FEMSetParameters,PhysicalParameters);
 
 };

Modified: trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.cpp
===================================================================
--- trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,11 +23,6 @@
 }
 
 
-void FEMTetrahedronData::registerAttributes()
-{
-	PhysicalParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(ids);
-}
 
 void FEMTetrahedronData::calcKeMatrix(MetaBody* femBody)
 {

Modified: trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.hpp
===================================================================
--- trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/DataClass/PhysicalParameters/FEMTetrahedronData.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -38,13 +38,12 @@
 		virtual ~FEMTetrahedronData();
 
 /// Serialization
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(PhysicalParameters,(ids));
 	REGISTER_CLASS_NAME(FEMTetrahedronData);
 	REGISTER_BASE_CLASS_NAME(PhysicalParameters);
 	
 /// Indexable
-	REGISTER_CLASS_INDEX(FEMTetrahedronData,RigidBodyParameters);
+	REGISTER_CLASS_INDEX(FEMTetrahedronData,RigidBodyParameters); // FIXME: should be PhysicalParameters?
 
 };
 

Modified: trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp
===================================================================
--- trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -15,10 +15,6 @@
 #include &lt;boost/filesystem/convenience.hpp&gt;
 
 
-void FEMSetTextLoader::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(fileName);
-}
 
 void FEMSetTextLoader::go(	  const shared_ptr&lt;PhysicalParameters&gt;&amp; par
 					, Body* body)

Modified: trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.hpp
===================================================================
--- trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,8 +37,7 @@
 					, int id3
 					, int id4);
 
-	protected :
-		virtual void registerAttributes();	
+	REGISTER_ATTRIBUTES(PhysicalParametersEngineUnit,(fileName))
 	REGISTER_CLASS_NAME(FEMSetTextLoader);
 	REGISTER_BASE_CLASS_NAME(PhysicalParametersEngineUnit);
 

Modified: trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.cpp
===================================================================
--- trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -30,12 +30,6 @@
 }
 
 
-void FEMLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(nodeGroupMask);
-	REGISTER_ATTRIBUTE(tetrahedronGroupMask);
-}
 
 
 void FEMLaw::action(MetaBody* fem)

Modified: trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.hpp
===================================================================
--- trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/Engine/StandAloneEngine/FEMLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,8 +24,7 @@
 		void action(MetaBody*);
 
 /// Serializtion
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(nodeGroupMask)(tetrahedronGroupMask));
 	REGISTER_CLASS_NAME(FEMLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 

Modified: trunk/pkg/fem/PreProcessor/FEMBeam.cpp
===================================================================
--- trunk/pkg/fem/PreProcessor/FEMBeam.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/PreProcessor/FEMBeam.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -90,24 +90,7 @@
 }
 
 
-void FEMBeam::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(femTxtFile);
-	REGISTER_ATTRIBUTE(gravity);
-	
-	REGISTER_ATTRIBUTE(regionMin1);
-	REGISTER_ATTRIBUTE(regionMax1);
-	REGISTER_ATTRIBUTE(translationAxis1);
-	REGISTER_ATTRIBUTE(velocity1);
-	
-	REGISTER_ATTRIBUTE(regionMin2);
-	REGISTER_ATTRIBUTE(regionMax2);
-	REGISTER_ATTRIBUTE(translationAxis2);
-	REGISTER_ATTRIBUTE(velocity2);
-}
 
-
 bool FEMBeam::generate()
 {
 	Omega::instance().setTimeStep(0.004);

Modified: trunk/pkg/fem/PreProcessor/FEMBeam.hpp
===================================================================
--- trunk/pkg/fem/PreProcessor/FEMBeam.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/fem/PreProcessor/FEMBeam.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -45,10 +45,7 @@
 		void createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		void positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		void imposeTranslation(shared_ptr&lt;MetaBody&gt;&amp; rootBody, Vector3r min, Vector3r max, Vector3r direction, Real velocity);
-
-	protected :
-		void registerAttributes();
-
+	REGISTER_ATTRIBUTES(FileGenerator,(femTxtFile)(gravity)(regionMin1)(regionMax1)(translationAxis1)(velocity1)(regionMin2)(regionMax2)(translationAxis2)(velocity2));
 	REGISTER_CLASS_NAME(FEMBeam);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.cpp
===================================================================
--- trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,10 +17,5 @@
 {		
 }
 
-void LineSegment::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(length);
-}
 
 YADE_PLUGIN();

Modified: trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.hpp
===================================================================
--- trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/GeometricalModel/LineSegment.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,11 +20,9 @@
 		virtual ~LineSegment ();
 	
 /// Serialization
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(GeometricalModel,(length));
 	REGISTER_CLASS_NAME(LineSegment);
 	REGISTER_BASE_CLASS_NAME(GeometricalModel);
-	
 /// Indexable
 	REGISTER_CLASS_INDEX(LineSegment,GeometricalModel);
 

Modified: trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.cpp
===================================================================
--- trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,20 +33,5 @@
 
 }
 
-void LatticeBeamAngularSpring::registerAttributes()
-{
-	InteractionPhysics::registerAttributes();
-	REGISTER_ATTRIBUTE(initialPlaneAngle);
-//	REGISTER_ATTRIBUTE(planeAngle); // FIXME - can be calculated after deserialization
-	REGISTER_ATTRIBUTE(lastCrossProduct);
-	REGISTER_ATTRIBUTE(planeSwap180);
-	REGISTER_ATTRIBUTE(initialOffPlaneAngle1);
-	REGISTER_ATTRIBUTE(initialOffPlaneAngle2);
-	REGISTER_ATTRIBUTE(lastOffPlaneAngleDifference1);
-	REGISTER_ATTRIBUTE(lastOffPlaneAngleDifference2);
-	REGISTER_ATTRIBUTE(swirl1);
-	REGISTER_ATTRIBUTE(swirl2);
-//	REGISTER_ATTRIBUTE(offPlaneAngle); // FIXME - can be calculated after deserialization
-}
 
 YADE_PLUGIN();

Modified: trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.hpp
===================================================================
--- trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/InteractionPhysics/LatticeBeamAngularSpring.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,8 +31,19 @@
 		virtual ~LatticeBeamAngularSpring();
 
 /// Serialization
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionPhysics,
+		(initialPlaneAngle)
+		// (planeAngle) // FIXME - can be calculated after deserialization
+		(lastCrossProduct)
+		(planeSwap180)
+		(initialOffPlaneAngle1)
+		(initialOffPlaneAngle2)
+		(lastOffPlaneAngleDifference1)
+		(lastOffPlaneAngleDifference2)
+		(swirl1)
+		(swirl2)
+		//	(offPlaneAngle) // FIXME - can be calculated after deserialization
+	);
 	REGISTER_CLASS_NAME(LatticeBeamAngularSpring);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysics);
 	

Modified: trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.cpp
===================================================================
--- trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,10 +20,5 @@
 
 }
 
-void NonLocalDependency::registerAttributes()
-{
-	InteractionPhysics::registerAttributes();
-	REGISTER_ATTRIBUTE(gaussValue);
-}
 
 YADE_PLUGIN();

Modified: trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.hpp
===================================================================
--- trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/InteractionPhysics/NonLocalDependency.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,16 +20,12 @@
 		virtual ~NonLocalDependency();
 
 /// Serialization
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionPhysics,(gaussValue));
 	REGISTER_CLASS_NAME(NonLocalDependency);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysics);
-	
 /// Indexable
 	REGISTER_CLASS_INDEX(NonLocalDependency,InteractionPhysics);
-
 };
-
 REGISTER_SERIALIZABLE(NonLocalDependency);
 
 

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -144,26 +144,4 @@
         }
 }
 
-void LatticeBeamParameters::registerAttributes()
-{
-	PhysicalParameters::registerAttributes();
-	REGISTER_ATTRIBUTE(id1);
-	REGISTER_ATTRIBUTE(id2);
-	
-	REGISTER_ATTRIBUTE(initialLength);
-	REGISTER_ATTRIBUTE(length); // FIXME - can be calculated after deserialization
-	
-	REGISTER_ATTRIBUTE(direction); // FIXME - can be calculated after deserialization
-	REGISTER_ATTRIBUTE(otherDirection); // this must be saved!
-	
-	REGISTER_ATTRIBUTE(criticalTensileStrain);
-	REGISTER_ATTRIBUTE(criticalCompressiveStrain);
-
-	REGISTER_ATTRIBUTE(longitudalStiffness);
-	REGISTER_ATTRIBUTE(bendingStiffness);
-	REGISTER_ATTRIBUTE(torsionalStiffness);
-
-	REGISTER_ATTRIBUTE(se3Displacement);
-}
-
 YADE_PLUGIN();

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -56,7 +56,25 @@
 /// Serialization
 	protected :
 		virtual void postProcessAttributes(bool);
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(PhysicalParameters,
+		(id1)
+		(id2)
+		
+		(initialLength)
+		(length) // FIXME - can be calculated after deserialization
+		
+		(direction) // FIXME - can be calculated after deserialization
+		(otherDirection) // this must be saved!
+		
+		(criticalTensileStrain)
+		(criticalCompressiveStrain)
+
+		(longitudalStiffness)
+		(bendingStiffness)
+		(torsionalStiffness)
+
+		(se3Displacement)
+	);
 	REGISTER_CLASS_NAME(LatticeBeamParameters);
 	REGISTER_BASE_CLASS_NAME(PhysicalParameters);
 	

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.cpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,9 +23,5 @@
 
 }
 
-void LatticeNodeParameters::registerAttributes()
-{
-	PhysicalParameters::registerAttributes();
-}
 
 YADE_PLUGIN();

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.hpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeNodeParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,8 +23,7 @@
 		virtual ~LatticeNodeParameters();
 
 /// Serialization
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(PhysicalParameters,/* */);
 	REGISTER_CLASS_NAME(LatticeNodeParameters);
 	REGISTER_BASE_CLASS_NAME(PhysicalParameters);
 	

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.cpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,13 +28,5 @@
 }
 
 
-void LatticeSetParameters::registerAttributes()
-{
-        PhysicalParameters::registerAttributes();
-        REGISTER_ATTRIBUTE(nodeGroupMask);
-        REGISTER_ATTRIBUTE(beamGroupMask);
-        REGISTER_ATTRIBUTE(useBendTensileSoftening);
-        REGISTER_ATTRIBUTE(useStiffnessSoftening);
-}
  
 YADE_PLUGIN();

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.hpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeSetParameters.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -36,8 +36,7 @@
                 virtual ~LatticeSetParameters();
 
 /// Serializable
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(PhysicalParameters,(nodeGroupMask)(beamGroupMask)(useBendTensileSoftening)(useStiffnessSoftening));
 	REGISTER_CLASS_NAME(LatticeSetParameters);
 	REGISTER_BASE_CLASS_NAME(PhysicalParameters);
 

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -89,21 +89,8 @@
 }
 
 
-void BeamRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-//	REGISTER_ATTRIBUTE(sections);
-	REGISTER_ATTRIBUTE(sections_midpoints);
-	REGISTER_ATTRIBUTE(sections_halflength);
-	REGISTER_ATTRIBUTE(sections_directions);
 
-//	REGISTER_ATTRIBUTE(first);
-//	REGISTER_ATTRIBUTE(subscribedBodies);
-}
 
-
 bool BeamRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.hpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/BeamRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -36,13 +36,23 @@
 
 		BeamRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
 
 	protected :
 		virtual void preProcessAttributes(bool deserializing);
 		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(DataRecorder,
+		(outputFile)
+		(interval)
+		//	(sections)
+		(sections_midpoints)
+		(sections_halflength)
+		(sections_directions)
+
+		//	(first)
+		//	(subscribedBodies)
+	);
 	REGISTER_CLASS_NAME(BeamRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 };

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.hpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,18 +31,16 @@
 		LatticeLaw();
 		virtual ~LatticeLaw();
 		void action(MetaBody*);
-		void registerAttributes()
-		{
-			REGISTER_ATTRIBUTE(roughEdges);
-			REGISTER_ATTRIBUTE(ensure2D);
-			REGISTER_ATTRIBUTE(calcTorsion);
-			REGISTER_ATTRIBUTE(backward_compatible);
-			REGISTER_ATTRIBUTE(tension_compression_different_stiffness);
-			REGISTER_ATTRIBUTE(respect_non_destroy);
+		REGISTER_ATTRIBUTES(InteractionSolver,
+			(roughEdges)
+			(ensure2D)
+			(calcTorsion)
+			(backward_compatible)
+			(tension_compression_different_stiffness)
+			(respect_non_destroy)
 			// must go to derived class
-			//REGISTER_ATTRIBUTE(nonlocal);
-		};
-
+			//(nonlocal)
+		);
 /// Serializtion
 	REGISTER_CLASS_NAME(LatticeLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -38,20 +38,7 @@
 }
 
 
-void MeasurePoisson::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(horizontal);
-	REGISTER_ATTRIBUTE(vertical);
-	REGISTER_ATTRIBUTE(bottom);
-	REGISTER_ATTRIBUTE(upper);
-	REGISTER_ATTRIBUTE(left);
-	REGISTER_ATTRIBUTE(right);
-}
 
-
 bool MeasurePoisson::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.hpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/MeasurePoisson.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,10 +29,10 @@
 		
 		MeasurePoisson ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
 
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)(horizontal)(vertical)(bottom)(upper)(left)(right));
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
 	REGISTER_CLASS_NAME(MeasurePoisson);

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -66,19 +66,8 @@
 }
 
 
-void MovingSupport::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-//	REGISTER_ATTRIBUTE(sections);
-	REGISTER_ATTRIBUTE(sections_midpoints);
-	REGISTER_ATTRIBUTE(sections_halflength);
-	REGISTER_ATTRIBUTE(sections_directions);
 
-//	REGISTER_ATTRIBUTE(first);
-//	REGISTER_ATTRIBUTE(subscribedBodies);
-}
 
-
 bool MovingSupport::isActivated(MetaBody*)
 {
 	return true;

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.hpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,10 +37,9 @@
 
 		MovingSupport ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
-
+	REGISTER_ATTRIBUTES(DataRecorder,/*(sections)*/(sections_midpoints)(sections_halflength)(sections_directions)/*(first)(subscribedBodies)*/);
 	protected :
 		virtual void preProcessAttributes(bool deserializing);
 		virtual void postProcessAttributes(bool deserializing);

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -71,21 +71,8 @@
 }
 
 
-void NodeRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	//REGISTER_ATTRIBUTE(regions);
-	REGISTER_ATTRIBUTE(regions_min);
-	REGISTER_ATTRIBUTE(regions_max);
-	REGISTER_ATTRIBUTE(only_this_stiffness);
 
-//	REGISTER_ATTRIBUTE(first);
-//	REGISTER_ATTRIBUTE(subscribedBodies);
-}
 
-
 bool NodeRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.hpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/NodeRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -35,10 +35,18 @@
 
 		NodeRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
-
+	REGISTER_ATTRIBUTES(DataRecorder,
+		(outputFile)
+		(interval)
+		//(regions)
+		(regions_min)
+		(regions_max)
+		(only_this_stiffness)
+		//	(first)
+		//	(subscribedBodies)
+	);
 	protected :
 		virtual void preProcessAttributes(bool deserializing);
 		virtual void postProcessAttributes(bool deserializing);

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -22,12 +22,6 @@
 {
 }
 
-void NonLocalInitializer::registerAttributes()
-{
-	StandAloneEngine::registerAttributes();
-	REGISTER_ATTRIBUTE(range);
-}
-
 bool NonLocalInitializer::calcNonLocal(Body* body1, Body* body2, BodyContainer* bodies, void* nonl)
 //void NonLocalInitializer::calcNonLocal(Body* body1, Body* body2, BodyContainer* bodies, InteractionContainer* nonl)
 //bool NonLocalInitializer::calcNonLocal(Body* body1, Body* body2, BodyContainer* bodies,//std::list&lt;std::list&lt;LatticeSetParameters::NonLocalInteraction&gt; &gt;

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.hpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,8 +29,7 @@
 		virtual ~NonLocalInitializer ();
 		virtual void action(MetaBody*);
 
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(StandAloneEngine,(range));
 	REGISTER_CLASS_NAME(NonLocalInitializer);
 	REGISTER_BASE_CLASS_NAME(StandAloneEngine);
 };

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -37,17 +37,7 @@
 }
 
 
-void StrainRecorder::registerAttributes()
-{
-	DataRecorder::registerAttributes();
-	REGISTER_ATTRIBUTE(outputFile);
-	REGISTER_ATTRIBUTE(interval);
-	REGISTER_ATTRIBUTE(subscribedBodies);
-	REGISTER_ATTRIBUTE(initialLength);
-	REGISTER_ATTRIBUTE(only_stress);
-}
 
-
 bool StrainRecorder::isActivated(MetaBody*)
 {
 	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.hpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -28,16 +28,15 @@
 
 		StrainRecorder ();
 
-		virtual void registerAttributes();
 		virtual void action(MetaBody*);
 		virtual bool isActivated(MetaBody*);
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_ATTRIBUTES(DataRecorder,(outputFile)(interval)(subscribedBodies)(initialLength)(only_stress));
 	REGISTER_CLASS_NAME(StrainRecorder);
 	REGISTER_BASE_CLASS_NAME(DataRecorder);
 };
-
 REGISTER_SERIALIZABLE(StrainRecorder);
 
 

Modified: trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -271,205 +271,7 @@
 }
 
 
-void LatticeExample::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(speciemen_size_in_meters); 	// size
-	REGISTER_ATTRIBUTE(cellsizeUnit_in_meters);	// g [m]  	- cell size
-	REGISTER_ATTRIBUTE(minAngle_betweenBeams_deg); 	// a [deg] 	- min angle
-        REGISTER_ATTRIBUTE(disorder_in_cellsizeUnit);   // s [-]        - disorder 
-        REGISTER_ATTRIBUTE(maxLength_in_cellsizeUnit);  // r [-]        - max beam length
-	REGISTER_ATTRIBUTE(use_Delaunay);
-        
-        REGISTER_ATTRIBUTE(crit_TensileStrain);         // E_min [%]    - default 0.02 %
-        REGISTER_ATTRIBUTE(crit_ComprStrain);           // E_max [%]    - default 0.2 %
-        REGISTER_ATTRIBUTE(longitudalStiffness_noUnit); // k_l [-]      - default 1.0
-        REGISTER_ATTRIBUTE(bendingStiffness_noUnit);    // k_b [-]      - default 0.6
-        REGISTER_ATTRIBUTE(torsionalStiffness_noUnit);  // k_t [-]      - default 0.6
-        
-	REGISTER_ATTRIBUTE(ignore_DOFs__better_is_OFF);
-        REGISTER_ATTRIBUTE(ensure2D);
-        REGISTER_ATTRIBUTE(roughEdges);
-        REGISTER_ATTRIBUTE(calculate_Torsion_3D);
-        REGISTER_ATTRIBUTE(quads);
-        
-        REGISTER_ATTRIBUTE(triangularBaseGrid);         //              - triangles
-        REGISTER_ATTRIBUTE(triangularBaseGrid3D);       //              - triangles 3d
-        REGISTER_ATTRIBUTE(useBendTensileSoftening);
-        REGISTER_ATTRIBUTE(useStiffnessSoftening);
-        REGISTER_ATTRIBUTE(useNonLocalModel);
-        REGISTER_ATTRIBUTE(nonLocalL_in_cellsizeUnit);  // l
-        
-	REGISTER_ATTRIBUTE(region_single_node_ABCDEF);
 
-	REGISTER_ATTRIBUTE(region_A_min);
-	REGISTER_ATTRIBUTE(region_A_max);
-	REGISTER_ATTRIBUTE(direction_A);
-	REGISTER_ATTRIBUTE(blocked_xyz_A);
-	REGISTER_ATTRIBUTE(displacement_A_meters);
-	
-	REGISTER_ATTRIBUTE(region_B_min);
-	REGISTER_ATTRIBUTE(region_B_max);
-	REGISTER_ATTRIBUTE(direction_B);
-	REGISTER_ATTRIBUTE(blocked_xyz_B);
-	REGISTER_ATTRIBUTE(displacement_B_meters);
-	
-	REGISTER_ATTRIBUTE(region_C_min);
-	REGISTER_ATTRIBUTE(region_C_max);
-	REGISTER_ATTRIBUTE(direction_C);
-	REGISTER_ATTRIBUTE(blocked_xyz_C);
-	REGISTER_ATTRIBUTE(displacement_C_meters);
-	
-	REGISTER_ATTRIBUTE(region_D_min);
-        REGISTER_ATTRIBUTE(region_D_max);
-        REGISTER_ATTRIBUTE(direction_D);
-	REGISTER_ATTRIBUTE(blocked_xyz_D);
-        REGISTER_ATTRIBUTE(displacement_D_meters);
-        
-	REGISTER_ATTRIBUTE(region_E_min);
-        REGISTER_ATTRIBUTE(region_E_max);
-        REGISTER_ATTRIBUTE(direction_E);
-	REGISTER_ATTRIBUTE(blocked_xyz_E);
-        REGISTER_ATTRIBUTE(displacement_E_meters);
-        
-	REGISTER_ATTRIBUTE(region_F_min);
-        REGISTER_ATTRIBUTE(region_F_max);
-        REGISTER_ATTRIBUTE(direction_F);
-	REGISTER_ATTRIBUTE(blocked_xyz_F);
-        REGISTER_ATTRIBUTE(displacement_F_meters);
-        
-	REGISTER_ATTRIBUTE(outputFile);
-        REGISTER_ATTRIBUTE(strainRecorder_xz_plane);
-        REGISTER_ATTRIBUTE(strainRecorder_node1);
-        REGISTER_ATTRIBUTE(strainRecorder_node2);
-
-        REGISTER_ATTRIBUTE(poissonFile);
-        REGISTER_ATTRIBUTE(measurePoisson_node3);
-        REGISTER_ATTRIBUTE(measurePoisson_node4);
-
-
-	REGISTER_ATTRIBUTE(nodeRecorderFile);
-	REGISTER_ATTRIBUTE(record_only_matrix);
-	REGISTER_ATTRIBUTE(nodeRec_A_min);
-	REGISTER_ATTRIBUTE(nodeRec_A_max);
-	REGISTER_ATTRIBUTE(nodeRec_B_min);
-	REGISTER_ATTRIBUTE(nodeRec_B_max);
-	REGISTER_ATTRIBUTE(nodeRec_C_min);
-	REGISTER_ATTRIBUTE(nodeRec_C_max);
-	REGISTER_ATTRIBUTE(nodeRec_D_min);
-	REGISTER_ATTRIBUTE(nodeRec_D_max);
-	REGISTER_ATTRIBUTE(nodeRec_E_min);
-	REGISTER_ATTRIBUTE(nodeRec_E_max);
-	REGISTER_ATTRIBUTE(nodeRec_F_min);
-	REGISTER_ATTRIBUTE(nodeRec_F_max);
-	
-	REGISTER_ATTRIBUTE(beamRecorderFile);
-	REGISTER_ATTRIBUTE(beamRec_A_dir);
-	REGISTER_ATTRIBUTE(beamRec_A_pos);
-	REGISTER_ATTRIBUTE(beamRec_A_range);
-	REGISTER_ATTRIBUTE(beamRec_B_dir);
-	REGISTER_ATTRIBUTE(beamRec_B_pos);
-	REGISTER_ATTRIBUTE(beamRec_B_range);
-	REGISTER_ATTRIBUTE(beamRec_C_dir);
-	REGISTER_ATTRIBUTE(beamRec_C_pos);
-	REGISTER_ATTRIBUTE(beamRec_C_range);
-	REGISTER_ATTRIBUTE(beamRec_D_dir);
-	REGISTER_ATTRIBUTE(beamRec_D_pos);
-	REGISTER_ATTRIBUTE(beamRec_D_range);
-	REGISTER_ATTRIBUTE(beamRec_E_dir);
-	REGISTER_ATTRIBUTE(beamRec_E_pos);
-	REGISTER_ATTRIBUTE(beamRec_E_range);
-
-	REGISTER_ATTRIBUTE(movSupp_A_dir);
-	REGISTER_ATTRIBUTE(movSupp_A_pos);
-	REGISTER_ATTRIBUTE(movSupp_A_range);
-	REGISTER_ATTRIBUTE(movSupp_B_dir);
-	REGISTER_ATTRIBUTE(movSupp_B_pos);
-	REGISTER_ATTRIBUTE(movSupp_B_range);
-	REGISTER_ATTRIBUTE(movSupp_C_dir);
-	REGISTER_ATTRIBUTE(movSupp_C_pos);
-	REGISTER_ATTRIBUTE(movSupp_C_range);
-	REGISTER_ATTRIBUTE(movSupp_D_dir);
-	REGISTER_ATTRIBUTE(movSupp_D_pos);
-	REGISTER_ATTRIBUTE(movSupp_D_range);
-
-        REGISTER_ATTRIBUTE(regionDelete_A_min);
-        REGISTER_ATTRIBUTE(regionDelete_A_max);
-        REGISTER_ATTRIBUTE(regionDelete_B_min);
-        REGISTER_ATTRIBUTE(regionDelete_B_max);
-        REGISTER_ATTRIBUTE(regionDelete_C_min);
-        REGISTER_ATTRIBUTE(regionDelete_C_max);
-        REGISTER_ATTRIBUTE(regionDelete_D_min);
-        REGISTER_ATTRIBUTE(regionDelete_D_max);
-        REGISTER_ATTRIBUTE(regionDelete_E_min);
-        REGISTER_ATTRIBUTE(regionDelete_E_max);
-        REGISTER_ATTRIBUTE(regionDelete_F_min);
-        REGISTER_ATTRIBUTE(regionDelete_F_max);
-
-        REGISTER_ATTRIBUTE(regionDelete_1_min);
-        REGISTER_ATTRIBUTE(regionDelete_1_max);
-        REGISTER_ATTRIBUTE(regionDelete_2_min);
-        REGISTER_ATTRIBUTE(regionDelete_2_max);
-        REGISTER_ATTRIBUTE(regionDelete_3_min);
-        REGISTER_ATTRIBUTE(regionDelete_3_max);
-        REGISTER_ATTRIBUTE(regionDelete_4_min);
-        REGISTER_ATTRIBUTE(regionDelete_4_max);
-        REGISTER_ATTRIBUTE(regionDelete_5_min);
-        REGISTER_ATTRIBUTE(regionDelete_5_max);
-
-        REGISTER_ATTRIBUTE(nonDestroy_A_min);
-        REGISTER_ATTRIBUTE(nonDestroy_A_max);
-        REGISTER_ATTRIBUTE(nonDestroy_B_min);
-        REGISTER_ATTRIBUTE(nonDestroy_B_max);
-        REGISTER_ATTRIBUTE(nonDestroy_stiffness);
-       
-	REGISTER_ATTRIBUTE(CT);
-	REGISTER_ATTRIBUTE(CT_A_min);
-        REGISTER_ATTRIBUTE(CT_A_max);
-        REGISTER_ATTRIBUTE(CT_B_min);
-        REGISTER_ATTRIBUTE(CT_B_max);
-
-        REGISTER_ATTRIBUTE(useAggregates);
-	REGISTER_ATTRIBUTE(no_Agg_outside);
-        REGISTER_ATTRIBUTE(aggregatePercent);
-        REGISTER_ATTRIBUTE(aggregateMeanDiameter);
-        REGISTER_ATTRIBUTE(aggregateSigmaDiameter);
-        REGISTER_ATTRIBUTE(aggregateMinDiameter);
-        REGISTER_ATTRIBUTE(aggregateMaxDiameter);
-        // MaterialParameters of aggregate
-        REGISTER_ATTRIBUTE(agg_longStiffness_noUnit);
-        REGISTER_ATTRIBUTE(agg_bendStiffness_noUnit);
-        REGISTER_ATTRIBUTE(agg_torsStiffness_noUnit);
-        REGISTER_ATTRIBUTE(agg_critCompressStrain);
-        REGISTER_ATTRIBUTE(agg_critTensileStrain);
-        // MaterialParameters of bond
-        REGISTER_ATTRIBUTE(bond_longStiffness_noUnit);
-        REGISTER_ATTRIBUTE(bond_bendStiffness_noUnit);
-        REGISTER_ATTRIBUTE(bond_torsStiffness_noUnit);
-        REGISTER_ATTRIBUTE(bond_critCompressStrain);
-        REGISTER_ATTRIBUTE(bond_critTensileStrain);
-        // MaterialParameters of steel fibres
-        REGISTER_ATTRIBUTE(fibre_longStiffness_noUnit);      // k_l fibre
-        REGISTER_ATTRIBUTE(fibre_bendStiffness_noUnit);      // k_b fibre
-        REGISTER_ATTRIBUTE(fibre_torsStiffness_noUnit);      // k_t fibre
-        REGISTER_ATTRIBUTE(fibre_critCompressStrain);        // E.c fibre
-        REGISTER_ATTRIBUTE(fibre_critTensileStrain);         // E.l fibre
-	REGISTER_ATTRIBUTE(fibre_count);
-	REGISTER_ATTRIBUTE(beams_per_fibre);
-	REGISTER_ATTRIBUTE(fibre_allows);
-	//REGISTER_ATTRIBUTE(fibre_irregularity_noUnit);
-	REGISTER_ATTRIBUTE(fibre_balancing_iterations);
-        // MaterialParameters of fibre bond
-        REGISTER_ATTRIBUTE(fibre_bond_longStiffness_noUnit);  // k_l fibre bond
-        REGISTER_ATTRIBUTE(fibre_bond_bendStiffness_noUnit);  // k_b fibre bond
-        REGISTER_ATTRIBUTE(fibre_bond_torsStiffness_noUnit);  // k_t fibre bond
-        REGISTER_ATTRIBUTE(fibre_bond_critCompressStrain);    // E.c fibre bond
-        REGISTER_ATTRIBUTE(fibre_bond_critTensileStrain);     // E.l fibre bond
-
-	REGISTER_ATTRIBUTE(fibres_horizontal);
-	REGISTER_ATTRIBUTE(fibres_vertical);
-}
-
 bool LatticeExample::generate()
 {
 	fibres_total=0;

Modified: trunk/pkg/lattice/PreProcessor/LatticeExample.hpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExample.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/PreProcessor/LatticeExample.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -296,10 +296,205 @@
                 void modifyCT(shared_ptr&lt;MetaBody&gt;&amp; rootBody, Vector3r min, Vector3r max);
 		void makeFibres();
 
-                virtual void registerAttributes();
                 REGISTER_CLASS_NAME(LatticeExample);
 		REGISTER_BASE_CLASS_NAME(FileGenerator);
 
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(speciemen_size_in_meters) 	// size
+		(cellsizeUnit_in_meters)	// g [m]  	- cell size
+		(minAngle_betweenBeams_deg) 	// a [deg] 	- min angle
+			  (disorder_in_cellsizeUnit)   // s [-]        - disorder 
+			  (maxLength_in_cellsizeUnit)  // r [-]        - max beam length
+		(use_Delaunay)
+			  
+			  (crit_TensileStrain)         // E_min [%]    - default 0.02 %
+			  (crit_ComprStrain)           // E_max [%]    - default 0.2 %
+			  (longitudalStiffness_noUnit) // k_l [-]      - default 1.0
+			  (bendingStiffness_noUnit)    // k_b [-]      - default 0.6
+			  (torsionalStiffness_noUnit)  // k_t [-]      - default 0.6
+			  
+		(ignore_DOFs__better_is_OFF)
+			  (ensure2D)
+			  (roughEdges)
+			  (calculate_Torsion_3D)
+			  (quads)
+			  
+			  (triangularBaseGrid)         //              - triangles
+			  (triangularBaseGrid3D)       //              - triangles 3d
+			  (useBendTensileSoftening)
+			  (useStiffnessSoftening)
+			  (useNonLocalModel)
+			  (nonLocalL_in_cellsizeUnit)  // l
+			  
+		(region_single_node_ABCDEF)
+
+		(region_A_min)
+		(region_A_max)
+		(direction_A)
+		(blocked_xyz_A)
+		(displacement_A_meters)
+		
+		(region_B_min)
+		(region_B_max)
+		(direction_B)
+		(blocked_xyz_B)
+		(displacement_B_meters)
+		
+		(region_C_min)
+		(region_C_max)
+		(direction_C)
+		(blocked_xyz_C)
+		(displacement_C_meters)
+		
+		(region_D_min)
+			  (region_D_max)
+			  (direction_D)
+		(blocked_xyz_D)
+			  (displacement_D_meters)
+			  
+		(region_E_min)
+			  (region_E_max)
+			  (direction_E)
+		(blocked_xyz_E)
+			  (displacement_E_meters)
+			  
+		(region_F_min)
+			  (region_F_max)
+			  (direction_F)
+		(blocked_xyz_F)
+			  (displacement_F_meters)
+			  
+		(outputFile)
+			  (strainRecorder_xz_plane)
+			  (strainRecorder_node1)
+			  (strainRecorder_node2)
+
+			  (poissonFile)
+			  (measurePoisson_node3)
+			  (measurePoisson_node4)
+
+
+		(nodeRecorderFile)
+		(record_only_matrix)
+		(nodeRec_A_min)
+		(nodeRec_A_max)
+		(nodeRec_B_min)
+		(nodeRec_B_max)
+		(nodeRec_C_min)
+		(nodeRec_C_max)
+		(nodeRec_D_min)
+		(nodeRec_D_max)
+		(nodeRec_E_min)
+		(nodeRec_E_max)
+		(nodeRec_F_min)
+		(nodeRec_F_max)
+		
+		(beamRecorderFile)
+		(beamRec_A_dir)
+		(beamRec_A_pos)
+		(beamRec_A_range)
+		(beamRec_B_dir)
+		(beamRec_B_pos)
+		(beamRec_B_range)
+		(beamRec_C_dir)
+		(beamRec_C_pos)
+		(beamRec_C_range)
+		(beamRec_D_dir)
+		(beamRec_D_pos)
+		(beamRec_D_range)
+		(beamRec_E_dir)
+		(beamRec_E_pos)
+		(beamRec_E_range)
+
+		(movSupp_A_dir)
+		(movSupp_A_pos)
+		(movSupp_A_range)
+		(movSupp_B_dir)
+		(movSupp_B_pos)
+		(movSupp_B_range)
+		(movSupp_C_dir)
+		(movSupp_C_pos)
+		(movSupp_C_range)
+		(movSupp_D_dir)
+		(movSupp_D_pos)
+		(movSupp_D_range)
+
+			  (regionDelete_A_min)
+			  (regionDelete_A_max)
+			  (regionDelete_B_min)
+			  (regionDelete_B_max)
+			  (regionDelete_C_min)
+			  (regionDelete_C_max)
+			  (regionDelete_D_min)
+			  (regionDelete_D_max)
+			  (regionDelete_E_min)
+			  (regionDelete_E_max)
+			  (regionDelete_F_min)
+			  (regionDelete_F_max)
+
+			  (regionDelete_1_min)
+			  (regionDelete_1_max)
+			  (regionDelete_2_min)
+			  (regionDelete_2_max)
+			  (regionDelete_3_min)
+			  (regionDelete_3_max)
+			  (regionDelete_4_min)
+			  (regionDelete_4_max)
+			  (regionDelete_5_min)
+			  (regionDelete_5_max)
+
+			  (nonDestroy_A_min)
+			  (nonDestroy_A_max)
+			  (nonDestroy_B_min)
+			  (nonDestroy_B_max)
+			  (nonDestroy_stiffness)
+			 
+		(CT)
+		(CT_A_min)
+			  (CT_A_max)
+			  (CT_B_min)
+			  (CT_B_max)
+
+			  (useAggregates)
+		(no_Agg_outside)
+			  (aggregatePercent)
+			  (aggregateMeanDiameter)
+			  (aggregateSigmaDiameter)
+			  (aggregateMinDiameter)
+			  (aggregateMaxDiameter)
+			  // MaterialParameters of aggregate
+			  (agg_longStiffness_noUnit)
+			  (agg_bendStiffness_noUnit)
+			  (agg_torsStiffness_noUnit)
+			  (agg_critCompressStrain)
+			  (agg_critTensileStrain)
+			  // MaterialParameters of bond
+			  (bond_longStiffness_noUnit)
+			  (bond_bendStiffness_noUnit)
+			  (bond_torsStiffness_noUnit)
+			  (bond_critCompressStrain)
+			  (bond_critTensileStrain)
+			  // MaterialParameters of steel fibres
+			  (fibre_longStiffness_noUnit)      // k_l fibre
+			  (fibre_bendStiffness_noUnit)      // k_b fibre
+			  (fibre_torsStiffness_noUnit)      // k_t fibre
+			  (fibre_critCompressStrain)        // E.c fibre
+			  (fibre_critTensileStrain)         // E.l fibre
+		(fibre_count)
+		(beams_per_fibre)
+		(fibre_allows)
+		//(fibre_irregularity_noUnit)
+		(fibre_balancing_iterations)
+			  // MaterialParameters of fibre bond
+			  (fibre_bond_longStiffness_noUnit)  // k_l fibre bond
+			  (fibre_bond_bendStiffness_noUnit)  // k_b fibre bond
+			  (fibre_bond_torsStiffness_noUnit)  // k_t fibre bond
+			  (fibre_bond_critCompressStrain)    // E.c fibre bond
+			  (fibre_bond_critTensileStrain)     // E.l fibre bond
+
+		(fibres_horizontal)
+		(fibres_vertical)
+);
 };
 
 REGISTER_SERIALIZABLE(LatticeExample);

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -68,34 +68,6 @@
 
 }
 
-
-void LatticeExampleCTData::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-
-	// mesh generation
-	REGISTER_ATTRIBUTE(speciemen_size_in_meters);     // size
-	REGISTER_ATTRIBUTE(cell_size_in_meters);          // g [m]        - cell size
-	REGISTER_ATTRIBUTE(disorder_in_cellsize_unit);    // s [-]        - disorder 
-
-// we can hide this parameter, because it's less important, just comment this line
-	REGISTER_ATTRIBUTE(max_rod_length_in_cellsize_unit);
-
-	// MaterialParameters of cement matrix
-	REGISTER_ATTRIBUTE(crit_tensile_strain);           // E_min [%]    - default 0.02 %
-	REGISTER_ATTRIBUTE(crit_compr_strain);             // E_max [%]    - default 0.2 %
-	REGISTER_ATTRIBUTE(longitudal_stiffness_no_unit); // k_l [-]      - default 1.0
-	REGISTER_ATTRIBUTE(bending_stiffness_no_unit);    // k_b [-]      - default 0.6
-	REGISTER_ATTRIBUTE(torsional_stiffness_no_unit);  // k_t [-]      - default 0.6
-
-	// conditions - displacement of top &amp; bottom
-	REGISTER_ATTRIBUTE(smooth_edges_displacement);
-	REGISTER_ATTRIBUTE(y_top_bottom_displ_in_meters);
-
-	//CT data file name
-	REGISTER_ATTRIBUTE(ct_data_file_name);
-}
-
 bool LatticeExampleCTData::generate()
 {
 	vector&lt;vector&lt;vector&lt;unsigned char&gt; &gt; &gt; ct_data;

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.hpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -63,9 +63,31 @@
 		void calcAxisAngle(LatticeBeamParameters* beam1, BodyContainer* bodies, int otherId, InteractionContainer* ints, int thisId);
 		void imposeTranslation(shared_ptr&lt;MetaBody&gt;&amp; rootBody, Vector3r min, Vector3r max, Vector3r direction, Real displacement);
 
-                virtual void registerAttributes();
                 REGISTER_CLASS_NAME(LatticeExampleCTData);
 		REGISTER_BASE_CLASS_NAME(FileGenerator);
+	REGISTER_ATTRIBUTES(FileGenerator,
+		// mesh generation
+		(speciemen_size_in_meters)     // size
+		(cell_size_in_meters)          // g [m]        - cell size
+		(disorder_in_cellsize_unit)    // s [-]        - disorder 
+
+	// we can hide this parameter, because it's less important, just comment this line
+		(max_rod_length_in_cellsize_unit)
+
+		// MaterialParameters of cement matrix
+		(crit_tensile_strain)           // E_min [%]    - default 0.02 %
+		(crit_compr_strain)             // E_max [%]    - default 0.2 %
+		(longitudal_stiffness_no_unit) // k_l [-]      - default 1.0
+		(bending_stiffness_no_unit)    // k_b [-]      - default 0.6
+		(torsional_stiffness_no_unit)  // k_t [-]      - default 0.6
+
+		// conditions - displacement of top &amp; bottom
+		(smooth_edges_displacement)
+		(y_top_bottom_displ_in_meters)
+
+		//CT data file name
+		(ct_data_file_name)
+	);
 };
 
 REGISTER_SERIALIZABLE(LatticeExampleCTData);

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -65,30 +65,7 @@
 }
 
 
-void LatticeExampleSimple::registerAttributes()
-{
-	FileGenerator::registerAttributes();
 
-	// mesh generation
-	REGISTER_ATTRIBUTE(speciemen_size_in_meters);     // size
-	REGISTER_ATTRIBUTE(cell_size_in_meters);          // g [m]        - cell size
-	REGISTER_ATTRIBUTE(disorder_in_cellsize_unit);    // s [-]        - disorder 
-
-// we can hide this parameter, because it's less important, just comment this line
-	REGISTER_ATTRIBUTE(max_rod_length_in_cellsize_unit);
-
-	// MaterialParameters of cement matrix
-	REGISTER_ATTRIBUTE(crit_tensile_strain);           // E_min [%]    - default 0.02 %
-	REGISTER_ATTRIBUTE(crit_compr_strain);             // E_max [%]    - default 0.2 %
-	REGISTER_ATTRIBUTE(longitudal_stiffness_no_unit); // k_l [-]      - default 1.0
-	REGISTER_ATTRIBUTE(bending_stiffness_no_unit);    // k_b [-]      - default 0.6
-	REGISTER_ATTRIBUTE(torsional_stiffness_no_unit);  // k_t [-]      - default 0.6
-
-	// conditions - displacement of top &amp; bottom
-	REGISTER_ATTRIBUTE(smooth_edges_displacement);
-	REGISTER_ATTRIBUTE(y_top_bottom_displ_in_meters);
-}
-
 bool LatticeExampleSimple::generate()
 {
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.hpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -60,9 +60,28 @@
 		void calcAxisAngle(LatticeBeamParameters* beam1, BodyContainer* bodies, int otherId, InteractionContainer* ints, int thisId);
 		void imposeTranslation(shared_ptr&lt;MetaBody&gt;&amp; rootBody, Vector3r min, Vector3r max, Vector3r direction, Real displacement);
 
-                virtual void registerAttributes();
                 REGISTER_CLASS_NAME(LatticeExampleSimple);
 		REGISTER_BASE_CLASS_NAME(FileGenerator);
+	REGISTER_ATTRIBUTES(FileGenerator,
+		// mesh generation
+		(speciemen_size_in_meters)     // size
+		(cell_size_in_meters)          // g [m]        - cell size
+		(disorder_in_cellsize_unit)    // s [-]        - disorder 
+
+		// we can hide this parameter, because it's less important, just comment this line
+		(max_rod_length_in_cellsize_unit)
+
+		// MaterialParameters of cement matrix
+		(crit_tensile_strain)           // E_min [%]    - default 0.02 %
+		(crit_compr_strain)             // E_max [%]    - default 0.2 %
+		(longitudal_stiffness_no_unit) // k_l [-]      - default 1.0
+		(bending_stiffness_no_unit)    // k_b [-]      - default 0.6
+		(torsional_stiffness_no_unit)  // k_t [-]      - default 0.6
+
+		// conditions - displacement of top &amp; bottom
+		(smooth_edges_displacement)
+		(y_top_bottom_displ_in_meters)
+	)
 };
 
 REGISTER_SERIALIZABLE(LatticeExampleSimple);

Modified: trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.cpp
===================================================================
--- trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,10 +17,5 @@
 {
 }
 
-void SpringGeometry::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(p1);
-	REGISTER_ATTRIBUTE(p2);
-}
 
 YADE_PLUGIN();

Modified: trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.hpp
===================================================================
--- trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/DataClass/InteractionGeometry/SpringGeometry.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,8 +20,7 @@
 		SpringGeometry();
 		virtual ~SpringGeometry();
 	
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionGeometry,(p1)(p2));
 	REGISTER_CLASS_NAME(SpringGeometry);
 	REGISTER_BASE_CLASS_NAME(InteractionGeometry);
 

Modified: trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.cpp
===================================================================
--- trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,11 +17,5 @@
 {
 }
 
-void SpringPhysics::registerAttributes()
-{
-	REGISTER_ATTRIBUTE(stiffness);
-	REGISTER_ATTRIBUTE(damping);
-	REGISTER_ATTRIBUTE(initialLength);
-}
 
 YADE_PLUGIN();

Modified: trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.hpp
===================================================================
--- trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/DataClass/InteractionPhysics/SpringPhysics.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -20,8 +20,7 @@
 		SpringPhysics();
 		virtual ~SpringPhysics();
 
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionPhysics,(stiffness)(damping)(initialLength));
 	REGISTER_CLASS_NAME(SpringPhysics);
 	REGISTER_BASE_CLASS_NAME(InteractionPhysics);
 

Modified: trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp
===================================================================
--- trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,11 +21,6 @@
 }
 
 
-void MassSpringLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(springGroupMask);
-}
 
 
 void MassSpringLaw::action(MetaBody * massSpring)

Modified: trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.hpp
===================================================================
--- trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,8 +17,7 @@
 		MassSpringLaw ();
 		void action(MetaBody*);
 
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(springGroupMask));
 	REGISTER_CLASS_NAME(MassSpringLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };

Modified: trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp
===================================================================
--- trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -102,41 +102,6 @@
 }
 
 
-void HangingCloth::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(width);
-	REGISTER_ATTRIBUTE(height);
-	REGISTER_ATTRIBUTE(springStiffness);
-	REGISTER_ATTRIBUTE(springDamping);
-	//REGISTER_ATTRIBUTE(particleDamping); 	// FIXME - ignored - delete it, or start using it
-	REGISTER_ATTRIBUTE(clothMass);
-	REGISTER_ATTRIBUTE(cellSize);
-	REGISTER_ATTRIBUTE(fixPoint1);
-	REGISTER_ATTRIBUTE(fixPoint2);
-	REGISTER_ATTRIBUTE(fixPoint3);
-	REGISTER_ATTRIBUTE(fixPoint4);
-	REGISTER_ATTRIBUTE(ground);
-	
-	// spheres
-	//REGISTER_ATTRIBUTE(nbSpheres);
-	//REGISTER_ATTRIBUTE(minRadius);
-	//REGISTER_ATTRIBUTE(maxRadius);
-	//rEGISTER_ATTRIBUTE(density); 		
-	//REGISTER_ATTRIBUTE(disorder);
-	//REGISTER_ATTRIBUTE(spacing);		
-	
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	//REGISTER_ATTRIBUTE(linkSpheres);
-
-//	REGISTER_ATTRIBUTE(sphereYoungModulus);
-//	REGISTER_ATTRIBUTE(spherePoissonRatio);
-//	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-}
-
-
 bool HangingCloth::generate()
 {
 	Omega::instance().setTimeStep(0.004);

Modified: trunk/pkg/mass-spring/PreProcessor/HangingCloth.hpp
===================================================================
--- trunk/pkg/mass-spring/PreProcessor/HangingCloth.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/mass-spring/PreProcessor/HangingCloth.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -59,8 +59,36 @@
 	
 	protected :
 		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(width)
+		(height)
+		(springStiffness)
+		(springDamping)
+		(clothMass)
+		(cellSize)
+		(fixPoint1)
+		(fixPoint2)
+		(fixPoint3)
+		(fixPoint4)
+		(ground)
+		
+		// spheres
+		//(nbSpheres)
+		//(minRadius)
+		//(maxRadius)
+		//(density) 		
+		//(disorder)
+		//(spacing)		
+		
+		(gravity)
+		(dampingForce)
+		(dampingMomentum)
+		//(linkSpheres)
 
+		//	(sphereYoungModulus)
+		//	(spherePoissonRatio)
+		//	(sphereFrictionDeg)
+	);
 	REGISTER_CLASS_NAME(HangingCloth);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp
===================================================================
--- trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -26,10 +26,6 @@
 }
 
 
-void FrictionLessElasticContactLaw::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-}
 
 
 void FrictionLessElasticContactLaw::action(MetaBody * ncb)

Modified: trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.hpp
===================================================================
--- trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -17,8 +17,7 @@
 		FrictionLessElasticContactLaw ();
 		void action(MetaBody*);
 
-	protected :
-		 void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,/* */);
 	REGISTER_CLASS_NAME(FrictionLessElasticContactLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 

Modified: trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp
===================================================================
--- trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -61,23 +61,7 @@
 }
 
 
-void BoxStack::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbBoxes);
-	REGISTER_ATTRIBUTE(boxSize);
-	REGISTER_ATTRIBUTE(boxDensity);
-//	REGISTER_ATTRIBUTE(kinematicBullet);
-	REGISTER_ATTRIBUTE(bulletSize);
-	REGISTER_ATTRIBUTE(bulletDensity);
-	REGISTER_ATTRIBUTE(bulletPosition);
-	REGISTER_ATTRIBUTE(bulletVelocity);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-}
 
-
 bool BoxStack::generate()
 {
 	Omega::instance().setTimeStep(0.04);

Modified: trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.hpp
===================================================================
--- trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -31,8 +31,6 @@
 		BoxStack ();
 		virtual ~BoxStack ();
 
-		virtual void registerAttributes();
-		
 		virtual bool generate();
 
 	private :
@@ -41,7 +39,7 @@
 		void createBox(shared_ptr&lt;Body&gt;&amp; body, int i, int j, int k);
 		void createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		void positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
-
+	REGISTER_ATTRIBUTES(FileGenerator,(nbBoxes)(boxSize)(boxDensity)(bulletSize)(bulletDensity)(bulletPosition)(bulletVelocity)(gravity)(dampingForce)(dampingMomentum));
 	REGISTER_CLASS_NAME(BoxStack);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 

Modified: trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp
===================================================================
--- trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -62,24 +62,6 @@
 }
 
 
-void RotatingBox::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(nbSpheres);
-	REGISTER_ATTRIBUTE(nbBoxes);
-	REGISTER_ATTRIBUTE(minSize);
-	REGISTER_ATTRIBUTE(maxSize);
-	REGISTER_ATTRIBUTE(densityBox);
-	REGISTER_ATTRIBUTE(densitySphere);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-	REGISTER_ATTRIBUTE(isRotating);
-	REGISTER_ATTRIBUTE(rotationSpeed);
-	REGISTER_ATTRIBUTE(rotationAxis);
-	REGISTER_ATTRIBUTE(middleWireFrame);
-//	REGISTER_ATTRIBUTE(disorder);
-}
 
 
 bool RotatingBox::generate()

Modified: trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.hpp
===================================================================
--- trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -41,8 +41,7 @@
 		~RotatingBox ();
 		virtual bool generate();
 	
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,(nbSpheres)(nbBoxes)(minSize)(maxSize)(densityBox)(densitySphere)(gravity)(dampingForce)(dampingMomentum)(isRotating)(rotationSpeed)(rotationAxis)(middleWireFrame));
 	REGISTER_CLASS_NAME(RotatingBox);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/snow/DataClass/BshSnowGrain.cpp
===================================================================
--- trunk/pkg/snow/DataClass/BshSnowGrain.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/DataClass/BshSnowGrain.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -5,19 +5,6 @@
 // the sample was 10.4mm hight
 
 
-void BshSnowGrain::registerAttributes()
-{
-	GeometricalModel::registerAttributes();
-	REGISTER_ATTRIBUTE(center);
-	REGISTER_ATTRIBUTE(c_axis);
-	REGISTER_ATTRIBUTE(start);
-	REGISTER_ATTRIBUTE(end);
-	REGISTER_ATTRIBUTE(color);
-	REGISTER_ATTRIBUTE(selection);
-	REGISTER_ATTRIBUTE(layer_distance);
-	REGISTER_ATTRIBUTE(gr_gr); // slices
-}
-
 BshSnowGrain::BshSnowGrain(const T_DATA&amp; dat,Vector3r c_ax,int SELECTION,Vector3r col, Real one_voxel_in_meters_is,Real layer_distance_voxels,Real angle_increment) : GeometricalModel()
 {
 	createIndex();

Modified: trunk/pkg/snow/DataClass/BshSnowGrain.hpp
===================================================================
--- trunk/pkg/snow/DataClass/BshSnowGrain.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/DataClass/BshSnowGrain.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -21,10 +21,7 @@
 		Grrrr(){};
 		Grrrr(std::vector&lt;Vector3r&gt;&amp; g):grr(g){};
 	protected :
-		void registerAttributes()
-		{
-			REGISTER_ATTRIBUTE(grr);
-		}
+		REGISTER_ATTRIBUTES(/* */, (grr));
 	REGISTER_CLASS_NAME(Grrrr);
 	REGISTER_BASE_CLASS_NAME(Serializable);
 };
@@ -93,7 +90,16 @@
 		}
 	
 	protected :
-		void registerAttributes();
+		REGISTER_ATTRIBUTES(GeometricalModel,
+			(center)
+			(c_axis)
+			(start)
+			(end)
+			(color)
+			(selection)
+			(layer_distance)
+			(gr_gr) // slices
+		);
 		void preProcessAttributes(bool loading)
 		{
 			if(!loading)

Modified: trunk/pkg/snow/DataClass/BssSnowGrain.cpp
===================================================================
--- trunk/pkg/snow/DataClass/BssSnowGrain.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/DataClass/BssSnowGrain.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -8,12 +8,6 @@
 	createIndex();
 };
 
-void BssSnowGrain::registerAttributes()
-{
-	InteractingSphere::registerAttributes();
-	REGISTER_ATTRIBUTE(m_copy);
-}
-
 BssSnowGrain::BssSnowGrain(BshSnowGrain* grain, Real one_voxel_in_meters_is)
 {
 	createIndex();

Modified: trunk/pkg/snow/DataClass/BssSnowGrain.hpp
===================================================================
--- trunk/pkg/snow/DataClass/BssSnowGrain.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/DataClass/BssSnowGrain.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -54,8 +54,9 @@
 		BssSnowGrain();
 		BssSnowGrain(BshSnowGrain* grain, Real one_voxel_in_meters_is);
 	
-	protected :
-		void registerAttributes();
+	// FIXME: BssSnowGrain has no copy-constructor; will be inaccessible from python
+	// REGISTER_ATTRIBUTES(InteractingSphere,(m_copy));
+	virtual void registerAttributes(){ InteractingSphere::registerAttributes(); REGISTER_ATTRIBUTE_(m_copy); }
 	REGISTER_CLASS_NAME(BssSnowGrain);
 	REGISTER_BASE_CLASS_NAME(InteractingSphere);
 	REGISTER_CLASS_INDEX(BssSnowGrain,InteractingSphere);

Modified: trunk/pkg/snow/DataClass/IstSnowLayersContact.cpp
===================================================================
--- trunk/pkg/snow/DataClass/IstSnowLayersContact.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/DataClass/IstSnowLayersContact.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -8,8 +8,3 @@
 IstSnowLayersContact::~IstSnowLayersContact()
 {}
 		
-void IstSnowLayersContact::registerAttributes()
-{
-	SpheresContactGeometry::registerAttributes();
-}
-

Modified: trunk/pkg/snow/DataClass/IstSnowLayersContact.hpp
===================================================================
--- trunk/pkg/snow/DataClass/IstSnowLayersContact.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/DataClass/IstSnowLayersContact.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -11,9 +11,7 @@
 		IstSnowLayersContact();
 		virtual ~IstSnowLayersContact();
 
-	protected :
-		virtual void registerAttributes();
-
+	REGISTER_ATTRIBUTES(SpheresContactGeometry,/* */);
 	REGISTER_CLASS_NAME(IstSnowLayersContact);
 	REGISTER_BASE_CLASS_NAME(SpheresContactGeometry);
 	REGISTER_CLASS_INDEX(IstSnowLayersContact,SpheresContactGeometry);

Modified: trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.cpp
===================================================================
--- trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -118,9 +118,6 @@
 {
 }
 
-void Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact::registerAttributes()
-{	
-}
 
 bool Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact::go(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
 							const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,

Modified: trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.hpp
===================================================================
--- trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -33,9 +33,8 @@
 	FUNCTOR2D(BssSnowGrain,BssSnowGrain);
 	
 	DEFINE_FUNCTOR_ORDER_2D(BssSnowGrain,BssSnowGrain);
-	
-	protected :
-		virtual void registerAttributes();
+
+	REGISTER_ATTRIBUTES(InteractionGeometryEngineUnit,/* */);
 };
 
 REGISTER_SERIALIZABLE(Ef2_BssSnowGrain_BssSnowGrain_makeIstSnowLayersContact);

Modified: trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -12,9 +12,6 @@
 #include&lt;yade/core/Omega.hpp&gt;
 
 
-void Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry::registerAttributes()
-{	
-}
 
 bool Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry::go(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
 							const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,

Modified: trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.hpp
===================================================================
--- trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -29,9 +29,7 @@
 	
 	//FIXME: what is this good for?!
 	DEFINE_FUNCTOR_ORDER_2D(BssSnowGrain,BssSnowGrain);
-	
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionGeometryEngineUnit,/* */);
 };
 
 REGISTER_SERIALIZABLE(Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry);

Modified: trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp
===================================================================
--- trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,13 +24,6 @@
 }
 
 
-void ElawSnowLayersDeformation::registerAttributes()
-{
-	InteractionSolver::registerAttributes();
-	REGISTER_ATTRIBUTE(sdecGroupMask);
-	REGISTER_ATTRIBUTE(creep_viscosity);
-}
-
 void ElawSnowLayersDeformation::action(MetaBody* ncb)
 {
 	//return;

Modified: trunk/pkg/snow/Engine/ElawSnowLayersDeformation.hpp
===================================================================
--- trunk/pkg/snow/Engine/ElawSnowLayersDeformation.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/Engine/ElawSnowLayersDeformation.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -24,8 +24,7 @@
 		ElawSnowLayersDeformation();
 		void action(MetaBody*);
 
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(InteractionSolver,(sdecGroupMask)(creep_viscosity));
 	REGISTER_CLASS_NAME(ElawSnowLayersDeformation);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
 };

Modified: trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp
===================================================================
--- trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -169,87 +169,8 @@
 }
 
 
-void SnowCreepTest::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(lowerCorner);
-	REGISTER_ATTRIBUTE(upperCorner);
-//.	REGISTER_ATTRIBUTE(thickness);
-//.	REGISTER_ATTRIBUTE(importFilename);
-	//REGISTER_ATTRIBUTE(nlayers);
-	//REGISTER_ATTRIBUTE(boxWalls);
-//.	REGISTER_ATTRIBUTE(internalCompaction);
-//.	REGISTER_ATTRIBUTE(maxMultiplier);
-//.	REGISTER_ATTRIBUTE(finalMaxMultiplier);
 
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
 
-        	REGISTER_ATTRIBUTE(normalCohesion);
-		REGISTER_ATTRIBUTE(shearCohesion);
-
-		REGISTER_ATTRIBUTE(setCohesionOnNewContacts);
-
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(boxFrictionDeg);
-
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(defaultDt);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-//.	REGISTER_ATTRIBUTE(rotationBlocked);
-//.	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
-//.	REGISTER_ATTRIBUTE(timeStepOutputInterval);
-//.	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
-//.	REGISTER_ATTRIBUTE(radiusControlInterval);
-	REGISTER_ATTRIBUTE(numberOfGrains);
-//.	REGISTER_ATTRIBUTE(radiusDeviation);
-//.	REGISTER_ATTRIBUTE(strainRate);
-//.	REGISTER_ATTRIBUTE(StabilityCriterion);
-//.	REGISTER_ATTRIBUTE(autoCompressionActivation);
-//	REGISTER_ATTRIBUTE(wall_top);
-//	REGISTER_ATTRIBUTE(wall_bottom);
-//	REGISTER_ATTRIBUTE(wall_1);
-//	REGISTER_ATTRIBUTE(wall_2);
-//	REGISTER_ATTRIBUTE(wall_3);
-//	REGISTER_ATTRIBUTE(wall_4);
-//	REGISTER_ATTRIBUTE(wall_top_wire);
-//	REGISTER_ATTRIBUTE(wall_bottom_wire);
-//	REGISTER_ATTRIBUTE(wall_1_wire);
-//	REGISTER_ATTRIBUTE(wall_2_wire);
-//	REGISTER_ATTRIBUTE(wall_3_wire);
-//	REGISTER_ATTRIBUTE(wall_4_wire);
-//	REGISTER_ATTRIBUTE(spheresColor);
-//	REGISTER_ATTRIBUTE(spheresRandomColor);
-//.	REGISTER_ATTRIBUTE(recordBottomForce);
-//.	REGISTER_ATTRIBUTE(forceRecordFile);
-//	REGISTER_ATTRIBUTE(recordAveragePositions);
-//.	REGISTER_ATTRIBUTE(positionRecordFile);
-//.	REGISTER_ATTRIBUTE(velocityRecordFile);
-//.	REGISTER_ATTRIBUTE(recordIntervalIter);
-//.	REGISTER_ATTRIBUTE(saveAnimationSnapshots);
-//.	REGISTER_ATTRIBUTE(AnimationSnapshotsBaseName);
-	REGISTER_ATTRIBUTE(WallStressRecordFile);
-
-//	REGISTER_ATTRIBUTE(gravity);
-	
-	//REGISTER_ATTRIBUTE(bigBall);
-	//REGISTER_ATTRIBUTE(bigBallRadius);
-	//REGISTER_ATTRIBUTE(bigBallDensity);
-	//REGISTER_ATTRIBUTE(bigBallDropTimeSeconds);
-	//REGISTER_ATTRIBUTE(bigBallFrictDeg);
-	//REGISTER_ATTRIBUTE(bigBallYoungModulus);
-	//REGISTER_ATTRIBUTE(bigBallPoissonRatio);
-	//REGISTER_ATTRIBUTE(bigBallDropHeight);
-
-		REGISTER_ATTRIBUTE(sigma_iso);
-
-        	REGISTER_ATTRIBUTE(creep_viscosity)
-}
-
-
 bool SnowCreepTest::generate()
 {
 //	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2

Modified: trunk/pkg/snow/PreProcessor/SnowCreepTest.hpp
===================================================================
--- trunk/pkg/snow/PreProcessor/SnowCreepTest.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/PreProcessor/SnowCreepTest.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -127,8 +127,83 @@
 		~SnowCreepTest ();
 		bool generate();
 	
-	protected :
-		void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(lowerCorner)
+		(upperCorner)
+	//.	(thickness)
+	//.	(importFilename)
+		//(nlayers)
+		//(boxWalls)
+	//.	(internalCompaction)
+	//.	(maxMultiplier)
+	//.	(finalMaxMultiplier)
+
+		(sphereYoungModulus)
+		(spherePoissonRatio)
+		(sphereFrictionDeg)
+
+				(normalCohesion)
+			(shearCohesion)
+
+			(setCohesionOnNewContacts)
+
+		(boxYoungModulus)
+		(boxPoissonRatio)
+		(boxFrictionDeg)
+
+		(density)
+		(defaultDt)
+		(dampingForce)
+		(dampingMomentum)
+	//.	(rotationBlocked)
+	//.	(timeStepUpdateInterval)
+	//.	(timeStepOutputInterval)
+	//.	(wallStiffnessUpdateInterval)
+	//.	(radiusControlInterval)
+		(numberOfGrains)
+	//.	(radiusDeviation)
+	//.	(strainRate)
+	//.	(StabilityCriterion)
+	//.	(autoCompressionActivation)
+	//	(wall_top)
+	//	(wall_bottom)
+	//	(wall_1)
+	//	(wall_2)
+	//	(wall_3)
+	//	(wall_4)
+	//	(wall_top_wire)
+	//	(wall_bottom_wire)
+	//	(wall_1_wire)
+	//	(wall_2_wire)
+	//	(wall_3_wire)
+	//	(wall_4_wire)
+	//	(spheresColor)
+	//	(spheresRandomColor)
+	//.	(recordBottomForce)
+	//.	(forceRecordFile)
+	//	(recordAveragePositions)
+	//.	(positionRecordFile)
+	//.	(velocityRecordFile)
+	//.	(recordIntervalIter)
+	//.	(saveAnimationSnapshots)
+	//.	(AnimationSnapshotsBaseName)
+		(WallStressRecordFile)
+
+	//	(gravity)
+		
+		//(bigBall)
+		//(bigBallRadius)
+		//(bigBallDensity)
+		//(bigBallDropTimeSeconds)
+		//(bigBallFrictDeg)
+		//(bigBallYoungModulus)
+		//(bigBallPoissonRatio)
+		//(bigBallDropHeight)
+
+			(sigma_iso)
+
+		 (creep_viscosity)
+	);
 	REGISTER_CLASS_NAME(SnowCreepTest);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp
===================================================================
--- trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -135,46 +135,6 @@
 {
 }
 
-void SnowVoxelsLoader::registerAttributes()
-{
-	FileGenerator::registerAttributes();
-	REGISTER_ATTRIBUTE(voxel_binary_data_file);
-// that was for integrating snow-read with this preprocessor, but for now it's not integrated. snow-read does the conversion separately
-//	REGISTER_ATTRIBUTE(voxel_txt_dir);
-//	REGISTER_ATTRIBUTE(voxel_caxis_file);
-//	REGISTER_ATTRIBUTE(voxel_colors_file);
-	REGISTER_ATTRIBUTE(grain_binary_data_file);
-	REGISTER_ATTRIBUTE(one_voxel_in_meters_is);
-	REGISTER_ATTRIBUTE(layer_distance_voxels);
-	REGISTER_ATTRIBUTE(angle_increment_radians);
-	REGISTER_ATTRIBUTE(skip_small_grains);
-
-	REGISTER_ATTRIBUTE(shearCohesion);
-	REGISTER_ATTRIBUTE(normalCohesion);
-        REGISTER_ATTRIBUTE(creep_viscosity)
-	REGISTER_ATTRIBUTE(use_grain_shear_creep);
-	REGISTER_ATTRIBUTE(use_grain_twist_creep);
-	REGISTER_ATTRIBUTE(enable_layers_creep);
-	REGISTER_ATTRIBUTE(layers_creep_viscosity);
-	REGISTER_ATTRIBUTE(sigma_iso);
-	REGISTER_ATTRIBUTE(setCohesionOnNewContacts);
-
-	REGISTER_ATTRIBUTE(sphereYoungModulus);
-	REGISTER_ATTRIBUTE(spherePoissonRatio);
-	REGISTER_ATTRIBUTE(sphereFrictionDeg);
-	REGISTER_ATTRIBUTE(boxYoungModulus);
-	REGISTER_ATTRIBUTE(boxPoissonRatio);
-	REGISTER_ATTRIBUTE(boxFrictionDeg);
-	REGISTER_ATTRIBUTE(density);
-	REGISTER_ATTRIBUTE(use_gravity_engine);
-	REGISTER_ATTRIBUTE(gravity);
-	REGISTER_ATTRIBUTE(dampingForce);
-	REGISTER_ATTRIBUTE(dampingMomentum);
-
-	REGISTER_ATTRIBUTE(WallStressRecordFile);
-	
-}
-
 bool SnowVoxelsLoader::load_voxels()
 {
 	if(grain_binary_data_file !=&quot;&quot; &amp;&amp; boost::filesystem::exists(grain_binary_data_file))

Modified: trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.hpp
===================================================================
--- trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.hpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.hpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -126,8 +126,42 @@
 		void create_grain(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, bool dynamic , boost::shared_ptr&lt;BshSnowGrain&gt; grain);
 		void create_box(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents, bool wire);
 	
-	protected :
-		virtual void registerAttributes();
+	REGISTER_ATTRIBUTES(FileGenerator,
+		(voxel_binary_data_file)
+		// that was for integrating snow-read with this preprocessor, but for now it's not integrated. snow-read does the conversion separately
+		//	(voxel_txt_dir)
+		//	(voxel_caxis_file)
+		//	(voxel_colors_file)
+		(grain_binary_data_file)
+		(one_voxel_in_meters_is)
+		(layer_distance_voxels)
+		(angle_increment_radians)
+		(skip_small_grains)
+
+		(shearCohesion)
+		(normalCohesion)
+			  (creep_viscosity)
+		(use_grain_shear_creep)
+		(use_grain_twist_creep)
+		(enable_layers_creep)
+		(layers_creep_viscosity)
+		(sigma_iso)
+		(setCohesionOnNewContacts)
+
+		(sphereYoungModulus)
+		(spherePoissonRatio)
+		(sphereFrictionDeg)
+		(boxYoungModulus)
+		(boxPoissonRatio)
+		(boxFrictionDeg)
+		(density)
+		(use_gravity_engine)
+		(gravity)
+		(dampingForce)
+		(dampingMomentum)
+
+		(WallStressRecordFile)
+	);
 	REGISTER_CLASS_NAME(SnowVoxelsLoader);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 };

Modified: trunk/py/SConscript
===================================================================
--- trunk/py/SConscript	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/py/SConscript	2009-07-17 21:50:55 UTC (rev 1875)
@@ -25,6 +25,7 @@
 		env.File('timing.py'),
 		env.File('pack.py'),
 		env.SharedLibrary('wrapper',['yadeWrapper/yadeWrapper.cpp'],SHLIBPREFIX='',LIBS=env['LIBS']+['XMLFormatManager','yade-factory','yade-serialization','Shop','BoundingVolumeMetaEngine','GeometricalModelMetaEngine','InteractingGeometryMetaEngine','InteractionGeometryMetaEngine','InteractionPhysicsMetaEngine','PhysicalParametersMetaEngine','ConstitutiveLawDispatcher','InteractionDispatchers','STLImporter','ParallelEngine','Clump'],),
+		env.SharedLibrary('_customConverters',['yadeWrapper/customConverters.cpp'],SHLIBPREFIX='',LIBS=env['LIBS']+['boost_python_indexing_suite_v2'])
 	])
 	if 'GTS' in env['features']: env.Depends('_packPredicates.so','$PREFIX/lib/yade$SUFFIX/py/gts/_gts.so')
 

Modified: trunk/py/utils.py
===================================================================
--- trunk/py/utils.py	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/py/utils.py	2009-07-17 21:50:55 UTC (rev 1875)
@@ -108,9 +108,7 @@
 	b.mold=InteractingGeometry('InteractingFacet',{'diffuseColor':color})
 	center=inscribedCircleCenter(vertices[0],vertices[1],vertices[2])
 	vertices=Vector3(vertices[0])-center,Vector3(vertices[1])-center,Vector3(vertices[2])-center
-	vStr='['+' '.join(['{%g %g %g}'%(v[0],v[1],v[2]) for v in vertices])+']'
-	b.shape.setRaw('vertices',vStr)
-	b.mold.setRaw('vertices',vStr)
+	b.shape['vertices']=vertices;	b.mold['vertices']=vertices
 	pp.update({'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'inertia':[0,0,0]})
 	b.phys=PhysicalParameters(physParamsClass)
 	b.phys.updateExistingAttrs(pp)

Added: trunk/py/yadeWrapper/customConverters.cpp
===================================================================
--- trunk/py/yadeWrapper/customConverters.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/py/yadeWrapper/customConverters.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,112 @@
+// 2009 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
+
+#include&lt;boost/python.hpp&gt;
+#include&lt;boost/python/suite/indexing/container_suite.hpp&gt;
+#include&lt;boost/python/suite/indexing/vector.hpp&gt;
+#include&lt;boost/python/class.hpp&gt;
+#include&lt;boost/python/module.hpp&gt;
+#include&lt;boost/foreach.hpp&gt;
+#ifndef FOREACH
+	#define FOREACH BOOST_FOREACH
+#endif
+
+#include&lt;vector&gt;
+#include&lt;string&gt;
+#include&lt;stdexcept&gt;
+#include&lt;iostream&gt;
+#include&lt;yade/lib-base/yadeWm3.hpp&gt;
+#include&lt;yade/lib-base/yadeWm3Extra.hpp&gt;
+
+
+
+using namespace boost::python;
+
+struct custom_Vector3r_from_seq{
+	custom_Vector3r_from_seq(){
+		 converter::registry::push_back(&amp;convertible,&amp;construct,type_id&lt;Vector3r&gt;());
+	}
+	static void* convertible(PyObject* obj_ptr){
+		 if(!PySequence_Check(obj_ptr) || PySequence_Size(obj_ptr)!=3) return 0;
+		 return obj_ptr;
+	}
+	static void construct(PyObject* obj_ptr, converter::rvalue_from_python_stage1_data* data){
+		 void* storage=((converter::rvalue_from_python_storage&lt;Vector3r&gt;*)(data))-&gt;storage.bytes;
+		 new (storage) Vector3r(extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,0)),extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,1)),extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,2)));
+		 data-&gt;convertible=storage;
+	}
+};
+
+/* two-way se3 handling */
+struct custom_se3_to_tuple{
+	static PyObject* convert(const Se3r&amp; se3){
+		tuple ret=make_tuple(se3.position,se3.orientation);
+		return incref(ret.ptr());
+	}
+};
+struct custom_Se3r_from_seq{
+	custom_Se3r_from_seq(){
+		 converter::registry::push_back(&amp;convertible,&amp;construct,type_id&lt;Se3r&gt;());
+	}
+	static void* convertible(PyObject* obj_ptr){
+		 if(!PySequence_Check(obj_ptr)) return 0;
+		 if(PySequence_Size(obj_ptr)!=2 &amp;&amp; PySequence_Size(obj_ptr)!=7) return 0;
+		 return obj_ptr;
+	}
+	static void construct(PyObject* obj_ptr, converter::rvalue_from_python_stage1_data* data){
+		void* storage=((converter::rvalue_from_python_storage&lt;Se3r&gt;*)(data))-&gt;storage.bytes;
+		new (storage) Se3r; Se3r* se3=(Se3r*)storage;
+		if(PySequence_Size(obj_ptr)==2){ // from vector and quaternion
+			se3-&gt;position=extract&lt;Vector3r&gt;(PySequence_GetItem(obj_ptr,0));
+			se3-&gt;orientation=extract&lt;Quaternionr&gt;(PySequence_GetItem(obj_ptr,1));
+		} else if(PySequence_Size(obj_ptr)==7){ // 3 vector components, 3 axis components, angle
+			se3-&gt;position=Vector3r(extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,0)),extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,1)),extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,2)));
+			Vector3r axis=Vector3r(extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,3)),extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,4)),extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,5)));
+			Real angle=extract&lt;Real&gt;(PySequence_GetItem(obj_ptr,6));
+			se3-&gt;orientation.FromAxisAngle(axis,angle);
+		} else throw std::logic_error(__FILE__ &quot;: First, the sequence size for Se3r object was 2 or 7, but now is not? (programming error, please report!&quot;);
+		data-&gt;convertible=storage;
+	}
+};
+
+/*** c++-vector to python-list and python-(list,sequence) to c++-vector converters ***/
+template&lt;typename containedType&gt;
+struct custom_vector_to_list{
+	static PyObject* convert(const std::vector&lt;containedType&gt;&amp; v){
+		list ret; FOREACH(const containedType&amp; e, v) ret.append(e);
+		return incref(ret.ptr());
+	}
+};
+template&lt;typename containedType&gt;
+struct custom_vector_from_seq{
+	custom_vector_from_seq(){ converter::registry::push_back(&amp;convertible,&amp;construct,type_id&lt;std::vector&lt;containedType&gt; &gt;()); }
+	static void* convertible(PyObject* obj_ptr){  if(!PySequence_Check(obj_ptr)) return 0; return obj_ptr; }
+	static void construct(PyObject* obj_ptr, converter::rvalue_from_python_stage1_data* data){
+		 void* storage=((converter::rvalue_from_python_storage&lt;std::vector&lt;containedType&gt; &gt;*)(data))-&gt;storage.bytes;
+		 new (storage) std::vector&lt;containedType&gt;();
+		 std::vector&lt;containedType&gt;* v=(std::vector&lt;containedType&gt;*)(storage);
+		 int l=PySequence_Size(obj_ptr); v-&gt;reserve(l); for(int i=0; i&lt;l; i++) { v-&gt;push_back(extract&lt;containedType&gt;(PySequence_GetItem(obj_ptr,i))); }
+		 data-&gt;convertible=storage;
+	}
+};
+
+
+
+
+using namespace boost::python;
+
+BOOST_PYTHON_MODULE(_customConverters){
+  // class_&lt;std::vector&lt;int&gt; &gt;(&quot;vecInt&quot;).def(indexing::container_suite&lt;std::vector&lt;int&gt; &gt;());
+
+  custom_Vector3r_from_seq(); // Vector3r is wrapped, it is returned as a Vector3 instance; no to-python converter needed
+  custom_Se3r_from_seq(); to_python_converter&lt;Se3r,custom_se3_to_tuple&gt;();
+  // register from-python converter and to-python converter
+  custom_vector_from_seq&lt;int&gt;(); to_python_converter&lt;std::vector&lt;int&gt;, custom_vector_to_list&lt;int&gt; &gt;();
+  custom_vector_from_seq&lt;Real&gt;(); to_python_converter&lt;std::vector&lt;Real&gt;, custom_vector_to_list&lt;Real&gt; &gt;();
+  custom_vector_from_seq&lt;Vector3r&gt;(); to_python_converter&lt;std::vector&lt;Vector3r&gt;, custom_vector_to_list&lt;Vector3r&gt; &gt;();
+  custom_vector_from_seq&lt;std::string&gt;(); to_python_converter&lt;std::vector&lt;std::string&gt;, custom_vector_to_list&lt;std::string&gt; &gt;();
+}
+
+
+
+
+

Modified: trunk/py/yadeWrapper/yadeWrapper.cpp
===================================================================
--- trunk/py/yadeWrapper/yadeWrapper.cpp	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/py/yadeWrapper/yadeWrapper.cpp	2009-07-17 21:50:55 UTC (rev 1875)
@@ -18,8 +18,6 @@
 #include&lt;boost/foreach.hpp&gt;
 #include&lt;boost/algorithm/string.hpp&gt;
 
-// [boost1.34] #include&lt;boost/python/stl_iterator.hpp&gt;
-
 #include&lt;yade/lib-base/Logging.hpp&gt;
 #include&lt;yade/lib-serialization-xml/XMLFormatManager.hpp&gt;
 #include&lt;yade/core/Omega.hpp&gt;
@@ -206,7 +204,7 @@
 BASIC_PY_PROXY_HEAD(pyParallelEngine,ParallelEngine)
 	pyParallelEngine(python::list slaves){init(&quot;ParallelEngine&quot;); slaves_set(slaves);}
 	void slaves_set(python::list slaves){
-		ensureAcc(); shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
+		shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
 		int len=python::len(slaves);
 		me-&gt;slaves=ParallelEngine::slaveContainer(); // empty the container
 		for(int i=0; i&lt;len; i++){
@@ -220,7 +218,7 @@
 		}
 	}
 	python::list slaves_get(void){	
-		ensureAcc(); shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
+		shared_ptr&lt;ParallelEngine&gt; me=dynamic_pointer_cast&lt;ParallelEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a ParallelEngine. (WTF?)&quot;);
 		python::list ret;
 		FOREACH(vector&lt;shared_ptr&lt;Engine &gt; &gt;&amp; grp, me-&gt;slaves){
 			python::list rret=anyEngines_get(grp);
@@ -240,7 +238,7 @@
 		// additional constructor
 		pyMetaEngine(string clss, python::list functors){init(clss); functors_set(functors);}
 		python::list functors_get(void){
-			ensureAcc(); shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine (?!)&quot;); python::list ret;
+			shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine (?!)&quot;); python::list ret;
 			/* garbage design: functorArguments are instances of EngineUnits, but they may not be present; therefore, only use them if they exist; our pyMetaEngine, however, will always have both names and EnguneUnit objects in the same count */
 			for(size_t i=0; i&lt;me-&gt;functorNames.size(); i++){
 				shared_ptr&lt;EngineUnit&gt; eu;
@@ -255,7 +253,7 @@
 			return ret;
 		}
 		void functors_set(python::list ftrs){
-			ensureAcc(); shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine. (?!)&quot;);
+			shared_ptr&lt;MetaEngine&gt; me=dynamic_pointer_cast&lt;MetaEngine&gt;(proxee); if(!me) throw runtime_error(&quot;Proxied class not a MetaEngine. (?!)&quot;);
 			me-&gt;clear(); int len=python::len(ftrs);
 			for(int i=0; i&lt;len; i++){
 				python::extract&lt;pyEngineUnit&gt; euEx(ftrs[i]); if(!euEx.check()) throw invalid_argument(&quot;Unable to extract type EngineUnit from sequence.&quot;);
@@ -297,6 +295,7 @@
 python::list anyEngines_get(const vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp; engContainer){
 	python::list ret; 
 	FOREACH(const shared_ptr&lt;Engine&gt;&amp; eng, engContainer){
+		if(!eng) ret.append(python::object());
 		#define APPEND_ENGINE_IF_POSSIBLE(engineType,pyEngineType) { shared_ptr&lt;engineType&gt; e=dynamic_pointer_cast&lt;engineType&gt;(eng); if(e) { ret.append(pyEngineType(e)); continue; } }
 		APPEND_ENGINE_IF_POSSIBLE(InteractionDispatchers,pyInteractionDispatchers); APPEND_ENGINE_IF_POSSIBLE(MetaEngine,pyMetaEngine); APPEND_ENGINE_IF_POSSIBLE(StandAloneEngine,pyStandAloneEngine); APPEND_ENGINE_IF_POSSIBLE(DeusExMachina,pyDeusExMachina); APPEND_ENGINE_IF_POSSIBLE(ParallelEngine,pyParallelEngine); 
 		throw std::runtime_error(&quot;Unknown engine type: `&quot;+eng-&gt;getClassName()+&quot;' (only MetaEngine, StandAloneEngine, DeusExMachina and ParallelEngine are supported)&quot;);
@@ -320,8 +319,8 @@
 BASIC_PY_PROXY_HEAD(pyInteraction,Interaction)
 	NONPOD_ATTRIBUTE_ACCESS(geom,pyInteractionGeometry,interactionGeometry);
 	NONPOD_ATTRIBUTE_ACCESS(phys,pyInteractionPhysics,interactionPhysics);
-	/* shorthands */ unsigned id1_get(void){ensureAcc(); return proxee-&gt;getId1();} unsigned id2_get(void){ensureAcc(); return proxee-&gt;getId2();}
-	bool isReal_get(void){ensureAcc(); return proxee-&gt;isReal(); }
+	/* shorthands */ unsigned id1_get(void){ return proxee-&gt;getId1();} unsigned id2_get(void){ return proxee-&gt;getId2();}
+	bool isReal_get(void){ return proxee-&gt;isReal(); }
 BASIC_PY_PROXY_TAIL;
 
 BASIC_PY_PROXY_HEAD(pyBody,Body)
@@ -329,11 +328,11 @@
 	NONPOD_ATTRIBUTE_ACCESS(mold,pyInteractingGeometry,interactingGeometry);
 	NONPOD_ATTRIBUTE_ACCESS(bound,pyBoundingVolume,boundingVolume);
 	NONPOD_ATTRIBUTE_ACCESS(phys,pyPhysicalParameters,physicalParameters);
-	unsigned id_get(){ensureAcc(); return proxee-&gt;getId();}
-	int mask_get(){ensureAcc(); return proxee-&gt;groupMask;}
-	void mask_set(int m){ensureAcc(); proxee-&gt;groupMask=m;}
-	bool dynamic_get(){ensureAcc(); return proxee-&gt;isDynamic;} void dynamic_set(bool dyn){ensureAcc(); proxee-&gt;isDynamic=dyn;}
-	bool isStandalone(){ensureAcc(); return proxee-&gt;isStandalone();} bool isClumpMember(){ensureAcc(); return proxee-&gt;isClumpMember();} bool isClump(){ensureAcc(); return proxee-&gt;isClump();}
+	unsigned id_get(){ return proxee-&gt;getId();}
+	int mask_get(){return proxee-&gt;groupMask;}
+	void mask_set(int m){ proxee-&gt;groupMask=m;}
+	bool dynamic_get(){ return proxee-&gt;isDynamic;} void dynamic_set(bool dyn){ proxee-&gt;isDynamic=dyn;}
+	bool isStandalone(){ return proxee-&gt;isStandalone();} bool isClumpMember(){ return proxee-&gt;isClumpMember();} bool isClump(){ return proxee-&gt;isClump();}
 BASIC_PY_PROXY_TAIL;
 
 class pyBodyContainer{
@@ -665,8 +664,8 @@
 BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_loadTmp_overloads,loadTmp,0,1);
 
 BASIC_PY_PROXY_HEAD(pyFileGenerator,FileGenerator)
-	void generate(string outFile){ensureAcc(); proxee-&gt;setFileName(outFile); proxee-&gt;setSerializationLibrary(&quot;XMLFormatManager&quot;); bool ret=proxee-&gt;generateAndSave(); LOG_INFO((ret?&quot;SUCCESS:\n&quot;:&quot;FAILURE:\n&quot;)&lt;&lt;proxee-&gt;message); if(ret==false) throw runtime_error(&quot;Generator reported error: &quot;+proxee-&gt;message); };
-	void load(){ ensureAcc(); char tmpnam_str [L_tmpnam]; char* result=tmpnam(tmpnam_str); if(result!=tmpnam_str) throw runtime_error(__FILE__ &quot;: tmpnam(char*) failed!&quot;);  string xml(tmpnam_str+string(&quot;.xml.bz2&quot;)); LOG_DEBUG(&quot;Using temp file &quot;&lt;&lt;xml); this-&gt;generate(xml); pyOmega().load(xml); }
+	void generate(string outFile){ proxee-&gt;setFileName(outFile); proxee-&gt;setSerializationLibrary(&quot;XMLFormatManager&quot;); bool ret=proxee-&gt;generateAndSave(); LOG_INFO((ret?&quot;SUCCESS:\n&quot;:&quot;FAILURE:\n&quot;)&lt;&lt;proxee-&gt;message); if(ret==false) throw runtime_error(&quot;Generator reported error: &quot;+proxee-&gt;message); };
+	void load(){  char tmpnam_str [L_tmpnam]; char* result=tmpnam(tmpnam_str); if(result!=tmpnam_str) throw runtime_error(__FILE__ &quot;: tmpnam(char*) failed!&quot;);  string xml(tmpnam_str+string(&quot;.xml.bz2&quot;)); LOG_DEBUG(&quot;Using temp file &quot;&lt;&lt;xml); this-&gt;generate(xml); pyOmega().load(xml); }
 BASIC_PY_PROXY_TAIL;
 
 class pySTLImporter : public STLImporter {
@@ -676,35 +675,9 @@
 BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(STLImporter_import_overloads,py_import,1,3);
 
 
-// automatic conversion of Vector3r and 3-tuple
-// this doesn't create any new class in python
-struct custom_Vector3r_to_tuple{
-	static PyObject* convert(Vector3r const&amp; v){
-		return python::incref(python::make_tuple(v[0],v[1],v[2]).ptr());
-	}
-};
-struct custom_Vector3r_from_tuple{
-	custom_Vector3r_from_tuple(){
-		python::converter::registry::push_back(&amp;convertible,&amp;construct,python::type_id&lt;Vector3r&gt;());
-	}
-	static void* convertible(PyObject* obj_ptr){
-		if(!PySequence_Check(obj_ptr) || PySequence_Size(obj_ptr)!=3) return 0;
-		return obj_ptr;
-	}
-	static void construct(PyObject* obj_ptr, python::converter::rvalue_from_python_stage1_data* data){
-		void* storage=((python::converter::rvalue_from_python_storage&lt;Vector3r&gt;*)(data))-&gt;storage.bytes;
-		new (storage) Vector3r(python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,0)),python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,1)),python::extract&lt;double&gt;(PySequence_GetItem(obj_ptr,2)));
-		data-&gt;convertible=storage;
-	}
-};
 
-
 BOOST_PYTHON_MODULE(wrapper)
 {
-
-	//python::to_python_converter&lt;Vector3r,custom_Vector3r_to_tuple&gt;();
-	//custom_Vector3r_from_tuple();
-
 	boost::python::class_&lt;pyOmega&gt;(&quot;Omega&quot;)
 		.add_property(&quot;iter&quot;,&amp;pyOmega::iter)
 		.add_property(&quot;stopAtIter&quot;,&amp;pyOmega::stopAtIter_get,&amp;pyOmega::stopAtIter_set)

Modified: trunk/scripts/test/facet-sphere.py
===================================================================
--- trunk/scripts/test/facet-sphere.py	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/scripts/test/facet-sphere.py	2009-07-17 21:50:55 UTC (rev 1875)
@@ -23,8 +23,8 @@
 	O.bodies.append(utils.sphere([random.gauss(0,1),random.gauss(0,1),random.uniform(1,2)],random.uniform(.02,.05),velocity=[random.gauss(0,.1),random.gauss(0,.1),random.gauss(0,.1)]))
 
 O.miscParams=[Generic('GLDrawSphere',{'glutUse':True})]
+O.dt=1e-4
 O.saveTmp('init')
-O.dt=1e-4
 
 
 from yade import log

Added: trunk/scripts/test/gts-triax-pack-obb.py
===================================================================
--- trunk/scripts/test/gts-triax-pack-obb.py	2009-07-16 16:59:11 UTC (rev 1874)
+++ trunk/scripts/test/gts-triax-pack-obb.py	2009-07-17 21:50:55 UTC (rev 1875)
@@ -0,0 +1,20 @@
+from numpy import arange
+from yade import pack
+import pylab
+# define the section shape as polygon in 2d; repeat first point at the end to close the polygon
+sq2=sqrt(2)
+poly=((3+.1,0),(3+0,.1),(3+sq2,.1+sq2),(3+.1+sq2,sq2),(3+.1,0))
+#pylab.plot(*zip(*poly)); pylab.xlim(xmin=0); pylab.grid(); pylab.title('Meridian of the revolution surface\n(close to continue)'); pylab.gca().set_aspect(aspect='equal',adjustable='box'); pylab.show()
+thetas=arange(0,pi/8,pi/24)
+pts=pack.revolutionSurfaceMeridians([poly for theta in thetas],thetas,origin=Vector3(-4,0,-1),orientation=Quaternion.IDENTITY)
+surf=pack.sweptPolylines2gtsSurface(pts,capStart=True,capEnd=True,threshold=1e-4)
+O.bodies.append(pack.gtsSurface2Facets(surf,color=(1,0,1)))
+# fill this solid with triaxial packing; it will compute minimum-volume oriented bounding box
+# to minimize the number of throw-away spheres.
+# It does away with about 3k spheres for radius 3e-2
+O.bodies.append(pack.triaxialPack(pack.inGtsSurface(surf),radius=3e-2,radiusStDev=1e-1,memoizeDb='/tmp/gts-triax-packings.sqlite'))
+# translate the surface away and pack it again with sphere, but without the oriented bounding box (useOBB=False)
+# Here, we need 20k spheres (with more or less the same result)
+surf.translate(0,0,1);
+O.bodies.append(pack.gtsSurface2Facets(surf,color=(1,0,0)))
+O.bodies.append(pack.triaxialPack(pack.inGtsSurface(surf),radius=3e-2,radiusStDev=1e-1,memoizeDb='/tmp/gts-triax-packings.sqlite',useOBB=False))


_______________________________________________
Mailing list: <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
Post to     : <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">yade-dev at lists.launchpad.net</A>
Unsubscribe : <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
More help   : <A HREF="https://help.launchpad.net/ListHelp">https://help.launchpad.net/ListHelp</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001245.html">[deprecated list] [Yade-dev] yade crash launching xml
</A></li>
	<LI>Next message: <A HREF="001246.html">[deprecated list] [Yade-dev] small changes in lots of code	(attribute registration)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1281">[ date ]</a>
              <a href="thread.html#1281">[ thread ]</a>
              <a href="subject.html#1281">[ subject ]</a>
              <a href="author.html#1281">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-dev">More information about the yade-dev
mailing list</a><br>
</body></html>
