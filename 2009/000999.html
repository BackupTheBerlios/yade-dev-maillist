<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [deprecated list] [Yade-dev] [svn] r1771 - in trunk: . core	core/containers	examples/collider-perf extra extra/clump	gui/py gui/qt3	lib/import lib/opengl pkg/common	pkg/common/Container	pkg/common/Engine/DeusExMachina	pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/common/RenderingEngine/OpenGLRenderingEngine	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/PreProcessor	pkg/fem/Engine/EngineUnit	pkg/fem/PreProcessor	pkg/lattice/PreProcessor	pkg/mass-spring/PreProcessor	pkg/realtime-rigidbody/PreProcessor	pkg/snow/PreProcessor	scripts scripts/test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-dev/2009/index.html" >
   <LINK REL="made" HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1771%20-%20in%20trunk%3A%20.%20core%0A%09core/containers%09examples/collider-perf%20extra%20extra/clump%0A%09gui/py%20gui/qt3%09lib/import%20lib/opengl%20pkg/common%0A%09pkg/common/Container%09pkg/common/Engine/DeusExMachina%0A%09pkg/common/Engine/EngineUnit%09pkg/common/Engine/MetaEngine%0A%09pkg/common/Engine/StandAloneEngine%09pkg/common/RenderingEngine/OpenGLRenderingEngine%09pkg/dem/DataClass/InteractionGeometry%09pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%09pkg/dem/PreProcessor%0A%09pkg/fem/Engine/EngineUnit%09pkg/fem/PreProcessor%0A%09pkg/lattice/PreProcessor%09pkg/mass-spring/PreProcessor%09pkg/realtime-rigidbody/PreProcessor%0A%09pkg/snow/PreProcessor%09scripts%20scripts/test&In-Reply-To=%3C200905222206.n4MM69UX031355%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000966.html">
   <LINK REL="Next"  HREF="000967.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[deprecated list] [Yade-dev] [svn] r1771 - in trunk: . core	core/containers	examples/collider-perf extra extra/clump	gui/py gui/qt3	lib/import lib/opengl pkg/common	pkg/common/Container	pkg/common/Engine/DeusExMachina	pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/common/RenderingEngine/OpenGLRenderingEngine	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/PreProcessor	pkg/fem/Engine/EngineUnit	pkg/fem/PreProcessor	pkg/lattice/PreProcessor	pkg/mass-spring/PreProcessor	pkg/realtime-rigidbody/PreProcessor	pkg/snow/PreProcessor	scripts scripts/test</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1771%20-%20in%20trunk%3A%20.%20core%0A%09core/containers%09examples/collider-perf%20extra%20extra/clump%0A%09gui/py%20gui/qt3%09lib/import%20lib/opengl%20pkg/common%0A%09pkg/common/Container%09pkg/common/Engine/DeusExMachina%0A%09pkg/common/Engine/EngineUnit%09pkg/common/Engine/MetaEngine%0A%09pkg/common/Engine/StandAloneEngine%09pkg/common/RenderingEngine/OpenGLRenderingEngine%09pkg/dem/DataClass/InteractionGeometry%09pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%09pkg/dem/PreProcessor%0A%09pkg/fem/Engine/EngineUnit%09pkg/fem/PreProcessor%0A%09pkg/lattice/PreProcessor%09pkg/mass-spring/PreProcessor%09pkg/realtime-rigidbody/PreProcessor%0A%09pkg/snow/PreProcessor%09scripts%20scripts/test&In-Reply-To=%3C200905222206.n4MM69UX031355%40sheep.berlios.de%3E"
       TITLE="[deprecated list] [Yade-dev] [svn] r1771 - in trunk: . core	core/containers	examples/collider-perf extra extra/clump	gui/py gui/qt3	lib/import lib/opengl pkg/common	pkg/common/Container	pkg/common/Engine/DeusExMachina	pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/common/RenderingEngine/OpenGLRenderingEngine	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/PreProcessor	pkg/fem/Engine/EngineUnit	pkg/fem/PreProcessor	pkg/lattice/PreProcessor	pkg/mass-spring/PreProcessor	pkg/realtime-rigidbody/PreProcessor	pkg/snow/PreProcessor	scripts scripts/test">eudoxos at mail.berlios.de
       </A><BR>
    <I>Sat May 23 00:06:09 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000966.html">[deprecated list] [Yade-dev] [svn] r1770 -	trunk/lib/serialization-qt
</A></li>
        <LI>Next message: <A HREF="000967.html">[deprecated list] [Yade-dev] [svn] r1772 -	trunk/pkg/common/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#999">[ date ]</a>
              <a href="thread.html#999">[ thread ]</a>
              <a href="subject.html#999">[ subject ]</a>
              <a href="author.html#999">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2009-05-23 00:06:02 +0200 (Sat, 23 May 2009)
New Revision: 1771

Added:
   trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp
   trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp
   trunk/scripts/test/bex-move.py
   trunk/scripts/test/facet-sphere.py
   trunk/scripts/test/insertion-sort-collider.py
Removed:
   trunk/core/containers/InteractionVecSet.cpp
   trunk/core/containers/InteractionVecSet.hpp
   trunk/pkg/common/Container/InteractionVecSet.hpp
Modified:
   trunk/SConstruct
   trunk/core/BexContainer.hpp
   trunk/core/GeometricalModel.hpp
   trunk/core/SConscript
   trunk/core/Timing.hpp
   trunk/examples/collider-perf/README
   trunk/examples/collider-perf/mkGraph.py
   trunk/examples/collider-perf/perf.table
   trunk/extra/Brefcom.cpp
   trunk/extra/Brefcom.hpp
   trunk/extra/clump/Shop.cpp
   trunk/gui/py/_eudoxos.cpp
   trunk/gui/py/_utils.cpp
   trunk/gui/py/pyAttrUtils.hpp
   trunk/gui/py/utils.py
   trunk/gui/py/yade-multi
   trunk/gui/py/yadeControl.cpp
   trunk/gui/qt3/GLViewer.cpp
   trunk/gui/qt3/QtGeneratedSimulationController.ui
   trunk/gui/qt3/SimulationController.cpp
   trunk/gui/qt3/SimulationController.hpp
   trunk/lib/import/STLImporter.cpp
   trunk/lib/opengl/GLUtils.hpp
   trunk/lib/opengl/OpenGLWrapper.hpp
   trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.hpp
   trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.cpp
   trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.hpp
   trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.cpp
   trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.hpp
   trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp
   trunk/pkg/common/Engine/MetaEngine/PhysicalParametersEngineUnit.hpp
   trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.cpp
   trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp
   trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.cpp
   trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.hpp
   trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp
   trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp
   trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp
   trunk/pkg/common/SConscript
   trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp
   trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.hpp
   trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp
   trunk/pkg/dem/Engine/DeusExMachina/NewtonsDampedLaw.cpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp
   trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/DirectShearCis.cpp
   trunk/pkg/dem/PreProcessor/Funnel.cpp
   trunk/pkg/dem/PreProcessor/HydraulicTest.cpp
   trunk/pkg/dem/PreProcessor/MembraneTest.cpp
   trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp
   trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp
   trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp
   trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp
   trunk/pkg/dem/PreProcessor/STLImporterTest.cpp
   trunk/pkg/dem/PreProcessor/SimpleShear.cpp
   trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp
   trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp
   trunk/pkg/dem/PreProcessor/ThreePointBending.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp
   trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp
   trunk/pkg/fem/PreProcessor/FEMBeam.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp
   trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp
   trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp
   trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp
   trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp
   trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp
   trunk/scripts/simple-scene.py
Log:
Big changes:

1. Add 2 new Bex: move and rot (to apply suddent position/orientation change). Should have almost no adverse effect if not used. Adapted NewtonsDampedLaw, LeapFrog integrators for that; added python wrappers. Test script in scripts/test/bex-move.py
2. Add new InsertionSortCollider. Faster by about 40% than PersistentSAPCollider in normal iterations, and about 10x faster on the initial sort. (not yet thoroughly tested, but passes the performance test with 128k bodies).
3. Remove InteractionVecSet

Smaller changes:

4. Rewrite the algorithm of Facet-Sphere contact detection in ef2_Facet_Sphere_Dem3DofGeom
5. Remove GeometricalModel::visible (not used anywhere), added bool GeometricalModel::highlight
6. Max number of bodies to make selection possible in OpenGLRenderingEngine::selectBodyLimit
7. Selection tries to call onBodySelect(id) function (if defined); see scripts/simple-scene.py for example
8. utils.wireNone, utils.wireAll, utils.wireNoSpheres functions to set at once wire flag of bodies; utils.highlightNone to reset highlight flag everywhere.
9. Selected body blinks, highlighted bodies change their colour in phases in the openGL view
10. Selected or highlighted bodies show their body id as number in front of them
11. Selecting body doesn't make it non-dynamic anymore (use Alt-D for that)
12. Create tab in the qt simulation controller for python commands (very primitive now; no history etc, still useful for simple commands)
13. Start adding docstrings to boost::python functions (in utils)
14. All python objects have dict() method returning dictionary of serializable attributes (key:value)
15. Yade-multi reports all log files, for easy cut&amp;paste&amp;grep 
16. Remove static_assert warning, use static_assert_ instead in openGL wrapper
17. Do not install headers and pkg-config from scons (never used)



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/SConstruct	2009-05-22 22:06:02 UTC (rev 1771)
@@ -533,7 +533,9 @@
 	#env.AddPreAction(installAlias,installHeaders)
 	from os.path import join,split,isabs,isdir,exists,lexists,islink,isfile,sep
 	installHeaders() # install to buildDir always
-	installHeaders(env.subst('$PREFIX')) # install to $PREFIX if specifically requested: like &quot;scons /usr/local/include&quot;
+	if 0: # do not install headers, nor make pkg-config (was never used, I think)
+		installHeaders(env.subst('$PREFIX')) # install to $PREFIX if specifically requested: like &quot;scons /usr/local/include&quot;
+		makePkgConfig('$buildDir/yade${SUFFIX}.pc')
 	if not env['haveForeach']:
 		boostDir=buildDir+'/include/yade-'+env['version']+'/boost'
 		foreachLink=boostDir+'/foreach.hpp'
@@ -543,7 +545,6 @@
 			if lexists(foreachLink): os.remove(foreachLink) # broken symlink: remove it
 			os.symlink(relpath(foreachLink,foreachTarget),foreachLink)
 		env.InstallAs(env['PREFIX']+'/include/yade-'+env['version']+'/boost/foreach.hpp',foreachTarget)
-	makePkgConfig('$buildDir/yade${SUFFIX}.pc')
 	env.Install(pcDir,'$buildDir/yade${SUFFIX}.pc')
 	installAlias=env.Alias('install',instDirs) # build and install everything that should go to instDirs, which are $PREFIX/{bin,lib} (uses scons' Install); include pkgconfig stuff
 	env.Default([installAlias,'$PREFIX'])

Modified: trunk/core/BexContainer.hpp
===================================================================
--- trunk/core/BexContainer.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/core/BexContainer.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -44,10 +44,12 @@
 		typedef std::vector&lt;Vector3r&gt; vvector;
 		std::vector&lt;vvector&gt; _forceData;
 		std::vector&lt;vvector&gt; _torqueData;
-		vvector _force, _torque;
+		std::vector&lt;vvector&gt; _moveData;
+		std::vector&lt;vvector&gt; _rotData;
+		vvector _force, _torque, _move, _rot;
 		size_t size;
 		int nThreads;
-		bool synced;
+		bool synced,moveRotUsed;
 		boost::mutex globalMutex;
 
 		inline void ensureSize(body_id_t id){
@@ -64,10 +66,11 @@
 		const Vector3r&amp; getTorqueUnsynced(body_id_t id){ensureSize(id); return _force[id];}
 		friend class PhysicalActionDamperUnit;
 	public:
-		BexContainer(): size(0), synced(true),syncCount(0){
+		BexContainer(): size(0), synced(true),moveRotUsed(false),syncCount(0){
 			nThreads=omp_get_max_threads();
 			for(int i=0; i&lt;nThreads; i++){
 				_forceData.push_back(vvector()); _torqueData.push_back(vvector());
+				_moveData.push_back(vvector()); _rotData.push_back(vvector());
 			}
 		}
 
@@ -75,7 +78,11 @@
 		const Vector3r&amp; getForce(body_id_t id)         { ensureSize(id); ensureSynced(); return _force[id]; }
 		void  addForce(body_id_t id, const Vector3r&amp; f){ ensureSize(id); synced=false;   _forceData[omp_get_thread_num()][id]+=f;}
 		const Vector3r&amp; getTorque(body_id_t id)        { ensureSize(id); ensureSynced(); return _torque[id]; }
-		void addTorque(body_id_t id, const Vector3r&amp; f){ ensureSize(id); synced=false;   _torqueData[omp_get_thread_num()][id]+=f;}
+		void addTorque(body_id_t id, const Vector3r&amp; t){ ensureSize(id); synced=false;   _torqueData[omp_get_thread_num()][id]+=t;}
+		const Vector3r&amp; getMove(body_id_t id)          { ensureSize(id); ensureSynced(); return _move[id]; }
+		void  addMove(body_id_t id, const Vector3r&amp; m) { ensureSize(id); synced=false; moveRotUsed=true; _moveData[omp_get_thread_num()][id]+=m;}
+		const Vector3r&amp; getRot(body_id_t id)           { ensureSize(id); ensureSynced(); return _rot[id]; }
+		void  addRot(body_id_t id, const Vector3r&amp; r)  { ensureSize(id); synced=false; moveRotUsed=true; _rotData[omp_get_thread_num()][id]+=r;}
 
 		/* Sum contributions from all threads, save to _force&amp;_torque.
 		 * Locks globalMutex, since one thread modifies common data (_force&amp;_torque).
@@ -90,6 +97,13 @@
 				for(int thread=0; thread&lt;nThreads; thread++){ sumF+=_forceData[thread][id]; sumT+=_torqueData[thread][id];}
 				_force[id]=sumF; _torque[id]=sumT;
 			}
+			if(moveRotUsed){
+				for(long id=0; id&lt;(long)size; id++){
+					Vector3r sumM(Vector3r::ZERO), sumR(Vector3r::ZERO);
+					for(int thread=0; thread&lt;nThreads; thread++){ sumM+=_moveData[thread][id]; sumR+=_rotData[thread][id];}
+					_move[id]=sumM; _rot[id]=sumR;
+				}
+			}
 			synced=true; syncCount++;
 		}
 		unsigned long syncCount; 
@@ -101,10 +115,13 @@
 			boost::mutex::scoped_lock lock(globalMutex);
 			if(size&gt;=newSize) return; // in case on thread was waiting for resize, but it was already satisfied by another one
 			for(int thread=0; thread&lt;nThreads; thread++){
-				_forceData [thread].resize(newSize);
-				_torqueData[thread].resize(newSize);
+				_forceData [thread].resize(newSize,Vector3r::ZERO);
+				_torqueData[thread].resize(newSize,Vector3r::ZERO);
+				_moveData[thread].resize(newSize,Vector3r::ZERO);
+				_rotData[thread].resize(newSize,Vector3r::ZERO);
 			}
-			_force.resize(newSize); _torque.resize(newSize);
+			_force.resize(newSize,Vector3r::ZERO); _torque.resize(newSize,Vector3r::ZERO);
+			_move.resize(newSize,Vector3r::ZERO); _rot.resize(newSize,Vector3r::ZERO);
 			size=newSize;
 		}
 		/*! Reset all data, also reset summary forces/torques and mark the container clean. */
@@ -113,13 +130,18 @@
 			for(int thread=0; thread&lt;nThreads; thread++){
 				memset(_forceData [thread][0], 0,sizeof(Vector3r)*size);
 				memset(_torqueData[thread][0],0,sizeof(Vector3r)*size);
+				memset(_moveData  [thread][0],0,sizeof(Vector3r)*size);
+				memset(_rotData   [thread][0],0,sizeof(Vector3r)*size);
 			}
 			memset(_force [0], 0,sizeof(Vector3r)*size);
 			memset(_torque[0], 0,sizeof(Vector3r)*size);
-			synced=true;
+			memset(_move  [0], 0,sizeof(Vector3r)*size);
+			memset(_rot   [0], 0,sizeof(Vector3r)*size);
+			synced=true; moveRotUsed=false;
 		}
 		//! say for how many threads we have allocated space
-		int getNumAllocatedThreads() const {return nThreads;}
+		const int&amp; getNumAllocatedThreads() const {return nThreads;}
+		const bool&amp; getMoveRotUsed() const {return moveRotUsed;}
 };
 
 #else
@@ -128,21 +150,30 @@
 	private:
 		std::vector&lt;Vector3r&gt; _force;
 		std::vector&lt;Vector3r&gt; _torque;
+		std::vector&lt;Vector3r&gt; _move;
+		std::vector&lt;Vector3r&gt; _rot;
 		size_t size;
 		inline void ensureSize(body_id_t id){ if(size&lt;=(size_t)id) resize(min((size_t)1.5*(id+100),(size_t)(id+2000)));}
 		friend class PhysicalActionDamperUnit;
 		const Vector3r&amp; getForceUnsynced (body_id_t id){ return getForce(id);}
 		const Vector3r&amp; getTorqueUnsynced(body_id_t id){ return getForce(id);}
+		bool moveRotUsed;
 	public:
-		BexContainer(): size(0),syncCount(0){}
+		BexContainer(): size(0), moveRotUsed(false), syncCount(0){}
 		const Vector3r&amp; getForce(body_id_t id){ensureSize(id); return _force[id];}
 		void  addForce(body_id_t id,const Vector3r&amp; f){ensureSize(id); _force[id]+=f;}
 		const Vector3r&amp; getTorque(body_id_t id){ensureSize(id); return _torque[id];}
 		void  addTorque(body_id_t id,const Vector3r&amp; t){ensureSize(id); _torque[id]+=t;}
+		const Vector3r&amp; getMove(body_id_t id){ensureSize(id); return _move[id];}
+		void  addMove(body_id_t id,const Vector3r&amp; f){ensureSize(id); moveRotUsed=true; _move[id]+=f;}
+		const Vector3r&amp; getRot(body_id_t id){ensureSize(id); return _rot[id];}
+		void  addRot(body_id_t id,const Vector3r&amp; f){ensureSize(id); moveRotUsed=true; _rot[id]+=f;}
 		//! Set all bex's to zero
 		void reset(){
-			memset(_force[0], 0,sizeof(Vector3r)*size);
+			memset(_force [0],0,sizeof(Vector3r)*size);
 			memset(_torque[0],0,sizeof(Vector3r)*size);
+			memset(_move  [0],0,sizeof(Vector3r)*size);
+			memset(_rot   [0],0,sizeof(Vector3r)*size);
 		}
 		//! No-op for API compatibility with the threaded version
 		void sync(){return;}
@@ -150,11 +181,14 @@
 		/*! Resize the container; this happens automatically,
 		 * but you may want to set the size beforehand to avoid resizes as the simulation grows. */
 		void resize(size_t newSize){
-			_force.resize(newSize);
-			_torque.resize(newSize);
+			_force.resize(newSize,Vector3r::ZERO);
+			_torque.resize(newSize,Vector3r::ZERO);
+			_move.resize(newSize,Vector3r::ZERO);
+			_rot.resize(newSize,Vector3r::ZERO);
 			size=newSize;
 		}
-		int getNumAllocatedThreads() const {return 1;}
+		const int getNumAllocatedThreads() const {return 1;}
+		const bool&amp; getMoveRotUsed() const {return moveRotUsed;}
 };
 
 

Modified: trunk/core/GeometricalModel.hpp
===================================================================
--- trunk/core/GeometricalModel.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/core/GeometricalModel.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -19,15 +19,11 @@
 class GeometricalModel : public Serializable, public Indexable
 {
 	public :
-		bool		 visible
-				,wire
-				,shadowCaster;
-
+		bool highlight,wire,shadowCaster;
 		Vector3r	diffuseColor;
+		GeometricalModel(): highlight(false),wire(false),shadowCaster(false),diffuseColor(Vector3r(1,1,1)){}
 
-		GeometricalModel(): visible(true),wire(false),shadowCaster(false),diffuseColor(Vector3r(1,1,1)){}
-
-	REGISTER_ATTRIBUTES(/*no base*/,(visible)(wire)(shadowCaster)(diffuseColor));
+	REGISTER_ATTRIBUTES(/*no base*/,(highlight)(wire)(shadowCaster)(diffuseColor));
 	REGISTER_CLASS_AND_BASE(GeometricalModel,Serializable Indexable);
 	REGISTER_INDEX_COUNTER(GeometricalModel);
 };

Modified: trunk/core/SConscript
===================================================================
--- trunk/core/SConscript	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/core/SConscript	2009-05-22 22:06:02 UTC (rev 1771)
@@ -28,7 +28,6 @@
 			'yadeExceptions.cpp',
 			'containers/BodyRedirectionVector.cpp',
 			'containers/BodyAssocVector.cpp',
-			'containers/InteractionVecSet.cpp',
 			'containers/InteractionHashMap.cpp',
 			'containers/InteractionVecMap.cpp',
 			],

Modified: trunk/core/Timing.hpp
===================================================================
--- trunk/core/Timing.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/core/Timing.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -7,7 +7,7 @@
 	long nExec;
 	delta nsec;
 	TimingInfo():nExec(0),nsec(0){}
-	static delta getNow(){ if(!enabled) return 0L; struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&amp;ts); return delta(1e9*ts.tv_sec+ts.tv_nsec);}
+	static delta getNow(bool evenIfDisabled=false){ if(!enabled &amp;&amp; !evenIfDisabled) return 0L; struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&amp;ts); return delta(1e9*ts.tv_sec+ts.tv_nsec);}
 	static bool enabled;
 };
 

Deleted: trunk/core/containers/InteractionVecSet.cpp
===================================================================
--- trunk/core/containers/InteractionVecSet.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/core/containers/InteractionVecSet.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -1,261 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">olivier.galizzi at imag.fr</A>                                               *
-*  Copyright (C) 2004 by Janek Kozicki                                   *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">cosurgi at berlios.de</A>                                                    *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;InteractionVecSet.hpp&quot;
-#include &lt;iostream&gt;
-
-
-InteractionVecSetIterator::InteractionVecSetIterator() : InteractionContainerIterator()
-{
-
-}
-
-
-InteractionVecSetIterator::~InteractionVecSetIterator()
-{
-
-}
-
-
-bool InteractionVecSetIterator::isDifferent(const InteractionContainerIterator&amp; i)
-{
-	const InteractionVecSetIterator&amp; it = static_cast&lt;const InteractionVecSetIterator&amp;&gt;(i);
-	if (it.vii == it.viiEnd) // we are at end of container
-		return !(vii==viiEnd);
-	else
-		return (sii != it.sii );
-}
-
-
-void InteractionVecSetIterator::increment()
-{
-	if ( sii != siiEnd )
-		++sii;
-	while( sii == siiEnd )
-	{
-		++vii;
-		if(vii != viiEnd)
-		{
-			sii	= (*vii).begin();
-			siiEnd	= (*vii).end();
-		}
-		else
-			break;
-	}
-}
-
-
-void InteractionVecSetIterator::affect(const InteractionContainerIterator&amp; i)
-{
-	const InteractionVecSetIterator&amp; tmpi = static_cast&lt;const InteractionVecSetIterator&amp;&gt;(i);
-	vii    = tmpi.vii;
-	viiEnd = tmpi.viiEnd;
-	sii    = tmpi.sii;
-	siiEnd = tmpi.siiEnd;
-}
-
-
-shared_ptr&lt;Interaction&gt; InteractionVecSetIterator::getValue()
-{
-	return (*sii).second;
-}
-
-
-shared_ptr&lt;InteractionContainerIterator&gt; InteractionVecSetIterator::createPtr()
-{
-	return shared_ptr&lt;InteractionContainerIterator&gt;(new InteractionVecSetIterator());
-}
-
-
-/*********************************************************************/
-/*********************************************************************/
-/*********************************************************************/
-/*********************************************************************/
-
-InteractionVecSet::InteractionVecSet()
-{
-	currentSize = 0;
-	clear();
-}
-
-
-InteractionVecSet::~InteractionVecSet()
-{
-}
-
-
-bool InteractionVecSet::insert(shared_ptr&lt;Interaction&gt;&amp; i)
-{
-	boost::mutex::scoped_lock lock(drawloopmutex);
-
-	body_id_t id1 = i-&gt;getId1();
-	body_id_t id2 = i-&gt;getId2();
-
-	if (id1&gt;id2)
-		swap(id1,id2);
-
-	if ( static_cast&lt;unsigned int&gt;(id1) &gt;=interactions.size())
-		interactions.resize(id1+1);
-
-	if (interactions[id1].insert(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,i)).second)
-	{
-		currentSize++;
-		return true;
-	}
-	else
-		return false;
-}
-
-
-bool InteractionVecSet::insert(body_id_t id1,body_id_t id2)
-{
-	shared_ptr&lt;Interaction&gt; i(new Interaction(id1,id2) );
-	return insert(i);	
-}
-
-
-void InteractionVecSet::clear()
-{
-	boost::mutex::scoped_lock lock(drawloopmutex);
-
-	interactions.clear();
-	currentSize=0;
-}
-
-
-bool InteractionVecSet::erase(body_id_t id1,body_id_t id2)
-{
-	boost::mutex::scoped_lock lock(drawloopmutex);
-
-	if (id1&gt;id2)
-		swap(id1,id2);
-
-	if ( static_cast&lt;unsigned int&gt;(id1) &lt; interactions.size())
-	{
-		shared_ptr&lt;Interaction&gt; tmpI;
-		if (interactions[id1].erase(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,tmpI)))
-		{
-			currentSize--;
-			return true;
-		}
-		else
-			return false;
-	}
-
-	return false;
-
-}
-
-
-const shared_ptr&lt;Interaction&gt;&amp; InteractionVecSet::find(body_id_t id1,body_id_t id2)
-{
-	if (id1&gt;id2)
-		swap(id1,id2);
-
-	if (static_cast&lt;unsigned int&gt;(id1)&lt;interactions.size())
-	{
-		set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator sii;
-		shared_ptr&lt;Interaction&gt; tmpI;
-		sii = interactions[id1].find(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,tmpI));
-		if (sii!=interactions[id1].end())
-			return (*sii).second;
-		else
-		{
-			empty = shared_ptr&lt;Interaction&gt;();
-			return empty;
-		}
-	}
-	else
-	{
-		empty = shared_ptr&lt;Interaction&gt;();
-		return empty;
-	}
-}
-
-
-InteractionContainer::iterator InteractionVecSet::begin()
-{
-	shared_ptr&lt;InteractionVecSetIterator&gt; it(new InteractionVecSetIterator());
-	it-&gt;vii    = interactions.begin();
-	it-&gt;viiEnd = interactions.end();
- 
-	if (it-&gt;vii!=it-&gt;viiEnd)
-	{
-		it-&gt;sii    = (*it-&gt;vii).begin();
- 		it-&gt;siiEnd = (*it-&gt;vii).end();
-	
-		while( it-&gt;sii == it-&gt;siiEnd )
-		{
-			++it-&gt;vii;
-			if(it-&gt;vii != it-&gt;viiEnd)
-			{
-				it-&gt;sii	   = (*it-&gt;vii).begin();
-				it-&gt;siiEnd = (*it-&gt;vii).end();
-			}
-			else
-				return InteractionContainer::iterator(it);
-		}
-	}
-
-	return InteractionContainer::iterator(it);
-}
-
-
-InteractionContainer::iterator InteractionVecSet::end()
-{
-
-	shared_ptr&lt;InteractionVecSetIterator&gt; it(new InteractionVecSetIterator());
-
-	it-&gt;vii		= interactions.end();
-	it-&gt;viiEnd	= interactions.end();
-	
-// in fact it is not possible to assign ssi, because it doesn't exist at all. (both begin() and end() do not exist)
-
-//	it-&gt;sii		= interactions.begin()-&gt;end();
-//	it-&gt;siiEnd	= interactions.begin()-&gt;end();
-// trying to access out of memory bounds: end() points behind LAST element. so accessing it causes segfault.
-//	it-&gt;sii		= (*it-&gt;vii).end();
-//	it-&gt;siiEnd	= (*it-&gt;vii).end();
-
-	return InteractionContainer::iterator(it);
-
-}
-
-
-// 
-// void InteractionVecSet::eraseCurrentAndGotoNextPotential()
-// {
-// 	vector&lt;set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator tmpVii = vii;
-// 	set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator tmpSii          = sii;
-// 	
-// 	gotoNextPotential();
-// 	
-// 	(*tmpVii).erase(tmpSii);
-// 	currentSize--;	
-// }
-// 
-// void InteractionVecSet::eraseCurrentAndGotoNext()
-// {
-// 	vector&lt;set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator tmpVii = vii;
-// 	set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator tmpSii          = sii;
-// 	
-// 	gotoNext();
-// 	
-// 	(*tmpVii).erase(tmpSii);
-// 	currentSize--;	
-// 	
-// }
-
-unsigned int InteractionVecSet::size()
-{
-	return currentSize;
-}
-
-// YADE_PLUGIN();

Deleted: trunk/core/containers/InteractionVecSet.hpp
===================================================================
--- trunk/core/containers/InteractionVecSet.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/core/containers/InteractionVecSet.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -1,78 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">olivier.galizzi at imag.fr</A>                                               *
-*  Copyright (C) 2004 by Janek Kozicki                                   *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">cosurgi at berlios.de</A>                                                    *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-#pragma once
-
-#include&lt;yade/core/InteractionContainer.hpp&gt;
-#include&lt;yade/core/Interaction.hpp&gt;
-#include&lt;set&gt;
-#include&lt;vector&gt;
-
-using namespace std;
-
-struct lessThanPair
-{
-	bool operator()(const pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;&amp; p1, const pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;&amp; p2) const
-	{
-		return (p1.first&lt;p2.first);
-	}
-};
-
-class InteractionVecSetIterator : public InteractionContainerIterator 
-{
-	public :
-		vector&lt;set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator vii;
-		vector&lt;set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator viiEnd;
-		set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator sii;
-		set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator siiEnd;
-
-		InteractionVecSetIterator();
-		~InteractionVecSetIterator();
-
-		virtual bool isDifferent(const InteractionContainerIterator&amp; i);
-		virtual void affect(const InteractionContainerIterator&amp; i);
-		virtual void increment();
-		virtual shared_ptr&lt;Interaction&gt; getValue();
-		virtual shared_ptr&lt;InteractionContainerIterator&gt; createPtr();
-
-};
-
-
-using namespace __gnu_cxx;
-
-class InteractionVecSet : public InteractionContainer
-{
-	private :
-		vector&lt;set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt; interactions;
-		unsigned int currentSize;
-		shared_ptr&lt;Interaction&gt; empty;
-
-
-	public :
-		InteractionVecSet();
-		virtual ~InteractionVecSet();
-
-		virtual bool insert(body_id_t id1,body_id_t id2);
-		virtual bool insert(shared_ptr&lt;Interaction&gt;&amp; i);
-		virtual void clear();
-		virtual bool erase(body_id_t id1,body_id_t id2);
-		virtual const shared_ptr&lt;Interaction&gt;&amp; find(body_id_t id1,body_id_t id2);
-
-		virtual InteractionContainer::iterator begin();
-     	virtual InteractionContainer::iterator end();
-
-		virtual unsigned int size();
-
-	REGISTER_CLASS_NAME(InteractionVecSet);
-	REGISTER_BASE_CLASS_NAME(InteractionContainer);
-
-};
-
-REGISTER_SERIALIZABLE(InteractionVecSet);
-

Modified: trunk/examples/collider-perf/README
===================================================================
--- trunk/examples/collider-perf/README	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/examples/collider-perf/README	2009-05-22 22:06:02 UTC (rev 1771)
@@ -17,5 +17,5 @@
 	number.
 2. First iteration on the scene (TriaxialTest and the selected collider) with timings is
    done and timing.stats() printed (appears in the log file).
-3. Another 100 iterations are measured with siming.stats(), after which the test exits.
+3. Another 100 iterations are measured with timing.stats(), after which the test exits.
 

Modified: trunk/examples/collider-perf/mkGraph.py
===================================================================
--- trunk/examples/collider-perf/mkGraph.py	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/examples/collider-perf/mkGraph.py	2009-05-22 22:06:02 UTC (rev 1771)
@@ -1,11 +1,12 @@
 #encoding: utf-8
-dta={'QS':{},'SAP':{}}
+dta={'QS':{},'SAP':{},'IS':{}}
 import sys
 for f in sys.argv[1:]:
 	print f,'',
 	N=f.split('.')[1];
 	assert(N[-1]=='k'); N=1000*int(N[:-1])
 	if '.q.' in f: collider='QS'
+	elif '.i.' in f: collider='IS'
 	else: collider='SAP'
 	for l in open(f):
 		if 'Collider' in l:
@@ -16,20 +17,23 @@
 
 SAP_N=dta['SAP'].keys(); SAP_N.sort()
 QS_N=dta['QS'].keys(); QS_N.sort()
+IS_N=dta['IS'].keys(); IS_N.sort()
 SAPinit=[dta['SAP'][N][0] for N in SAP_N]; SAPstep=[dta['SAP'][N][1] for N in SAP_N]
 QSinit=[dta['QS'][N][0] for N in QS_N]; QSstep=[dta['QS'][N][1] for N in QS_N]
+ISinit=[dta['IS'][N][0] for N in IS_N]; ISstep=[dta['IS'][N][1] for N in IS_N]
 from pylab import *
 plot(SAP_N,SAPinit,'m')
+plot(IS_N,ISinit,'y')
 gca().set_yscale('log')
 xlabel(&quot;Number of spheres&quot;)
 ylabel(u&quot;Log (!) time for the 1st SAP collider step [s]&quot;)
 title(&quot;SAP vs. QuickSort colliders performance&quot;)
-legend(('SAP init',),'upper left')
+legend(('SAP init','IS init'),'upper left')
 
 ax2=twinx()
-plot(SAP_N,SAPstep,'r-',QS_N,QSstep,'g-',QS_N,QSinit,'b-')
+plot(SAP_N,SAPstep,'r-',IS_N,ISstep,'g-',QS_N,QSstep,'g-',QS_N,QSinit,'b-')
 ylabel(u&quot;Linear time per 1 step [s]&quot;)
-legend(('SAP step','QuickSort step','QuickSort init'),'right')
+legend(('SAP step','InsertionSort step','QuickSort step','QuickSort init'),'right')
 grid()
 savefig('colliders.svg')
 show()

Modified: trunk/examples/collider-perf/perf.table
===================================================================
--- trunk/examples/collider-perf/perf.table	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/examples/collider-perf/perf.table	2009-05-22 22:06:02 UTC (rev 1771)
@@ -49,3 +49,28 @@
 3k.q 3000 'SpatialQuickSortCollider'
 2k.q 2000 'SpatialQuickSortCollider'
 1k.q 1000 'SpatialQuickSortCollider'
+128k.i 128000 'InsertionSortCollider'
+96k.i 96000 'InsertionSortCollider'
+64k.i 64000 'InsertionSortCollider'
+56k.i 56000 'InsertionSortCollider'
+48k.i 48000 'InsertionSortCollider'
+40k.i 40000 'InsertionSortCollider'
+36k.i 36000 'InsertionSortCollider'
+32k.i 32000 'InsertionSortCollider'
+28k.i 28000 'InsertionSortCollider'
+24k.i 24000 'InsertionSortCollider'
+20k.i 20000 'InsertionSortCollider'
+18k.i 18000 'InsertionSortCollider'
+16k.i 16000 'InsertionSortCollider'
+14k.i 14000 'InsertionSortCollider'
+12k.i 12000 'InsertionSortCollider'
+10k.i 10000 'InsertionSortCollider'
+9k.i 9000 'InsertionSortCollider'
+8k.i 8000 'InsertionSortCollider'
+7k.i 7000 'InsertionSortCollider'
+6k.i 6000 'InsertionSortCollider'
+5k.i 5000 'InsertionSortCollider'
+4k.i 4000 'InsertionSortCollider'
+3k.i 3000 'InsertionSortCollider'
+2k.i 2000 'InsertionSortCollider'
+1k.i 1000 'InsertionSortCollider'

Modified: trunk/extra/Brefcom.cpp
===================================================================
--- trunk/extra/Brefcom.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/extra/Brefcom.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -67,11 +67,7 @@
 
 
 void BrefcomMakeContact::go(const shared_ptr&lt;PhysicalParameters&gt;&amp; pp1, const shared_ptr&lt;PhysicalParameters&gt;&amp; pp2, const shared_ptr&lt;Interaction&gt;&amp; interaction){
-	#ifdef BREFCOM_DEM3DOF
-		Dem3DofGeom* contGeom=YADE_CAST&lt;Dem3DofGeom*&gt;(interaction-&gt;interactionGeometry.get());
-	#else
-		SpheresContactGeometry* contGeom=YADE_CAST&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.get());
-	#endif
+	Dem3DofGeom* contGeom=YADE_CAST&lt;Dem3DofGeom*&gt;(interaction-&gt;interactionGeometry.get());
 
 	assert(contGeom); // for now, don't handle anything other than SpheresContactGeometry and Dem3DofGeom
 
@@ -127,19 +123,6 @@
 // !! at least one virtual function in the .cpp file
 BrefcomContact::~BrefcomContact(){};
 
-#if 0
-/********************** BrefcomLaw ****************************/
-CREATE_LOGGER(BrefcomLaw);
-
-void BrefcomLaw::applyForce(const Vector3r&amp; force, const body_id_t&amp; id1, const body_id_t&amp; id2){
-	rootBody-&gt;bex.addForce(id1,force);
-	rootBody-&gt;bex.addForce(id2,-force);
-	rootBody-&gt;bex.addTorque(id1,(contGeom-&gt;contactPoint-contGeom-&gt;pos1).Cross(force));
-	rootBody-&gt;bex.addTorque(id2,(contGeom-&gt;contactPoint-contGeom-&gt;pos2).Cross(-force));
-}
-#endif
-
-
 CREATE_LOGGER(ef2_Spheres_Brefcom_BrefcomLaw);
 
 long BrefcomContact::cummBetaIter=0, BrefcomContact::cummBetaCount=0;
@@ -188,65 +171,52 @@
 	return 1.-exp(beta)*(1-sigmaTYield/sigmaTNorm);
 }
 
+Real ef2_Spheres_Brefcom_BrefcomLaw::minStrain_moveBody2=1.; /* deactivated if &gt; 0 */
+Real ef2_Spheres_Brefcom_BrefcomLaw::yieldLogSpeed=1.;
+Real ef2_Spheres_Brefcom_BrefcomLaw::yieldEllipseShift=0.;
+
 void ef2_Spheres_Brefcom_BrefcomLaw::go(shared_ptr&lt;InteractionGeometry&gt;&amp; _geom, shared_ptr&lt;InteractionPhysics&gt;&amp; _phys, Interaction* I, MetaBody* rootBody){
 	//timingDeltas-&gt;start();
-	#ifdef BREFCOM_DEM3DOF
-		Dem3DofGeom* contGeom=static_cast&lt;Dem3DofGeom*&gt;(_geom.get());
-	#else
-		SpheresContactGeometry* contGeom=static_cast&lt;SpheresContactGeometry*&gt;(_geom.get());
-		assert(contGeom-&gt;hasShear);
-	#endif
+	Dem3DofGeom* contGeom=static_cast&lt;Dem3DofGeom*&gt;(_geom.get());
 	BrefcomContact* BC=static_cast&lt;BrefcomContact*&gt;(_phys.get());
 
 	/* kept fully damaged contacts; note that normally the contact is deleted _after_ the BREFCOM_MATERIAL_MODEL,
 	 * i.e. if it is 1.0 here, omegaThreshold is &gt;= 1.0 for sure.
 	 * &amp;&amp;'ing that just to make sure anyway ...
 	 */
-	if(BC-&gt;omega&gt;=1.0 &amp;&amp; BC-&gt;omegaThreshold&gt;=1.0) return;
+	// if(BC-&gt;omega&gt;=1.0 &amp;&amp; BC-&gt;omegaThreshold&gt;=1.0) return;
 
 	// shorthands
-	Real&amp; epsN(BC-&gt;epsN); Vector3r&amp; epsT(BC-&gt;epsT); Real&amp; kappaD(BC-&gt;kappaD); Real&amp; epsPlSum(BC-&gt;epsPlSum); const Real&amp; E(BC-&gt;E); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; tanFrictionAngle(BC-&gt;tanFrictionAngle); const Real&amp; G(BC-&gt;G); const Real&amp; crossSection(BC-&gt;crossSection); const Real&amp; omegaThreshold(BC-&gt;omegaThreshold); const Real&amp; epsCrackOnset(BC-&gt;epsCrackOnset); Real&amp; relResidualStrength(BC-&gt;relResidualStrength); const Real&amp; dt=Omega::instance().getTimeStep();  const Real&amp; epsFracture(BC-&gt;epsFracture); const bool&amp; neverDamage(BC-&gt;neverDamage); const Real&amp; dmgTau(BC-&gt;dmgTau); const Real&amp; plTau(BC-&gt;plTau);
+	Real&amp; epsN(BC-&gt;epsN); Vector3r&amp; epsT(BC-&gt;epsT); Real&amp; kappaD(BC-&gt;kappaD); Real&amp; epsPlSum(BC-&gt;epsPlSum); const Real&amp; E(BC-&gt;E); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; tanFrictionAngle(BC-&gt;tanFrictionAngle); const Real&amp; G(BC-&gt;G); const Real&amp; crossSection(BC-&gt;crossSection); const Real&amp; omegaThreshold(BC-&gt;omegaThreshold); const Real&amp; epsCrackOnset(BC-&gt;epsCrackOnset); Real&amp; relResidualStrength(BC-&gt;relResidualStrength); const Real&amp; dt=Omega::instance().getTimeStep();  const Real&amp; epsFracture(BC-&gt;epsFracture); const bool&amp; neverDamage(BC-&gt;neverDamage); const Real&amp; dmgTau(BC-&gt;dmgTau); const Real&amp; plTau(BC-&gt;plTau); const bool&amp; isCohesive(BC-&gt;isCohesive);
 	/* const Real&amp; transStrainCoeff(BC-&gt;transStrainCoeff); const Real&amp; epsTrans(BC-&gt;epsTrans); const Real&amp; xiShear(BC-&gt;xiShear); */
 	Real&amp; omega(BC-&gt;omega); Real&amp; sigmaN(BC-&gt;sigmaN);  Vector3r&amp; sigmaT(BC-&gt;sigmaT); Real&amp; Fn(BC-&gt;Fn); Vector3r&amp; Fs(BC-&gt;Fs); // for python access
+	const Real&amp; yieldLogSpeed(ef2_Spheres_Brefcom_BrefcomLaw::yieldLogSpeed); const int&amp; yieldSurfType(ef2_Spheres_Brefcom_BrefcomLaw::yieldSurfType);
+	const Real&amp; yieldEllipseShift(ef2_Spheres_Brefcom_BrefcomLaw::yieldEllipseShift); 
 
-	#define YADE_VERIFY(condition) if(!(condition)){LOG_FATAL(&quot;Verirfication `&quot;&lt;&lt;#condition&lt;&lt;&quot;' failed!&quot;); throw;}
+	#define YADE_VERIFY(condition) if(!(condition)){LOG_FATAL(&quot;Verification `&quot;&lt;&lt;#condition&lt;&lt;&quot;' failed!&quot;); throw;}
 	
 	#define NNAN(a) YADE_VERIFY(!isnan(a));
 	#define NNANV(v) YADE_VERIFY(!isnan(v[0])); assert(!isnan(v[1])); assert(!isnan(v[2]));
 
 	//timingDeltas-&gt;checkpoint(&quot;setup&quot;);
-	#ifdef BREFCOM_DEM3DOF
-		epsN=contGeom-&gt;strainN(); epsT=contGeom-&gt;strainT();
-	#else
-		epsN=contGeom-&gt;epsN(); epsT=contGeom-&gt;epsT();
-	#endif
+	// if(contGeom-&gt;refR1&lt;0) contGeom-&gt;refLength=contGeom-&gt;refR2; // make facet-sphere contact always at equilibrium when touching exactly (and not the initial distance)
+	epsN=contGeom-&gt;strainN(); epsT=contGeom-&gt;strainT();
 	if(isnan(epsN)){
-		#ifndef BREFCOM_DEM3DOF
-			LOG_FATAL(&quot;d0=&quot;&lt;&lt;contGeom-&gt;d0&lt;&lt;&quot;, d1,d2=&quot;&lt;&lt;contGeom-&gt;d1&lt;&lt;&quot;,&quot;&lt;&lt;contGeom-&gt;d2&lt;&lt;&quot;; pos1,pos2=&quot;&lt;&lt;contGeom-&gt;pos1&lt;&lt;&quot;,&quot;&lt;&lt;contGeom-&gt;pos2);
-		#else
-			LOG_FATAL(&quot;refLength=&quot;&lt;&lt;contGeom-&gt;refLength&lt;&lt;&quot;; pos1=&quot;&lt;&lt;contGeom-&gt;se31.position&lt;&lt;&quot;; pos2=&quot;&lt;&lt;contGeom-&gt;se32.position&lt;&lt;&quot;; displacementN=&quot;&lt;&lt;contGeom-&gt;displacementN());
-		#endif
+		LOG_FATAL(&quot;refLength=&quot;&lt;&lt;contGeom-&gt;refLength&lt;&lt;&quot;; pos1=&quot;&lt;&lt;contGeom-&gt;se31.position&lt;&lt;&quot;; pos2=&quot;&lt;&lt;contGeom-&gt;se32.position&lt;&lt;&quot;; displacementN=&quot;&lt;&lt;contGeom-&gt;displacementN());
 		throw runtime_error(&quot;!! epsN==NaN !!&quot;);
 	}
 	NNAN(epsN); NNANV(epsT);
 	// already in SpheresContactGeometry:
 	// contGeom-&gt;relocateContactPoints(); // allow very large mutual rotations
 	if(logStrain &amp;&amp; epsN&lt;0){
-		#ifndef BREFCOM_DEM3DOF
-			Real epsN0=max(epsN,-.7); // FIXME: ugly hack
-			if(epsN0&lt;-1){
-				LOG_ERROR(&quot;epsN0=&quot;&lt;&lt;epsN0);
-					LOG_ERROR(&quot;d0=&quot;&lt;&lt;contGeom-&gt;d0&lt;&lt;&quot;; d0fixup=&quot;&lt;&lt;contGeom-&gt;d0fixup&lt;&lt;&quot;; distance=&quot;&lt;&lt;(contGeom-&gt;pos1-contGeom-&gt;pos2).Length()&lt;&lt;&quot;; displacementN=&quot;&lt;&lt;contGeom-&gt;displacementN());
-			}
-		#else
-			Real epsN0=epsN;
-		#endif
+		Real epsN0=epsN;
 		epsN=log(epsN0+1); epsT*=epsN/epsN0;
 	}
 	NNAN(epsN); NNANV(epsT);
 	//timingDeltas-&gt;checkpoint(&quot;geom&quot;);
 
 	epsN+=BC-&gt;isoPrestress/E;
+	//TRVAR1(epsN);
 	#ifdef BREFCOM_MATERIAL_MODEL
 		BREFCOM_MATERIAL_MODEL
 	#else
@@ -254,10 +224,19 @@
 		sigmaT=G*epsT;
 	#endif
 	sigmaN-=BC-&gt;isoPrestress;
+	if(contGeom-&gt;refR1&lt;0 &amp;&amp; ef2_Spheres_Brefcom_BrefcomLaw::minStrain_moveBody2&lt;=0 &amp;&amp; epsN&lt;ef2_Spheres_Brefcom_BrefcomLaw::minStrain_moveBody2){
+		/* move Body2 (the sphere) so that minStrain is satisfied */
+		rootBody-&gt;bex.addMove(I-&gt;getId2(),contGeom-&gt;normal*(ef2_Spheres_Brefcom_BrefcomLaw::minStrain_moveBody2-epsN)*contGeom-&gt;refLength);
+		LOG_TRACE(&quot;Moving by &quot;&lt;&lt;contGeom-&gt;normal*(ef2_Spheres_Brefcom_BrefcomLaw::minStrain_moveBody2-epsN)*contGeom-&gt;refLength);
+	}
 	NNAN(kappaD); NNAN(epsCrackOnset); NNAN(epsFracture); NNAN(omega);
 	NNAN(sigmaN); NNANV(sigmaT); NNAN(crossSection);
 	//timingDeltas-&gt;checkpoint(&quot;material&quot;);
-	if(omega&gt;omegaThreshold){
+
+	const int watch1=6300, watch2=6299;
+	#define SHOW(a) if((I-&gt;getId1()==watch1 &amp;&amp; I-&gt;getId2()==watch2) || (I-&gt;getId2()==watch1 &amp;&amp; I-&gt;getId1()==watch2)) cerr&lt;&lt;__FILE__&lt;&lt;&quot;:&quot;&lt;&lt;__LINE__&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl;
+	SHOW(&quot;epsN&quot;&lt;&lt;epsN);
+	if(epsN&gt;0. &amp;&amp; ((isCohesive &amp;&amp; omega&gt;omegaThreshold) || !isCohesive)){
 		I-&gt;isReal=false;
 		const shared_ptr&lt;Body&gt;&amp; body1=Body::byId(I-&gt;getId1(),rootBody), body2=Body::byId(I-&gt;getId2(),rootBody); assert(body1); assert(body2);
 		const shared_ptr&lt;BrefcomPhysParams&gt;&amp; rbp1=YADE_PTR_CAST&lt;BrefcomPhysParams&gt;(body1-&gt;physicalParameters), rbp2=YADE_PTR_CAST&lt;BrefcomPhysParams&gt;(body2-&gt;physicalParameters);
@@ -269,11 +248,7 @@
 	Fn=sigmaN*crossSection; BC-&gt;normalForce=Fn*contGeom-&gt;normal;
 	Fs=sigmaT*crossSection; BC-&gt;shearForce=Fs;
 
-	#ifdef BREFCOM_DEM3DOF
-		applyForceAtContactPoint(BC-&gt;normalForce+BC-&gt;shearForce, contGeom-&gt;contactPoint, I-&gt;getId1(), contGeom-&gt;se31.position, I-&gt;getId2(), contGeom-&gt;se32.position, rootBody);
-	#else
-		applyForceAtContactPoint(BC-&gt;normalForce+BC-&gt;shearForce, contGeom-&gt;contactPoint, I-&gt;getId1(), contGeom-&gt;pos1, I-&gt;getId2(), contGeom-&gt;pos2, rootBody);
-	#endif
+	applyForceAtContactPoint(BC-&gt;normalForce+BC-&gt;shearForce, contGeom-&gt;contactPoint, I-&gt;getId1(), contGeom-&gt;se31.position, I-&gt;getId2(), contGeom-&gt;se32.position, rootBody);
 	//timingDeltas-&gt;checkpoint(&quot;rest&quot;);
 }
 

Modified: trunk/extra/Brefcom.hpp
===================================================================
--- trunk/extra/Brefcom.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/extra/Brefcom.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -173,8 +173,6 @@
 };
 REGISTER_SERIALIZABLE(BrefcomPhysParams);
 
-#define BREFCOM_DEM3DOF
-
 class ef2_Spheres_Brefcom_BrefcomLaw: public ConstitutiveLaw{
 	public:
 	/*! Damage evolution law */
@@ -183,15 +181,18 @@
 		return 1.-(epsCrackOnset/kappaD)*exp(-(kappaD-epsCrackOnset)/epsFracture);
 	}
 		bool logStrain;
-		ef2_Spheres_Brefcom_BrefcomLaw(): logStrain(false){ /*timingDeltas=shared_ptr&lt;TimingDeltas&gt;(new TimingDeltas);*/ }
+		//! yield function: 0: mohr-coulomb (original); 1: parabolic; 2: logarithmic, 3: log+lin_tension, 4: elliptic, 5: elliptic+log
+		int yieldSurfType;
+		//! scaling in the logarithmic yield surface (should be &lt;1 for realistic results; &gt;=0 for meaningful results)
+		static Real yieldLogSpeed;
+		static Real yieldEllipseShift;
+		//! HACK: limit strain on some contacts by moving body #2 in the contact; only if refR1&lt;0 (facet); deactivated if &gt; 0
+		static Real minStrain_moveBody2;
+		ef2_Spheres_Brefcom_BrefcomLaw(): logStrain(false), yieldSurfType(0) { /*timingDeltas=shared_ptr&lt;TimingDeltas&gt;(new TimingDeltas);*/ }
 		void go(shared_ptr&lt;InteractionGeometry&gt;&amp; _geom, shared_ptr&lt;InteractionPhysics&gt;&amp; _phys, Interaction* I, MetaBody* rootBody);
-	#ifdef BREFCOM_DEM3DOF
-		FUNCTOR2D(Dem3DofGeom,BrefcomContact);
-	#else
-		FUNCTOR2D(SpheresContactGeometry,BrefcomContact);
-	#endif
+	FUNCTOR2D(Dem3DofGeom,BrefcomContact);
 	REGISTER_CLASS_AND_BASE(ef2_Spheres_Brefcom_BrefcomLaw,ConstitutiveLaw);
-	REGISTER_ATTRIBUTES(ConstitutiveLaw,(logStrain));
+	REGISTER_ATTRIBUTES(ConstitutiveLaw,(logStrain)(yieldSurfType)(yieldLogSpeed)(yieldEllipseShift)(minStrain_moveBody2));
 	DECLARE_LOGGER;
 };
 REGISTER_SERIALIZABLE(ef2_Spheres_Brefcom_BrefcomLaw);

Modified: trunk/extra/clump/Shop.cpp
===================================================================
--- trunk/extra/clump/Shop.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/extra/clump/Shop.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -16,9 +16,6 @@
 #include&lt;yade/pkg-common/Sphere.hpp&gt;
 #include&lt;yade/pkg-common/PersistentSAPCollider.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-
 #include&lt;yade/pkg-common/InteractingBox.hpp&gt;
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 
@@ -159,7 +156,6 @@
 	setDefault(&quot;shape_color&quot;,Vector3r(0,0,1));
 
 	setDefault(&quot;shape_wire&quot;,false);
-	setDefault(&quot;shape_visible&quot;,true);
 	setDefault(&quot;shape_shadowCaster&quot;,true);
 
 	setDefault(&quot;param_damping&quot;,.2);
@@ -311,7 +307,6 @@
 	shape-&gt;radius=radius;
 	shape-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;shape_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;shape_color&quot;);
 	shape-&gt;wire=getDefault&lt;bool&gt;(&quot;shape_wire&quot;);
-	shape-&gt;visible=getDefault&lt;bool&gt;(&quot;shape_visible&quot;);
 	shape-&gt;shadowCaster=getDefault&lt;bool&gt;(&quot;shape_shadowCaster&quot;);
 	body-&gt;geometricalModel=shape;
 
@@ -345,7 +340,6 @@
 		shape-&gt;extents=extents;
 		shape-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;shape_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;shape_color&quot;);
 		shape-&gt;wire=getDefault&lt;bool&gt;(&quot;shape_wire&quot;);
-		shape-&gt;visible=getDefault&lt;bool&gt;(&quot;shape_visible&quot;);
 		shape-&gt;shadowCaster=getDefault&lt;bool&gt;(&quot;shape_shadowCaster&quot;);
 		body-&gt;geometricalModel=shape;
 
@@ -387,7 +381,6 @@
 		shape-&gt;v[0]=v[0]; shape-&gt;v[1]=v[1]; shape-&gt;v[2]=v[2]; shape-&gt;v[3]=v[3];
 		shape-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;shape_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;shape_color&quot;);
 		shape-&gt;wire=getDefault&lt;bool&gt;(&quot;shape_wire&quot;);
-		shape-&gt;visible=getDefault&lt;bool&gt;(&quot;shape_visible&quot;);
 		shape-&gt;shadowCaster=getDefault&lt;bool&gt;(&quot;shape_shadowCaster&quot;);
 		body-&gt;geometricalModel=shape;
 

Modified: trunk/gui/py/_eudoxos.cpp
===================================================================
--- trunk/gui/py/_eudoxos.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/py/_eudoxos.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -7,7 +7,6 @@
 	log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade.eudoxos&quot;);
 #endif
 
-
 # if 0
 Real elasticEnergyDensityInAABB(python::tuple AABB){
 	Vector3r bbMin=tuple2vec(python::extract&lt;python::tuple&gt;(AABB[0])()), bbMax=tuple2vec(python::extract&lt;python::tuple&gt;(AABB[1])()); Vector3r box=bbMax-bbMin;
@@ -34,7 +33,7 @@
 #endif
 
 /* yield surface for the brefcom concrete model; this is used only to make yield surface plot from python, for debugging */
-Real yieldSigmaTMagnitude(Real sigmaN){
+Real yieldSigmaTMagnitude(Real sigmaN, int yieldSurfType=0){
 	#ifdef BREFCOM_YIELD_SIGMA_T_MAGNITUDE
 		/* find first suitable interaction */
 		MetaBody* rootBody=Omega::instance().getRootBody().get();
@@ -47,6 +46,8 @@
 		BrefcomContact* BC=dynamic_cast&lt;BrefcomContact*&gt;(I-&gt;interactionPhysics.get());
 		if(!BC) {LOG_ERROR(&quot;Interaction physics is not BrefcomContact instance, returning NaN!&quot;); return nan;}
 		const Real &amp;omega(BC-&gt;omega); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; tanFrictionAngle(BC-&gt;tanFrictionAngle);
+		const Real&amp; yieldLogSpeed(ef2_Spheres_Brefcom_BrefcomLaw::yieldLogSpeed); // const int&amp; yieldSurfType(ef2_Spheres_Brefcom_BrefcomLaw::yieldSurfType);
+		const Real&amp; yieldEllipseShift(ef2_Spheres_Brefcom_BrefcomLaw::yieldEllipseShift);
 		return BREFCOM_YIELD_SIGMA_T_MAGNITUDE(sigmaN);
 	#else
 		LOG_FATAL(&quot;Brefcom model not available in this build.&quot;);
@@ -54,6 +55,7 @@
 	#endif
 }
 
+
 // copied from _utils.cpp
 Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(extract&lt;double&gt;(t[0])(),extract&lt;double&gt;(t[1])(),extract&lt;double&gt;(t[2])());}
 

Modified: trunk/gui/py/_utils.cpp
===================================================================
--- trunk/gui/py/_utils.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/py/_utils.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -176,6 +176,13 @@
 	d[&quot;cs&quot;]=b-&gt;cs;
     return d;
 }
+/* reset highlight of all bodies */
+void highlightNone(){
+	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
+		if(!b-&gt;geometricalModel) continue;
+		b-&gt;geometricalModel-&gt;highlight=false;
+	}
+}
 
 /*!Sum moments acting on given bodies
  *
@@ -220,6 +227,28 @@
 	return ret;
 }
 
+/* Set wire display of all/some/none bodies depending on the filter. */
+void wireSome(string filter){
+	enum{none,all,noSpheres,unknown};
+	int mode=(filter==&quot;none&quot;?none:(filter==&quot;all&quot;?all:(filter==&quot;noSpheres&quot;?noSpheres:unknown)));
+	if(mode==unknown) { LOG_WARN(&quot;Unknown wire filter `&quot;&lt;&lt;filter&lt;&lt;&quot;', using noSpheres instead.&quot;); mode=noSpheres; }
+	FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *Omega::instance().getRootBody()-&gt;bodies){
+		if(!b-&gt;geometricalModel) return;
+		bool wire;
+		switch(mode){
+			case none: wire=false; break;
+			case all: wire=true; break;
+			case noSpheres: wire=!(bool)(dynamic_pointer_cast&lt;Sphere&gt;(b-&gt;geometricalModel)); break;
+			default: throw logic_error(&quot;No such case possible&quot;);
+		}
+		b-&gt;geometricalModel-&gt;wire=wire;
+	}
+}
+void wireAll(){wireSome(&quot;all&quot;);}
+void wireNone(){wireSome(&quot;none&quot;);}
+void wireNoSpheres(){wireSome(&quot;noSpheres&quot;);}
+
+
 /* Tell us whether a point lies in polygon given by array of points.
  *  @param xy is the point that is being tested
  *  @param vertices is Numeric.array (or list or tuple) of vertices of the polygon.
@@ -253,6 +282,7 @@
 	return inside;
 }
 
+
 /* Project 3d point into 2d using spiral projection along given axis;
  * the returned tuple is
  * 	
@@ -302,11 +332,11 @@
 	// <A HREF="http://numpy.scipy.org/numpydoc/numpy-13.html">http://numpy.scipy.org/numpydoc/numpy-13.html</A> mentions this must be done in module init, otherwise we will crash
 	import_array();
 
-	def(&quot;PWaveTimeStep&quot;,PWaveTimeStep);
-	def(&quot;aabbExtrema&quot;,aabbExtrema,aabbExtrema_overloads(args(&quot;cutoff&quot;,&quot;centers&quot;)));
-	def(&quot;negPosExtremeIds&quot;,negPosExtremeIds,negPosExtremeIds_overloads(args(&quot;axis&quot;,&quot;distFactor&quot;)));
-	def(&quot;coordsAndDisplacements&quot;,coordsAndDisplacements,coordsAndDisplacements_overloads(args(&quot;AABB&quot;)));
-	def(&quot;setRefSe3&quot;,setRefSe3);
+	def(&quot;PWaveTimeStep&quot;,PWaveTimeStep,&quot;Get timestep accoring to the velocity of P-Wave propagation; computed from sphere radii, rigidities and masses.&quot;);
+	def(&quot;aabbExtrema&quot;,aabbExtrema,aabbExtrema_overloads(args(&quot;cutoff&quot;,&quot;centers&quot;),&quot;Return coordinates of box enclosing all bodies\n centers: do not take sphere radii in account, only their centroids (default=False)\n cutoff: 0-1 number by which the box will be scaled around its center (default=0)&quot;));
+	def(&quot;negPosExtremeIds&quot;,negPosExtremeIds,negPosExtremeIds_overloads(args(&quot;axis&quot;,&quot;distFactor&quot;),&quot;Return list of ids for spheres (only) that are on extremal ends of the specimen along given axis; distFactor multiplies their radius so that sphere that do not touch the boundary coordinate can also be returned.&quot;));
+	def(&quot;coordsAndDisplacements&quot;,coordsAndDisplacements,coordsAndDisplacements_overloads(args(&quot;AABB&quot;),&quot;Return tuple of 2 same-length lists for coordinates and displacements (coordinate minus reference coordinate) along given axis (1st arg); if the AABB=((x_min,y_min,z_min),(x_max,y_max,z_max)) box is given, only bodies within this box will be considered.&quot;));
+	def(&quot;setRefSe3&quot;,setRefSe3,&quot;Set reference positions and orientation of all bodies equal to their current ones.&quot;);
 	def(&quot;interactionAnglesHistogram&quot;,interactionAnglesHistogram,interactionAnglesHistogram_overloads(args(&quot;axis&quot;,&quot;mask&quot;,&quot;bins&quot;,&quot;aabb&quot;)));
 	def(&quot;bodyNumInteractionsHistogram&quot;,bodyNumInteractionsHistogram,bodyNumInteractionsHistogram_overloads(args(&quot;aabb&quot;)));
 	def(&quot;elasticEnergy&quot;,elasticEnergyInAABB);
@@ -320,6 +350,10 @@
 	def(&quot;spiralProject&quot;,spiralProject,spiralProject_overloads(args(&quot;axis&quot;,&quot;periodStart&quot;,&quot;theta0&quot;)));
 	def(&quot;pointInsidePolygon&quot;,pointInsidePolygon);
 	def(&quot;scalarOnColorScale&quot;,Shop__scalarOnColorScale);
+	def(&quot;highlightNone&quot;,highlightNone);
+	def(&quot;wireAll&quot;,wireAll);
+	def(&quot;wireNone&quot;,wireNone);
+	def(&quot;wireNoSpheres&quot;,wireNoSpheres);
 }
 
 

Modified: trunk/gui/py/pyAttrUtils.hpp
===================================================================
--- trunk/gui/py/pyAttrUtils.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/py/pyAttrUtils.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -26,6 +26,7 @@
 	string wrappedGetAttrStr(std::string key){ensureFunc();vector&lt;string&gt; a=accessor-&gt;getAttrStr(key); string ret(&quot;[&quot;); FOREACH(string s, a) ret+=s+&quot; &quot;; return ret+&quot;]&quot;;} \
 	void wrappedSetAttrStr(std::string key, std::string val){ensureFunc();return accessor-&gt;setAttrStr(key,val);} \
 	boost::python::list wrappedPyKeys(){ensureFunc(); return accessor-&gt;pyKeys();} \
+	boost::python::dict wrappedPyDict(){ensureFunc(); return accessor-&gt;pyDict();} \
 	bool wrappedPyHasKey(std::string key){ensureFunc(); return accessor-&gt;descriptors.find(key)!=accessor-&gt;descriptors.end();} \
 	
 	
@@ -36,7 +37,7 @@
  *
  * They define python special functions that support dictionary operations on this object and calls proxies for them. */
 #define ATTR_ACCESS_PY(cxxClass) \
-	def(&quot;__getitem__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setitem__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;keys&quot;,&amp;cxxClass::wrappedPyKeys).def(&quot;has_key&quot;,&amp;cxxClass::wrappedPyHasKey) \
+	def(&quot;__getitem__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setitem__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;keys&quot;,&amp;cxxClass::wrappedPyKeys).def(&quot;has_key&quot;,&amp;cxxClass::wrappedPyHasKey).def(&quot;dict&quot;,&amp;cxxClass::wrappedPyDict) \
 	.def(&quot;getRaw&quot;,&amp;cxxClass::wrappedGetAttrStr).def(&quot;setRaw&quot;,&amp;cxxClass::wrappedSetAttrStr)
 	//def(&quot;__getattr__&quot;,&amp;cxxClass::wrappedPyGet).def(&quot;__setattr__&quot;,&amp;cxxClass::wrappedPySet).def(&quot;attrs&quot;,&amp;cxxClass::wrappedPyKeys)
 
@@ -158,6 +159,9 @@
 			stringstream voidStream;
 			descriptors[name].archive-&gt;deserialize(voidStream,*(descriptors[name].archive),value);
 		}
+
+		//! return dictionary of attributes and their python values (debugging mosly)
+		boost::python::dict pyDict(){boost::python::dict ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret[I-&gt;first]=pyGet(I-&gt;first); return ret; }
 		//! return python list of keys (attribute names)
 		boost::python::list pyKeys(){boost::python::list ret; for(DescriptorMap::iterator I=descriptors.begin();I!=descriptors.end();I++)ret.append(I-&gt;first); return ret;}
 

Modified: trunk/gui/py/utils.py
===================================================================
--- trunk/gui/py/utils.py	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/py/utils.py	2009-05-22 22:06:02 UTC (rev 1771)
@@ -76,15 +76,15 @@
 	Obj should be up in the inheritance tree, otherwise some attributes may not be defined in the new class.&quot;&quot;&quot;
 	return obj.__class__(newClassName,dict([ (key,obj[key]) for key in obj.keys() ]))
 
-def sphere(center,radius,density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=None,physParamsClass='BodyMacroParameters',physParamsAttr={}):
+def sphere(center,radius,density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=None,physParamsClass='BodyMacroParameters',physParamsAttr={},velocity=[0,0,0]):
 	&quot;&quot;&quot;Create default sphere, with given parameters. Physical properties such as mass and inertia are calculated automatically.&quot;&quot;&quot;
 	s=Body()
 	if not color: color=randomColor()
-	s.shape=GeometricalModel('Sphere',{'radius':radius,'diffuseColor':color,'wire':wire,'visible':True})
+	s.shape=GeometricalModel('Sphere',{'radius':radius,'diffuseColor':color,'wire':wire})
 	s.mold=InteractingGeometry('InteractingSphere',{'radius':radius,'diffuseColor':color})
 	V=(4./3)*math.pi*radius**3
 	inert=(2./5.)*V*density*radius**2
-	pp={'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':V*density,'inertia':[inert,inert,inert],'young':young,'poisson':poisson,'frictionAngle':frictionAngle}
+	pp={'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':V*density,'inertia':[inert,inert,inert],'young':young,'poisson':poisson,'frictionAngle':frictionAngle, 'velocity':[velocity[0],velocity[1],velocity[2]]}
 	pp.update(physParamsAttr)
 	s.phys=PhysicalParameters(physParamsClass)
 	for k in [attr for attr in pp.keys() if attr in s.phys.keys()]:
@@ -97,7 +97,7 @@
 	&quot;&quot;&quot;Create default box (cuboid), with given parameters. Physical properties such as mass and inertia are calculated automatically.&quot;&quot;&quot;
 	b=Body()
 	if not color: color=randomColor()
-	b.shape=GeometricalModel('Box',{'extents':extents,'diffuseColor':color,'wire':wire,'visible':True})
+	b.shape=GeometricalModel('Box',{'extents':extents,'diffuseColor':color,'wire':wire})
 	b.mold=InteractingGeometry('InteractingBox',{'extents':extents,'diffuseColor':color})
 	mass=8*extents[0]*extents[1]*extents[2]*density
 
@@ -117,7 +117,7 @@
 	&quot;&quot;&quot;Create default facet with given parameters.&quot;&quot;&quot;
 	b=Body()
 	if not color: color=randomColor()
-	b.shape=GeometricalModel('Facet',{'diffuseColor':color,'wire':wire,'visible':True})
+	b.shape=GeometricalModel('Facet',{'diffuseColor':color,'wire':wire})
 	b.mold=InteractingGeometry('InteractingFacet',{'diffuseColor':color})
 	center=inscribedCircleCenter(list(vertices[0]),list(vertices[1]),list(vertices[2]))
 	vertices=map(lambda a,b:map(lambda x,y:x-y,a,b),vertices,[center,center,center]) 
@@ -153,7 +153,6 @@
 			center[axis]=extrema[j][axis]+(j-.5)*thickness
 			walls.append(box(center=center,extents=extents,dynamic=False,**kw))
 			walls[-1].shape['wire']=True
-			walls[-1].shape['visible']=True
 	return walls
 
 
@@ -357,7 +356,7 @@
 		if 'description' in names: O.tags['description']=values[names.index('description')]
 		else:
 			bangCols=[i for i,h in enumerate(names) if h[-1]=='!']
-			if len(bangCols)==0: bangCols=range(len(headings))
+			if len(bangCols)==0: bangCols=range(len(names))
 			for i in range(len(names)):
 				if names[i][-1]=='!': names[i]=names[i][:-1] # strip trailing !
 			O.tags['description']=','.join(names[col]+'='+('%g'%values[col] if isinstance(values[col],float) else str(values[col])) for col in bangCols).replace(&quot;'&quot;,'').replace('&quot;','')

Modified: trunk/gui/py/yade-multi
===================================================================
--- trunk/gui/py/yade-multi	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/py/yade-multi	2009-05-22 22:06:02 UTC (rev 1771)
@@ -3,7 +3,7 @@
 #
 # portions &#169; 2008 V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
 
-import os, sys, thread, time,logging
+import os, sys, thread, time, logging, pipes
 
 class JobInfo():
 	def __init__(self,num,id,command,log,nSlots):
@@ -180,6 +180,7 @@
 	logFile=logFormat.replace('%',str(l))
 	if idStrings: logFile=logFile.replace('@',idStrings[l])
 	else: logFile=logFile.replace('@',str(l))
+	logFile=logFile.replace('!','')
 	envVars=[]
 	nSlots=1
 	for col,head in enumerate(headings):
@@ -187,7 +188,7 @@
 		if head=='!OMP_NUM_THREADS': nSlots=int(values[l][col])
 		if head[0]=='!': envVars+=['%s=%s'%(head[1:],values[l][col])]
 	if nSlots&gt;maxJobs: logging.warning('WARNING: job #%d wants %d slots but only %d are available'%(i,nSlots,maxJobs))
-	jobs.append(JobInfo(i,idStrings[l] if idStrings else '#'+str(i),'PARAM_TABLE=%s:%d %s nice -n %d %s -N PythonUI -- -n -x %s &gt; %s 2&gt;&amp;1'%(table,l,' '.join(envVars),nice,executable,simul,logFile),logFile,nSlots))
+	jobs.append(JobInfo(i,idStrings[l] if idStrings else '#'+str(i),'PARAM_TABLE=%s:%d %s nice -n %d %s -N PythonUI -- -n -x %s &gt; %s 2&gt;&amp;1'%(table,l,' '.join(envVars),nice,executable,simul,pipes.quote(logFile)),logFile,nSlots))
 
 print &quot;Job summary:&quot;
 for job in jobs:
@@ -198,11 +199,17 @@
 # OK, go now
 if not dryRun: runJobs(jobs,maxJobs)
 
-print 'All jobs finished,',
+print 'All jobs finished.'
+
+# for easy grepping in logfiles:
+print 'Log files:'
+for job in jobs: print job.log,
+print
+
 if not gnuplotOut:
-	print 'bye.'
+	print 'Bye.'
 else:
-	print 'assembling gnuplot files&#8230;'
+	print 'Assembling gnuplot files&#8230;'
 	for job in jobs:
 		for l in file(job.log):
 			if l.startswith('gnuplot '):
@@ -228,4 +235,5 @@
 	gp=file(gnuplotOut,'w')
 	gp.write(preamble)
 	gp.write('plot '+','.join(plots))
-	print &quot;Finished writing &quot;+gnuplotOut+&quot;, bye.&quot;
+	print &quot;gnuplot&quot;,gnuplotOut
+	print &quot;Plot written, bye.&quot;

Modified: trunk/gui/py/yadeControl.cpp
===================================================================
--- trunk/gui/py/yadeControl.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/py/yadeControl.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -413,6 +413,8 @@
 		}
 		long len(){return proxee-&gt;size();}
 		void clear(){proxee-&gt;clear();}
+		python::list withBody(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;isReal &amp;&amp; (I-&gt;getId1()==id || I-&gt;getId2()==id)) ret.append(pyInteraction(I));} return ret;}
+		python::list withBodyAll(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;getId1()==id || I-&gt;getId2()==id) ret.append(pyInteraction(I));} return ret; }
 };
 
 Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(python::extract&lt;double&gt;(t[0])(),python::extract&lt;double&gt;(t[1])(),python::extract&lt;double&gt;(t[2])());}
@@ -422,8 +424,12 @@
 		pyBexContainer(){}
 		python::tuple force_get(long id){  MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r f=rb-&gt;bex.getForce(id); return python::make_tuple(f[0],f[1],f[2]); }
 		python::tuple torque_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getTorque(id); return python::make_tuple(m[0],m[1],m[2]);}
+		python::tuple move_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getMove(id); return python::make_tuple(m[0],m[1],m[2]);}
+		python::tuple rot_get(long id){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.sync(); Vector3r m=rb-&gt;bex.getRot(id); return python::make_tuple(m[0],m[1],m[2]);}
 		void force_add(long id, python::tuple f){  MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addForce (id,tuple2vec(f)); }
 		void torque_add(long id, python::tuple t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addTorque(id,tuple2vec(t));}
+		void move_add(long id, python::tuple t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addMove(id,tuple2vec(t));}
+		void rot_add(long id, python::tuple t){ MetaBody* rb=Omega::instance().getRootBody().get(); rb-&gt;bex.addRot(id,tuple2vec(t));}
 };
 
 class pyOmega{
@@ -596,7 +602,7 @@
 	pyBodyContainer bodies_get(void){assertRootBody(); return pyBodyContainer(OMEGA.getRootBody()-&gt;bodies); }
 	pyInteractionContainer interactions_get(void){assertRootBody(); return pyInteractionContainer(OMEGA.getRootBody()-&gt;interactions); }
 	
-	pyBexContainer actions_get(void){return pyBexContainer();}
+	pyBexContainer bex_get(void){return pyBexContainer();}
 	
 
 	boost::python::list listChildClasses(const string&amp; base){
@@ -693,7 +699,8 @@
 		.add_property(&quot;initializers&quot;,&amp;pyOmega::initializers_get,&amp;pyOmega::initializers_set)
 		.add_property(&quot;bodies&quot;,&amp;pyOmega::bodies_get)
 		.add_property(&quot;interactions&quot;,&amp;pyOmega::interactions_get)
-		.add_property(&quot;actions&quot;,&amp;pyOmega::actions_get)
+		.add_property(&quot;actions&quot;,&amp;pyOmega::bex_get)
+		.add_property(&quot;bex&quot;,&amp;pyOmega::bex_get)
 		.add_property(&quot;tags&quot;,&amp;pyOmega::tags_get)
 		.def(&quot;childClasses&quot;,&amp;pyOmega::listChildClasses)
 		.def(&quot;isChildClassOf&quot;,&amp;pyOmega::isChildClassOf)
@@ -721,6 +728,9 @@
 		.def(&quot;__getitem__&quot;,&amp;pyInteractionContainer::pyGetitem)
 		.def(&quot;__len__&quot;,&amp;pyInteractionContainer::len)
 		.def(&quot;nth&quot;,&amp;pyInteractionContainer::pyNth)
+		.def(&quot;withBody&quot;,&amp;pyInteractionContainer::withBody)
+		.def(&quot;withBodyAll&quot;,&amp;pyInteractionContainer::withBodyAll)
+		.def(&quot;nth&quot;,&amp;pyInteractionContainer::pyNth)
 		.def(&quot;clear&quot;,&amp;pyInteractionContainer::clear);
 	boost::python::class_&lt;pyInteractionIterator&gt;(&quot;InteractionIterator&quot;,python::init&lt;pyInteractionIterator&amp;&gt;())
 		.def(&quot;__iter__&quot;,&amp;pyInteractionIterator::pyIter)
@@ -730,8 +740,12 @@
 		.def(&quot;f&quot;,&amp;pyBexContainer::force_get)
 		.def(&quot;t&quot;,&amp;pyBexContainer::torque_get)
 		.def(&quot;m&quot;,&amp;pyBexContainer::torque_get) // for compatibility with ActionContainer
+		.def(&quot;move&quot;,&amp;pyBexContainer::move_get)
+		.def(&quot;rot&quot;,&amp;pyBexContainer::rot_get)
 		.def(&quot;addF&quot;,&amp;pyBexContainer::force_add)
-		.def(&quot;addT&quot;,&amp;pyBexContainer::torque_add);
+		.def(&quot;addT&quot;,&amp;pyBexContainer::torque_add)
+		.def(&quot;addMove&quot;,&amp;pyBexContainer::move_add)
+		.def(&quot;addRot&quot;,&amp;pyBexContainer::rot_add);
 
 	boost::python::class_&lt;pyTimingDeltas&gt;(&quot;TimingDeltas&quot;,python::init&lt;pyTimingDeltas&amp;&gt;())
 		.def(&quot;reset&quot;,&amp;pyTimingDeltas::reset)

Modified: trunk/gui/qt3/GLViewer.cpp
===================================================================
--- trunk/gui/qt3/GLViewer.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/qt3/GLViewer.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -19,6 +19,10 @@
 #include&lt;yade/core/Interaction.hpp&gt;
 #include&lt;boost/filesystem/operations.hpp&gt;
 #include&lt;boost/version.hpp&gt;
+#ifdef EMBED_PYTHON
+	#include&lt;boost/python.hpp&gt;
+	using namespace boost;
+#endif
 
 CREATE_LOGGER(GLViewer);
 GLLock::GLLock(GLViewer* _glv):
@@ -246,7 +250,7 @@
 	/* letters alphabetically */
 	else if(e-&gt;key()==Qt::Key_C &amp;&amp; selectedName() &gt;= 0 &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(selectedName())) setSceneCenter(manipulatedFrame()-&gt;position());
 	else if(e-&gt;key()==Qt::Key_C &amp;&amp; (e-&gt;state() &amp; AltButton)){ displayMessage(&quot;Median centering&quot;); centerMedianQuartile(); }
-	//else if(e-&gt;key()==Qt::Key_D) wasDynamic=true;
+	else if(e-&gt;key()==Qt::Key_D &amp;&amp;(e-&gt;state() &amp; AltButton)){ body_id_t id; if((id=Omega::instance().selectedBody)&gt;=0){ const shared_ptr&lt;Body&gt;&amp; b=Body::byId(id); b-&gt;isDynamic=!b-&gt;isDynamic; LOG_INFO(&quot;Body #&quot;&lt;&lt;id&lt;&lt;&quot; now &quot;&lt;&lt;(b-&gt;isDynamic?&quot;&quot;:&quot;NOT&quot;)&lt;&lt;&quot; dynamic&quot;); } }
 	else if(e-&gt;key()==Qt::Key_D) {timeDispMask+=1; if(timeDispMask&gt;(TIME_REAL|TIME_VIRT|TIME_ITER))timeDispMask=0; }
 	else if(e-&gt;key()==Qt::Key_G) {bool anyDrawn=drawGridXYZ[0]||drawGridXYZ[1]||drawGridXYZ[2]; for(int i=0; i&lt;3; i++)drawGridXYZ[i]=!anyDrawn; }
 	else if (e-&gt;key()==Qt::Key_M &amp;&amp; selectedName() &gt;= 0){
@@ -354,8 +358,8 @@
 	MetaBody* rb=Omega::instance().getRootBody().get();
 	if (!rb) return;
 
-	if(rb-&gt;bodies-&gt;size()&lt;500){LOG_INFO(&quot;Less than 500 bodies, moving possible. Select with shift, press 'm' to move.&quot;);}
-	else{LOG_INFO(&quot;More than 500 bodies. Moving not possible.&quot;);}
+	if(rb-&gt;bodies-&gt;size()&lt;renderer-&gt;selectBodyLimit){LOG_INFO(&quot;Less than &quot;+lexical_cast&lt;string&gt;(renderer-&gt;selectBodyLimit)+&quot; bodies, moving possible. Select with shift, press 'm' to move.&quot;);}
+	else{LOG_INFO(&quot;More than &quot;+lexical_cast&lt;string&gt;(renderer-&gt;selectBodyLimit)+&quot; (OpenGLRenderingEngine::selectBodyLimit) bodies. Moving not possible.&quot;);}
 	Vector3r min,max;	
 	if(rb-&gt;boundingVolume){
 		min=rb-&gt;boundingVolume-&gt;min; max=rb-&gt;boundingVolume-&gt;max;
@@ -385,9 +389,10 @@
 
 void GLViewer::draw()
 {
+	qglviewer::Vec vd=camera()-&gt;viewDirection(); renderer-&gt;viewDirection=Vector3r(vd[0],vd[1],vd[2]);
 	if(Omega::instance().getRootBody()){
 		int selection = selectedName();
-		if(selection!=-1 &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(selection)){
+		if(selection!=-1 &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(selection) &amp;&amp; isMoving){
 			static int last(-1);
 			if(last == selection) // delay by one redraw, so the body will not jump into 0,0,0 coords
 			{
@@ -421,7 +426,8 @@
 }
 
 void GLViewer::drawWithNames(){
-	if(Omega::instance().getRootBody() &amp;&amp; Omega::instance().getRootBody()-&gt;bodies-&gt;size()&lt;500) renderer-&gt;renderWithNames(Omega::instance().getRootBody());
+	qglviewer::Vec vd=camera()-&gt;viewDirection(); renderer-&gt;viewDirection=Vector3r(vd[0],vd[1],vd[2]);
+	if(Omega::instance().getRootBody() &amp;&amp; Omega::instance().getRootBody()-&gt;bodies-&gt;size()&lt;renderer-&gt;selectBodyLimit) renderer-&gt;renderWithNames(Omega::instance().getRootBody());
 }
 
 // new object selected.
@@ -446,12 +452,25 @@
 		setSelectedName(selection);
 		LOG_DEBUG(&quot;New selection &quot;&lt;&lt;selection);
 		displayMessage(&quot;Selected body #&quot;+lexical_cast&lt;string&gt;(selection)+(Body::byId(selection)-&gt;isClump()?&quot; (clump)&quot;:&quot;&quot;));
-		wasDynamic=Body::byId(selection)-&gt;isDynamic;
-		Body::byId(selection)-&gt;isDynamic = false;
+		//wasDynamic=Body::byId(selection)-&gt;isDynamic;
+		//Body::byId(selection)-&gt;isDynamic = false;
 		Quaternionr&amp; q = Body::byId(selection)-&gt;physicalParameters-&gt;se3.orientation;
 		Vector3r&amp;    v = Body::byId(selection)-&gt;physicalParameters-&gt;se3.position;
 		manipulatedFrame()-&gt;setPositionAndOrientation(qglviewer::Vec(v[0],v[1],v[2]),qglviewer::Quaternion(q[0],q[1],q[2],q[3]));
 		Omega::instance().selectedBody = selection;
+		#ifdef EMBED_PYTHON
+			try{
+				PyGILState_STATE gstate;
+					gstate = PyGILState_Ensure();
+					python::object main=python::import(&quot;__main__&quot;);
+					python::object global=main.attr(&quot;__dict__&quot;);
+					python::eval(string(&quot;onBodySelect(&quot;+lexical_cast&lt;string&gt;(selection)+&quot;)&quot;).c_str(),global,global);
+				PyGILState_Release(gstate);
+				// see <A HREF="https://svn.boost.org/trac/boost/ticket/2781">https://svn.boost.org/trac/boost/ticket/2781</A> for exception handling
+			} catch (python::error_already_set const &amp;) {
+				LOG_DEBUG(&quot;unable to call onBodySelect. Not defined?&quot;);
+			}
+		#endif
 	}
 }
 
@@ -459,9 +478,9 @@
 // if so, then set isDynamic of previous selection, to old value
 void GLViewer::endSelection(const QPoint &amp;point){
 	manipulatedClipPlane=-1;
-	int old = selectedName();
+	//int old = selectedName();
 	QGLViewer::endSelection(point);
-	if(old != -1 &amp;&amp; old!=selectedName() &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(old)) Body::byId(old)-&gt;isDynamic = wasDynamic;
+	// if(old != -1 &amp;&amp; old!=selectedName() &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(old)) Body::byId(old)-&gt;isDynamic = wasDynamic;
 }
 
 qglviewer::Vec GLViewer::displayedSceneCenter(){

Modified: trunk/gui/qt3/QtGeneratedSimulationController.ui
===================================================================
--- trunk/gui/qt3/QtGeneratedSimulationController.ui	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/qt3/QtGeneratedSimulationController.ui	2009-05-22 22:06:02 UTC (rev 1771)
@@ -8,8 +8,8 @@
         &lt;rect&gt;
             &lt;x&gt;0&lt;/x&gt;
             &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;271&lt;/width&gt;
-            &lt;height&gt;629&lt;/height&gt;
+            &lt;width&gt;252&lt;/width&gt;
+            &lt;height&gt;563&lt;/height&gt;
         &lt;/rect&gt;
     &lt;/property&gt;
     &lt;property name=&quot;sizePolicy&quot;&gt;
@@ -184,7 +184,7 @@
                     &lt;property name=&quot;minimumSize&quot;&gt;
                         &lt;size&gt;
                             &lt;width&gt;0&lt;/width&gt;
-                            &lt;height&gt;25&lt;/height&gt;
+                            &lt;height&gt;50&lt;/height&gt;
                         &lt;/size&gt;
                     &lt;/property&gt;
                     &lt;property name=&quot;text&quot;&gt;
@@ -350,50 +350,39 @@
                                 &lt;property name=&quot;flat&quot;&gt;
                                     &lt;bool&gt;false&lt;/bool&gt;
                                 &lt;/property&gt;
-                                &lt;widget class=&quot;QRadioButton&quot;&gt;
+                                &lt;vbox&gt;
                                     &lt;property name=&quot;name&quot;&gt;
-                                        &lt;cstring&gt;rbTimeStepper&lt;/cstring&gt;
+                                        &lt;cstring&gt;unnamed&lt;/cstring&gt;
                                     &lt;/property&gt;
-                                    &lt;property name=&quot;enabled&quot;&gt;
-                                        &lt;bool&gt;true&lt;/bool&gt;
-                                    &lt;/property&gt;
-                                    &lt;property name=&quot;geometry&quot;&gt;
-                                        &lt;rect&gt;
-                                            &lt;x&gt;10&lt;/x&gt;
-                                            &lt;y&gt;20&lt;/y&gt;
-                                            &lt;width&gt;116&lt;/width&gt;
-                                            &lt;height&gt;25&lt;/height&gt;
-                                        &lt;/rect&gt;
-                                    &lt;/property&gt;
-                                    &lt;property name=&quot;text&quot;&gt;
-                                        &lt;string&gt;Time stepper&lt;/string&gt;
-                                    &lt;/property&gt;
-                                    &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                        &lt;number&gt;0&lt;/number&gt;
-                                    &lt;/property&gt;
-                                &lt;/widget&gt;
-                                &lt;widget class=&quot;QRadioButton&quot;&gt;
-                                    &lt;property name=&quot;name&quot;&gt;
-                                        &lt;cstring&gt;rbFixed&lt;/cstring&gt;
-                                    &lt;/property&gt;
-                                    &lt;property name=&quot;enabled&quot;&gt;
-                                        &lt;bool&gt;true&lt;/bool&gt;
-                                    &lt;/property&gt;
-                                    &lt;property name=&quot;geometry&quot;&gt;
-                                        &lt;rect&gt;
-                                            &lt;x&gt;10&lt;/x&gt;
-                                            &lt;y&gt;50&lt;/y&gt;
-                                            &lt;width&gt;116&lt;/width&gt;
-                                            &lt;height&gt;25&lt;/height&gt;
-                                        &lt;/rect&gt;
-                                    &lt;/property&gt;
-                                    &lt;property name=&quot;text&quot;&gt;
-                                        &lt;string&gt;Fixed step&lt;/string&gt;
-                                    &lt;/property&gt;
-                                    &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                        &lt;number&gt;2&lt;/number&gt;
-                                    &lt;/property&gt;
-                                &lt;/widget&gt;
+                                    &lt;widget class=&quot;QRadioButton&quot;&gt;
+                                        &lt;property name=&quot;name&quot;&gt;
+                                            &lt;cstring&gt;rbTimeStepper&lt;/cstring&gt;
+                                        &lt;/property&gt;
+                                        &lt;property name=&quot;enabled&quot;&gt;
+                                            &lt;bool&gt;true&lt;/bool&gt;
+                                        &lt;/property&gt;
+                                        &lt;property name=&quot;text&quot;&gt;
+                                            &lt;string&gt;Time stepper&lt;/string&gt;
+                                        &lt;/property&gt;
+                                        &lt;property name=&quot;buttonGroupId&quot;&gt;
+                                            &lt;number&gt;0&lt;/number&gt;
+                                        &lt;/property&gt;
+                                    &lt;/widget&gt;
+                                    &lt;widget class=&quot;QRadioButton&quot;&gt;
+                                        &lt;property name=&quot;name&quot;&gt;
+                                            &lt;cstring&gt;rbFixed&lt;/cstring&gt;
+                                        &lt;/property&gt;
+                                        &lt;property name=&quot;enabled&quot;&gt;
+                                            &lt;bool&gt;true&lt;/bool&gt;
+                                        &lt;/property&gt;
+                                        &lt;property name=&quot;text&quot;&gt;
+                                            &lt;string&gt;Fixed step&lt;/string&gt;
+                                        &lt;/property&gt;
+                                        &lt;property name=&quot;buttonGroupId&quot;&gt;
+                                            &lt;number&gt;2&lt;/number&gt;
+                                        &lt;/property&gt;
+                                    &lt;/widget&gt;
+                                &lt;/vbox&gt;
                             &lt;/widget&gt;
                             &lt;widget class=&quot;QFrame&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
                                 &lt;property name=&quot;name&quot;&gt;
@@ -471,6 +460,12 @@
                                                         &lt;verstretch&gt;0&lt;/verstretch&gt;
                                                     &lt;/sizepolicy&gt;
                                                 &lt;/property&gt;
+                                                &lt;property name=&quot;minimumSize&quot;&gt;
+                                                    &lt;size&gt;
+                                                        &lt;width&gt;0&lt;/width&gt;
+                                                        &lt;height&gt;40&lt;/height&gt;
+                                                    &lt;/size&gt;
+                                                &lt;/property&gt;
                                                 &lt;property name=&quot;text&quot;&gt;
                                                     &lt;string&gt;&lt;/string&gt;
                                                 &lt;/property&gt;
@@ -531,6 +526,12 @@
                                                         &lt;verstretch&gt;0&lt;/verstretch&gt;
                                                     &lt;/sizepolicy&gt;
                                                 &lt;/property&gt;
+                                                &lt;property name=&quot;minimumSize&quot;&gt;
+                                                    &lt;size&gt;
+                                                        &lt;width&gt;0&lt;/width&gt;
+                                                        &lt;height&gt;40&lt;/height&gt;
+                                                    &lt;/size&gt;
+                                                &lt;/property&gt;
                                                 &lt;property name=&quot;text&quot;&gt;
                                                     &lt;string&gt;&lt;/string&gt;
                                                 &lt;/property&gt;
@@ -726,6 +727,60 @@
                             &lt;/widget&gt;
                         &lt;/grid&gt;
                     &lt;/widget&gt;
+                    &lt;widget class=&quot;QWidget&quot;&gt;
+                        &lt;property name=&quot;name&quot;&gt;
+                            &lt;cstring&gt;TabPage&lt;/cstring&gt;
+                        &lt;/property&gt;
+                        &lt;attribute name=&quot;title&quot;&gt;
+                            &lt;string&gt;Python&lt;/string&gt;
+                        &lt;/attribute&gt;
+                        &lt;vbox&gt;
+                            &lt;property name=&quot;name&quot;&gt;
+                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;widget class=&quot;QLineEdit&quot;&gt;
+                                &lt;property name=&quot;name&quot;&gt;
+                                    &lt;cstring&gt;pyOneliner&lt;/cstring&gt;
+                                &lt;/property&gt;
+                                &lt;property name=&quot;font&quot;&gt;
+                                    &lt;font&gt;
+                                        &lt;family&gt;Monospace&lt;/family&gt;
+                                    &lt;/font&gt;
+                                &lt;/property&gt;
+                            &lt;/widget&gt;
+                            &lt;widget class=&quot;QLabel&quot;&gt;
+                                &lt;property name=&quot;name&quot;&gt;
+                                    &lt;cstring&gt;textLabel1_2&lt;/cstring&gt;
+                                &lt;/property&gt;
+                                &lt;property name=&quot;text&quot;&gt;
+                                    &lt;string&gt;(Command output goes to the console, not here)&lt;/string&gt;
+                                &lt;/property&gt;
+                                &lt;property name=&quot;alignment&quot;&gt;
+                                    &lt;set&gt;WordBreak|AlignVCenter|AlignRight&lt;/set&gt;
+                                &lt;/property&gt;
+                                &lt;property name=&quot;indent&quot;&gt;
+                                    &lt;number&gt;-1&lt;/number&gt;
+                                &lt;/property&gt;
+                            &lt;/widget&gt;
+                            &lt;spacer&gt;
+                                &lt;property name=&quot;name&quot;&gt;
+                                    &lt;cstring&gt;spacer2&lt;/cstring&gt;
+                                &lt;/property&gt;
+                                &lt;property name=&quot;orientation&quot;&gt;
+                                    &lt;enum&gt;Vertical&lt;/enum&gt;
+                                &lt;/property&gt;
+                                &lt;property name=&quot;sizeType&quot;&gt;
+                                    &lt;enum&gt;Expanding&lt;/enum&gt;
+                                &lt;/property&gt;
+                                &lt;property name=&quot;sizeHint&quot;&gt;
+                                    &lt;size&gt;
+                                        &lt;width&gt;20&lt;/width&gt;
+                                        &lt;height&gt;191&lt;/height&gt;
+                                    &lt;/size&gt;
+                                &lt;/property&gt;
+                            &lt;/spacer&gt;
+                        &lt;/vbox&gt;
+                    &lt;/widget&gt;
                 &lt;/widget&gt;
                 &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
                     &lt;property name=&quot;name&quot;&gt;
@@ -927,6 +982,12 @@
         &lt;receiver&gt;QtGeneratedSimulationController&lt;/receiver&gt;
         &lt;slot&gt;pbZXY_clicked()&lt;/slot&gt;
     &lt;/connection&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;pyOneliner&lt;/sender&gt;
+        &lt;signal&gt;returnPressed()&lt;/signal&gt;
+        &lt;receiver&gt;QtGeneratedSimulationController&lt;/receiver&gt;
+        &lt;slot&gt;pyOnelinerEnter()&lt;/slot&gt;
+    &lt;/connection&gt;
 &lt;/connections&gt;
 &lt;includes&gt;
     &lt;include location=&quot;local&quot; impldecl=&quot;in implementation&quot;&gt;QtGeneratedSimulationController.ui.h&lt;/include&gt;
@@ -960,6 +1021,7 @@
     &lt;slot&gt;pbXYZ_clicked()&lt;/slot&gt;
     &lt;slot&gt;pbYZX_clicked()&lt;/slot&gt;
     &lt;slot&gt;pbZXY_clicked()&lt;/slot&gt;
+    &lt;slot&gt;pyOnelinerEnter()&lt;/slot&gt;
 &lt;/slots&gt;
 &lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
 &lt;/UI&gt;

Modified: trunk/gui/qt3/SimulationController.cpp
===================================================================
--- trunk/gui/qt3/SimulationController.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/qt3/SimulationController.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -15,6 +15,7 @@
 #include &lt;qpushbutton.h&gt;
 #include &lt;qgroupbox.h&gt;
 #include &lt;qradiobutton.h&gt;
+#include &lt;qlineedit.h&gt;
 #include &lt;boost/lexical_cast.hpp&gt;
 #include &lt;boost/filesystem/operations.hpp&gt;
 #include &lt;boost/filesystem/convenience.hpp&gt;
@@ -28,6 +29,11 @@
 #		define FOREACH BOOST_FOREACH
 #	endif
 
+#ifdef EMBED_PYTHON
+	#include&lt;boost/python.hpp&gt;
+#endif
+
+
 CREATE_LOGGER(SimulationController);
 
 using namespace boost;
@@ -84,6 +90,10 @@
 	// run timer ANY TIME (simulation may be started asynchronously)
 	updateTimerId=startTimer(refreshTime);
 
+	#ifndef EMBED_PYTHON
+		pyOneliner-&gt;setEnabled(false);
+		pyOneliner-&gt;setText(&quot;Yade compiled without Python&quot;);
+	#endif
 }
 
 /* restart timer with SimulationController::refreshTime */
@@ -116,6 +126,27 @@
 };
 
 
+/* enter was pressed in the line-entry;
+   execute the command and make the line empty
+*/
+void SimulationController::pyOnelinerEnter(){
+#ifdef EMBED_PYTHON
+	PyGILState_STATE gstate;
+		gstate = PyGILState_Ensure();
+		try{
+			python::object main=python::import(&quot;__main__&quot;);
+			python::object global=main.attr(&quot;__dict__&quot;);
+			python::exec(pyOneliner-&gt;text().ascii(),global,global);
+		} catch (const python::error_already_set&amp; e){
+			LOG_ERROR(&quot;Error from python...&quot;);
+			PyErr_Print();
+		}
+	PyGILState_Release(gstate);
+	pyOneliner-&gt;clear();
+#endif
+};
+
+
 void SimulationController::pbLoadClicked()
 {
 	pbStopClicked();

Modified: trunk/gui/qt3/SimulationController.hpp
===================================================================
--- trunk/gui/qt3/SimulationController.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/gui/qt3/SimulationController.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -79,6 +79,7 @@
 		virtual void pbXYZ_clicked();
 		virtual void pbYZX_clicked();
 		virtual void pbZXY_clicked();
+		virtual void pyOnelinerEnter();
 
 
 

Modified: trunk/lib/import/STLImporter.cpp
===================================================================
--- trunk/lib/import/STLImporter.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/lib/import/STLImporter.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -50,7 +50,6 @@
 		shared_ptr&lt;Facet&gt; gFacet(new Facet);
 		gFacet-&gt;diffuseColor    = Vector3r(0.5,0.5,0.5);
 		gFacet-&gt;wire	    = wire;
-		gFacet-&gt;visible	    = true;
 		gFacet-&gt;shadowCaster    = true;
 
 		for (int j=0; j&lt;3; ++j)

Modified: trunk/lib/opengl/GLUtils.hpp
===================================================================
--- trunk/lib/opengl/GLUtils.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/lib/opengl/GLUtils.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -6,6 +6,7 @@
 
 #include&lt;yade/lib-opengl/OpenGLWrapper.hpp&gt;
 #include&lt;yade/lib-QGLViewer/qglviewer.h&gt;
+#include&lt;boost/lexical_cast.hpp&gt;
 #include&lt;sstream&gt;
 #include&lt;iomanip&gt;
 #include&lt;string&gt;
@@ -24,6 +25,10 @@
 		GLUtils::GLDrawText(oss.str(),pos,color);
 	}
 
+	static void GLDrawInt(long i, const Vector3r&amp; pos, const Vector3r&amp; color=Vector3r(1,1,1)){
+		GLUtils::GLDrawText(boost::lexical_cast&lt;std::string&gt;(i),pos,color);
+	}
+
 	static void GLDrawText(const std::string&amp; txt, const Vector3r&amp; pos, const Vector3r&amp; color=Vector3r(1,1,1)){
 		glPushMatrix();
 		glTranslatev(pos);

Modified: trunk/lib/opengl/OpenGLWrapper.hpp
===================================================================
--- trunk/lib/opengl/OpenGLWrapper.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/lib/opengl/OpenGLWrapper.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -14,50 +14,50 @@
 #include &lt;GL/gl.h&gt;
 #include &lt;GL/glut.h&gt;
 
-template &lt;bool&gt; struct static_assert;
-template &lt;&gt; struct static_assert&lt;true&gt; {};
+template &lt;bool&gt; struct static_assert_;
+template &lt;&gt; struct static_assert_&lt;true&gt; {};
 
 struct OpenGLWrapper {}; // for ctags
 
 ///	Primary Templates
 
-template&lt; typename Type &gt; inline void glRotate		( Type ,Type ,Type , Type  )	{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glScale		( Type ,Type , Type  )		{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glScalev		( const Type  )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTranslate	( Type ,Type , Type  )		{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTranslatev	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glVertex2		( Type ,Type  )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glVertex3		( Type ,Type , Type  )		{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glVertex4		( Type ,Type ,Type , Type  )	{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glVertex2v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glVertex3v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glVertex4v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glNormal3		( Type ,Type ,Type  )		{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glNormal3v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glIndex		( Type  )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glIndexv		( Type  )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glColor3		( Type ,Type ,Type  )		{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glColor4		( Type ,Type ,Type , Type  )	{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glColor3v		( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glColor4v		( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord1	( Type  )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord2	( Type ,Type  )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord3	( Type ,Type , Type  )		{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord4	( Type ,Type ,Type , Type  )	{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord1v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord2v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord3v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glTexCoord4v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glRasterPos2	( Type ,Type  )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glRasterPos3	( Type ,Type , Type  )		{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glRasterPos4	( Type ,Type ,Type , Type  )	{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glRasterPos2v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glRasterPos3v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glRasterPos4v	( const Type )			{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glRect		( Type ,Type ,Type , Type  )	{	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glMaterial	( GLenum face, GLenum pname, Type param ){	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glMaterialv	( GLenum face, GLenum pname, Type param ){	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
-template&lt; typename Type &gt; inline void glMultMatrix	(const Type*){	static_assert&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRotate		( Type ,Type ,Type , Type  )	{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glScale		( Type ,Type , Type  )		{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glScalev		( const Type  )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTranslate	( Type ,Type , Type  )		{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTranslatev	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glVertex2		( Type ,Type  )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glVertex3		( Type ,Type , Type  )		{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glVertex4		( Type ,Type ,Type , Type  )	{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glVertex2v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glVertex3v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glVertex4v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glNormal3		( Type ,Type ,Type  )		{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glNormal3v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glIndex		( Type  )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glIndexv		( Type  )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glColor3		( Type ,Type ,Type  )		{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glColor4		( Type ,Type ,Type , Type  )	{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glColor3v		( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glColor4v		( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord1	( Type  )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord2	( Type ,Type  )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord3	( Type ,Type , Type  )		{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord4	( Type ,Type ,Type , Type  )	{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord1v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord2v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord3v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glTexCoord4v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRasterPos2	( Type ,Type  )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRasterPos3	( Type ,Type , Type  )		{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRasterPos4	( Type ,Type ,Type , Type  )	{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRasterPos2v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRasterPos3v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRasterPos4v	( const Type )			{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glRect		( Type ,Type ,Type , Type  )	{	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glMaterial	( GLenum face, GLenum pname, Type param ){	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glMaterialv	( GLenum face, GLenum pname, Type param ){	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
+template&lt; typename Type &gt; inline void glMultMatrix	(const Type*){	static_assert_&lt;false&gt; GL_OpenGLWrapper_bad_type;(void) GL_OpenGLWrapper_bad_type; };
 
 
 ///	Template Specializations

Deleted: trunk/pkg/common/Container/InteractionVecSet.hpp
===================================================================
--- trunk/pkg/common/Container/InteractionVecSet.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Container/InteractionVecSet.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -1 +0,0 @@
-#include&lt;yade/core/InteractionVecSet.hpp&gt;

Modified: trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -6,30 +6,15 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;TranslationEngine.hpp&quot;
+#include&quot;TranslationEngine.hpp&quot;
 #include&lt;yade/pkg-common/ParticleParameters.hpp&gt;
 #include&lt;yade/core/MetaBody.hpp&gt;
 
-void TranslationEngine::postProcessAttributes(bool deserializing)
-{
-	if(deserializing)
-		translationAxis.Normalize();
-}
-
-
-void TranslationEngine::registerAttributes()
-{
-	DeusExMachina::registerAttributes();
-	REGISTER_ATTRIBUTE(velocity);
-	REGISTER_ATTRIBUTE(translationAxis);
-}
-
-
 void TranslationEngine::applyCondition(MetaBody * ncb){
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies=ncb-&gt;bodies;
 
 	Real dt=Omega::instance().getTimeStep();
-	static int sign = 1;
+	const int sign = 1; // ?
 	FOREACH(body_id_t id,subscribedBodies){
 		assert(id&lt;bodies-&gt;size());
 		if(ParticleParameters* p = dynamic_cast&lt;ParticleParameters*&gt;((*bodies)[id]-&gt;physicalParameters.get())){

Modified: trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -9,23 +9,17 @@
 #pragma once
 
 #include&lt;yade/core/DeusExMachina.hpp&gt;
-#include &lt;Wm3Vector3.h&gt;
 #include&lt;yade/lib-base/yadeWm3.hpp&gt;
 
-class TranslationEngine : public DeusExMachina
-{
-	public :
+class TranslationEngine : public DeusExMachina {
+	public:
 		Real velocity;
 		Vector3r translationAxis;
-		void applyCondition(MetaBody *);
-
-	protected :
-		virtual void postProcessAttributes(bool deserializing);
-		void registerAttributes();
-	REGISTER_CLASS_NAME(TranslationEngine);
-	REGISTER_BASE_CLASS_NAME(DeusExMachina);
+		virtual void applyCondition(MetaBody *);
+		virtual void postProcessAttributes(bool deserializing){ if(deserializing) translationAxis.Normalize(); }
+	REGISTER_ATTRIBUTES(DeusExMachina,(velocity)(translationAxis));
+	REGISTER_CLASS_AND_BASE(TranslationEngine,DeusExMachina);
 };
-
 REGISTER_SERIALIZABLE(TranslationEngine);
 
 

Modified: trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.cpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -13,7 +13,7 @@
 // FIXME : should we pass timestep as parameter of functor
 // FIXME : what's with timestepper
 void LeapFrogOrientationIntegrator::go(	  const shared_ptr&lt;PhysicalParameters&gt;&amp; b
-						, Body* body)
+						, Body* body, BexContainer&amp; bex)
 {
 	if(!body-&gt;isDynamic) return;
 		
@@ -43,6 +43,8 @@
 		if((rb-&gt;blockedDOFs &amp; PhysicalParameters::DOF_RY)==0) rb-&gt;angularVelocity[1]+=dt*rb-&gt;angularAcceleration[1];
 		if((rb-&gt;blockedDOFs &amp; PhysicalParameters::DOF_RZ)==0) rb-&gt;angularVelocity[2]+=dt*rb-&gt;angularAcceleration[2];
 	}
+	if(bex.getMoveRotUsed() &amp;&amp; bex.getRot(body-&gt;getId())!=Vector3r::ZERO){ Vector3r r(bex.getRot(body-&gt;getId())); Real norm=r.Normalize(); q.FromAxisAngle(r,norm); rb-&gt;se3.orientation=q*rb-&gt;se3.orientation; }
+
 	rb-&gt;se3.orientation.Normalize();
 
 // 	firsts[id] = false;

Modified: trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.hpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/EngineUnit/LeapFrogOrientationIntegrator.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -18,7 +18,7 @@
 	
 	public :
 		virtual void go( 	  const shared_ptr&lt;PhysicalParameters&gt;&amp;
-					, Body*);
+					, Body*, BexContainer&amp; );
 
 	FUNCTOR1D(RigidBodyParameters);	
 	REGISTER_CLASS_NAME(LeapFrogOrientationIntegrator);

Modified: trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.cpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -11,10 +11,8 @@
 #include&lt;yade/core/Omega.hpp&gt;
 
 
-// FIXME : should we pass timestep as parameter of functor
-// FIXME : what's with timestepper
-void LeapFrogPositionIntegrator::go(       const shared_ptr&lt;PhysicalParameters&gt;&amp; b
-						, Body* body)
+void LeapFrogPositionIntegrator::go(const shared_ptr&lt;PhysicalParameters&gt;&amp; b
+						, Body* body, BexContainer&amp; bex)
 {
 	if(!body-&gt;isDynamic) return;
 
@@ -39,7 +37,7 @@
 		if((p-&gt;blockedDOFs &amp; PhysicalParameters::DOF_Y)==0) p-&gt;velocity[1]+=dt*p-&gt;acceleration[1];
 		if((p-&gt;blockedDOFs &amp; PhysicalParameters::DOF_Z)==0) p-&gt;velocity[2]+=dt*p-&gt;acceleration[2];
 	}
-	p-&gt;se3.position += p-&gt;velocity*dt;
+	p-&gt;se3.position += p-&gt;velocity*dt + bex.getMove(body-&gt;getId());
 
 	//cerr&lt;&lt;&quot;#&quot;&lt;&lt;body-&gt;getId()&lt;&lt;&quot;dx=&quot;&lt;&lt;prevVelocities[id]*dt&lt;&lt;endl;
 

Modified: trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.hpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/EngineUnit/LeapFrogPositionIntegrator.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -18,7 +18,7 @@
 	
 	public :
 		virtual void go(	  const shared_ptr&lt;PhysicalParameters&gt;&amp;
-					, Body*);
+					, Body*, BexContainer&amp;);
 
 	FUNCTOR1D(ParticleParameters);	
 	REGISTER_CLASS_NAME(LeapFrogPositionIntegrator);

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -40,8 +40,8 @@
 			// and can call go in all cases
 			if(swap){I-&gt;swapOrder();}
 			// body pointers must be updated, in case we swapped
-			const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(I-&gt;getId1());
-			const shared_ptr&lt;Body&gt;&amp; b2=Body::byId(I-&gt;getId2());
+			const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(I-&gt;getId1(),rootBody);
+			const shared_ptr&lt;Body&gt;&amp; b2=Body::byId(I-&gt;getId2(),rootBody);
 
 			assert(I-&gt;functorCache.geom);
 			I-&gt;isReal=I-&gt;functorCache.geom-&gt;go(b1-&gt;interactingGeometry,b2-&gt;interactingGeometry,b1-&gt;physicalParameters-&gt;se3, b2-&gt;physicalParameters-&gt;se3,I);

Modified: trunk/pkg/common/Engine/MetaEngine/PhysicalParametersEngineUnit.hpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/PhysicalParametersEngineUnit.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/MetaEngine/PhysicalParametersEngineUnit.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -11,6 +11,7 @@
 #include&lt;yade/core/PhysicalParameters.hpp&gt;
 #include&lt;yade/core/Body.hpp&gt;
 #include&lt;yade/core/EngineUnit1D.hpp&gt;
+#include&lt;yade/core/BexContainer.hpp&gt;
 
 /*! \brief
 	Abstract interface for all classes that want to do something depending on PhysicalParameters (works like adding external virtual function)
@@ -25,8 +26,8 @@
 class PhysicalParametersEngineUnit :    public EngineUnit1D
 					&lt;
 		 				void ,
-		 				TYPELIST_2(	  const shared_ptr&lt;PhysicalParameters&gt;&amp;
-								, Body*
+		 				TYPELIST_3(	  const shared_ptr&lt;PhysicalParameters&gt;&amp;
+								, Body*, BexContainer&amp;
 			   				  )
 					&gt;
 {	

Modified: trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -15,16 +15,17 @@
 void PhysicalParametersMetaEngine::action(MetaBody* ncb)
 {
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+	ncb-&gt;bex.sync();
 	
 	BodyContainer::iterator bi    = bodies-&gt;begin();
 	BodyContainer::iterator biEnd = bodies-&gt;end();
 	for( ; bi!=biEnd ; ++bi )
 	{
 		shared_ptr&lt;Body&gt; b = *bi;
-		operator()(b-&gt;physicalParameters,b.get());
+		operator()(b-&gt;physicalParameters,b.get(),ncb-&gt;bex);
 	}
 	
- 	operator()(ncb-&gt;physicalParameters,ncb);
+ 	operator()(ncb-&gt;physicalParameters,ncb,ncb-&gt;bex);
 }
 
 YADE_PLUGIN();

Modified: trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/MetaEngine/PhysicalParametersMetaEngine.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -13,14 +13,15 @@
 #include&lt;yade/lib-multimethods/DynLibDispatcher.hpp&gt;
 #include&lt;yade/core/PhysicalParameters.hpp&gt;
 #include&lt;yade/core/Body.hpp&gt;
+#include&lt;yade/core/BexContainer.hpp&gt;
 
 class PhysicalParametersMetaEngine :	public MetaEngine1D
 					&lt;	
 						PhysicalParameters ,
 						PhysicalParametersEngineUnit,
 						void ,
-						TYPELIST_2(	  const shared_ptr&lt;PhysicalParameters&gt;&amp;
-								, Body*
+						TYPELIST_3(	  const shared_ptr&lt;PhysicalParameters&gt;&amp;
+								, Body*, BexContainer&amp;
 				  			  )
 					&gt;
 {

Added: trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -0,0 +1,161 @@
+// 2009 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
+
+#include&quot;InsertionSortCollider.hpp&quot;
+#include&lt;yade/core/MetaBody.hpp&gt;
+#include&lt;yade/core/Interaction.hpp&gt;
+#include&lt;yade/core/InteractionContainer.hpp&gt;
+
+#include&lt;algorithm&gt;
+#include&lt;vector&gt;
+#include&lt;boost/static_assert.hpp&gt;
+
+using namespace std;
+
+YADE_PLUGIN(&quot;InsertionSortCollider&quot;)
+
+CREATE_LOGGER(InsertionSortCollider);
+
+// return true if bodies bb overlap in all 3 dimensions
+bool InsertionSortCollider::spatialOverlap(body_id_t id1, body_id_t id2){
+	return
+		(minima[3*id1+0]&lt;maxima[3*id2+0]) &amp;&amp; (maxima[3*id1+0]&gt;minima[3*id2+0]) &amp;&amp;
+		(minima[3*id1+1]&lt;maxima[3*id2+1]) &amp;&amp; (maxima[3*id1+1]&gt;minima[3*id2+1]) &amp;&amp;
+		(minima[3*id1+2]&lt;maxima[3*id2+2]) &amp;&amp; (maxima[3*id1+2]&gt;minima[3*id2+2]);
+}
+
+// called by the insertion sort if 2 bodies swapped their bounds
+void InsertionSortCollider::handleBoundInversion(body_id_t id1, body_id_t id2, InteractionContainer* interactions, MetaBody* rb){
+	// do bboxes overlap in all 3 dimensions?
+	bool overlap=spatialOverlap(id1,id2);
+	// existing interaction?
+	const shared_ptr&lt;Interaction&gt;&amp; I=interactions-&gt;find(id1,id2);
+	bool hasInter=(bool)I;
+	// interaction doesn't exist and shouldn't, or it exists and should
+	if((!overlap &amp;&amp; !hasInter) || (overlap &amp;&amp; hasInter)) return;
+	// create interaction if not yet existing
+	if(overlap &amp;&amp; !hasInter){ // second condition only for readability
+		// FIXME: if(!Collider::mayCollide(bi.get(),bj.get())) return;
+		if(!Collider::mayCollide(Body::byId(id1,rb).get(),Body::byId(id2,rb).get())) return;
+		LOG_TRACE(&quot;Creating new interaction #&quot;&lt;&lt;id1&lt;&lt;&quot;+#&quot;&lt;&lt;id2);
+		shared_ptr&lt;Interaction&gt; newI=shared_ptr&lt;Interaction&gt;(new Interaction(id1,id2));
+		interactions-&gt;insert(newI);
+		return;
+	}
+	/* Note: this doesn't cover all disappearing interactions, only those that broke in the sortAxis direction;
+	 	it is only a minor optimization (to be verified) to have it here.
+		The rest of interaction will be deleted at the end of action. */
+	if(!overlap &amp;&amp; hasInter){ if(!I-&gt;isReal) interactions-&gt;erase(id1,id2); return; }
+	assert(false); // unreachable
+}
+
+void InsertionSortCollider::insertionSort(vector&lt;Bound&gt;&amp; v, InteractionContainer* interactions, MetaBody* rb){
+	long size=v.size();
+	for(long i=0; i&lt;size; i++){
+		Bound viInit=v[i]; long j=i-1;
+		while(j&gt;=0 &amp;&amp; v[j]&gt;viInit){
+			v[j+1]=v[j];
+			handleBoundInversion(viInit.id,v[j].id,interactions,rb);
+			j--;
+		}
+		v[j+1]=viInit;
+	}
+}
+
+void InsertionSortCollider::action(MetaBody* rb){
+	//timingDeltas-&gt;start();
+
+	size_t nBodies=rb-&gt;bodies-&gt;size();
+	// int axis1=(sortAxis+1)%3, axis2=(sortAxis+2)%3, axis0=sortAxis;
+	long iter=rb-&gt;currentIteration;
+	InteractionContainer* interactions=rb-&gt;interactions.get();
+
+
+	// pre-conditions
+		// adjust storage size
+		bool doInitSort=false;
+		if(XX.size()!=2*nBodies){
+			LOG_DEBUG(&quot;Resize bounds containers from &quot;&lt;&lt;XX.size()&lt;&lt;&quot; to &quot;&lt;&lt;nBodies*2&lt;&lt;&quot;, will std::sort.&quot;);
+			// bodies deleted; clear the container completely, and do as if all bodies were added (rather slow&#8230;)
+			if(2*nBodies&lt;XX.size()){ XX.clear(); YY.clear(); ZZ.clear(); }
+			// more than 100 bodies was added, do initial sort again
+			// maybe: should rather depend on ratio of added bodies to those already present...?
+			if(2*nBodies-XX.size()&gt;200 || XX.size()==0) doInitSort=true;
+			XX.reserve(2*nBodies); YY.reserve(2*nBodies); ZZ.reserve(2*nBodies);
+			assert((XX.size()%2)==0);
+			for(size_t id=XX.size()/2; id&lt;nBodies; id++){
+				// add lower and upper bounds; coord is not important, will be updated from bb shortly
+				XX.push_back(Bound(0,id,true)); XX.push_back(Bound(0,id,false));
+				YY.push_back(Bound(0,id,true)); YY.push_back(Bound(0,id,false));
+				ZZ.push_back(Bound(0,id,true)); ZZ.push_back(Bound(0,id,false));
+			}
+		}
+		if(minima.size()!=3*nBodies){ minima.resize(3*nBodies); maxima.resize(3*nBodies); }
+		assert(XX.size()==2*rb-&gt;bodies-&gt;size());
+
+	//timingDeltas-&gt;checkpoint(&quot;setup&quot;);
+
+	// copy bounds along given axis into our arrays
+		for(size_t i=0; i&lt;2*nBodies; i++){
+			const body_id_t&amp; idXX=XX[i].id; const body_id_t&amp; idYY=YY[i].id; const body_id_t&amp; idZZ=ZZ[i].id;
+			const shared_ptr&lt;BoundingVolume&gt;&amp; bvXX=Body::byId(idXX,rb)-&gt;boundingVolume; const shared_ptr&lt;BoundingVolume&gt;&amp; bvYY=Body::byId(idYY,rb)-&gt;boundingVolume; const shared_ptr&lt;BoundingVolume&gt;&amp; bvZZ=Body::byId(idZZ,rb)-&gt;boundingVolume;
+			// if(!bvXX){ LOG_FATAL(&quot;InsertionSortCollider doesn't handle boundingVolume-less bodies.&quot;); throw runtime_error(&quot;InsertionSortCollider encountered boundingVolume-less body.&quot;); }
+			XX[i].coord=bvXX ? (XX[i].isMin ? bvXX-&gt;min[0] : bvXX-&gt;max[0]) : Body::byId(idXX,rb)-&gt;physicalParameters-&gt;se3.position[0];
+			YY[i].coord=bvYY ? (YY[i].isMin ? bvYY-&gt;min[1] : bvYY-&gt;max[1]) : Body::byId(idYY,rb)-&gt;physicalParameters-&gt;se3.position[1];
+			ZZ[i].coord=bvZZ ? (ZZ[i].isMin ? bvZZ-&gt;min[2] : bvZZ-&gt;max[2]) : Body::byId(idZZ,rb)-&gt;physicalParameters-&gt;se3.position[2];
+			//YY[i].coord=(YY[i].isMin ? Body::byId(YY[i].id,rb)-&gt;boundingVolume-&gt;min[1] :  Body::byId(YY[i].id,rb)-&gt;boundingVolume-&gt;max[1]);
+			//ZZ[i].coord=(ZZ[i].isMin ? Body::byId(ZZ[i].id,rb)-&gt;boundingVolume-&gt;min[2] :  Body::byId(ZZ[i].id,rb)-&gt;boundingVolume-&gt;max[2]);
+			// and for each body, copy its minima and maxima arrays as well
+			if(XX[i].isMin){
+				BOOST_STATIC_ASSERT(sizeof(Vector3r)==3*sizeof(Real));
+				//minima[3*id]=bvXX-&gt;min[0]; minima[3*id+1]=bvXX-&gt;min[1]; minima[3*id+2]=bvXX-&gt;min[2]; maxima[3*id]=bvXX-&gt;max[0]; maxima[3*id+1]=bvXX-&gt;max[1]; maxima[3*id+2]=bvXX-&gt;max[2];
+				if(bvXX) { memcpy(&amp;minima[3*idXX],&amp;bvXX-&gt;min,3*sizeof(Real)); memcpy(&amp;maxima[3*idXX],&amp;bvXX-&gt;max,3*sizeof(Real)); } // &#8656; faster than 6 assignments 
+				else{ const Vector3r&amp; pos=Body::byId(idXX,rb)-&gt;physicalParameters-&gt;se3.position; memcpy(&amp;minima[3*idXX],pos,3*sizeof(Real)); memcpy(&amp;maxima[3*idXX],pos,3*sizeof(Real)); }
+			}
+		}
+
+	//timingDeltas-&gt;checkpoint(&quot;copy&quot;);
+	
+
+	// sort
+		if(!doInitSort){
+			insertionSort(XX,interactions,rb);
+			insertionSort(YY,interactions,rb);
+			insertionSort(ZZ,interactions,rb);
+		}
+		else {
+			std::sort(XX.begin(),XX.end());
+			std::sort(YY.begin(),YY.end());
+			std::sort(ZZ.begin(),ZZ.end());
+			// traverse the container along requested axis
+			assert(sortAxis==0 || sortAxis==1 || sortAxis==2);
+			vector&lt;Bound&gt;&amp; V=(sortAxis==0?XX:(sortAxis==1?YY:ZZ));
+			// go through potential aabb collisions, create interactions as necessary
+			for(size_t i=0; i&lt;2*nBodies; i++){
+				// start from the lower bound
+				if(!V[i].isMin) continue;
+				const body_id_t&amp; iid=V[i].id;
+				// TRVAR3(i,iid,V[i].coord);
+				// go up until we meet the upper bound
+				for(size_t j=i+1; V[j].id!=iid; j++){
+					// skip bodies with smaller (arbitrary, could be greater as well) id,
+					// since they will detect us when their turn comes
+					const body_id_t&amp; jid=V[j].id;
+					if(jid&lt;iid) { /* LOG_TRACE(&quot;Skip #&quot;&lt;&lt;V[j].id&lt;&lt;(V[j].isMin?&quot;(min)&quot;:&quot;(max)&quot;)&lt;&lt;&quot; with &quot;&lt;&lt;iid&lt;&lt;&quot; (smaller id)&quot;); */ continue; }
+					handleBoundInversion(iid,jid,interactions,rb);
+				}
+			}
+		}
+	//timingDeltas-&gt;checkpoint(&quot;sort&amp;collide&quot;);
+
+	// garbage collection once in a while: for interactions that were still real when the bounding boxes separated
+	// the collider would never get to see them again otherwise
+	if(iter%1000==0){
+		typedef pair&lt;body_id_t,body_id_t&gt; bodyIdPair;
+		list&lt;bodyIdPair&gt; toBeDeleted;
+		FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I,*interactions){
+			if(!I-&gt;isReal &amp;&amp; (!I-&gt;isNew || !spatialOverlap(I-&gt;getId1(),I-&gt;getId2()))) toBeDeleted.push_back(bodyIdPair(I-&gt;getId1(),I-&gt;getId2()));
+		}
+		FOREACH(const bodyIdPair&amp; p, toBeDeleted){ interactions-&gt;erase(p.first,p.second); LOG_TRACE(&quot;Deleted interaction #&quot;&lt;&lt;p.first&lt;&lt;&quot;+#&quot;&lt;&lt;p.second); }
+	}
+	//timingDeltas-&gt;checkpoint(&quot;stale&quot;);
+}

Added: trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -0,0 +1,59 @@
+// 2009 &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt; 
+
+#pragma once
+#include&lt;yade/core/Collider.hpp&gt;
+class InteractionContainer;
+/* Collider that should run in O(n log(n)) time, but faster than PersistentSAPCollider.
+
+	At the initial step, Bodies' bounds (along sortAxis) are first std::sort'ed along one axis (sortAxis), then collided.
+
+	Insertion sort is used for sorting the bound list that is already pre-sorted from last iteration, where each inversion
+	calls checkOverlap which then handles either overlap (by creating interaction if necessary) or its absence (by deleting
+	interaction if it exists and is only potential (!isReal &amp;&amp; isNew).
+
+	Note that not all interactions are traversed at one run, therefore an overlap miss also has to check the interaction container.
+
+	For performance reasons, we require all bodies to have boundingVolume.
+
+*/
+
+class InsertionSortCollider: public Collider{
+	//! struct for storing bounds of bodies
+	struct Bound{
+		//! coordinate along the given sortAxis
+		Real coord;
+		//! id of the body this bound belongs to
+		body_id_t id;
+		//! is it the minimum (true) or maximum (false) bound?
+		bool isMin;
+		Bound(Real coord_, body_id_t id_, bool isMin_): coord(coord_), id(id_), isMin(isMin_){}
+		//Bound(const Bound&amp; b): coord(b.coord), id(b.id), isMin(b.isMin){}
+		//Bound&amp; operator=(const Bound&amp; b){ coord=b.coord; id=b.id; isMin=b.isMin; cerr&lt;&lt;&quot;!=!&quot;&lt;&lt;endl; return *this;}
+		bool operator&lt;(const Bound&amp; b) const {return coord&lt;b.coord;}
+		bool operator&gt;(const Bound&amp; b) const {return coord&gt;b.coord;}
+	};
+	//! storage for bounds
+	std::vector&lt;Bound&gt; XX,YY,ZZ;
+	//! storage for bb maxima and minima
+	std::vector&lt;Real&gt; maxima, minima;
+
+
+
+	/*! sorting routine; insertion sort is very fast for strongly pre-sorted lists, which is our case
+  	    <A HREF="http://en.wikipedia.org/wiki/Insertion_sort">http://en.wikipedia.org/wiki/Insertion_sort</A> has the algorithm and other details
+	*/
+	void insertionSort(std::vector&lt;Bound&gt;&amp; v,InteractionContainer*,MetaBody*);
+	void handleBoundInversion(body_id_t,body_id_t,InteractionContainer*,MetaBody*);
+	bool spatialOverlap(body_id_t,body_id_t);
+
+	public:
+	//! axis for the initial sort
+	int sortAxis;
+
+	InsertionSortCollider(): sortAxis(0){ /* timingDeltas=shared_ptr&lt;TimingDeltas&gt;(new TimingDeltas);*/ }
+	virtual void action(MetaBody*);
+	REGISTER_CLASS_AND_BASE(InsertionSortCollider,Collider);
+	REGISTER_ATTRIBUTES(Collider,(sortAxis));
+	DECLARE_LOGGER;
+};
+REGISTER_SERIALIZABLE(InsertionSortCollider);

Modified: trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -112,19 +112,6 @@
 	// serial version
 	//if(nbObjects&gt;ompBodiesMin || ompBodiesMin==0){ &#8230; }
 	sortBounds(xBounds,nbObjects); sortBounds(yBounds,nbObjects); sortBounds(zBounds,nbObjects);
-	#if 0
-		else {
-			#pragma omp parallel sections
-			{
-			#pragma omp section
-				sortBounds(xBounds, nbObjects);
-			#pragma omp section
-				sortBounds(yBounds, nbObjects);
-			#pragma omp section
-				sortBounds(zBounds, nbObjects);
-			}
-		}
-	#endif
 
 //	timingDeltas-&gt;checkpoint(&quot;sortBounds&quot;);
 }

Modified: trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -6,22 +6,14 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;PhysicalActionContainerReseter.hpp&quot;
+#include&quot;PhysicalActionContainerReseter.hpp&quot;
 #include&lt;yade/core/MetaBody.hpp&gt;
 
+YADE_PLUGIN(&quot;PhysicalActionContainerReseter&quot;,&quot;BexResetter&quot;);
 
-PhysicalActionContainerReseter::PhysicalActionContainerReseter() 
-{
-}
+PhysicalActionContainerReseter::PhysicalActionContainerReseter(){}
+PhysicalActionContainerReseter::~PhysicalActionContainerReseter(){} 
+void PhysicalActionContainerReseter::action(MetaBody* ncb){ ncb-&gt;bex.reset(); }
 
-PhysicalActionContainerReseter::~PhysicalActionContainerReseter() 
-{
-}
+void BexResetter::action(MetaBody* ncb){ ncb-&gt;bex.reset(); }
 
-void PhysicalActionContainerReseter::action(MetaBody* ncb)
-{
-	ncb-&gt;bex.reset();
-}
-
-
-YADE_PLUGIN();

Modified: trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/StandAloneEngine/PhysicalActionContainerReseter.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -19,10 +19,15 @@
 		virtual ~PhysicalActionContainerReseter();
 		virtual void action(MetaBody*);
 
-	REGISTER_CLASS_NAME(PhysicalActionContainerReseter);
-	REGISTER_BASE_CLASS_NAME(StandAloneEngine);
+	REGISTER_CLASS_AND_BASE(PhysicalActionContainerReseter,StandAloneEngine);
 };
-
 REGISTER_SERIALIZABLE(PhysicalActionContainerReseter);
 
+class BexResetter: public StandAloneEngine{
+	public:
+		virtual void action(MetaBody*);
+	REGISTER_CLASS_AND_BASE(BexResetter,StandAloneEngine);
+};
+REGISTER_SERIALIZABLE(BexResetter);
 
+

Modified: trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -164,7 +164,6 @@
 	gSphere-&gt;radius			= r;
 	gSphere-&gt;diffuseColor	= color;
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster	= true;
 	
 	iSphere-&gt;radius			= r;

Modified: trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp
===================================================================
--- trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -3,6 +3,8 @@
 
 #include&quot;OpenGLRenderingEngine.hpp&quot;
 #include&lt;yade/lib-opengl/OpenGLWrapper.hpp&gt;
+#include&lt;yade/lib-opengl/GLUtils.hpp&gt;
+#include&lt;yade/core/Timing.hpp&gt;
 #include&lt;GL/glu.h&gt;
 #include&lt;GL/gl.h&gt;
 #include&lt;GL/glut.h&gt;
@@ -11,6 +13,7 @@
 CREATE_LOGGER(OpenGLRenderingEngine);
 
 bool OpenGLRenderingEngine::glutInitDone=false;
+size_t OpenGLRenderingEngine::selectBodyLimit=500;
 
 OpenGLRenderingEngine::OpenGLRenderingEngine() : RenderingEngine(), clipPlaneNum(3){
 	Body_state = false;
@@ -127,12 +130,20 @@
 	assert(glutInitDone);
 	current_selection = selection;
 
+	// recompute emissive light colors for highlighted bodies
+	Real now=TimingInfo::getNow(/*even if timing is disabled*/true)*1e-9;
+	highlightEmission0[0]=highlightEmission0[1]=highlightEmission0[2]=.8*normSquare(now,1);
+	highlightEmission1[0]=highlightEmission1[1]=highlightEmission0[2]=.5*normSaw(now,2);
+		
+
 	// Draw light source
 	const GLfloat pos[4]	= {Light_position[0],Light_position[1],Light_position[2],1.0};
-	const GLfloat ambientColor[4]	= {0.5,0.5,0.5,1.0};	
+	const GLfloat ambientColor[4]={0.5,0.5,0.5,1.0};	
+	//const GLfloat specularColor[4]={0.5,0.5,0.5,1.0};	
 	glClearColor(Background_color[0],Background_color[1],Background_color[2],1.0);
 	glLightfv(GL_LIGHT0, GL_POSITION, pos);
 	glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColor);
+	//glLightfv(GL_LIGHT0, GL_SPECULAR, specularColor);
 	glEnable(GL_LIGHT0);
 	glDisable(GL_LIGHTING);
 	glPushMatrix();
@@ -153,16 +164,6 @@
 	// set displayed Se3 of body (scaling) and isDisplayed (clipping)
 	setBodiesDispSe3(rootBody);
 
-	// debugging only: show line between spatial and scaled body position
-	#if 0
-		if(scaleDisplacements){
-			glColor3d(1,1,0); glBegin(GL_LINES); 
-			FOREACH(const shared_ptr&lt;Body&gt;&amp; b, *rootBody-&gt;bodies){
-				glVertex3v(b-&gt;physicalParameters-&gt;se3.position); glVertex3v(b-&gt;physicalParameters-&gt;dispSe3.position); }
-			glEnd();
-		}
-	#endif
-
 	if (Body_geometrical_model){
 		if (Cast_shadows){	
 			if (Fast_shadow_volume) renderSceneUsingFastShadowVolumes(rootBody,Light_position);
@@ -357,7 +358,7 @@
 
 void OpenGLRenderingEngine::renderGeometricalModel(const shared_ptr&lt;MetaBody&gt;&amp; rootBody){	
 	const GLfloat ambientColorSelected[4]={10.0,0.0,0.0,1.0};	
-	const GLfloat ambientColorUnselected[4]={0.5,0.5,0.5,1.0};	
+	const GLfloat ambientColorUnselected[4]={0.5,0.5,0.5,1.0};
 	if((rootBody-&gt;geometricalModel || Draw_inside) &amp;&amp; Draw_inside) {
 		FOREACH(const shared_ptr&lt;Body&gt; b, *rootBody-&gt;bodies){
 			if(b-&gt;geometricalModel &amp;&amp; ((b-&gt;getGroupMask() &amp; Draw_mask) || b-&gt;getGroupMask()==0)){
@@ -367,10 +368,33 @@
 				Real angle; Vector3r axis;	se3.orientation.ToAxisAngle(axis,angle);	
 				glTranslatef(se3.position[0],se3.position[1],se3.position[2]);
 				glRotatef(angle*Mathr::RAD_TO_DEG,axis[0],axis[1],axis[2]);
-				if(current_selection==b-&gt;getId()){glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColorSelected);}
-				geometricalModelDispatcher(b-&gt;geometricalModel,b-&gt;physicalParameters,Body_wire);
-				if(current_selection == b-&gt;getId()){glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColorUnselected);}
+				if(current_selection==b-&gt;getId() || b-&gt;geometricalModel-&gt;highlight){
+					glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColorSelected);
+					glColorMaterial(GL_FRONT_AND_BACK,GL_EMISSION);
+					const Vector3r&amp; h(current_selection==b-&gt;getId() ? highlightEmission0 : highlightEmission1);
+					glColor4(h[0],h[1],h[2],.2);
+					glColorMaterial(GL_FRONT_AND_BACK,GL_DIFFUSE);
+
+					geometricalModelDispatcher(b-&gt;geometricalModel,b-&gt;physicalParameters,Body_wire);
+
+					glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColorUnselected);
+					glColorMaterial(GL_FRONT_AND_BACK,GL_EMISSION);
+					glColor3v(Vector3r::ZERO);
+					glColorMaterial(GL_FRONT_AND_BACK,GL_DIFFUSE);
+				} else {
+					geometricalModelDispatcher(b-&gt;geometricalModel,b-&gt;physicalParameters,Body_wire);
+				}
 				glPopMatrix();
+				if(current_selection==b-&gt;getId() || b-&gt;geometricalModel-&gt;highlight){
+					if(!b-&gt;boundingVolume || Body_wire || b-&gt;geometricalModel-&gt;wire) GLUtils::GLDrawInt(b-&gt;getId(),se3.position);
+					else {
+						// move the label towards the camera by the bounding box so that it is not hidden inside the body
+						const Vector3r&amp; mn=b-&gt;boundingVolume-&gt;min; const Vector3r&amp; mx=b-&gt;boundingVolume-&gt;max; const Vector3r&amp; p=se3.position;
+						Vector3r ext(viewDirection[0]&gt;0?p[0]-mn[0]:p[0]-mx[0],viewDirection[1]&gt;0?p[1]-mn[1]:p[1]-mx[1],viewDirection[2]&gt;0?p[2]-mn[2]:p[2]-mx[2]); // signed extents towards the camera
+						Vector3r dr=-1.01*(viewDirection.Dot(ext)*viewDirection);
+						GLUtils::GLDrawInt(b-&gt;getId(),se3.position+dr,Vector3r::ONE);
+					}
+				}
 			}
 		}
 	}
@@ -481,6 +505,8 @@
 
 	REGISTER_ATTRIBUTE(clipPlaneSe3);
 	REGISTER_ATTRIBUTE(clipPlaneActive);
+
+	REGISTER_ATTRIBUTE(selectBodyLimit);
 }
 
 

Modified: trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp
===================================================================
--- trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -6,6 +6,7 @@
 #include&lt;yade/lib-multimethods/DynLibDispatcher.hpp&gt;
 #include&lt;yade/core/MetaEngine1D.hpp&gt;
 #include&lt;yade/core/Body.hpp&gt;
+#include&lt;yade/lib-opengl/OpenGLWrapper.hpp&gt;
 
 #include&lt;yade/pkg-common/GLDrawFunctors.hpp&gt;
 
@@ -30,6 +31,13 @@
 		void setBodiesDispSe3(const shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		long numBodiesWhenRefSe3LastSet,numIterWhenRefSe3LastSet;
 		static bool glutInitDone;
+		static size_t selectBodyLimit;
+		Vector3r viewDirection; // updated from GLViewer regularly
+		Vector3r highlightEmission0;
+		Vector3r highlightEmission1;
+		// normalized saw signal with given periodicity, with values &#8712; &#9001;0,1&#9002; */
+		Real normSaw(Real t, Real period){ Real xi=(t-period*((int)(t/period)))/period; /* normalized value, (0-1&#9002; */ return (xi&lt;.5?2*xi:2-2*xi); }
+		Real normSquare(Real t, Real period){ Real xi=(t-period*((int)(t/period)))/period; /* normalized value, (0-1&#9002; */ return (xi&lt;.5?0:1); }
 
 	private :
 		DynLibDispatcher&lt; InteractionGeometry , GLDrawInteractionGeometryFunctor, void , TYPELIST_5(const shared_ptr&lt;InteractionGeometry&gt;&amp;, const shared_ptr&lt;Interaction&gt;&amp; , const shared_ptr&lt;Body&gt;&amp;, const shared_ptr&lt;Body&gt;&amp;, bool) &gt; interactionGeometryDispatcher;

Modified: trunk/pkg/common/SConscript
===================================================================
--- trunk/pkg/common/SConscript	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/common/SConscript	2009-05-22 22:06:02 UTC (rev 1771)
@@ -137,6 +137,7 @@
 	env.SharedLibrary('SpheresFactory',['Engine/StandAloneEngine/SpheresFactory.cpp'],
 		LIBS=env['LIBS']+['AABB','InteractingSphere','Facet','Sphere','BodyMacroParameters','InteractionGeometryMetaEngine']),
 	env.SharedLibrary('SpatialQuickSortCollider',['Engine/StandAloneEngine/SpatialQuickSortCollider.cpp']),
+	env.SharedLibrary('InsertionSortCollider',['Engine/StandAloneEngine/InsertionSortCollider.cpp']),
 	env.SharedLibrary('PersistentSAPCollider',['Engine/StandAloneEngine/PersistentSAPCollider.cpp']),
 	env.SharedLibrary('DistantPersistentSAPCollider',['Engine/StandAloneEngine/DistantPersistentSAPCollider.cpp']),
 	env.SharedLibrary('PhysicalActionContainerReseter',['Engine/StandAloneEngine/PhysicalActionContainerReseter.cpp']),

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -37,61 +37,99 @@
 bool ef2_Facet_Sphere_Dem3DofGeom::go(const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1, const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2, const Se3r&amp; se31, const Se3r&amp; se32, const shared_ptr&lt;Interaction&gt;&amp; c){
 	InteractingFacet* facet=static_cast&lt;InteractingFacet*&gt;(cm1.get());
 	Real sphereRadius=static_cast&lt;InteractingSphere*&gt;(cm2.get())-&gt;radius;
-	// begin facet-local coordinates 
-		Vector3r contactLine=se31.orientation.Conjugate()*(se32.position-se31.position);
-		Vector3r normal=facet-&gt;nf;
-		Real L=normal.Dot(contactLine); // height/depth of sphere's center from facet's plane
-		if(L&lt;0){normal*=-1; L*=-1;}
-		if(L&gt;sphereRadius &amp;&amp; !c-&gt;isReal) return false; // sphere too far away from the plane
 
-		Vector3r contactPt=contactLine-L*normal; // projection of sphere's center to facet's plane (preliminary contact point)
-		const Vector3r* edgeNormals=facet-&gt;ne; // array[3] of edge normals (in facet plane)
-		int edgeMax=0; Real distMax=edgeNormals[0].Dot(contactPt);
-		for(int i=1; i&lt;3; i++){
-			Real dist=edgeNormals[i].Dot(contactPt);
-			if(distMax&lt;dist){edgeMax=i; distMax=dist;}
-		}
-		//TRVAR2(distMax,edgeMax);
-		// OK, what's the logic here? Copying from IF2IS4SCG&#8230;
-		Real sphereRReduced=shrinkFactor*sphereRadius;
-		Real inCircleR=facet-&gt;icr-sphereRReduced;
-		Real penetrationDepth;
-		if(inCircleR&lt;0){inCircleR=facet-&gt;icr; sphereRReduced=0;}
-		if(distMax&lt;inCircleR){// contact with facet's surface
-			penetrationDepth=sphereRadius-L;	
-			normal.Normalize();
-		} else { // contact with the edge
-			contactPt+=edgeNormals[edgeMax]*(inCircleR-distMax);
-			bool noVertexContact=false;
-			//TRVAR3(edgeNormals[edgeMax],inCircleR,distMax);
-			// contact with vertex no. edgeMax
-			// FIXME: this is the original version, but why (edgeMax-1)%3? IN that case, edgeNormal to edgeMax would never be tried
-			//    if     (contactPt.Dot(edgeNormals[        (edgeMax-1)%3])&gt;inCircleR) contactPt=facet-&gt;vu[edgeMax]*(facet-&gt;vl[edgeMax]-sphereRReduced);
-			if     (contactPt.Dot(edgeNormals[        edgeMax      ])&gt;inCircleR) contactPt=facet-&gt;vu[edgeMax]*(facet-&gt;vl[edgeMax]-sphereRReduced);
-			// contact with vertex no. edgeMax+1
-			else if(contactPt.Dot(edgeNormals[edgeMax=(edgeMax+1)%3])&gt;inCircleR) contactPt=facet-&gt;vu[edgeMax]*(facet-&gt;vl[edgeMax]-sphereRReduced);
-			// contact with edge no. edgeMax
-			else noVertexContact=true;
-			normal=contactLine-contactPt;
-			#ifdef FACET_TOPO
-				if(noVertexContact &amp;&amp; facet-&gt;edgeAdjIds[edgeMax]!=Body::ID_NONE){
-					// find angle between our normal and the facet's normal (still local coords)
-					Quaternionr q; q.Align(facet-&gt;nf,normal); Vector3r axis; Real angle; q.ToAxisAngle(axis,angle);
-					assert(angle&gt;=0 &amp;&amp; angle&lt;=Mathr::PI);
-					if(edgeNormals[edgeMax].Dot(axis)&lt;0) angle*=-1.;
-					bool negFace=normal.Dot(facet-&gt;nf)&lt;0; // contact in on the negative facet's face
-					Real halfAngle=(negFace?-1.:1.)*facet-&gt;edgeAdjHalfAngle[edgeMax]; 
-					if(halfAngle&lt;0 &amp;&amp; angle&gt;halfAngle) return false; // on concave boundary, and if in the other facet's sector, no contact
-					// otherwise the contact will be created
-				}
-			#endif
-			//TRVAR4(contactLine,contactPt,normal,normal.Length());
-			//TRVAR3(se31.orientation*contactLine,se31.position+se31.orientation*contactPt,se31.orientation*normal);
-			penetrationDepth=sphereRadius-normal.Normalize();
-			//TRVAR1(penetrationDepth);
-		}
-	// end facet-local coordinates
+	#if 1
+		/* new code written from scratch, to make sure the algorithm is correct; it is about the same speed 
+			as sega's algo below, but seems more readable to me.
+			The FACET_TOPO thing is still missing here but can be copied literally once it is tested */
+		// begin facet-local coordinates
+			Vector3r cogLine=se31.orientation.Conjugate()*(se32.position-se31.position); // connect centers of gravity
+			//TRVAR4(se31.position,se31.orientation,se32.position,cogLine);
+			Vector3r normal=facet-&gt;nf;
+			Real planeDist=normal.Dot(cogLine);
+			if(planeDist&lt;0){normal*=-1; planeDist*=-1; }
+			if(planeDist&gt;sphereRadius &amp;&amp; !c-&gt;isReal) { /* LOG_TRACE(&quot;Sphere too far (&quot;&lt;&lt;planeDist&lt;&lt;&quot;) from plane&quot;); */ return false;  }
+			Vector3r planarPt=cogLine-planeDist*normal; // project sphere center to the facet plane
+			Real normDotPt[3];
+			Vector3r contactPt(Vector3r::ZERO);
+			for(int i=0; i&lt;3; i++) normDotPt[i]=facet-&gt;ne[i].Dot(planarPt-facet-&gt;vertices[i]);
+			short w=(normDotPt[0]&gt;0?1:0)+(normDotPt[1]&gt;0?2:0)+(normDotPt[2]&gt;0?4:0);
+			//TRVAR4(planarPt,normDotPt[0],normDotPt[1],normDotPt[2]);
+			//TRVAR2(normal,cogLine);
+			//TRVAR3(facet-&gt;vertices[0],facet-&gt;vertices[1],facet-&gt;vertices[2]);
+			switch(w){
+				case 0: contactPt=planarPt; break; // inside triangle
+				case 1: contactPt=getClosestSegmentPt(planarPt,facet-&gt;vertices[0],facet-&gt;vertices[1]); break; // +-- (n1)
+				case 2: contactPt=getClosestSegmentPt(planarPt,facet-&gt;vertices[1],facet-&gt;vertices[2]); break; // -+- (n2)
+				case 4: contactPt=getClosestSegmentPt(planarPt,facet-&gt;vertices[2],facet-&gt;vertices[0]); break; // --+ (n3)
+				case 3: contactPt=facet-&gt;vertices[1]; break; // ++- (v1)
+				case 5: contactPt=facet-&gt;vertices[0]; break; // +-+ (v0)
+				case 6: contactPt=facet-&gt;vertices[2]; break; // -++ (v2)
+				case 7: throw logic_error(&quot;Impossible triangle intersection?&quot;); // +++ (impossible)
+				default: throw logic_error(&quot;Nonsense intersection value!&quot;);
+			}
+			normal=cogLine-contactPt; // called normal, but it is no longer the facet's normal (for compat)
+			//TRVAR3(normal,contactPt,sphereRadius);
+			if(!c-&gt;isReal &amp;&amp; normal.SquaredLength()&gt;sphereRadius*sphereRadius) { /* LOG_TRACE(&quot;Sphere too far from closest point&quot;); */ return false; } // fast test before sqrt
+			Real penetrationDepth=sphereRadius-normal.Normalize();
+	#else
+		/* This code was mostly copied from InteractingFacet2InteractinSphere4SpheresContactGeometry */
+		// begin facet-local coordinates 
+			Vector3r contactLine=se31.orientation.Conjugate()*(se32.position-se31.position);
+			Vector3r normal=facet-&gt;nf;
+			Real L=normal.Dot(contactLine); // height/depth of sphere's center from facet's plane
+			if(L&lt;0){normal*=-1; L*=-1;}
+			if(L&gt;sphereRadius &amp;&amp; !c-&gt;isReal) return false; // sphere too far away from the plane
 
+			Vector3r contactPt=contactLine-L*normal; // projection of sphere's center to facet's plane (preliminary contact point)
+			const Vector3r* edgeNormals=facet-&gt;ne; // array[3] of edge normals (in facet plane)
+			int edgeMax=0; Real distMax=edgeNormals[0].Dot(contactPt);
+			for(int i=1; i&lt;3; i++){
+				Real dist=edgeNormals[i].Dot(contactPt);
+				if(distMax&lt;dist){edgeMax=i; distMax=dist;}
+			}
+			//TRVAR2(distMax,edgeMax);
+			// OK, what's the logic here? Copying from IF2IS4SCG&#8230;
+			Real sphereRReduced=shrinkFactor*sphereRadius;
+			Real inCircleR=facet-&gt;icr-sphereRReduced;
+			Real penetrationDepth;
+			if(inCircleR&lt;0){inCircleR=facet-&gt;icr; sphereRReduced=0;}
+			if(distMax&lt;inCircleR){// contact with facet's surface
+				penetrationDepth=sphereRadius-L;	
+				normal.Normalize();
+			} else { // contact with the edge
+				contactPt+=edgeNormals[edgeMax]*(inCircleR-distMax);
+				bool noVertexContact=false;
+				//TRVAR3(edgeNormals[edgeMax],inCircleR,distMax);
+				// contact with vertex no. edgeMax
+				// FIXME: this is the original version, but why (edgeMax-1)%3? IN that case, edgeNormal to edgeMax would never be tried
+				//    if     (contactPt.Dot(edgeNormals[        (edgeMax-1)%3])&gt;inCircleR) contactPt=facet-&gt;vu[edgeMax]*(facet-&gt;vl[edgeMax]-sphereRReduced);
+				if     (contactPt.Dot(edgeNormals[        edgeMax      ])&gt;inCircleR) contactPt=facet-&gt;vu[edgeMax]*(facet-&gt;vl[edgeMax]-sphereRReduced);
+				// contact with vertex no. edgeMax+1
+				else if(contactPt.Dot(edgeNormals[edgeMax=(edgeMax+1)%3])&gt;inCircleR) contactPt=facet-&gt;vu[edgeMax]*(facet-&gt;vl[edgeMax]-sphereRReduced);
+				// contact with edge no. edgeMax
+				else noVertexContact=true;
+				normal=contactLine-contactPt;
+				#ifdef FACET_TOPO
+					if(noVertexContact &amp;&amp; facet-&gt;edgeAdjIds[edgeMax]!=Body::ID_NONE){
+						// find angle between our normal and the facet's normal (still local coords)
+						Quaternionr q; q.Align(facet-&gt;nf,normal); Vector3r axis; Real angle; q.ToAxisAngle(axis,angle);
+						assert(angle&gt;=0 &amp;&amp; angle&lt;=Mathr::PI);
+						if(edgeNormals[edgeMax].Dot(axis)&lt;0) angle*=-1.;
+						bool negFace=normal.Dot(facet-&gt;nf)&lt;0; // contact in on the negative facet's face
+						Real halfAngle=(negFace?-1.:1.)*facet-&gt;edgeAdjHalfAngle[edgeMax]; 
+						if(halfAngle&lt;0 &amp;&amp; angle&gt;halfAngle) return false; // on concave boundary, and if in the other facet's sector, no contact
+						// otherwise the contact will be created
+					}
+				#endif
+				//TRVAR4(contactLine,contactPt,normal,normal.Length());
+				//TRVAR3(se31.orientation*contactLine,se31.position+se31.orientation*contactPt,se31.orientation*normal);
+				penetrationDepth=sphereRadius-normal.Normalize();
+				//TRVAR1(penetrationDepth);
+			}
+		// end facet-local coordinates
+	#endif
+
 	if(penetrationDepth&lt;0 &amp;&amp; !c-&gt;isReal) return false;
 
 	shared_ptr&lt;Dem3DofGeom_FacetSphere&gt; fs;
@@ -104,7 +142,7 @@
 		fs-&gt;refR1=-1; fs-&gt;refR2=sphereRadius;
 		fs-&gt;refLength=fs-&gt;effR2;
 		fs-&gt;cp1pt=contactPt; // facet-local intial contact point
-		fs-&gt;localFacetNormal=normal;
+		fs-&gt;localFacetNormal=facet-&gt;nf;
 		fs-&gt;cp2rel.Align(Vector3r::UNIT_X,se32.orientation.Conjugate()*(-normalGlob)); // initial sphere-local center-contactPt orientation WRT +x
 		fs-&gt;cp2rel.Normalize();
 	}
@@ -112,6 +150,9 @@
 	fs-&gt;normal=normalGlob;
 	fs-&gt;contactPoint=se32.position+(-normalGlob)*(sphereRadius-penetrationDepth);
 	if(c-&gt;isNew){
+		//TRVAR2(planeDist,planarPt);
+		//TRVAR3(normDotPt[0],normDotPt[1],normDotPt[2]);
+		//TRVAR2(w,contactPt);
 		TRVAR1(penetrationDepth);
 		TRVAR3(fs-&gt;refLength,fs-&gt;cp1pt,fs-&gt;localFacetNormal);
 		TRVAR3(fs-&gt;effR2,fs-&gt;cp2rel,fs-&gt;normal);

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.hpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.hpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -51,12 +51,19 @@
 
 #include&lt;yade/pkg-common/InteractionGeometryEngineUnit.hpp&gt;
 class ef2_Facet_Sphere_Dem3DofGeom:public InteractionGeometryEngineUnit{
+	Vector3r getClosestSegmentPt(const Vector3r&amp; P, const Vector3r&amp; A, const Vector3r&amp; B){
+		// algo: <A HREF="http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/">http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/</A>
+		Vector3r BA=B-A;
+		Real u=(P.Dot(BA)-A.Dot(BA))/(BA.SquaredLength());
+		return A+min(1.,max(0.,u))*BA;
+	}
 	public:
 		virtual bool go(const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1, const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2, const Se3r&amp; se31, const Se3r&amp; se32, const shared_ptr&lt;Interaction&gt;&amp; c);
 		virtual bool goReverse(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1, const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2, const Se3r&amp; se31, const Se3r&amp; se32, const shared_ptr&lt;Interaction&gt;&amp; c){
 			c-&gt;swapOrder(); return go(cm2,cm1,se32,se31,c);
 			LOG_ERROR(&quot;!! goReverse maybe doesn't work in ef2_Facet_Sphere_Dem3DofGeom. InteractionGeometryMetaEngine should swap interaction members first and call go(...) afterwards.&quot;);
 		}
+
 		//! Reduce the facet's size, probably to avoid singularities at common facets' edges (?)
 		Real shrinkFactor;
 		ef2_Facet_Sphere_Dem3DofGeom(): shrinkFactor(0.) {}

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -1,6 +1,7 @@
 #include &quot;Dem3DofGeom_SphereSphere.hpp&quot;
 
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
+#include&lt;yade/core/Omega.hpp&gt;
 YADE_PLUGIN(&quot;Dem3DofGeom_SphereSphere&quot;,&quot;GLDraw_Dem3DofGeom_SphereSphere&quot;,&quot;ef2_Sphere_Sphere_Dem3DofGeom&quot;);
 
 
@@ -163,7 +164,9 @@
 		ss-&gt;refLength=dist;
 		ss-&gt;refR1=s1-&gt;radius; ss-&gt;refR2=s2-&gt;radius;
 		Real penetrationDepth=s1-&gt;radius+s2-&gt;radius-ss-&gt;refLength;
-		ss-&gt;effR1=s1-&gt;radius-.5*penetrationDepth; ss-&gt;effR2=s2-&gt;radius-.5*penetrationDepth;
+		if(Omega::instance().getCurrentIteration()&lt;=10){
+			ss-&gt;effR1=s1-&gt;radius-.5*penetrationDepth; ss-&gt;effR2=s2-&gt;radius-.5*penetrationDepth;
+		} else {ss-&gt;effR1=s1-&gt;radius; ss-&gt;effR2=s2-&gt;radius;}
 		// for bending only: ss-&gt;initRelOri12=se31.orientation.Conjugate()*se32.orientation;
 		// quasi-constants
 		ss-&gt;cp1rel.Align(Vector3r::UNIT_X,se31.orientation.Conjugate()*normal);

Modified: trunk/pkg/dem/Engine/DeusExMachina/NewtonsDampedLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/NewtonsDampedLaw.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/Engine/DeusExMachina/NewtonsDampedLaw.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -34,7 +34,7 @@
 		if (!b-&gt;isDynamic &amp;&amp; !b-&gt;isClumpMember()) continue;
 		
 		RigidBodyParameters* rb = YADE_CAST&lt;RigidBodyParameters*&gt;(b-&gt;physicalParameters.get());
-		unsigned int id = b-&gt;getId();
+		body_id_t id = b-&gt;getId();
 		const Vector3r&amp; m=ncb-&gt;bex.getTorque(id);
 		const Vector3r&amp; f=ncb-&gt;bex.getForce(id);
 
@@ -92,9 +92,10 @@
 		Quaternionr q;
 		q.FromAxisAngle ( axis,angle*dt );
 		rb-&gt;se3.orientation = q*rb-&gt;se3.orientation;
+		if(ncb-&gt;bex.getMoveRotUsed() &amp;&amp; ncb-&gt;bex.getRot(id)!=Vector3r::ZERO){ Vector3r r(ncb-&gt;bex.getRot(id)); Real norm=r.Normalize(); q.FromAxisAngle(r,norm); rb-&gt;se3.orientation=q*rb-&gt;se3.orientation; }
 		rb-&gt;se3.orientation.Normalize();
 
-		rb-&gt;se3.position += rb-&gt;velocity*dt;
+		rb-&gt;se3.position += rb-&gt;velocity*dt + ncb-&gt;bex.getMove(id);
 
 		if(b-&gt;isClump()) static_cast&lt;Clump*&gt;(b.get())-&gt;moveMembers();
 	}

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -8,9 +8,8 @@
 
 #include&quot;SimpleElasticRelationships.hpp&quot;
 #include&lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include&lt;yade/pkg-dem/DemXDofGeom.hpp&gt;
 #include&lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
-#include&lt;yade/pkg-dem/SDECLinkGeometry.hpp&gt; // FIXME - I can't dispatch by SDECLinkGeometry &lt;-&gt; SpheresContactGeometry !!?
-#include&lt;yade/pkg-dem/SDECLinkPhysics.hpp&gt; // FIXME
 #include&lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
 #include&lt;yade/core/Omega.hpp&gt;
 #include&lt;yade/core/MetaBody.hpp&gt;
@@ -22,9 +21,9 @@
 					, const shared_ptr&lt;Interaction&gt;&amp; interaction)
 {
 	
-	SpheresContactGeometry* interactionGeometry = YADE_CAST&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.get());
+	//SpheresContactGeometry* interactionGeometry = YADE_CAST&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.get());
 	
-	if(interactionGeometry) // so it is SpheresContactGeometry  - NON PERMANENT LINK
+	//if(interactionGeometry)
 	{
 		if( interaction-&gt;isNew)
 		{
@@ -39,8 +38,19 @@
 			Real Eb 	= sdec2-&gt;young;
 			Real Va 	= sdec1-&gt;poisson;
 			Real Vb 	= sdec2-&gt;poisson;
-			Real Da 	= interactionGeometry-&gt;radius1; // FIXME - multiply by factor of sphere interaction distance (so sphere interacts at bigger range that its geometrical size)
-			Real Db 	= interactionGeometry-&gt;radius2; // FIXME - as above
+			#if 0
+				Real Da 	= interactionGeometry-&gt;radius1; // FIXME - multiply by factor of sphere interaction distance (so sphere interacts at bigger range that its geometrical size)
+				Real Db 	= interactionGeometry-&gt;radius2; // FIXME - as above
+				Vector3r normal=interactionGeometry-&gt;normal;
+			#else
+				Real Da,Db; Vector3r normal;
+				SpheresContactGeometry* scg=dynamic_cast&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.get());
+				Dem3DofGeom* d3dg=dynamic_cast&lt;Dem3DofGeom*&gt;(interaction-&gt;interactionGeometry.get());
+				if(scg){ Da=scg-&gt;radius1; Db=scg-&gt;radius2; normal=scg-&gt;normal; }
+				else if(d3dg){Da=d3dg-&gt;refR1&gt;0?d3dg-&gt;refR1:2*d3dg-&gt;refR2; Db=d3dg-&gt;refR2&gt;0?d3dg-&gt;refR2:d3dg-&gt;refR1; normal=d3dg-&gt;normal; }
+				else throw runtime_error(&quot;SimpleElasticRelationships: geometry is neither SpheresContactGeometry nor Dem3DofGeom&quot;);
+			#endif
+			
 			Real fa 	= sdec1-&gt;frictionAngle;
 			Real fb 	= sdec2-&gt;frictionAngle;
 
@@ -60,7 +70,7 @@
 			contactPhysics-&gt;frictionAngle			= std::min(fa,fb); // FIXME - this is actually a waste of memory space, just like initialKs and initialKn
 			contactPhysics-&gt;tangensOfFrictionAngle		= std::tan(contactPhysics-&gt;frictionAngle); 
 
-			contactPhysics-&gt;prevNormal 			= interactionGeometry-&gt;normal;
+			contactPhysics-&gt;prevNormal 			= normal;
 			contactPhysics-&gt;initialEquilibriumDistance	= Dinit;			
 
 			contactPhysics-&gt;kn = contactPhysics-&gt;initialKn;
@@ -68,6 +78,8 @@
 			contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
 
 		}	
+		return;
 	}
+	throw runtime_error(&quot;SimpleElasticRelationships currently fails for non-SpheresContactGeometry geometry!&quot;);
 };
 YADE_PLUGIN();

Modified: trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -56,10 +56,6 @@
 
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-#include&lt;yade/pkg-common/InteractionHashMap.hpp&gt;
-
 #include&lt;yade/extra/Shop.hpp&gt;
 
 #include &lt;boost/filesystem/convenience.hpp&gt;
@@ -252,8 +248,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-
 	shared_ptr&lt;Body&gt; body;
 	
 	if(boxWalls)
@@ -489,7 +483,6 @@
 //	gSphere-&gt;diffuseColor		= ((int)(position[0]*400.0))%2?Vector3r(0.7,0.7,0.7):Vector3r(0.45,0.45,0.45);
 	gSphere-&gt;diffuseColor		= spheresColor;
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -538,7 +531,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/DirectShearCis.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/DirectShearCis.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/DirectShearCis.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -56,9 +56,6 @@
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-
 #include &lt;boost/filesystem/convenience.hpp&gt;
 #include &lt;utility&gt;
 
@@ -144,11 +141,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-// Container
-	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-		
 
 // Box walls
 	shared_ptr&lt;Body&gt; w1;	// The left one :
@@ -233,7 +225,6 @@
 	// de quoi avoir des bandes (huit en largeur) de couleur differentes :
 	gSphere-&gt;diffuseColor		= ((int)(Mathr::Floor(8*position.X()/width)))%2?Vector3r(0.7,0.7,0.7):Vector3r(0.45,0.45,0.45);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -280,7 +271,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,0,0);
 	gBox-&gt;wire			= true;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/Funnel.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/Funnel.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/Funnel.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -41,10 +41,7 @@
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
-
 Funnel::Funnel () : FileGenerator()
 {
 	nbSpheres = Vector3r(2,3,2);
@@ -102,11 +99,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-////////////////////////////////////
-///////// Container
-	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 		
 ////////////////////////////////////
 ///////// ground
@@ -201,7 +193,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -248,7 +239,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/HydraulicTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/HydraulicTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/HydraulicTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -47,7 +47,6 @@
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
 #include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 #include&lt;yade/pkg-common/TranslationEngine.hpp&gt;
 
@@ -93,10 +92,7 @@
 	rootBody = shared_ptr&lt;MetaBody&gt; ( new MetaBody );
 	positionRootBody ( rootBody );
 
-////////////////////////////////////
 
-	rootBody-&gt;transientInteractions  = shared_ptr&lt;InteractionContainer&gt; ( new InteractionVecSet );
-	rootBody-&gt;bodies    = shared_ptr&lt;BodyContainer&gt; ( new BodyRedirectionVector );
 
 /////////////////////////////////////
 /////////////////////////////////////

Modified: trunk/pkg/dem/PreProcessor/MembraneTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/MembraneTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/MembraneTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -53,8 +53,6 @@
 #include&lt;yade/pkg-common/InteractingNode.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 #include&lt;yade/pkg-dem/SimpleViscoelasticBodyParameters.hpp&gt;
 
@@ -110,10 +108,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-// Containers
-	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 
 // Nodes
 	float all = (float) (nbX * nbZ);
@@ -250,7 +244,6 @@
   gSphere-&gt;radius           = radius;
   gSphere-&gt;diffuseColor     = Vector3r(0.5,0.5,1.0);
   gSphere-&gt;wire             = false;
-  gSphere-&gt;visible          = true;
   gSphere-&gt;shadowCaster     = true;
         
   iSphere-&gt;radius           = radius;
@@ -280,7 +273,6 @@
         node-&gt;radius                    = 0.5 * membraneThickness;
 	node-&gt;diffuseColor		= Vector3r(0.7,0.7,0.7);
 	node-&gt;wire			= false;
-	node-&gt;visible			= true;
 	node-&gt;shadowCaster		= false;
 
         Vector3r position               = Vector3r(i*XLength/(double)nbX,0.0,j*ZLength/(double)nbZ);

Modified: trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/ModifiedTriaxialTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -54,9 +54,6 @@
 
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-#include&lt;yade/pkg-common/InteractionHashMap.hpp&gt;
 
 #include &lt;boost/filesystem/convenience.hpp&gt;
 #include &lt;boost/lexical_cast.hpp&gt;
@@ -490,7 +487,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= spheresColor;
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -538,7 +534,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/SDECImpactTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -47,8 +47,6 @@
 
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 
 #include &lt;boost/filesystem/convenience.hpp&gt;
@@ -191,8 +189,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 
 	shared_ptr&lt;Body&gt; body;
 	if(importFilename.size() != 0 &amp;&amp; filesystem::exists(importFilename) )
@@ -387,7 +383,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= spheresColor;
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -434,7 +429,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -50,8 +50,6 @@
 #include&lt;yade/pkg-common/PhysicalActionContainerReseter.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 
 SDECLinkedSpheres::SDECLinkedSpheres () : FileGenerator()
@@ -117,12 +115,7 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-////////////////////////////////////
 	
-//	rootBody-&gt;persistentInteractions	= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-//	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-
 ////////////////////////////////////
 
 	shared_ptr&lt;Body&gt; ground;
@@ -250,7 +243,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -296,7 +288,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/SDECMovingWall.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -46,10 +46,7 @@
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
-
 SDECMovingWall::SDECMovingWall () : FileGenerator()
 {
 	nbSpheres = Vector3r(40,4,4);
@@ -140,11 +137,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-////////////////////////////////////
-///////// Container
-	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 		
 ////////////////////////////////////
 ///////// ground
@@ -235,7 +227,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(0.7,0.7,0.7);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -284,7 +275,6 @@
 // a simple way to have alternating colors per layer
 	gSphere-&gt;diffuseColor		= Vector3r(std::sin((float)j),std::cos((float)j),j/nbSpheres[1]);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -331,7 +321,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/SDECSpheresPlane.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -45,8 +45,6 @@
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 
 SDECSpheresPlane::SDECSpheresPlane () : FileGenerator()
@@ -111,11 +109,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-////////////////////////////////////
-///////// Container
-	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 		
 ////////////////////////////////////
 ///////// ground
@@ -206,7 +199,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(0.7,0.7,0.7);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -254,7 +246,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -301,7 +292,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/STLImporterTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/STLImporterTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/STLImporterTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -22,7 +22,6 @@
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 #include&lt;yade/pkg-common/InteractionGeometryMetaEngine.hpp&gt;
 #include&lt;yade/pkg-common/InteractionPhysicsMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 #include&lt;yade/pkg-common/MetaInteractingGeometry.hpp&gt;
 #include&lt;yade/pkg-common/MetaInteractingGeometry2AABB.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalActionApplier.hpp&gt;
@@ -103,8 +102,6 @@
 ////////////////////////////////////
 ///////// Container
 	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 		
 ////////////////////////////////////
 ///////// walls
@@ -207,7 +204,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;

Modified: trunk/pkg/dem/PreProcessor/SimpleShear.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SimpleShear.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/SimpleShear.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -51,9 +51,6 @@
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-
 #include &lt;boost/filesystem/convenience.hpp&gt;
 #include &lt;utility&gt;
 
@@ -134,11 +131,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-// Container
-	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-		
 
 // Box walls
 	shared_ptr&lt;Body&gt; w1;	// The left one :
@@ -224,7 +216,6 @@
 	// de quoi avoir des bandes (huit en largeur) de couleur differentes :
 	gSphere-&gt;diffuseColor		= ((int)(Mathr::Floor(8*position.X()/width)))%2?Vector3r(0.7,0.7,0.7):Vector3r(0.45,0.45,0.45);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -272,7 +263,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,0,0);
 	gBox-&gt;wire			= true;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/TestSimpleViscoelastic.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -19,7 +19,6 @@
 #include&lt;yade/pkg-common/InteractingBox.hpp&gt;
 #include&lt;yade/pkg-common/InteractionGeometryMetaEngine.hpp&gt;
 #include&lt;yade/pkg-common/InteractionPhysicsMetaEngine.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 #include&lt;yade/pkg-common/MetaInteractingGeometry.hpp&gt;
 #include&lt;yade/pkg-common/MetaInteractingGeometry2AABB.hpp&gt;
 #include&lt;yade/pkg-common/PersistentSAPCollider.hpp&gt;
@@ -90,9 +89,6 @@
 ////////////////////////////////////
 ///////// Container
 	
-    rootBody-&gt;transientInteractions	= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-    rootBody-&gt;bodies			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-
 ////////////////////////////////////
 ///////// ground
     
@@ -146,7 +142,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
@@ -245,7 +240,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;

Modified: trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/TetrahedronsTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -45,10 +45,7 @@
 #include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
-
 TetrahedronsTest::TetrahedronsTest () : FileGenerator()
 {
 	nbTetrahedrons		= Vector3r(5,6,7);
@@ -129,8 +126,6 @@
 ////////////////////////////////////
 ///////// Container
 	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 		
 ////////////////////////////////////
 ///////// ground
@@ -193,7 +188,6 @@
 	makeTet(tet,radius);
 	tet-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	tet-&gt;wire			= false;
-	tet-&gt;visible			= true;
 	tet-&gt;shadowCaster		= false;
 
 	// Vaclav,
@@ -283,7 +277,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/ThreePointBending.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/ThreePointBending.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/ThreePointBending.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -48,9 +48,6 @@
 #include&lt;yade/pkg-common/PhysicalActionContainerReseter.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-
 #include&lt;yade/pkg-common/TranslationEngine.hpp&gt;
 
 #include &lt;boost/filesystem/operations.hpp&gt;
@@ -125,9 +122,6 @@
 
 ////////////////////////////////////
 	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-
 	Vector3r min(10000,10000,10000),max(-10000,-10000,-10000);
 
 	// load simulation file, extract spheres and use those
@@ -280,7 +274,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -57,9 +57,6 @@
 
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-
 #include&lt;yade/pkg-common/InteractionDispatchers.hpp&gt;
 
 #include&lt;yade/extra/Shop.hpp&gt;
@@ -450,7 +447,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= spheresColor;
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -498,7 +494,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -62,10 +62,6 @@
 
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-#include&lt;yade/pkg-common/InteractionHashMap.hpp&gt;
-
 #include&lt;yade/extra/Shop.hpp&gt;
 
 #include &lt;boost/filesystem/convenience.hpp&gt;
@@ -273,8 +269,6 @@
 
 	//rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionHashMap);
 
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-
 	shared_ptr&lt;Body&gt; body;
 	
 	
@@ -447,7 +441,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= spheresColor;
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -495,7 +488,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp
===================================================================
--- trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/fem/Engine/EngineUnit/FEMSetTextLoader.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -86,7 +86,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(0.9,0.9,0.3);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	body-&gt;geometricalModel		= gSphere;
@@ -123,7 +122,6 @@
 
 	gTet-&gt;diffuseColor		= Vector3r(1,1,1);
 	gTet-&gt;wire			= false;
-	gTet-&gt;visible			= true;
 	gTet-&gt;shadowCaster		= true;
 //	gTet-&gt;v1 			= (*(rootBody-&gt;bodies))[id1]-&gt;physicalParameters-&gt;se3.position;
 //	gTet-&gt;v2 			= (*(rootBody-&gt;bodies))[id2]-&gt;physicalParameters-&gt;se3.position;

Modified: trunk/pkg/fem/PreProcessor/FEMBeam.cpp
===================================================================
--- trunk/pkg/fem/PreProcessor/FEMBeam.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/fem/PreProcessor/FEMBeam.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -44,8 +44,6 @@
 #include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
 #include&lt;yade/pkg-common/GeometricalModelMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 
 #include &lt;boost/filesystem/convenience.hpp&gt;
@@ -117,11 +115,8 @@
 	positionRootBody(rootBody);
 	
 	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 	
 	
-	
 	createActors(rootBody);
 	imposeTranslation(rootBody,regionMin1,regionMax1,translationAxis1,velocity1);
 	imposeTranslation(rootBody,regionMin2,regionMax2,translationAxis2,velocity2);
@@ -218,7 +213,6 @@
 	shared_ptr&lt;GeometricalModel&gt; gm 	= YADE_PTR_CAST&lt;GeometricalModel&gt;(ClassFactory::instance().createShared(&quot;FEMSetGeometry&quot;));
 	gm-&gt;diffuseColor 			= Vector3r(1,1,1);
 	gm-&gt;wire 				= false;
-	gm-&gt;visible 				= true;
 	gm-&gt;shadowCaster 			= true;
 	
 	rootBody-&gt;interactingGeometry 		= YADE_PTR_CAST&lt;InteractingGeometry&gt;(set);	

Modified: trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -457,9 +457,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 	
-//	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-//	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-
 	
 	shared_ptr&lt;Body&gt; body;
 	
@@ -890,7 +887,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(1.8,1.8,0.0);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= false;
 	
         body-&gt;geometricalModel          = gSphere;
@@ -948,7 +944,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(0.8,0.8,0.8);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= false;
 	
         body-&gt;geometricalModel          = gSphere;
@@ -999,7 +994,6 @@
 	physics-&gt;velocity		= Vector3r(0,0,0);
 
 	gQuad-&gt;diffuseColor		= Vector3r(0.0,0.0,0.0);
-	gQuad-&gt;visible			= true;
 	gQuad-&gt;wire			= false;
 	gQuad-&gt;shadowCaster		= false;
 	
@@ -1026,7 +1020,6 @@
 	gBeam-&gt;length			= length;
 	gBeam-&gt;diffuseColor		= Vector3r(0.6,0.6,0.6);
 	gBeam-&gt;wire			= false;
-	gBeam-&gt;visible			= true;
 	gBeam-&gt;shadowCaster		= false;
 	
 	body-&gt;geometricalModel		= gBeam;
@@ -1242,7 +1235,6 @@
 	shared_ptr&lt;GeometricalModel&gt; gm = YADE_PTR_CAST&lt;GeometricalModel&gt;(ClassFactory::instance().createShared(&quot;LatticeSetGeometry&quot;));
 	gm-&gt;diffuseColor 		= Vector3r(1,1,1);
 	gm-&gt;wire 			= false;
-	gm-&gt;visible 			= true;
 	gm-&gt;shadowCaster 		= true;
 	
 	rootBody-&gt;interactingGeometry	= YADE_PTR_CAST&lt;InteractingGeometry&gt;(set);	

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -10,8 +10,6 @@
 #include&lt;fstream&gt;
 #include&quot;LatticeExampleCTData.hpp&quot;
 #include&lt;yade/core/MetaBody.hpp&gt;
-//#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
 #include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
 #include&lt;yade/pkg-common/GeometricalModelMetaEngine.hpp&gt;
 #include&lt;yade/pkg-common/AABB.hpp&gt;
@@ -135,9 +133,6 @@
 	make_simulation_loop(rootBody);    // make the simulation loop
 	positionRootBody(rootBody); // set global coordinate system, etc.
 	
-// decide what containers to use
-//	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-//	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 
 	shared_ptr&lt;Body&gt; body;
 
@@ -342,7 +337,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(0.8,0.8,0.8);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= false;
 	
         body-&gt;geometricalModel          = gSphere;
@@ -377,7 +371,6 @@
 	gBeam-&gt;length			= length;
 	gBeam-&gt;diffuseColor		= Vector3r(0.6,0.6,0.6);
 	gBeam-&gt;wire			= false;
-	gBeam-&gt;visible			= true;
 	gBeam-&gt;shadowCaster		= false;
 	
 	body-&gt;geometricalModel		= gBeam;
@@ -545,7 +538,6 @@
 	shared_ptr&lt;GeometricalModel&gt; gm = YADE_PTR_CAST&lt;GeometricalModel&gt;(ClassFactory::instance().createShared(&quot;LatticeSetGeometry&quot;));
 	gm-&gt;diffuseColor 		= Vector3r(1,1,1);
 	gm-&gt;wire 			= false;
-	gm-&gt;visible 			= true;
 	gm-&gt;shadowCaster 		= true;
 
 	rootBody-&gt;interactingGeometry	= YADE_PTR_CAST&lt;InteractingGeometry&gt;(set);	

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -8,8 +8,6 @@
 
 #include&quot;LatticeExampleSimple.hpp&quot;
 #include&lt;yade/core/MetaBody.hpp&gt;
-//#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
 #include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
 #include&lt;yade/pkg-common/GeometricalModelMetaEngine.hpp&gt;
 #include&lt;yade/pkg-common/AABB.hpp&gt;
@@ -97,9 +95,6 @@
 	make_simulation_loop(rootBody);    // make the simulation loop
 	positionRootBody(rootBody); // set global coordinate system, etc.
 	
-// decide what containers to use
-//	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-//	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 
 	shared_ptr&lt;Body&gt; body;
 
@@ -294,7 +289,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(0.8,0.8,0.8);
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= false;
 	
         body-&gt;geometricalModel          = gSphere;
@@ -329,7 +323,6 @@
 	gBeam-&gt;length			= length;
 	gBeam-&gt;diffuseColor		= Vector3r(0.6,0.6,0.6);
 	gBeam-&gt;wire			= false;
-	gBeam-&gt;visible			= true;
 	gBeam-&gt;shadowCaster		= false;
 	
 	body-&gt;geometricalModel		= gBeam;
@@ -497,7 +490,6 @@
 	shared_ptr&lt;GeometricalModel&gt; gm = YADE_PTR_CAST&lt;GeometricalModel&gt;(ClassFactory::instance().createShared(&quot;LatticeSetGeometry&quot;));
 	gm-&gt;diffuseColor 		= Vector3r(1,1,1);
 	gm-&gt;wire 			= false;
-	gm-&gt;visible 			= true;
 	gm-&gt;shadowCaster 		= true;
 
 	rootBody-&gt;interactingGeometry	= YADE_PTR_CAST&lt;InteractingGeometry&gt;(set);	

Modified: trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp
===================================================================
--- trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -56,8 +56,6 @@
 
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 
 HangingCloth::HangingCloth () : FileGenerator()
@@ -144,10 +142,6 @@
 	Omega::instance().setTimeStep(0.004);
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);
 
-	rootBody-&gt;persistentInteractions	= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-
 	
 	shared_ptr&lt;InteractionGeometryMetaEngine&gt; interactionGeometryDispatcher(new InteractionGeometryMetaEngine);
 	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere2InteractingSphere4SpheresContactGeometry&quot;);
@@ -232,7 +226,6 @@
 	shared_ptr&lt;Mesh2D&gt; mesh2d(new Mesh2D);
 	mesh2d-&gt;diffuseColor	= Vector3r(0,0,1);
 	mesh2d-&gt;wire		= false;
-	mesh2d-&gt;visible		= true;
 	mesh2d-&gt;shadowCaster	= false;
 
 	rootBody-&gt;geometricalModel			= mesh2d;
@@ -502,7 +495,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -543,7 +535,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp
===================================================================
--- trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/realtime-rigidbody/PreProcessor/BoxStack.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -38,10 +38,7 @@
 #include&lt;yade/pkg-common/GravityEngines.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
-#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
-
 BoxStack::BoxStack () : FileGenerator()
 {
 	nbBoxes		= Vector3r(1,5,7);
@@ -91,9 +88,6 @@
 	
 	////////////////////////////////////
 
-	rootBody-&gt;persistentInteractions	= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 
 	shared_ptr&lt;Body&gt; body;
 	
@@ -147,7 +141,6 @@
 	gBox-&gt;extents			= size;
 	gBox-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= size;
@@ -189,7 +182,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -226,7 +218,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp
===================================================================
--- trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/realtime-rigidbody/PreProcessor/RotatingBox.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -33,7 +33,6 @@
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
 #include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 
 #include&lt;yade/pkg-common/PhysicalActionDamper.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalActionApplier.hpp&gt;
@@ -85,14 +84,11 @@
 
 bool RotatingBox::generate()
 {
-	Omega::instance().setTimeStep(0.01);
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);
 
 	createActors(rootBody);
 	positionRootBody(rootBody);
 	
-	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 
 	
 	shared_ptr&lt;Body&gt; body;
@@ -122,8 +118,8 @@
 				createBox(box,i,j,k);
 				rootBody-&gt;bodies-&gt;insert(box);
  			}
-
-	message=&quot;ATTN: please set smaller timestep or it will bounce like crazy.&quot;;
+	
+	rootBody-&gt;dt=1e-2;
 	return true;
 }
 
@@ -165,7 +161,6 @@
 	gBox-&gt;extents			= size;
 	gBox-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gBox-&gt;wire			= false;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= size;
@@ -208,7 +203,6 @@
 	gSphere-&gt;radius			= radius;
 	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -245,7 +239,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp
===================================================================
--- trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/snow/PreProcessor/SnowCreepTest.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -57,7 +57,6 @@
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
 #include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 #include&lt;yade/pkg-common/InteractionHashMap.hpp&gt;
 
 #include&lt;yade/extra/Shop.hpp&gt;
@@ -259,7 +258,6 @@
 	createActors(rootBody);
 	positionRootBody(rootBody);
 
-// 	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
 	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
 
 	shared_ptr&lt;Body&gt; body;
@@ -497,7 +495,6 @@
 //	gSphere-&gt;diffuseColor		= ((int)(position[0]*400.0))%2?Vector3r(0.7,0.7,0.7):Vector3r(0.45,0.45,0.45);
 	gSphere-&gt;diffuseColor		= spheresColor;
 	gSphere-&gt;wire			= false;
-	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
@@ -546,7 +543,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp
===================================================================
--- trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/pkg/snow/PreProcessor/SnowVoxelsLoader.cpp	2009-05-22 22:06:02 UTC (rev 1771)
@@ -50,7 +50,6 @@
 #include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
 
 #include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
-#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
 #include&lt;yade/pkg-common/InteractionHashMap.hpp&gt;
 #include&lt;yade/pkg-snow/ElawSnowLayersDeformation.hpp&gt;
 
@@ -600,7 +599,6 @@
 
 	gSnowGrain-&gt;diffuseColor	= grain-&gt;color;
 	gSnowGrain-&gt;wire		= false;
-	gSnowGrain-&gt;visible		= true;
 	gSnowGrain-&gt;shadowCaster	= true;
 	
 	//iSphere-&gt;radius			= radius; // already calculated
@@ -649,7 +647,6 @@
 	gBox-&gt;extents			= extents;
 	gBox-&gt;diffuseColor		= Vector3r(0.5,0.5,0.5);
 	gBox-&gt;wire			= wire;
-	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;

Modified: trunk/scripts/simple-scene.py
===================================================================
--- trunk/scripts/simple-scene.py	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/scripts/simple-scene.py	2009-05-22 22:06:02 UTC (rev 1771)
@@ -20,7 +20,7 @@
 ## MetaEngines act as dispatchers and based on the type of objects they operate on, different EngineUnits are called.
 o.engines=[
 	## Resets forces and momenta the act on bodies
-	PhysicalActionContainerReseter(),
+	BexResetter(),
 	## associates bounding volume - in this case, AxisAlignedBoundingBox (AABB) - to each body.
 	## MetaEngine calls corresponding EngineUnit, depending on whether the body is Sphere, Box, or MetaBody (rootBody).
 	## AABBs will be used to detect collisions later, by PersistentSAPCollider
@@ -126,5 +126,12 @@
 o.save('/tmp/a.xml.bz2');
 #o.run(100000); o.wait(); print o.iter/o.realtime,'iterations/sec'
 
+def onBodySelect(id):
+	print &quot;Selected:&quot;,id
+	utils.highlightNone()
+	for i in O.interactions.withBody(id):
+		O.bodies[i.id2 if i.id1==id else i.id1].shape['highlight']=True
+		print i.id1,i.id2,i.phys,i.geom
+
 from yade import qt
 qt.Controller()

Added: trunk/scripts/test/bex-move.py
===================================================================
--- trunk/scripts/test/bex-move.py	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/scripts/test/bex-move.py	2009-05-22 22:06:02 UTC (rev 1771)
@@ -0,0 +1,11 @@
+O.bodies.append(utils.sphere([0,0,0],1,dynamic=True))
+O.engines=[
+	BexResetter(),
+	PeriodicPythonRunner(command='O.bex.addMove(0,(1e-2,0,0))',iterPeriod=1),
+	NewtonsDampedLaw()
+]
+
+for i in xrange(0,20):
+	O.step()
+	print O.bex.f(0),O.bodies[0].phys.pos
+quit()

Added: trunk/scripts/test/facet-sphere.py
===================================================================
--- trunk/scripts/test/facet-sphere.py	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/scripts/test/facet-sphere.py	2009-05-22 22:06:02 UTC (rev 1771)
@@ -0,0 +1,48 @@
+# -*- coding: utf-8 -*-
+# &#169; V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">eudoxos at arcig.cz</A>&gt;
+#
+# Test case for sphere-facet interaction.
+O.engines=[
+	BexResetter(),
+	BoundingVolumeMetaEngine([InteractingSphere2AABB(),InteractingFacet2AABB()]),
+	PersistentSAPCollider(),
+	InteractionDispatchers(
+		[ef2_Facet_Sphere_Dem3DofGeom()],
+		[SimpleElasticRelationships()],
+		[ef2_Dem3Dof_Elastic_ElasticLaw()],
+	),
+	GravityEngine(gravity=[0,0,-10]),
+	NewtonsDampedLaw(damping=0.01),
+	]
+O.bodies.append([
+	utils.facet([[-1,-1,0],[1,-1,0],[0,1,0]],dynamic=False,color=[1,0,0],young=1e3),
+	utils.facet([[1,-1,0],[0,1,0,],[1,.5,.5]],dynamic=False,young=1e3)
+])
+import random
+for i in range(0,100):
+	O.bodies.append(utils.sphere([random.gauss(0,1),random.gauss(0,1),random.uniform(1,2)],random.uniform(.02,.05),velocity=[random.gauss(0,.1),random.gauss(0,.1),random.gauss(0,.1)]))
+
+O.miscParams=[Generic('GLDrawSphere',{'glutUse':True})]
+O.saveTmp('init')
+O.dt=1e-4
+
+
+from yade import log
+#log.setLevel(&quot;ef2_Facet_Sphere_Dem3DofGeom&quot;,log.TRACE)
+try:
+	from yade import qt
+	renderer=qt.Renderer()
+	renderer['Interaction_geometry']=True
+	qt.Controller()
+except ImportError: pass
+
+
+if 1:
+	O.timingEnabled=True
+	from yade import timing
+	for i in range(4):
+		timing.reset()
+		O.loadTmp('init')
+		O.run(100000,True)
+		timing.stats()
+	quit()

Added: trunk/scripts/test/insertion-sort-collider.py
===================================================================
--- trunk/scripts/test/insertion-sort-collider.py	2009-05-11 16:14:12 UTC (rev 1770)
+++ trunk/scripts/test/insertion-sort-collider.py	2009-05-22 22:06:02 UTC (rev 1771)
@@ -0,0 +1,43 @@
+o=Omega()
+
+o.engines=[
+	BexResetter(),
+	BoundingVolumeMetaEngine([InteractingSphere2AABB(),InteractingBox2AABB(),InteractingFacet2AABB(),MetaInteractingGeometry2AABB()]),
+	InsertionSortCollider(),
+	InteractionDispatchers([ef2_Facet_Sphere_Dem3DofGeom()],[SimpleElasticRelationships()],[ef2_Dem3Dof_Elastic_ElasticLaw()],),
+	GravityEngine(gravity=[0,0,-10]),
+	NewtonsDampedLaw(damping=0.01),
+]
+
+O.bodies.append([
+	utils.facet([[-1,-1,0],[1,-1,0],[0,1,0]],dynamic=False,color=[1,0,0],young=1e3),
+	utils.facet([[1,-1,0],[0,1,0,],[1,.5,.5]],dynamic=False,young=1e3)
+])
+import random
+if 1:
+	for i in range(0,100):
+		O.bodies.append(utils.sphere([random.gauss(0,1),random.gauss(0,1),random.uniform(1,2)],random.uniform(.02,.05),velocity=[random.gauss(0,.1),random.gauss(0,.1),random.gauss(0,.1)]))
+else:
+	O.bodies.append(utils.sphere([0,0,.6],.5))
+O.dt=1e-4
+O.saveTmp('init')
+import yade.log
+#yade.log.setLevel(&quot;InsertionSortCollider&quot;,yade.log.TRACE);
+# compare 2 colliders:
+if 1:
+	O.timingEnabled=True
+	from yade import timing
+	for collider in InsertionSortCollider(),PersistentSAPCollider(haveDistantTransient=True):
+		for i in range(2):
+			O.loadTmp('init')
+			utils.replaceCollider(collider)
+			O.run(100,True)
+			timing.reset()
+			O.run(50000,True)
+			timing.stats()
+else:
+	#O.run(100,True)
+	O.step()
+	print len(O.interactions)
+	#O.bodies[2].phys['se3']=[-.6,0,.6,1,0,0,0]
+	#O.step()


_______________________________________________
Mailing list: <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
Post to     : <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">yade-dev at lists.launchpad.net</A>
Unsubscribe : <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
More help   : <A HREF="https://help.launchpad.net/ListHelp">https://help.launchpad.net/ListHelp</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000966.html">[deprecated list] [Yade-dev] [svn] r1770 -	trunk/lib/serialization-qt
</A></li>
	<LI>Next message: <A HREF="000967.html">[deprecated list] [Yade-dev] [svn] r1772 -	trunk/pkg/common/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#999">[ date ]</a>
              <a href="thread.html#999">[ thread ]</a>
              <a href="subject.html#999">[ subject ]</a>
              <a href="author.html#999">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-dev">More information about the yade-dev
mailing list</a><br>
</body></html>
