<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [deprecated list] [Yade-dev] [svn] r1786 - in trunk: . core	examples	examples/collider-perf	examples/concrete	examples/concrete/pack extra extra/tetra	gui/py lib/import	pkg/common/Engine/DeusExMachina	pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/dem	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor	pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction	pkg/dem/RenderingEngine/GLDrawElasticContactInteraction	pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry	pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry	pkg/lattice/Engine/StandAloneEngine	pkg/lattice/PreProcessor	pkg/mass-spring/Engine/StandAloneEngine	pkg/mass-spring/PreProcessor	pkg/realtime-rigidbody/Engine/StandAloneEngine	pkg/snow/Engine	pkg/snow/RenderingEngine scripts/test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-dev/2009/index.html" >
   <LINK REL="made" HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1786%20-%20in%20trunk%3A%20.%20core%0A%09examples%09examples/collider-perf%0A%09examples/concrete%09examples/concrete/pack%20extra%20extra/tetra%0A%09gui/py%20lib/import%09pkg/common/Engine/DeusExMachina%0A%09pkg/common/Engine/EngineUnit%09pkg/common/Engine/MetaEngine%09pkg/common/Engine/StandAloneEngine%0A%09pkg/dem%09pkg/dem/DataClass/InteractionGeometry%09pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%09pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%09pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction%09pkg/dem/RenderingEngine/GLDrawElasticContactInteraction%09pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry%09pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry%09pkg/lattice/Engine/StandAloneEngine%0A%09pkg/lattice/PreProcessor%09pkg/mass-spring/Engine/StandAloneEngine%0A%09pkg/mass-spring/PreProcessor%09pkg/realtime-rigidbody/Engine/StandAloneEngine%09pkg/snow/Engine%0A%09pkg/snow/RenderingEngine%20scripts/test&In-Reply-To=%3C200905291435.n4TEZTD1018532%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000997.html">
   <LINK REL="Next"  HREF="001006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[deprecated list] [Yade-dev] [svn] r1786 - in trunk: . core	examples	examples/collider-perf	examples/concrete	examples/concrete/pack extra extra/tetra	gui/py lib/import	pkg/common/Engine/DeusExMachina	pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/dem	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor	pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction	pkg/dem/RenderingEngine/GLDrawElasticContactInteraction	pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry	pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry	pkg/lattice/Engine/StandAloneEngine	pkg/lattice/PreProcessor	pkg/mass-spring/Engine/StandAloneEngine	pkg/mass-spring/PreProcessor	pkg/realtime-rigidbody/Engine/StandAloneEngine	pkg/snow/Engine	pkg/snow/RenderingEngine scripts/test</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1786%20-%20in%20trunk%3A%20.%20core%0A%09examples%09examples/collider-perf%0A%09examples/concrete%09examples/concrete/pack%20extra%20extra/tetra%0A%09gui/py%20lib/import%09pkg/common/Engine/DeusExMachina%0A%09pkg/common/Engine/EngineUnit%09pkg/common/Engine/MetaEngine%09pkg/common/Engine/StandAloneEngine%0A%09pkg/dem%09pkg/dem/DataClass/InteractionGeometry%09pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%09pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%09pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction%09pkg/dem/RenderingEngine/GLDrawElasticContactInteraction%09pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry%09pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry%09pkg/lattice/Engine/StandAloneEngine%0A%09pkg/lattice/PreProcessor%09pkg/mass-spring/Engine/StandAloneEngine%0A%09pkg/mass-spring/PreProcessor%09pkg/realtime-rigidbody/Engine/StandAloneEngine%09pkg/snow/Engine%0A%09pkg/snow/RenderingEngine%20scripts/test&In-Reply-To=%3C200905291435.n4TEZTD1018532%40sheep.berlios.de%3E"
       TITLE="[deprecated list] [Yade-dev] [svn] r1786 - in trunk: . core	examples	examples/collider-perf	examples/concrete	examples/concrete/pack extra extra/tetra	gui/py lib/import	pkg/common/Engine/DeusExMachina	pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/dem	pkg/dem/DataClass/InteractionGeometry	pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor	pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction	pkg/dem/RenderingEngine/GLDrawElasticContactInteraction	pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry	pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry	pkg/lattice/Engine/StandAloneEngine	pkg/lattice/PreProcessor	pkg/mass-spring/Engine/StandAloneEngine	pkg/mass-spring/PreProcessor	pkg/realtime-rigidbody/Engine/StandAloneEngine	pkg/snow/Engine	pkg/snow/RenderingEngine scripts/test">eudoxos at mail.berlios.de
       </A><BR>
    <I>Fri May 29 16:35:29 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000997.html">[deprecated list] [Yade-dev] [svn] r1785 - trunk/pkg/snow/Engine
</A></li>
        <LI>Next message: <A HREF="001006.html">[deprecated list] [Yade-dev] [svn] r1787 - in trunk: core	examples/concrete/pack	gui/py	lib/computational-geometry	pkg/common/Engine/MetaEngine	pkg/dem pkg/dem/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1005">[ date ]</a>
              <a href="thread.html#1005">[ thread ]</a>
              <a href="subject.html#1005">[ subject ]</a>
              <a href="author.html#1005">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2009-05-29 16:35:22 +0200 (Fri, 29 May 2009)
New Revision: 1786

Added:
   trunk/examples/concrete/
   trunk/examples/concrete/pack/
   trunk/examples/concrete/pack/mk-pack.py
Modified:
   trunk/SConstruct
   trunk/core/Collider.cpp
   trunk/core/Interaction.cpp
   trunk/core/Interaction.hpp
   trunk/core/InteractionContainer.cpp
   trunk/core/InteractionContainer.hpp
   trunk/core/MetaEngine2D.hpp
   trunk/core/yade.cpp
   trunk/examples/collider-perf/perf.table
   trunk/extra/Shop.cpp
   trunk/extra/tetra/Tetra.cpp
   trunk/gui/py/_eudoxos.cpp
   trunk/gui/py/_utils.cpp
   trunk/gui/py/utils.py
   trunk/gui/py/yadeControl.cpp
   trunk/lib/import/STLReader.hpp
   trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp
   trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp
   trunk/pkg/common/Engine/MetaEngine/ConstitutiveLawDispatcher.cpp
   trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp
   trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.hpp
   trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp
   trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.hpp
   trunk/pkg/common/Engine/MetaEngine/InteractionPhysicsMetaEngine.cpp
   trunk/pkg/common/Engine/StandAloneEngine/DistantPersistentSAPCollider.cpp
   trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp
   trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp
   trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp
   trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.cpp
   trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.cpp
   trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp
   trunk/pkg/dem/ConcretePM.cpp
   trunk/pkg/dem/ConcretePM.hpp
   trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp
   trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
   trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometry.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingBox4InteractionOfMyTetrahedron.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingMyTetrahedron4InteractionOfMyTetrahedron.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2BssSweptSphereLineSegment4SpheresContactGeometry.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp
   trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp
   trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp
   trunk/pkg/dem/Engine/EngineUnit/ef2_Spheres_Viscoelastic_SimpleViscoelasticContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp
   trunk/pkg/dem/PreProcessor/HydraulicTest.cpp
   trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp
   trunk/pkg/dem/PreProcessor/ThreePointBending.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.hpp
   trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp
   trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp
   trunk/pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry/GLDrawSDECLinkGeometry.cpp
   trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp
   trunk/pkg/dem/SConscript
   trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp
   trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp
   trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp
   trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp
   trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp
   trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp
   trunk/pkg/snow/RenderingEngine/Ef1_IstSnowLayersContact_glDraw.cpp
   trunk/scripts/test/regular-sphere-pack.py
Log:
1. Remove Interaction::isNew, Interaction::isReal. Add Interaction::isReal() which test for presence of _both_ interactionGeometry and interactionPhysics and Interaction::isFresh() which checks the interaction creation timestamp against current iteration. Updated all code for that. Please verify that your stuff works, it is possible I made some mistakes!
2. All code saying isReal=false replaced by interaction-&gt;requestErase(id1,id2)
3. make requestErase thread-safe
4. Add interace for traversing interactions pending erase (template)
5. Add TriaxialTest::noFiles and TriaxialCompressionEngine::noFiles to not generate any files (default: off)
6. Add predicate utils.ptInAABB(p,minPt,maxPt)
7. utils.spheresToFile return number of spheres written (instead of None)
8. Add examples/concrete/pack to generate packing; other stuff in concrete will follow, with simplified version of the cpm model in ConcretePM.


Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/SConstruct	2009-05-29 14:35:22 UTC (rev 1786)
@@ -129,7 +129,7 @@
 	ListVariable('exclude','Yade components that will not be built','none',names=['qt3','gui','extra','common','dem','fem','lattice','mass-spring','realtime-rigidbody','snow']),
 	EnumVariable('arcs','Whether to generate or use branch probabilities','',['','gen','use'],{'no':'','0':'','false':''},1),
 	# OK, dummy prevents bug in scons: if one selects all, it says all in scons.config, but without quotes, which generates error.
-	ListVariable('features','Optional features that are turned on','python,log4cxx',names=['python','log4cxx','binfmt','dummy']),
+	ListVariable('features','Optional features that are turned on','python,log4cxx,gl',names=['gl','python','log4cxx','binfmt','CGAL','dummy']),
 	('jobs','Number of jobs to run at the same time (same as -j, but saved)',4,None,int),
 	('extraModules', 'Extra directories with their own SConscript files (must be in-tree) (whitespace separated)',None,None,Split),
 	('buildPrefix','Where to create build-[version][variant] directory for intermediary files','..'),
@@ -334,6 +334,9 @@
 			and conf.CheckCXXHeader(['Python.h','numpy/ndarrayobject.h'],'&lt;&gt;'))
 		if not ok: featureNotOK('python')
 		env.Append(CPPDEFINES=['EMBED_PYTHON'])
+	if 'CGAL' in env['features']:
+		ok=cong.CheckLibWithHeader('CGAL','CGAL/Exact_predicates_inexact_constructions_kernel.h','c++','CGAL::Exact_predicates_inexact_constructions_kernel::Point_3();')
+		if not ok: featureNotOK('CGAL')
 	if env['useMiniWm3']: env.Append(LIBS='miniWm3',CPPDEFINES=['MINIWM3'])
 
 	env=conf.Finish()

Modified: trunk/core/Collider.cpp
===================================================================
--- trunk/core/Collider.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/core/Collider.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -11,8 +11,9 @@
 Collider::Collider(){}
 
 Collider::~Collider(){}
-
 bool Collider::handleExistingInteraction(Interaction* I){
+	throw runtime_error(&quot;handleExistingInteraction should not be called&quot;);
+#if 0
 	/* logically, we have 4 possibilities
 	 * 1.  real  new &#8594; &#172;new, keep
 	 * 2.  real &#172;new &#8594; keep (same as 1.)
@@ -34,8 +35,8 @@
 
 	assert(false); // unreachable
 	return false;
+#endif
 }
-
 bool Collider::mayCollide(const Body* b1, const Body* b2){
 	return 
 		// not yet implemented: only collide if at least one of the bodies is not shadow

Modified: trunk/core/Interaction.cpp
===================================================================
--- trunk/core/Interaction.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/core/Interaction.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -8,23 +8,27 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;Interaction.hpp&quot;
+#include&quot;Interaction.hpp&quot;
 
+#include&lt;yade/core/MetaBody.hpp&gt;
+
 Interaction::Interaction(): id1(0), id2(0){ reset(); }
 Interaction::Interaction(body_id_t newId1,body_id_t newId2): id1(newId1), id2(newId2){ reset(); }
 
+bool Interaction::isFresh(MetaBody* rb){ return iterMadeReal==rb-&gt;currentIteration;}
+
+
 void Interaction::reset(){
-	isNew=true;
-	isReal=false;
 	isNeighbor = true;//NOTE : TriangulationCollider needs that
+	iterMadeReal=-1;
 	functorCache.geomExists=true;
 	//functorCache.geom=shared_ptr&lt;InteractionGeometryEngineUnit&gt;(); functorCache.phys=shared_ptr&lt;InteractionPhysicsEngineUnit&gt;(); functorCache.constLaw=shared_ptr&lt;ConstitutiveLaw&gt;();
 }
 
 
 void Interaction::swapOrder(){
-	if(interactionGeometry || interactionPhysics || !isNew){
-		throw std::logic_error(&quot;Bodies in interaction cannot be swapped if !isNew, have interactionGeometry or have interactionPhysics.&quot;);
+	if(interactionGeometry || interactionPhysics){
+		throw std::logic_error(&quot;Bodies in interaction cannot be swapped if they have interactionGeometry or interactionPhysics.&quot;);
 	}
 	std::swap(id1,id2);
 }

Modified: trunk/core/Interaction.hpp
===================================================================
--- trunk/core/Interaction.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/core/Interaction.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -17,20 +17,26 @@
 class InteractionGeometryEngineUnit;
 class InteractionPhysicsEngineUnit;
 class ConstitutiveLaw;
+class MetaBody;
 
 class Interaction : public Serializable
 {
 	private	:
 		body_id_t id1,id2;
+		//! Step number at which the interaction was fully created (interactionGeometry and interactionPhysics).
+		//! Should be touched only by InteractionPhysicsMetaEngine and InteractionDispatchers, making them friends therefore
+		long iterMadeReal;
+		friend class InteractionPhysicsMetaEngine;
+		friend class InteractionDispatchers;
 	public :
-		// FIXME : test if InteractionPhysics==0 and remove this flag; we can also remove this flag, if we make another container for PotetntialInteraction with only ids
-		bool isNew;		
-		// maybe we can remove this, and check if InteractingGeometry, and InteractionPhysics are empty?
-		bool isReal;		
+		bool isReal() const {return (bool)interactionGeometry &amp;&amp; (bool)interactionPhysics;}
+		//! If this interaction was just created in this step (for the constitutive law, to know that it is the first time there)
+		bool isFresh(MetaBody* rb);
+
 		//! phase flag to mark (for example, SpatialQuickSortCollider mark by it the stale interactions) 
 		bool cycle;      
 		//! NOTE : TriangulationCollider needs this (nothing else)
-		bool isNeighbor;	
+		bool isNeighbor;
 
 		shared_ptr&lt;InteractionGeometry&gt; interactionGeometry;
 		shared_ptr&lt;InteractionPhysics&gt; interactionPhysics;
@@ -61,8 +67,7 @@
 	REGISTER_ATTRIBUTES(/*no base*/,
 		(id1)
 		(id2)
-		(isNew)
-		(isReal)
+		(iterMadeReal)
 		(interactionGeometry)
 		(interactionPhysics)
 	);

Modified: trunk/core/InteractionContainer.cpp
===================================================================
--- trunk/core/InteractionContainer.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/core/InteractionContainer.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -9,11 +9,18 @@
 *************************************************************************/
 
 #include &quot;InteractionContainer.hpp&quot;
-#include &quot;Interaction.hpp&quot;
 
+void InteractionContainer::requestErase(body_id_t id1, body_id_t id2){
+	find(id1,id2)-&gt;reset(); bodyIdPair v(0,2); v.push_back(id1); v.push_back(id2); 
+	boost::mutex::scoped_lock lock(pendingEraseMutex);
+	pendingErase.push_back(v);
+}
 
+void InteractionContainer::unconditionalErasePending(){
+	FOREACH(const bodyIdPair&amp; p, pendingErase){ erase(p[0],p[1]); }
+	pendingErase.clear();
+}
 
-void InteractionContainer::requestErase(body_id_t id1, body_id_t id2){ find(id1,id2)-&gt;reset(); bodyIdPair v(0,2); v.push_back(id1); v.push_back(id2); pendingErase.push_back(v); }
 
 void InteractionContainer::preProcessAttributes(bool deserializing)
 {

Modified: trunk/core/InteractionContainer.hpp
===================================================================
--- trunk/core/InteractionContainer.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/core/InteractionContainer.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -15,8 +15,11 @@
 #include&lt;iostream&gt;
 #include&lt;boost/range.hpp&gt;
 
+// BOOST_FOREACH compatibility
+#ifndef FOREACH
+#  define FOREACH BOOST_FOREACH
+#endif
 
-
 #include&lt;yade/core/Interaction.hpp&gt;
 
 using namespace boost;
@@ -81,7 +84,7 @@
 class InteractionContainer : public Serializable
 {
 	public :
-		boost::mutex	drawloopmutex; // FIXME a hack, containers have to be rewritten lock-free.
+		boost::mutex	drawloopmutex;
 
 		InteractionContainer() { };
 		virtual ~InteractionContainer() {};
@@ -103,11 +106,42 @@
 
 		// std::pair is not handle by yade::serialization, use vector&lt;body_id_t&gt; instead
 		typedef vector&lt;body_id_t&gt; bodyIdPair;
-		// Ask for erasing the interaction given (from the constitutive law); this resets the interaction (to the initial=potential state)
-		// and collider should traverse pendingErase to decide whether to delete the interaction completely or keep it potential
+		//! Ask for erasing the interaction given (from the constitutive law); this resets the interaction (to the initial=potential state)
+		//! and collider should traverse pendingErase to decide whether to delete the interaction completely or keep it potential
 		void requestErase(body_id_t id1, body_id_t id2);
+		/*! List of pairs of interactions that will be (maybe) erased by the collider;
+			
+			If accessed from within a parallel section, pendingEraseMutex must be locked (this is done inside requestErase for you)
+			If there is, at one point, a multi-threaded collider, pendingEraseMutex should be moved to the public part and used from there as well.
+		*/
 		list&lt;bodyIdPair&gt; pendingErase;
+		/*! Erase all pending interactions unconditionally.
+
+			This should be called only in rare cases that collider is not used but still interactions should be erased.
+			Otherwise collider should decide on a case-by-case basis, which interaction to erase for good and which to keep in the potential state
+			(without interactionGeometry and interactionPhysics).
+
+			This function doesn't lock pendingEraseMutex, as it is (supposedly) called from no-parallel sections only once per iteration
+		*/
+		void unconditionalErasePending();
+		/*! Traverse all pending interactions and erase them if the (T*)-&gt;shouldBeErased(id1,id2) return true
+			and keep it if it return false; finally, pendingErase will be clear()'ed.
+
+			Class using this interface (which is presumably a collider) must define the 
+					
+				bool shouldBeErased(body_id_t, body_id_t) const
+
+			method which will be called for every interaction.
+		*/
+		template&lt;class T&gt; void erasePending(const T&amp; t){
+			FOREACH(const vector&lt;body_id_t&gt;&amp; p, pendingErase){ if(t.shouldBeErased(p[0],p[1])) erase(p[0],p[1]); }
+			pendingErase.clear();
+		}
 	private :
+		#ifdef YADE_OPENMP
+			// This is used only from within requestErase() for now, therefore it can be private
+			boost::mutex pendingEraseMutex;
+		#endif
 		// used only during serialization/deserialization
 		vector&lt;shared_ptr&lt;Interaction&gt; &gt; interaction;
 	protected :
@@ -119,10 +153,6 @@
 
 REGISTER_SERIALIZABLE(InteractionContainer);
 
-// BOOST_FOREACH compatibility
-#ifndef FOREACH
-#  define FOREACH BOOST_FOREACH
-#endif
 
 namespace boost{
    template&lt;&gt; struct range_iterator&lt;InteractionContainer&gt;{ typedef InteractionContainer::iterator type; };

Modified: trunk/core/MetaEngine2D.hpp
===================================================================
--- trunk/core/MetaEngine2D.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/core/MetaEngine2D.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -40,11 +40,7 @@
 		}
 		/* add functor by its literal name */
 		virtual void add(string euType){
-			shared_ptr&lt;EngineUnitType&gt; eu=dynamic_pointer_cast&lt;EngineUnitType&gt;(ClassFactory::instance().createShared(euType));
-			if(!eu){
-				cerr&lt;&lt;__FILE__&lt;&lt;&quot;:&quot;&lt;&lt;__LINE__&lt;&lt;&quot; WARNING! dynamic cast of engine unit &quot;&lt;&lt;euType&lt;&lt;&quot; failed, will use static_cast. Go figure why.&quot;&lt;&lt;endl;
-				eu=static_pointer_cast&lt;EngineUnitType&gt;(ClassFactory::instance().createShared(euType));
-			}
+			shared_ptr&lt;EngineUnitType&gt; eu=static_pointer_cast&lt;EngineUnitType&gt;(ClassFactory::instance().createShared(euType));
 			add(eu);
 		}
 

Modified: trunk/core/yade.cpp
===================================================================
--- trunk/core/yade.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/core/yade.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -147,10 +147,10 @@
 		&quot;   NDEBUG        (heavy optimizations, no assertions and debugging features)\n&quot;
 	#endif
 	#ifdef YADE_OPENMP
-		&quot;   YADE_OPENMP   (supports openMP; set OMP_NUM_THREADS env. var to control parallelism.\n&quot;
+		&quot;   YADE_OPENMP   (supports openMP; set OMP_NUM_THREADS env. var to control parallelism.)\n&quot;
 	#endif
 	#ifdef LOG4CXX
-		&quot;   LOG4CXX       configurable logging framework enabled (~/.yade-suffix/logging.conf)\n&quot;
+		&quot;   LOG4CXX       (configurable logging framework enabled; ~/.yade-&quot; SUFFIX &quot;/logging.conf)\n&quot;
 	#endif
 	;
 	if(!isnan(std::numeric_limits&lt;double&gt;::quiet_NaN())) cerr&lt;&lt;

Modified: trunk/examples/collider-perf/perf.table
===================================================================
--- trunk/examples/collider-perf/perf.table	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/examples/collider-perf/perf.table	2009-05-29 14:35:22 UTC (rev 1786)
@@ -1,76 +1,77 @@
-description nSpheres collider
-128k 128000 'PersistentSAPCollider'
-96k 96000 'PersistentSAPCollider'
-64k 64000 'PersistentSAPCollider'
-56k 56000 'PersistentSAPCollider'
-48k 48000 'PersistentSAPCollider'
-40k 40000 'PersistentSAPCollider'
-36k 36000 'PersistentSAPCollider'
-32k 32000 'PersistentSAPCollider'
-28k 28000 'PersistentSAPCollider'
-24k 24000 'PersistentSAPCollider'
-20k 20000 'PersistentSAPCollider'
-18k 18000 'PersistentSAPCollider'
-16k 16000 'PersistentSAPCollider'
-14k 14000 'PersistentSAPCollider'
-12k 12000 'PersistentSAPCollider'
-10k 10000 'PersistentSAPCollider'
-9k 9000 'PersistentSAPCollider'
-8k 8000 'PersistentSAPCollider'
-7k 7000 'PersistentSAPCollider'
-6k 6000 'PersistentSAPCollider'
-5k 5000 'PersistentSAPCollider'
-4k 4000 'PersistentSAPCollider'
-3k 3000 'PersistentSAPCollider'
-2k 2000 'PersistentSAPCollider'
-1k 1000 'PersistentSAPCollider'
-128k.q 128000 'SpatialQuickSortCollider'
-96k.q 96000 'SpatialQuickSortCollider'
-64k.q 64000 'SpatialQuickSortCollider'
-56k.q 56000 'SpatialQuickSortCollider'
-48k.q 48000 'SpatialQuickSortCollider'
-40k.q 40000 'SpatialQuickSortCollider'
-36k.q 36000 'SpatialQuickSortCollider'
-32k.q 32000 'SpatialQuickSortCollider'
-28k.q 28000 'SpatialQuickSortCollider'
-24k.q 24000 'SpatialQuickSortCollider'
-20k.q 20000 'SpatialQuickSortCollider'
-18k.q 18000 'SpatialQuickSortCollider'
-16k.q 16000 'SpatialQuickSortCollider'
-14k.q 14000 'SpatialQuickSortCollider'
-12k.q 12000 'SpatialQuickSortCollider'
-10k.q 10000 'SpatialQuickSortCollider'
-9k.q 9000 'SpatialQuickSortCollider'
-8k.q 8000 'SpatialQuickSortCollider'
-7k.q 7000 'SpatialQuickSortCollider'
-6k.q 6000 'SpatialQuickSortCollider'
-5k.q 5000 'SpatialQuickSortCollider'
-4k.q 4000 'SpatialQuickSortCollider'
-3k.q 3000 'SpatialQuickSortCollider'
-2k.q 2000 'SpatialQuickSortCollider'
-1k.q 1000 'SpatialQuickSortCollider'
-128k.i 128000 'InsertionSortCollider'
-96k.i 96000 'InsertionSortCollider'
-64k.i 64000 'InsertionSortCollider'
-56k.i 56000 'InsertionSortCollider'
-48k.i 48000 'InsertionSortCollider'
-40k.i 40000 'InsertionSortCollider'
-36k.i 36000 'InsertionSortCollider'
-32k.i 32000 'InsertionSortCollider'
-28k.i 28000 'InsertionSortCollider'
-24k.i 24000 'InsertionSortCollider'
-20k.i 20000 'InsertionSortCollider'
-18k.i 18000 'InsertionSortCollider'
-16k.i 16000 'InsertionSortCollider'
-14k.i 14000 'InsertionSortCollider'
-12k.i 12000 'InsertionSortCollider'
-10k.i 10000 'InsertionSortCollider'
-9k.i 9000 'InsertionSortCollider'
-8k.i 8000 'InsertionSortCollider'
-7k.i 7000 'InsertionSortCollider'
-6k.i 6000 'InsertionSortCollider'
-5k.i 5000 'InsertionSortCollider'
-4k.i 4000 'InsertionSortCollider'
-3k.i 3000 'InsertionSortCollider'
-2k.i 2000 'InsertionSortCollider'
-1k.i 1000 'InsertionSortCollider'
+!OMP_NUM_THREADS description nSpheres collider
+3 128k 128000 'PersistentSAPCollider'
+3 96k 96000 'PersistentSAPCollider'
+3 64k 64000 'PersistentSAPCollider'
+3 56k 56000 'PersistentSAPCollider'
+3 48k 48000 'PersistentSAPCollider'
+3 40k 40000 'PersistentSAPCollider'
+3 36k 36000 'PersistentSAPCollider'
+3 32k 32000 'PersistentSAPCollider'
+3 28k 28000 'PersistentSAPCollider'
+3 24k 24000 'PersistentSAPCollider'
+3 20k 20000 'PersistentSAPCollider'
+3 18k 18000 'PersistentSAPCollider'
+3 16k 16000 'PersistentSAPCollider'
+3 14k 14000 'PersistentSAPCollider'
+3 12k 12000 'PersistentSAPCollider'
+3 10k 10000 'PersistentSAPCollider'
+3 9k 9000 'PersistentSAPCollider'
+3 8k 8000 'PersistentSAPCollider'
+3 7k 7000 'PersistentSAPCollider'
+3 6k 6000 'PersistentSAPCollider'
+3 5k 5000 'PersistentSAPCollider'
+3 4k 4000 'PersistentSAPCollider'
+3 3k 3000 'PersistentSAPCollider'
+3 2k 2000 'PersistentSAPCollider'
+3 1k 1000 'PersistentSAPCollider'
+3 128k.q 128000 'SpatialQuickSortCollider'
+3 96k.q 96000 'SpatialQuickSortCollider'
+3 64k.q 64000 'SpatialQuickSortCollider'
+3 56k.q 56000 'SpatialQuickSortCollider'
+3 48k.q 48000 'SpatialQuickSortCollider'
+3 40k.q 40000 'SpatialQuickSortCollider'
+3 36k.q 36000 'SpatialQuickSortCollider'
+3 32k.q 32000 'SpatialQuickSortCollider'
+3 28k.q 28000 'SpatialQuickSortCollider'
+3 24k.q 24000 'SpatialQuickSortCollider'
+3 20k.q 20000 'SpatialQuickSortCollider'
+3 18k.q 18000 'SpatialQuickSortCollider'
+3 16k.q 16000 'SpatialQuickSortCollider'
+3 14k.q 14000 'SpatialQuickSortCollider'
+3 12k.q 12000 'SpatialQuickSortCollider'
+3 10k.q 10000 'SpatialQuickSortCollider'
+3 9k.q 9000 'SpatialQuickSortCollider'
+3 8k.q 8000 'SpatialQuickSortCollider'
+3 7k.q 7000 'SpatialQuickSortCollider'
+3 6k.q 6000 'SpatialQuickSortCollider'
+3 5k.q 5000 'SpatialQuickSortCollider'
+3 4k.q 4000 'SpatialQuickSortCollider'
+3 3k.q 3000 'SpatialQuickSortCollider'
+3 2k.q 2000 'SpatialQuickSortCollider'
+3 1k.q 1000 'SpatialQuickSortCollider'
+1 128k.i1 128000 'InsertionSortCollider'
+3 128k.i 128000 'InsertionSortCollider'
+3 96k.i 96000 'InsertionSortCollider'
+3 64k.i 64000 'InsertionSortCollider'
+3 56k.i 56000 'InsertionSortCollider'
+3 48k.i 48000 'InsertionSortCollider'
+3 40k.i 40000 'InsertionSortCollider'
+3 36k.i 36000 'InsertionSortCollider'
+3 32k.i 32000 'InsertionSortCollider'
+3 28k.i 28000 'InsertionSortCollider'
+3 24k.i 24000 'InsertionSortCollider'
+3 20k.i 20000 'InsertionSortCollider'
+3 18k.i 18000 'InsertionSortCollider'
+3 16k.i 16000 'InsertionSortCollider'
+3 14k.i 14000 'InsertionSortCollider'
+3 12k.i 12000 'InsertionSortCollider'
+3 10k.i 10000 'InsertionSortCollider'
+3 9k.i 9000 'InsertionSortCollider'
+3 8k.i 8000 'InsertionSortCollider'
+3 7k.i 7000 'InsertionSortCollider'
+3 6k.i 6000 'InsertionSortCollider'
+3 5k.i 5000 'InsertionSortCollider'
+3 4k.i 4000 'InsertionSortCollider'
+3 3k.i 3000 'InsertionSortCollider'
+3 2k.i 2000 'InsertionSortCollider'
+3 1k.i 1000 'InsertionSortCollider'

Added: trunk/examples/concrete/pack/mk-pack.py
===================================================================
--- trunk/examples/concrete/pack/mk-pack.py	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/examples/concrete/pack/mk-pack.py	2009-05-29 14:35:22 UTC (rev 1786)
@@ -0,0 +1,73 @@
+from yade import log
+import shutil, tempfile
+#
+# Generate box or cylindrical packing that is rather compact using TriaxialTest.
+#
+
+# if non-negative, the resulting sample will be cylindrical; if &lt; 0, generate box
+cylAxis=1
+# how many layers of average spheres to cut away from flat parts (relative to mean sphere radius); sphere center count
+cutoffFlat=3.5
+# how many layers of average spheres to cut away from round surfaces (relative to mean sphere radius); sphere centers count
+cutoffRound=2
+
+tt=TriaxialTest(
+	numberOfGrains=500,
+	radiusMean=3e-4,
+	# this is just size ratio if radiusMean is specified
+	# if you comment out the line above, it will be the corner (before compaction) and radiusMean will be set accordingly
+	upperCorner=[2,4,2],
+	radiusStdDev=0, # all spheres exactly the same radius
+	
+	##
+	## no need to touch any the following, till the end of file
+	##
+	noFiles=True,
+	lowerCorner=[0,0,0],
+	sigmaIsoCompaction=1e7,
+	sigmaLateralConfinement=1e3,
+	StabilityCriterion=.05,
+	strainRate=.2,
+	fast=True,
+	maxWallVelocity=.1,
+	wallOversizeFactor=2,
+	autoUnload=True, # unload after isotropic compaction
+	autoCompressionActivation=False # stop once unloaded
+)
+
+tt.load()
+log.setLevel('TriaxialCompressionEngine',log.WARN)
+O.run() ## triax stops by itself once unloaded
+O.wait()
+
+# resulting specimen geometry
+ext=utils.aabbExtrema()
+rSphere=tt['radiusMean']
+
+outFile=tempfile.NamedTemporaryFile(delete=False)
+
+if cylAxis&lt;0: # box-shaped packing
+	aabbMin,aabbMax=tuple([ext[0][i]+rSphere*cutoffFlat for i in 0,1,2]),tuple([ext[1][i]-rSphere*cutoffFlat for i in 0,1,2])
+	def isInBox(id):
+		pos=O.bodies[id].phys.pos
+		return utils.ptInAABB(pos,aabbMin,aabbMax)
+	nSpheres=utils.spheresToFile(outFile,consider=isInBox)
+else: # cylinger packing
+	mid   =[.5*(ext[1][i]+ext[0][i]) for i in [0,1,2]]
+	extent=[.5*(ext[1][i]-ext[0][i]) for i in [0,1,2]]
+	ax1,ax2=(cylAxis+1)%3,(cylAxis+2)%3
+	cylRadius=min(extent[ax1],extent[ax2])-cutoffRound*rSphere
+	cylHalfHt=extent[cylAxis]-cutoffFlat*rSphere
+	def isInCyl(id):
+		pos=O.bodies[id].phys.pos
+		axisDist=sqrt((pos[ax1]-mid[ax1])**2+(pos[ax2]-mid[ax2])**2)
+		if axisDist&gt;cylRadius: return False
+		axialDist=abs(pos[cylAxis]-mid[cylAxis])
+		if axialDist&gt;cylHalfHt: return False
+		return True
+	nSpheres=utils.spheresToFile(outFile,consider=isInCyl)
+
+outFile2='pack-%d-%s.sphere'%(nSpheres,'box' if cylAxis&lt;0 else 'cyl')
+shutil.move(outFile,outFile2)
+print nSpheres,'spheres written to',outFile2
+quit()

Modified: trunk/extra/Shop.cpp
===================================================================
--- trunk/extra/Shop.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/extra/Shop.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -96,7 +96,7 @@
 	// get max force on contacts
 	Real maxContactF=0;
 	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *rb-&gt;transientInteractions){
-		if(!I-&gt;isReal) continue;
+		if(!I-&gt;isReal()) continue;
 		shared_ptr&lt;NormalShearInteraction&gt; nsi=YADE_PTR_CAST&lt;NormalShearInteraction&gt;(I-&gt;interactionPhysics); assert(nsi);
 		maxContactF=max(maxContactF,(nsi-&gt;normalForce+nsi-&gt;shearForce).Length());
 	}

Modified: trunk/extra/tetra/Tetra.cpp
===================================================================
--- trunk/extra/tetra/Tetra.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/extra/tetra/Tetra.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -49,7 +49,7 @@
 	
 	shared_ptr&lt;TetraBang&gt; bang;
 	// depending whether it's a new interaction: create new one, or use the existing one.
-	if (interaction-&gt;isNew) bang=shared_ptr&lt;TetraBang&gt;(new TetraBang());
+	if (!interaction-&gt;interactionGeometry) bang=shared_ptr&lt;TetraBang&gt;(new TetraBang());
 	else bang=YADE_PTR_CAST&lt;TetraBang&gt;(interaction-&gt;interactionGeometry);	
 	interaction-&gt;interactionGeometry=bang;
 	
@@ -375,7 +375,7 @@
 {
 
 	for(InteractionContainer::iterator contactI=rootBody-&gt;transientInteractions-&gt;begin(); contactI!=rootBody-&gt;transientInteractions-&gt;end(); ++contactI){
-		if (!(*contactI)-&gt;isReal) continue; // Tetra2TetraBang::go returned false for this interaction, skip it
+		if (!(*contactI)-&gt;isReal()) continue; // Tetra2TetraBang::go returned false for this interaction, skip it
 		const shared_ptr&lt;TetraBang&gt;&amp; contactGeom(dynamic_pointer_cast&lt;TetraBang&gt;((*contactI)-&gt;interactionGeometry));
 		if(!contactGeom) continue;
 

Modified: trunk/gui/py/_eudoxos.cpp
===================================================================
--- trunk/gui/py/_eudoxos.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/gui/py/_eudoxos.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -39,10 +39,10 @@
 		MetaBody* rootBody=Omega::instance().getRootBody().get();
 		shared_ptr&lt;Interaction&gt; I;
 		FOREACH(I, *rootBody-&gt;transientInteractions){
-			if(I-&gt;isReal) break;
+			if(I-&gt;isReal()) break;
 		}
 		Real nan=std::numeric_limits&lt;Real&gt;::quiet_NaN();
-		if(!I-&gt;isReal) {LOG_ERROR(&quot;No real interaction found, returning NaN!&quot;); return nan; }
+		if(!I-&gt;isReal()) {LOG_ERROR(&quot;No real interaction found, returning NaN!&quot;); return nan; }
 		CpmPhys* BC=dynamic_cast&lt;CpmPhys*&gt;(I-&gt;interactionPhysics.get());
 		if(!BC) {LOG_ERROR(&quot;Interaction physics is not CpmPhys instance, returning NaN!&quot;); return nan;}
 		const Real &amp;omega(BC-&gt;omega); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; tanFrictionAngle(BC-&gt;tanFrictionAngle);

Modified: trunk/gui/py/_utils.cpp
===================================================================
--- trunk/gui/py/_utils.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/gui/py/_utils.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -24,6 +24,8 @@
 Vector3r tuple2vec(const python::tuple&amp; t){return Vector3r(extract&lt;double&gt;(t[0])(),extract&lt;double&gt;(t[1])(),extract&lt;double&gt;(t[2])());}
 bool isInBB(Vector3r p, Vector3r bbMin, Vector3r bbMax){return p[0]&gt;bbMin[0] &amp;&amp; p[0]&lt;bbMax[0] &amp;&amp; p[1]&gt;bbMin[1] &amp;&amp; p[1]&lt;bbMax[1] &amp;&amp; p[2]&gt;bbMin[2] &amp;&amp; p[2]&lt;bbMax[2];}
 
+bool ptInAABB(python::tuple p, python::tuple bbMin, python::tuple bbMax){return isInBB(tuple2vec(p),tuple2vec(bbMin),tuple2vec(bbMax));}
+
 /* \todo implement groupMask */
 python::tuple aabbExtrema(Real cutoff=0.0, bool centers=false){
 	if(cutoff&lt;0. || cutoff&gt;1.) throw invalid_argument(&quot;Cutoff must be &gt;=0 and &lt;=1.&quot;);
@@ -120,7 +122,7 @@
 	vector&lt;Real&gt; cummProj(bins,0.);
 	shared_ptr&lt;MetaBody&gt; rb=Omega::instance().getRootBody();
 	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; i, *rb-&gt;transientInteractions){
-		if(!i-&gt;isReal) continue;
+		if(!i-&gt;isReal()) continue;
 		const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(i-&gt;getId1(),rb), b2=Body::byId(i-&gt;getId2(),rb);
 		if(!b1-&gt;maskOk(mask) || !b2-&gt;maskOk(mask)) continue;
 		if(useBB &amp;&amp; !isInBB(b1-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax) &amp;&amp; !isInBB(b2-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax)) continue;
@@ -143,7 +145,7 @@
 	vector&lt;int&gt; bodyNumInta; bodyNumInta.resize(rb-&gt;bodies-&gt;size(),-1 /* uninitialized */);
 	int maxInta=0;
 	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; i, *rb-&gt;transientInteractions){
-		if(!i-&gt;isReal) continue;
+		if(!i-&gt;isReal()) continue;
 		const body_id_t id1=i-&gt;getId1(), id2=i-&gt;getId2(); const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(id1,rb), b2=Body::byId(id2,rb);
 		if(useBB &amp;&amp; isInBB(b1-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax)) bodyNumInta[id1]=bodyNumInta[id1]&gt;0?bodyNumInta[id1]+1:1;
 		if(useBB &amp;&amp; isInBB(b2-&gt;physicalParameters-&gt;se3.position,bbMin,bbMax)) bodyNumInta[id2]=bodyNumInta[id2]&gt;0?bodyNumInta[id2]+1:1;
@@ -334,6 +336,7 @@
 
 	def(&quot;PWaveTimeStep&quot;,PWaveTimeStep,&quot;Get timestep accoring to the velocity of P-Wave propagation; computed from sphere radii, rigidities and masses.&quot;);
 	def(&quot;aabbExtrema&quot;,aabbExtrema,aabbExtrema_overloads(args(&quot;cutoff&quot;,&quot;centers&quot;),&quot;Return coordinates of box enclosing all bodies\n centers: do not take sphere radii in account, only their centroids (default=False)\n cutoff: 0-1 number by which the box will be scaled around its center (default=0)&quot;));
+	def(&quot;ptInAABB&quot;,ptInAABB,&quot;Return True/False whether the point (3-tuple) p is within box given by its min (3-tuple) and max (3-tuple) corners&quot;);
 	def(&quot;negPosExtremeIds&quot;,negPosExtremeIds,negPosExtremeIds_overloads(args(&quot;axis&quot;,&quot;distFactor&quot;),&quot;Return list of ids for spheres (only) that are on extremal ends of the specimen along given axis; distFactor multiplies their radius so that sphere that do not touch the boundary coordinate can also be returned.&quot;));
 	def(&quot;coordsAndDisplacements&quot;,coordsAndDisplacements,coordsAndDisplacements_overloads(args(&quot;AABB&quot;),&quot;Return tuple of 2 same-length lists for coordinates and displacements (coordinate minus reference coordinate) along given axis (1st arg); if the AABB=((x_min,y_min,z_min),(x_max,y_max,z_max)) box is given, only bodies within this box will be considered.&quot;));
 	def(&quot;setRefSe3&quot;,setRefSe3,&quot;Set reference positions and orientation of all bodies equal to their current ones.&quot;);

Modified: trunk/gui/py/utils.py
===================================================================
--- trunk/gui/py/utils.py	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/gui/py/utils.py	2009-05-29 14:35:22 UTC (rev 1786)
@@ -224,13 +224,18 @@
 
 def spheresToFile(filename,consider=lambda id: True):
 	&quot;&quot;&quot;Save sphere coordinates into ASCII file; the format of the line is: x y z r.
-	Non-spherical bodies are silently skipped.&quot;&quot;&quot;
+	Non-spherical bodies are silently skipped.
+	
+	Returns number of spheres that were written.&quot;&quot;&quot;
 	o=Omega()
 	out=open(filename,'w')
+	count=0
 	for b in o.bodies:
 		if not b.shape or not b.shape.name=='Sphere' or not consider(b.id): continue
 		out.write('%g\t%g\t%g\t%g\n'%(b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius']))
+		count+=1
 	out.close()
+	return count
 
 def avgNumInteractions(cutoff=0.):
 	nums,counts=bodyNumInteractionsHistogram(aabbExtrema(cutoff))

Modified: trunk/gui/py/yadeControl.cpp
===================================================================
--- trunk/gui/py/yadeControl.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/gui/py/yadeControl.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -408,12 +408,12 @@
 		}
 		/* return nth _real_ iteration from the container (0-based index); this is to facilitate picking random interaction */
 		pyInteraction pyNth(long n){
-			long i=0; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(!I-&gt;isReal) continue; if(i++==n) return pyInteraction(I); }
+			long i=0; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(!I-&gt;isReal()) continue; if(i++==n) return pyInteraction(I); }
 			throw invalid_argument(string(&quot;Interaction number out of range (&quot;)+lexical_cast&lt;string&gt;(n)+&quot;&gt;=&quot;+lexical_cast&lt;string&gt;(i)+&quot;).&quot;);
 		}
 		long len(){return proxee-&gt;size();}
 		void clear(){proxee-&gt;clear();}
-		python::list withBody(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;isReal &amp;&amp; (I-&gt;getId1()==id || I-&gt;getId2()==id)) ret.append(pyInteraction(I));} return ret;}
+		python::list withBody(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;isReal() &amp;&amp; (I-&gt;getId1()==id || I-&gt;getId2()==id)) ret.append(pyInteraction(I));} return ret;}
 		python::list withBodyAll(long id){ python::list ret; FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *proxee){ if(I-&gt;getId1()==id || I-&gt;getId2()==id) ret.append(pyInteraction(I));} return ret; }
 };
 

Modified: trunk/lib/import/STLReader.hpp
===================================================================
--- trunk/lib/import/STLReader.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/lib/import/STLReader.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -106,19 +106,20 @@
     
     vector&lt;Vrtx&gt; vcs;
     set&lt;pair&lt;int,int&gt; &gt; egs;
+	 int ret;
 
     /* Read a single facet from an ASCII .STL file */
     while(!feof(fp))
     {
 	float n[3];
 	Vrtx v[3];
-	fscanf(fp, &quot;%*s %*s %f %f %f\n&quot;, &amp;n[0], &amp;n[1], &amp;n[2]);
-	fscanf(fp, &quot;%*s %*s&quot;);
-	fscanf(fp, &quot;%*s %f %f %f\n&quot;, &amp;v[0][0],  &amp;v[0][1],  &amp;v[0][2]);
-	fscanf(fp, &quot;%*s %f %f %f\n&quot;, &amp;v[1][0],  &amp;v[1][1],  &amp;v[1][2]);
-	fscanf(fp, &quot;%*s %f %f %f\n&quot;, &amp;v[2][0],  &amp;v[2][1],  &amp;v[2][2]);
-	fscanf(fp, &quot;%*s&quot;); // end loop
-	fscanf(fp, &quot;%*s&quot;); // end facet
+	ret=fscanf(fp, &quot;%*s %*s %f %f %f\n&quot;, &amp;n[0], &amp;n[1], &amp;n[2]);
+	ret=fscanf(fp, &quot;%*s %*s&quot;);
+	ret=fscanf(fp, &quot;%*s %f %f %f\n&quot;, &amp;v[0][0],  &amp;v[0][1],  &amp;v[0][2]);
+	ret=fscanf(fp, &quot;%*s %f %f %f\n&quot;, &amp;v[1][0],  &amp;v[1][1],  &amp;v[1][2]);
+	ret=fscanf(fp, &quot;%*s %f %f %f\n&quot;, &amp;v[2][0],  &amp;v[2][1],  &amp;v[2][2]);
+	ret=fscanf(fp, &quot;%*s&quot;); // end loop
+	ret=fscanf(fp, &quot;%*s&quot;); // end facet
 	if(feof(fp)) break;
 
 	int vid[3];

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemCNCEngine.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -281,7 +281,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			

Modified: trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/DeusExMachina/CinemKNCEngine.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -274,7 +274,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			

Modified: trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/DeusExMachina/TranslationEngine.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -16,7 +16,7 @@
 	Real dt=Omega::instance().getTimeStep();
 	const int sign = 1; // ?
 	FOREACH(body_id_t id,subscribedBodies){
-		assert(id&lt;bodies-&gt;size());
+		assert(id&lt;(body_id_t)bodies-&gt;size());
 		if(ParticleParameters* p = dynamic_cast&lt;ParticleParameters*&gt;((*bodies)[id]-&gt;physicalParameters.get())){
 			p-&gt;se3.position+=sign*dt*velocity*translationAxis;
 			p-&gt;velocity=sign*velocity*translationAxis;

Modified: trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/EngineUnit/ElasticBodySimpleRelationship.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -20,7 +20,7 @@
 	ElasticBodyParameters* s2 = static_cast&lt;ElasticBodyParameters*&gt;(b2.get());	
 
 	// the need to calculate this is only when the interaction is new
-	if( interaction-&gt;isNew)
+	if(!interaction-&gt;interactionPhysics)
 	{
 		boost::shared_ptr&lt;NormalInteraction&gt; sei(new NormalInteraction); // ElasticContactInteraction
 		// BUG?! kn is stiffness [N], young is modulus [N/m&#178;] !!

Modified: trunk/pkg/common/Engine/MetaEngine/ConstitutiveLawDispatcher.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/ConstitutiveLawDispatcher.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/MetaEngine/ConstitutiveLawDispatcher.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -11,9 +11,8 @@
 	#else
 		FOREACH(shared_ptr&lt;Interaction&gt; I, *rootBody-&gt;transientInteractions){
 	#endif
-		if(I-&gt;isReal){
-			assert(I-&gt;interactionGeometry);
-			assert(I-&gt;interactionPhysics);
+		if(I-&gt;isReal()){
+			assert(I-&gt;interactionGeometry); assert(I-&gt;interactionPhysics);
 			operator()(I-&gt;interactionGeometry,I-&gt;interactionPhysics,I.get(),rootBody);
 		}
 	}

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -1,16 +1,25 @@
 #include&quot;InteractionDispatchers.hpp&quot;
 
 YADE_PLUGIN(&quot;InteractionDispatchers&quot;);
+CREATE_LOGGER(InteractionDispatchers);
 
 InteractionDispatchers::InteractionDispatchers(){
 	geomDispatcher=shared_ptr&lt;InteractionGeometryMetaEngine&gt;(new InteractionGeometryMetaEngine);
 	physDispatcher=shared_ptr&lt;InteractionPhysicsMetaEngine&gt;(new InteractionPhysicsMetaEngine);
 	constLawDispatcher=shared_ptr&lt;ConstitutiveLawDispatcher&gt;(new ConstitutiveLawDispatcher);
+	alreadyWarnedNoCollider=false;
 }
 
 #define DISPATCH_CACHE
 
 void InteractionDispatchers::action(MetaBody* rootBody){
+	if(rootBody-&gt;interactions-&gt;pendingErase.size()&gt;0){
+		if(!alreadyWarnedNoCollider){
+			LOG_WARN(&quot;Interactions pending erase found, no collider being used?&quot;);
+			alreadyWarnedNoCollider=true;
+		}
+		rootBody-&gt;interactions-&gt;unconditionalErasePending();
+	}
 	#ifdef YADE_OPENMP
 		const long size=rootBody-&gt;interactions-&gt;size();
 		#pragma omp parallel for
@@ -24,9 +33,9 @@
 			const shared_ptr&lt;Body&gt;&amp; b2_=Body::byId(I-&gt;getId2(),rootBody);
 
 			// we know there is no geometry functor already, take the short path
-			if(!I-&gt;functorCache.geomExists) { I-&gt;isReal=false; continue; }
+			if(!I-&gt;functorCache.geomExists) { assert(!I-&gt;isReal()); continue; }
 			// no interaction geometry for either of bodies; no interaction possible
-			if(!b1_-&gt;interactingGeometry || !b2_-&gt;interactingGeometry) { I-&gt;isReal=false; continue; }
+			if(!b1_-&gt;interactingGeometry || !b2_-&gt;interactingGeometry) { assert(!I-&gt;isReal()); continue; }
 
 			bool swap=false;
 			// InteractionGeometryMetaEngine
@@ -44,8 +53,8 @@
 			const shared_ptr&lt;Body&gt;&amp; b2=Body::byId(I-&gt;getId2(),rootBody);
 
 			assert(I-&gt;functorCache.geom);
-			I-&gt;isReal=I-&gt;functorCache.geom-&gt;go(b1-&gt;interactingGeometry,b2-&gt;interactingGeometry,b1-&gt;physicalParameters-&gt;se3, b2-&gt;physicalParameters-&gt;se3,I);
-			if(!I-&gt;isReal) continue;
+			bool geomCreated=I-&gt;functorCache.geom-&gt;go(b1-&gt;interactingGeometry,b2-&gt;interactingGeometry,b1-&gt;physicalParameters-&gt;se3, b2-&gt;physicalParameters-&gt;se3,I);
+			if(!geomCreated) continue;
 
 			// InteractionPhysicsMetaEngine
 			if(!I-&gt;functorCache.phys){
@@ -54,7 +63,10 @@
 			}
 			assert(I-&gt;functorCache.phys);
 			I-&gt;functorCache.phys-&gt;go(b1-&gt;physicalParameters,b2-&gt;physicalParameters,I);
+			assert(I-&gt;interactionPhysics);
+			I-&gt;iterMadeReal=rootBody-&gt;currentIteration; // mark the interaction as created right now
 
+
 			// ConstitutiveLawDispatcher
 			// populating constLaw cache must be done after geom and physics dispatchers have been called, since otherwise the interaction
 			// would not have interactionGeometry and interactionPhysics yet.
@@ -64,15 +76,14 @@
 			}
 		  	assert(I-&gt;functorCache.constLaw);
 			I-&gt;functorCache.constLaw-&gt;go(I-&gt;interactionGeometry,I-&gt;interactionPhysics,I.get(),rootBody);
-
 		#else
 			const shared_ptr&lt;Body&gt;&amp; b1=Body::byId(I-&gt;getId1(),rootBody);
 			const shared_ptr&lt;Body&gt;&amp; b2=Body::byId(I-&gt;getId2(),rootBody);
 			// InteractionGeometryMetaEngine
-			I-&gt;isReal =
+			bool geomCreated =
 				b1-&gt;interactingGeometry &amp;&amp; b2-&gt;interactingGeometry &amp;&amp; // some bodies do not have interactingGeometry
 				geomDispatcher-&gt;operator()(b1-&gt;interactingGeometry, b2-&gt;interactingGeometry, b1-&gt;physicalParameters-&gt;se3, b2-&gt;physicalParameters-&gt;se3,I);
-			if(!I-&gt;isReal) continue;
+			if(!geomCreated) continue;
 			// InteractionPhysicsMetaEngine
 			// geom may have swapped bodies, get bodies again
 			physDispatcher-&gt;operator()(Body::byId(I-&gt;getId1(),rootBody)-&gt;physicalParameters, Body::byId(I-&gt;getId2(),rootBody)-&gt;physicalParameters,I);

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.hpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionDispatchers.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -6,6 +6,7 @@
 #include&lt;yade/pkg-common/ConstitutiveLawDispatcher.hpp&gt;
 
 class InteractionDispatchers: public StandAloneEngine {
+	bool alreadyWarnedNoCollider;
 	public:
 		InteractionDispatchers();
 		virtual void action(MetaBody*);
@@ -18,5 +19,6 @@
 			(physDispatcher)
 			(constLawDispatcher)
 		);
+		DECLARE_LOGGER;
 };
 REGISTER_SERIALIZABLE(InteractionDispatchers);

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -13,6 +13,8 @@
 
 #include&lt;yade/core/MetaBody.hpp&gt;
 	
+CREATE_LOGGER(InteractionGeometryMetaEngine);
+
 /* Single dispatch for given pair of bodies, returning new interaction.
  *
  * The caller is responsible for inserting the interaction into some interaction container.
@@ -27,21 +29,30 @@
 	//bool op=operator()(b1-&gt;interactingGeometry,b2-&gt;interactingGeometry,b1-&gt;physicalParameters-&gt;se3,b2-&gt;physicalParameters-&gt;se3,i);
 	//if(!op) throw runtime_error(&quot;InteractionGeometryMetaEngine::explicitAction could not dispatch for given types (&quot;+b1-&gt;interactingGeometry-&gt;getClassName()+&quot;,&quot;+b2-&gt;interactingGeometry-&gt;getClassName()+&quot;) or the dispatchee returned false.&quot;);
 	//return i;
+
+	// FIXME: not clear why it is not a good idea. If I really wnat interaction that I call this function, I also want it to say loudly that it failed.
 	
 	// Seems asserts and throws in code above is not good idea.
 	// Below code do same (i.e. create interaction for specified bodies), but
-	// without artifical exceptions. If creating interaction is fail (for
+	// without artifical exceptions. If creating interaction fails (for
 	// example if bodies don't have an interactionGeometry), returned
 	// interaction is non real, i.e. interaction-&gt;isReal==false. Sega.
 	shared_ptr&lt;Interaction&gt; interaction(new Interaction(b1-&gt;getId(),b2-&gt;getId()));
-	interaction-&gt;isReal =
-		b1-&gt;interactingGeometry &amp;&amp; b2-&gt;interactingGeometry &amp;&amp; 
-		operator()( b1-&gt;interactingGeometry , b2-&gt;interactingGeometry , b1-&gt;physicalParameters-&gt;se3 , b2-&gt;physicalParameters-&gt;se3 , interaction );
+	b1-&gt;interactingGeometry &amp;&amp; b2-&gt;interactingGeometry &amp;&amp; operator()( b1-&gt;interactingGeometry , b2-&gt;interactingGeometry , b1-&gt;physicalParameters-&gt;se3 , b2-&gt;physicalParameters-&gt;se3 , interaction );
 	return interaction;
 }
 
 void InteractionGeometryMetaEngine::action(MetaBody* ncb)
 {
+	// Erase interaction that were requested for erase, but not processed by the collider, if any (and warn once about that, as it is suspicious)
+	if(ncb-&gt;interactions-&gt;pendingErase.size()&gt;0){
+		if(!alreadyWarnedNoCollider){
+			LOG_WARN(&quot;Interactions pending erase found, no collider being used?&quot;);
+			alreadyWarnedNoCollider=true;
+		}
+		ncb-&gt;interactions-&gt;unconditionalErasePending();
+	}
+
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
 	#ifdef YADE_OPENMP
 		const long size=ncb-&gt;transientInteractions-&gt;size();
@@ -53,9 +64,8 @@
 	#endif
 			const shared_ptr&lt;Body&gt;&amp; b1=(*bodies)[interaction-&gt;getId1()];
 			const shared_ptr&lt;Body&gt;&amp; b2=(*bodies)[interaction-&gt;getId2()];
-			interaction-&gt;isReal =
-				b1-&gt;interactingGeometry &amp;&amp; b2-&gt;interactingGeometry &amp;&amp; // some bodies do not have interactingGeometry
-				operator()(b1-&gt;interactingGeometry, b2-&gt;interactingGeometry, b1-&gt;physicalParameters-&gt;se3, b2-&gt;physicalParameters-&gt;se3, interaction);
+			b1-&gt;interactingGeometry &amp;&amp; b2-&gt;interactingGeometry &amp;&amp; // some bodies do not have interactingGeometry
+			operator()(b1-&gt;interactingGeometry, b2-&gt;interactingGeometry, b1-&gt;physicalParameters-&gt;se3, b2-&gt;physicalParameters-&gt;se3, interaction);
 	}
 }
 

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -34,13 +34,15 @@
 						, false								// disable auto symmetry handling
 					&gt;
 {
+	bool alreadyWarnedNoCollider;
 	public :
 		virtual void action(MetaBody*);
 		shared_ptr&lt;Interaction&gt; explicitAction(const shared_ptr&lt;Body&gt;&amp; b1, const shared_ptr&lt;Body&gt;&amp; b2);
+		InteractionGeometryMetaEngine(): alreadyWarnedNoCollider(false){}
 
-	REGISTER_CLASS_NAME(InteractionGeometryMetaEngine);
-	REGISTER_BASE_CLASS_NAME(MetaEngine2D);
+	REGISTER_CLASS_AND_BASE(InteractionGeometryMetaEngine,MetaEngine2D);
 	REGISTER_ATTRIBUTES(MetaEngine,/* no attributes here*/ );
+	DECLARE_LOGGER;
 };
 
 REGISTER_SERIALIZABLE(InteractionGeometryMetaEngine);

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionPhysicsMetaEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionPhysicsMetaEngine.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionPhysicsMetaEngine.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -16,7 +16,7 @@
  */
 void InteractionPhysicsMetaEngine::explicitAction(shared_ptr&lt;PhysicalParameters&gt;&amp; pp1, shared_ptr&lt;PhysicalParameters&gt;&amp; pp2, shared_ptr&lt;Interaction&gt;&amp; i){
 	// should we throw instead of asserting?
-	assert(i-&gt;isReal);
+	assert(i-&gt;isReal());
 	operator()(pp1,pp2,i);
 }
 
@@ -32,10 +32,13 @@
 	#else
 		FOREACH(const shared_ptr&lt;Interaction&gt;&amp; interaction, *ncb-&gt;interactions){
 	#endif
-			shared_ptr&lt;Body&gt;&amp; b1 = (*bodies)[interaction-&gt;getId1()];
-			shared_ptr&lt;Body&gt;&amp; b2 = (*bodies)[interaction-&gt;getId2()];
-			if (interaction-&gt;isReal)
+			if(interaction-&gt;interactionGeometry){
+				shared_ptr&lt;Body&gt;&amp; b1 = (*bodies)[interaction-&gt;getId1()];
+				shared_ptr&lt;Body&gt;&amp; b2 = (*bodies)[interaction-&gt;getId2()];
 				operator()(b1-&gt;physicalParameters, b2-&gt;physicalParameters, interaction);
+				assert(interaction-&gt;interactionPhysics);
+				interaction-&gt;iterMadeReal=ncb-&gt;currentIteration;
+			}
 		}
 }
 

Modified: trunk/pkg/common/Engine/StandAloneEngine/DistantPersistentSAPCollider.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/DistantPersistentSAPCollider.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/DistantPersistentSAPCollider.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -85,9 +85,8 @@
 	for( ; ii!=iiEnd ; ++ii)
 	{
 		shared_ptr&lt;Interaction&gt; interaction = *ii;
-		// FIXME : remove this isNew flag and test if interactionPhysic ?
-		if (interaction-&gt;isReal) // if a interaction was only potential then no geometry was created for it and so this time it is still a new one
-			interaction-&gt;isNew = false;
+		//if (interaction-&gt;isReal()) // if a interaction was only potential then no geometry was created for it and so this time it is still a new one
+			// interaction-&gt;isNew = false;
 		//interaction-&gt;isReal = false;
 	}
 	
@@ -200,7 +199,7 @@
 	if (overlap &amp;&amp; !found)
 		transientInteractions-&gt;insert(body_id_t(id1),body_id_t(id2));
 	// removes the pair p=(id1,id2) if the two AABB do not overlapp any more and if p already exists in the overlappingBB
-	else if (!overlap &amp;&amp; found &amp;&amp; !interaction-&gt;isReal)
+	else if (!overlap &amp;&amp; found &amp;&amp; !interaction-&gt;isReal())
 		transientInteractions-&gt;erase(body_id_t(id1),body_id_t(id2));//Bruno's hack
 //else if (!overlap &amp;&amp; found)
 //		transientInteractions-&gt;erase(body_id_t(id1),body_id_t(id2));

Modified: trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -16,11 +16,11 @@
 CREATE_LOGGER(InsertionSortCollider);
 
 // return true if bodies bb overlap in all 3 dimensions
-bool InsertionSortCollider::spatialOverlap(body_id_t id1, body_id_t id2){
+bool InsertionSortCollider::spatialOverlap(body_id_t id1, body_id_t id2) const {
 	return
-		(minima[3*id1+0]&lt;maxima[3*id2+0]) &amp;&amp; (maxima[3*id1+0]&gt;minima[3*id2+0]) &amp;&amp;
-		(minima[3*id1+1]&lt;maxima[3*id2+1]) &amp;&amp; (maxima[3*id1+1]&gt;minima[3*id2+1]) &amp;&amp;
-		(minima[3*id1+2]&lt;maxima[3*id2+2]) &amp;&amp; (maxima[3*id1+2]&gt;minima[3*id2+2]);
+		(minima[3*id1+0]&lt;=maxima[3*id2+0]) &amp;&amp; (maxima[3*id1+0]&gt;=minima[3*id2+0]) &amp;&amp;
+		(minima[3*id1+1]&lt;=maxima[3*id2+1]) &amp;&amp; (maxima[3*id1+1]&gt;=minima[3*id2+1]) &amp;&amp;
+		(minima[3*id1+2]&lt;=maxima[3*id2+2]) &amp;&amp; (maxima[3*id1+2]&gt;=minima[3*id2+2]);
 }
 
 // called by the insertion sort if 2 bodies swapped their bounds
@@ -32,16 +32,16 @@
 	bool hasInter=(bool)I;
 	// interaction doesn't exist and shouldn't, or it exists and should
 	if(!overlap &amp;&amp; !hasInter) return;
-	if(overlap &amp;&amp; hasInter){ /* FIXME: should check I-&gt;isNew and I-&gt;isReal; etc */ return; }
+	if(overlap &amp;&amp; hasInter){  return; }
 	// create interaction if not yet existing
 	if(overlap &amp;&amp; !hasInter){ // second condition only for readability
 		if(!Collider::mayCollide(Body::byId(id1,rb).get(),Body::byId(id2,rb).get())) return;
-		LOG_TRACE(&quot;Creating new interaction #&quot;&lt;&lt;id1&lt;&lt;&quot;+#&quot;&lt;&lt;id2);
+		// LOG_TRACE(&quot;Creating new interaction #&quot;&lt;&lt;id1&lt;&lt;&quot;+#&quot;&lt;&lt;id2);
 		shared_ptr&lt;Interaction&gt; newI=shared_ptr&lt;Interaction&gt;(new Interaction(id1,id2));
 		interactions-&gt;insert(newI);
 		return;
 	}
-	if(!overlap &amp;&amp; hasInter){ if(!I-&gt;isReal &amp;&amp; I-&gt;isNew) interactions-&gt;erase(id1,id2); return; }
+	if(!overlap &amp;&amp; hasInter){ if(!I-&gt;isReal()) interactions-&gt;erase(id1,id2); return; }
 	assert(false); // unreachable
 }
 
@@ -110,6 +110,8 @@
 	//timingDeltas-&gt;checkpoint(&quot;copy&quot;);
 
 	// process interactions that the constitutive law asked to be erased
+	interactions-&gt;erasePending(*this);
+	#if 0
 	FOREACH(const InteractionContainer::bodyIdPair&amp; p, interactions-&gt;pendingErase){
 		// remove those that do not overlap spatially anymore
 		if(!spatialOverlap(p[0],p[1])){ interactions-&gt;erase(p[0],p[1]); LOG_TRACE(&quot;Deleted interaction #&quot;&lt;&lt;p[0]&lt;&lt;&quot;+#&quot;&lt;&lt;p[1]); }
@@ -121,6 +123,7 @@
 		}
 	}
 	interactions-&gt;pendingErase.clear();
+	#endif
 	
 
 	// sort
@@ -130,7 +133,16 @@
 		}
 		else {
 			if(doInitSort){
-				std::sort(XX.begin(),XX.end()); std::sort(YY.begin(),YY.end()); std::sort(ZZ.begin(),ZZ.end());
+				// the initial sort is in independent in 3 dimensions, may be run in parallel
+				#pragma omp parallel sections
+				{
+					#pragma omp section
+						std::sort(XX.begin(),XX.end());
+					#pragma omp section	
+						std::sort(YY.begin(),YY.end());
+					#pragma omp section
+						std::sort(ZZ.begin(),ZZ.end());
+				}
 			} else {
 				insertionSort(XX,interactions,rb,false); insertionSort(YY,interactions,rb,false); insertionSort(ZZ,interactions,rb,false);
 			}
@@ -156,18 +168,4 @@
 			}
 		}
 	//timingDeltas-&gt;checkpoint(&quot;sort&amp;collide&quot;);
-	
-#if 0
-	// garbage collection once in a while: for interactions that were still real when the bounding boxes separated
-	// the collider would never get to see them again otherwise
-	if(iter%1000==0){
-		typedef pair&lt;body_id_t,body_id_t&gt; bodyIdPair;
-		list&lt;bodyIdPair&gt; toBeDeleted;
-		FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I,*interactions){
-			if(!I-&gt;isReal &amp;&amp; (!I-&gt;isNew || !spatialOverlap(I-&gt;getId1(),I-&gt;getId2()))) toBeDeleted.push_back(bodyIdPair(I-&gt;getId1(),I-&gt;getId2()));
-		}
-		FOREACH(const bodyIdPair&amp; p, toBeDeleted){ interactions-&gt;erase(p.first,p.second); LOG_TRACE(&quot;Deleted interaction #&quot;&lt;&lt;p.first&lt;&lt;&quot;+#&quot;&lt;&lt;p.second); }
-	}
-	//timingDeltas-&gt;checkpoint(&quot;stale&quot;);
-#endif
 }

Modified: trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/InsertionSortCollider.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -9,7 +9,7 @@
 
 	Insertion sort is used for sorting the bound list that is already pre-sorted from last iteration, where each inversion
 	calls checkOverlap which then handles either overlap (by creating interaction if necessary) or its absence (by deleting
-	interaction if it exists and is only potential (!isReal &amp;&amp; isNew).
+	interaction if it is only potential).
 
 	Bodies without bounding volume are ahndle gracefully and never collide.
 
@@ -41,13 +41,16 @@
 	*/
 	void insertionSort(std::vector&lt;Bound&gt;&amp; v,InteractionContainer*,MetaBody*,bool doCollide=true);
 	void handleBoundInversion(body_id_t,body_id_t,InteractionContainer*,MetaBody*);
-	bool spatialOverlap(body_id_t,body_id_t);
+	bool spatialOverlap(body_id_t,body_id_t) const;
 
 	public:
 	//! axis for the initial sort
 	int sortAxis;
 	//! if true, separate sorting and colliding phase; MUCH slower, but processes all interactions at every step
+	// This makes the collider non-persistent, not remembering last state
 	bool sortThenCollide;
+	//! Predicate called from loop within InteractionContainer::erasePending
+	bool shouldBeErased(body_id_t id1, body_id_t id2) const { return !spatialOverlap(id1,id2); }
 
 	InsertionSortCollider(): sortAxis(0), sortThenCollide(false){ /* timingDeltas=shared_ptr&lt;TimingDeltas&gt;(new TimingDeltas);*/ }
 	virtual void action(MetaBody*);

Modified: trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -36,6 +36,8 @@
 
 }
 
+// template void InteractionContainer::erasePending&lt;PersistentSAPCollider&gt;(const PersistentSAPCollider&amp;);
+
 void PersistentSAPCollider::action(MetaBody* ncb)
 {
 	rootBody=ncb;
@@ -80,25 +82,7 @@
 
 //	timingDeltas-&gt;checkpoint(&quot;minMaxUpdate&quot;);
 
-	typedef pair&lt;body_id_t,body_id_t&gt; bodyIdPair;
-	list&lt;bodyIdPair&gt; toBeDeleted;
-	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I,*ncb-&gt;transientInteractions){
-		// TODO: this logic will be unitedly in Collider::handleExistingInteraction
-		//
-		// remove interactions deleted by the constitutive law: thay are not new, but nor real either
-		// to make sure, do that only with haveDistantTransient
-		if(haveDistantTransient &amp;&amp; !I-&gt;isNew &amp;&amp; !I-&gt;isReal) { toBeDeleted.push_back(bodyIdPair(I-&gt;getId1(),I-&gt;getId2())); continue; }
-		// Once the interaction has been fully created, it is not &quot;new&quot; anymore
-		if (I-&gt;isReal) I-&gt;isNew=false;
-		// OTOH if is is now real anymore, it falls back to the potential state
-		if(!haveDistantTransient &amp;&amp; !I-&gt;isReal) I-&gt;isNew=true;
-		// for non-distant interactions, isReal depends on whether there is geometrical overlap; that is calculated later
-		// for distant: if isReal&amp;&amp;!isNew means:
-		// 	the interaction was marked (by the constitutive law) as not real anymore should be deleted
-		if(!haveDistantTransient) I-&gt;isReal=false;
-		//if(!I-&gt;isReal){LOG_DEBUG(&quot;Interaction #&quot;&lt;&lt;I-&gt;getId1()&lt;&lt;&quot;=#&quot;&lt;&lt;I-&gt;getId2()&lt;&lt;&quot; is not real.&quot;);}
-	}
-	FOREACH(const bodyIdPair&amp; p, toBeDeleted){ transientInteractions-&gt;erase(p.first,p.second); }
+	ncb-&gt;interactions-&gt;erasePending(*this);
 
 //	timingDeltas-&gt;checkpoint(&quot;deleteInvalid&quot;);
 	
@@ -236,6 +220,16 @@
 	}
 }
 
+
+bool PersistentSAPCollider::shouldBeErased(body_id_t id1, body_id_t id2) const {
+	// if there is no bbox overlap
+	int offset1=3*id1, offset2=3*id2;
+	return (
+		maxima[offset1  ]&lt;minima[offset2  ] || maxima[offset2  ]&lt;minima[offset1  ] || 
+		maxima[offset1+1]&lt;minima[offset2+1] || maxima[offset2+1]&lt;minima[offset1+1] || 
+		maxima[offset1+2]&lt;minima[offset2+2] || maxima[offset2+2]&lt;minima[offset1+2] );
+}
+
 /* Note that this function is called only for bodies that actually overlap along some axis */
 void PersistentSAPCollider::updateOverlapingBBSet(int id1,int id2){
 		// look if the pair (id1,id2) already exists in the overlappingBB collection
@@ -260,7 +254,7 @@
 			transientInteractions-&gt;insert(body_id_t(id1),body_id_t(id2));
 		}
 		// removes the pair p=(id1,id2) if the two AABB do not overlapp any more and if p already exists in the overlappingBB
-		else if(!overlap &amp;&amp; found &amp;&amp; (haveDistantTransient ? !interaction-&gt;isReal : true) ){
+		else if(!overlap &amp;&amp; found &amp;&amp; (haveDistantTransient ? !interaction-&gt;isReal() : true) ){
 			//LOG_DEBUG(&quot;Erasing interaction #&quot;&lt;&lt;id1&lt;&lt;&quot;=#&quot;&lt;&lt;id2&lt;&lt;&quot; (isReal=&quot;&lt;&lt;interaction-&gt;isReal&lt;&lt;&quot;)&quot;);
 			transientInteractions-&gt;erase(body_id_t(id1),body_id_t(id2));
 		}

Modified: trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/PersistentSAPCollider.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -99,8 +99,7 @@
 		//! Don't break transient interaction once bodies don't overlap anymore; material law will be responsible for breaking it.
 		bool haveDistantTransient;
 
-		//! minimum number of bodies to run updateIds in parallel secions; if 0 (default for now), never run in parallel
-		//long ompBodiesMin;
+		bool shouldBeErased(body_id_t, body_id_t) const;
 
 		void registerAttributes(){
 			Collider::registerAttributes();

Modified: trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/PersistentTriangulationCollider.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -97,9 +97,9 @@
 	InteractionContainer::iterator I_end = transientInteractions-&gt;end();
 	for ( InteractionContainer::iterator I=transientInteractions-&gt;begin(); I!=I_end; ++I )
 	{
-
-		if ( ( *I )-&gt;isReal ) ( *I )-&gt;isNew=false;
-		if ( !haveDistantTransient ) ( *I )-&gt;isReal=false; // reset this flag, is used later... (??)
+		// FIXME: eudoxos commented out as isReal and isNew is removed...
+		//  if ( ( *I )-&gt;isReal ) ( *I )-&gt;isNew=false;
+		//  if ( !haveDistantTransient ) ( *I )-&gt;isReal=false; // reset this flag, is used later... (??)
 		( *I )-&gt;isNeighbor = false;// will be set again just below
 	}
 
@@ -132,7 +132,7 @@
 		I_end = transientInteractions-&gt;end();
 		for ( InteractionContainer::iterator I=transientInteractions-&gt;begin(); I!=I_end; ++I )
 		{
-			if ( ( ! ( *I )-&gt;isNeighbor ) &amp;&amp; ( haveDistantTransient ? ! ( *I )-&gt;isReal : true ) )
+			if ( ( ! ( *I )-&gt;isNeighbor ) &amp;&amp; ( haveDistantTransient ? ! ( *I )-&gt;isReal() : true ) )
 			{
 				toErase.push_back ( pair&lt;unsigned int,unsigned int&gt; ( ( *I )-&gt;getId1() , ( *I )-&gt;getId2() ) );
 				//cerr &lt;&lt; &quot;to delete &quot; &lt;&lt; ( *I )-&gt;getId1() &lt;&lt; &quot;-&quot; &lt;&lt; ( *I )-&gt;getId2() &lt;&lt; &quot;(isNeighbor=&quot; &lt;&lt; ( *I )-&gt;isNeighbor&lt;&lt; endl;

Modified: trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/SpatialQuickSortCollider.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -92,7 +92,8 @@
 				}
 				interaction-&gt;cycle=true; 
 				// if interaction !isReal it falls back to the potential state
-				if (!haveDistantTransient &amp;&amp; !interaction-&gt;isReal) interaction-&gt;isNew=true;
+				// FIXME: eudoxos: do nothing here... is that correct?
+				// if (!haveDistantTransient &amp;&amp; !interaction-&gt;isReal()) interaction-&gt;isNew=true;
 			}
 	    }
 	}
@@ -104,18 +105,13 @@
 		interaction = *ii;
 		if( 
 			// if haveDistantTransient remove interactions deleted by the constitutive law
-				(haveDistantTransient &amp;&amp; !interaction-&gt;isNew &amp;&amp; !interaction-&gt;isReal)
+				(haveDistantTransient &amp;&amp; !interaction-&gt;isReal())
 			// if !haveDistantTransient remove interactions without AABB overlapping
 				|| (!haveDistantTransient &amp;&amp; !interaction-&gt;cycle) 
 		) { 
 			transientInteractions-&gt;erase( interaction-&gt;getId1(), interaction-&gt;getId2() ); 
 			continue; 
 		}
-		// Once the interaction has been fully created, it is not &quot;new&quot; anymore
-		if(interaction-&gt;isReal) interaction-&gt;isNew=false;
-		// For non-distant interactions reset isReal (it would be calculated later);
-		// for distant interactions isReal is set/unset by constitutive law
-		if(!haveDistantTransient) interaction-&gt;isReal=false;
 	}
 
 }

Modified: trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp
===================================================================
--- trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/common/Engine/StandAloneEngine/SpheresFactory.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -92,7 +92,7 @@
 			bool is_overlap=false;
 			for( unsigned int i=0, e=bI-&gt;probedBodies.size(); i&lt;e; ++i)
 			{
-				if (iGME-&gt;explicitAction(sphere,Body::byId(bI-&gt;probedBodies[i]))-&gt;isReal)
+				if (iGME-&gt;explicitAction(sphere,Body::byId(bI-&gt;probedBodies[i]))-&gt;interactionGeometry)
 				{
 					is_overlap=true;
 					break;

Modified: trunk/pkg/dem/ConcretePM.cpp
===================================================================
--- trunk/pkg/dem/ConcretePM.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/ConcretePM.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -16,51 +16,46 @@
 CREATE_LOGGER(Ip2_CpmMat_CpmMat_CpmPhys);
 
 void Ip2_CpmMat_CpmMat_CpmPhys::go(const shared_ptr&lt;PhysicalParameters&gt;&amp; pp1, const shared_ptr&lt;PhysicalParameters&gt;&amp; pp2, const shared_ptr&lt;Interaction&gt;&amp; interaction){
+	if(interaction-&gt;interactionPhysics) return; 
+
 	Dem3DofGeom* contGeom=YADE_CAST&lt;Dem3DofGeom*&gt;(interaction-&gt;interactionGeometry.get());
+	assert(contGeom);
 
-	assert(contGeom); // for now, don't handle anything other than SpheresContactGeometry and Dem3DofGeom
+	const shared_ptr&lt;BodyMacroParameters&gt;&amp; elast1=static_pointer_cast&lt;BodyMacroParameters&gt;(pp1);
+	const shared_ptr&lt;BodyMacroParameters&gt;&amp; elast2=static_pointer_cast&lt;BodyMacroParameters&gt;(pp2);
 
-	if(!interaction-&gt;isNew &amp;&amp; interaction-&gt;interactionPhysics){ /* relax */ } 
-	else {
-		interaction-&gt;isNew=false; // just in case
+	Real E12=2*elast1-&gt;young*elast2-&gt;young/(elast1-&gt;young+elast2-&gt;young); // harmonic Young's modulus average
+	//Real nu12=2*elast1-&gt;poisson*elast2-&gt;poisson/(elast1-&gt;poisson+elast2-&gt;poisson); // dtto for Poisson ratio 
+	Real minRad=(contGeom-&gt;refR1&lt;=0?contGeom-&gt;refR2:(contGeom-&gt;refR2&lt;=0?contGeom-&gt;refR1:min(contGeom-&gt;refR1,contGeom-&gt;refR2)));
+	Real S12=Mathr::PI*pow(minRad,2); // &quot;surface&quot; of interaction
+	//Real E=(E12 /* was here for Kn:  *S12/d0  */)*((1+alpha)/(beta*(1+nu12)+gamma*(1-alpha*nu12)));
+	//Real E=E12; // apply alpha, beta, gamma: garbage values of E !?
 
-		const shared_ptr&lt;BodyMacroParameters&gt;&amp; elast1=static_pointer_cast&lt;BodyMacroParameters&gt;(pp1);
-		const shared_ptr&lt;BodyMacroParameters&gt;&amp; elast2=static_pointer_cast&lt;BodyMacroParameters&gt;(pp2);
+	if(!neverDamage) { assert(!isnan(sigmaT)); }
 
-		Real E12=2*elast1-&gt;young*elast2-&gt;young/(elast1-&gt;young+elast2-&gt;young); // harmonic Young's modulus average
-		//Real nu12=2*elast1-&gt;poisson*elast2-&gt;poisson/(elast1-&gt;poisson+elast2-&gt;poisson); // dtto for Poisson ratio 
-		Real minRad=(contGeom-&gt;refR1&lt;=0?contGeom-&gt;refR2:(contGeom-&gt;refR2&lt;=0?contGeom-&gt;refR1:min(contGeom-&gt;refR1,contGeom-&gt;refR2)));
-		Real S12=Mathr::PI*pow(minRad,2); // &quot;surface&quot; of interaction
-		//Real E=(E12 /* was here for Kn:  *S12/d0  */)*((1+alpha)/(beta*(1+nu12)+gamma*(1-alpha*nu12)));
-		//Real E=E12; // apply alpha, beta, gamma: garbage values of E !?
+	shared_ptr&lt;CpmPhys&gt; contPhys(new CpmPhys());
 
-		if(!neverDamage) { assert(!isnan(sigmaT)); }
+	contPhys-&gt;E=E12;
+	contPhys-&gt;G=E12*G_over_E;
+	contPhys-&gt;tanFrictionAngle=tan(.5*(elast1-&gt;frictionAngle+elast2-&gt;frictionAngle));
+	contPhys-&gt;undamagedCohesion=sigmaT;
+	contPhys-&gt;crossSection=S12;
+	contPhys-&gt;epsCrackOnset=epsCrackOnset;
+	contPhys-&gt;epsFracture=relDuctility*epsCrackOnset;
+	// inherited from NormalShearInteracion, used in the timestepper
+	contPhys-&gt;kn=contPhys-&gt;E*contPhys-&gt;crossSection;
+	contPhys-&gt;ks=contPhys-&gt;G*contPhys-&gt;crossSection;
 
-		shared_ptr&lt;CpmPhys&gt; contPhys(new CpmPhys());
+	if(neverDamage) contPhys-&gt;neverDamage=true;
+	if(cohesiveThresholdIter&lt;0 || Omega::instance().getCurrentIteration()&lt;cohesiveThresholdIter) contPhys-&gt;isCohesive=true;
+	else contPhys-&gt;isCohesive=false;
+	contPhys-&gt;dmgTau=dmgTau;
+	contPhys-&gt;dmgRateExp=dmgRateExp;
+	contPhys-&gt;plTau=plTau;
+	contPhys-&gt;plRateExp=plRateExp;
+	contPhys-&gt;isoPrestress=isoPrestress;
 
-		contPhys-&gt;E=E12;
-		contPhys-&gt;G=E12*G_over_E;
-		contPhys-&gt;tanFrictionAngle=tan(.5*(elast1-&gt;frictionAngle+elast2-&gt;frictionAngle));
-		contPhys-&gt;undamagedCohesion=sigmaT;
-		contPhys-&gt;crossSection=S12;
-		contPhys-&gt;epsCrackOnset=epsCrackOnset;
-		contPhys-&gt;epsFracture=relDuctility*epsCrackOnset;
-		contPhys-&gt;omegaThreshold=omegaThreshold;
-		// inherited from NormalShearInteracion, used in the timestepper
-		contPhys-&gt;kn=contPhys-&gt;E*contPhys-&gt;crossSection;
-		contPhys-&gt;ks=contPhys-&gt;G*contPhys-&gt;crossSection;
-
-		if(neverDamage) contPhys-&gt;neverDamage=true;
-		if(cohesiveThresholdIter&lt;0 || Omega::instance().getCurrentIteration()&lt;cohesiveThresholdIter) contPhys-&gt;isCohesive=true;
-		else contPhys-&gt;isCohesive=false;
-		contPhys-&gt;dmgTau=dmgTau;
-		contPhys-&gt;dmgRateExp=dmgRateExp;
-		contPhys-&gt;plTau=plTau;
-		contPhys-&gt;plRateExp=plRateExp;
-		contPhys-&gt;isoPrestress=isoPrestress;
-
-		interaction-&gt;interactionPhysics=contPhys;
-	}
+	interaction-&gt;interactionPhysics=contPhys;
 }
 
 
@@ -127,21 +122,15 @@
 Real Law2_Dem3DofGeom_CpmPhys_Cpm::minStrain_moveBody2=1.; /* deactivated if &gt; 0 */
 Real Law2_Dem3DofGeom_CpmPhys_Cpm::yieldLogSpeed=1.;
 Real Law2_Dem3DofGeom_CpmPhys_Cpm::yieldEllipseShift=0.;
+Real Law2_Dem3DofGeom_CpmPhys_Cpm::omegaThreshold=0.;
 
 void Law2_Dem3DofGeom_CpmPhys_Cpm::go(shared_ptr&lt;InteractionGeometry&gt;&amp; _geom, shared_ptr&lt;InteractionPhysics&gt;&amp; _phys, Interaction* I, MetaBody* rootBody){
 	//timingDeltas-&gt;start();
 	Dem3DofGeom* contGeom=static_cast&lt;Dem3DofGeom*&gt;(_geom.get());
 	CpmPhys* BC=static_cast&lt;CpmPhys*&gt;(_phys.get());
 
-	/* kept fully damaged contacts; note that normally the contact is deleted _after_ the CPM_MATERIAL_MODEL,
-	 * i.e. if it is 1.0 here, omegaThreshold is &gt;= 1.0 for sure.
-	 * &amp;&amp;'ing that just to make sure anyway ...
-	 */
-	// if(BC-&gt;omega&gt;=1.0 &amp;&amp; BC-&gt;omegaThreshold&gt;=1.0) return;
-
 	// shorthands
-	Real&amp; epsN(BC-&gt;epsN); Vector3r&amp; epsT(BC-&gt;epsT); Real&amp; kappaD(BC-&gt;kappaD); Real&amp; epsPlSum(BC-&gt;epsPlSum); const Real&amp; E(BC-&gt;E); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; tanFrictionAngle(BC-&gt;tanFrictionAngle); const Real&amp; G(BC-&gt;G); const Real&amp; crossSection(BC-&gt;crossSection); const Real&amp; omegaThreshold(BC-&gt;omegaThreshold); const Real&amp; epsCrackOnset(BC-&gt;epsCrackOnset); Real&amp; relResidualStrength(BC-&gt;relResidualStrength); const Real&amp; dt=Omega::instance().getTimeStep();  const Real&amp; epsFracture(BC-&gt;epsFracture); const bool&amp; neverDamage(BC-&gt;neverDamage); const Real&amp; dmgTau(BC-&gt;dmgTau); const Real&amp; plTau(BC-&gt;plTau); const bool&amp; isCohesive(BC-&gt;isCohesive);
-	/* const Real&amp; transStrainCoeff(BC-&gt;transStrainCoeff); const Real&amp; epsTrans(BC-&gt;epsTrans); const Real&amp; xiShear(BC-&gt;xiShear); */
+	Real&amp; epsN(BC-&gt;epsN); Vector3r&amp; epsT(BC-&gt;epsT); Real&amp; kappaD(BC-&gt;kappaD); Real&amp; epsPlSum(BC-&gt;epsPlSum); const Real&amp; E(BC-&gt;E); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; tanFrictionAngle(BC-&gt;tanFrictionAngle); const Real&amp; G(BC-&gt;G); const Real&amp; crossSection(BC-&gt;crossSection); const Real&amp; omegaThreshold(Law2_Dem3DofGeom_CpmPhys_Cpm::omegaThreshold); const Real&amp; epsCrackOnset(BC-&gt;epsCrackOnset); Real&amp; relResidualStrength(BC-&gt;relResidualStrength); const Real&amp; dt=Omega::instance().getTimeStep();  const Real&amp; epsFracture(BC-&gt;epsFracture); const bool&amp; neverDamage(BC-&gt;neverDamage); const Real&amp; dmgTau(BC-&gt;dmgTau); const Real&amp; plTau(BC-&gt;plTau); const bool&amp; isCohesive(BC-&gt;isCohesive);
 	Real&amp; omega(BC-&gt;omega); Real&amp; sigmaN(BC-&gt;sigmaN);  Vector3r&amp; sigmaT(BC-&gt;sigmaT); Real&amp; Fn(BC-&gt;Fn); Vector3r&amp; Fs(BC-&gt;Fs); // for python access
 	const Real&amp; yieldLogSpeed(Law2_Dem3DofGeom_CpmPhys_Cpm::yieldLogSpeed); const int&amp; yieldSurfType(Law2_Dem3DofGeom_CpmPhys_Cpm::yieldSurfType);
 	const Real&amp; yieldEllipseShift(Law2_Dem3DofGeom_CpmPhys_Cpm::yieldEllipseShift); 
@@ -171,12 +160,20 @@
 	//timingDeltas-&gt;checkpoint(&quot;geom&quot;);
 
 	epsN+=BC-&gt;isoPrestress/E;
-	//TRVAR1(epsN);
 	#ifdef CPM_MATERIAL_MODEL
 		CPM_MATERIAL_MODEL
 	#else
-		sigmaN=E*epsN;
-		sigmaT=G*epsT;
+		// very simplified version of the constitutive law
+		kappaD=max(max(0,epsN),kappaD); // internal variable, max positive strain (non-decreasing)
+		omega=isCohesive?funcG(kappaD,epsCrackOnset,epsFracture,neverDamage):1.; // damage variable (non-decreasing, as funcG is also non-decreasing)
+		sigmaN=(1-(epsN&gt;0?omega:0))*E*epsN; // damage taken in account in tension only
+		sigmaT=G*epsT; // trial stress
+		Real yieldSigmaT=max((Real)0.,undamagedCohesion*(1-omega)-sigmaN*tanFrictionAngle); // Mohr-Coulomb law with damage
+		if(sigmaT.SquaredLength()&gt;yieldSigmaT*yieldSigmaT){
+			sigmaT*=yieldSigmaT/sigmaT.Length(); // stress return
+			epsPlSum+=rT*contGeom-&gt;slipToStrainTMax(rT/G); // adjust strain
+		}
+		relResidualStrength=isCohesive?(kappaD&lt;epsCrackOnset?1.:(1-omega)*(kappaD)/epsCrackOnset):0;
 	#endif
 	sigmaN-=BC-&gt;isoPrestress;
 	if(contGeom-&gt;refR1&lt;0 &amp;&amp; Law2_Dem3DofGeom_CpmPhys_Cpm::minStrain_moveBody2&lt;=0 &amp;&amp; epsN&lt;Law2_Dem3DofGeom_CpmPhys_Cpm::minStrain_moveBody2){
@@ -303,7 +300,7 @@
 	// get max force on contacts
 	Real maxContactF=0;
 	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *rb-&gt;interactions){
-		if(!I-&gt;isReal) continue;
+		if(!I-&gt;isReal()) continue;
 		shared_ptr&lt;CpmPhys&gt; BC=YADE_PTR_CAST&lt;CpmPhys&gt;(I-&gt;interactionPhysics); assert(BC);
 		maxContactF=max(maxContactF,max(BC-&gt;Fn,BC-&gt;Fs.Length()));
 		CpmMat* bpp1(YADE_CAST&lt;CpmMat*&gt;(Body::byId(I-&gt;getId1())-&gt;physicalParameters.get()));
@@ -314,7 +311,7 @@
 	unbalancedForce=(useMaxForce?maxF:meanF)/maxContactF;
 
 	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *rb-&gt;interactions){
-		if(!I-&gt;isReal) continue;
+		if(!I-&gt;isReal()) continue;
 		shared_ptr&lt;CpmPhys&gt; BC=YADE_PTR_CAST&lt;CpmPhys&gt;(I-&gt;interactionPhysics); assert(BC);
 		CpmMat* bpp1(YADE_CAST&lt;CpmMat*&gt;(Body::byId(I-&gt;getId1())-&gt;physicalParameters.get()));
 		CpmMat* bpp2(YADE_CAST&lt;CpmMat*&gt;(Body::byId(I-&gt;getId2())-&gt;physicalParameters.get()));

Modified: trunk/pkg/dem/ConcretePM.hpp
===================================================================
--- trunk/pkg/dem/ConcretePM.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/ConcretePM.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -104,10 +104,6 @@
 			/// since the softening law is exponential, this doesn't mean that the contact is fully damaged at this point,
 			/// that happens only asymptotically 
 			epsFracture,
-			//! damage after which the contact disappears (&lt;1), since omega reaches 1 only for strain &#8594;+&#8734;
-			omegaThreshold,
-			//! weight coefficient for shear strain when computing the strain semi-norm kappaD
-			xiShear,
 			//! characteristic time for damage (if non-positive, the law without rate-dependence is used)
 			dmgTau,
 			//! exponent in the rate-dependent damage evolution
@@ -146,7 +142,7 @@
 
 
 
-		CpmPhys(): NormalShearInteraction(),E(0), G(0), tanFrictionAngle(0), undamagedCohesion(0), crossSection(0), xiShear(0), dmgTau(-1), dmgRateExp(0), dmgStrain(0), plTau(-1), plRateExp(0), isoPrestress(0.), kappaD(0.), epsTrans(0.), epsPlSum(0.) { createIndex(); epsT=Vector3r::ZERO; isCohesive=false; neverDamage=false; omega=0; Fn=0; Fs=Vector3r::ZERO; epsPlSum=0; dmgOverstress=0; }
+		CpmPhys(): NormalShearInteraction(),E(0), G(0), tanFrictionAngle(0), undamagedCohesion(0), crossSection(0), dmgTau(-1), dmgRateExp(0), dmgStrain(0), plTau(-1), plRateExp(0), isoPrestress(0.), kappaD(0.), epsTrans(0.), epsPlSum(0.) { createIndex(); epsT=Vector3r::ZERO; isCohesive=false; neverDamage=false; omega=0; Fn=0; Fs=Vector3r::ZERO; epsPlSum=0; dmgOverstress=0; }
 		virtual ~CpmPhys();
 
 		REGISTER_ATTRIBUTES(NormalShearInteraction,
@@ -157,8 +153,6 @@
 			(crossSection)
 			(epsCrackOnset)
 			(epsFracture)
-			(omegaThreshold)
-			(xiShear)
 			(dmgTau)
 			(dmgRateExp)
 			(dmgStrain)
@@ -206,7 +200,7 @@
 		/* uniaxial tension resistance, bending parameter of the damage evolution law, whear weighting constant for epsT in the strain seminorm (kappa) calculation. Default to NaN so that user gets loudly notified it was not set.
 		
 		*/
-		Real sigmaT, epsCrackOnset, relDuctility, G_over_E, tau, expDmgRate, omegaThreshold, dmgTau, dmgRateExp, plTau, plRateExp, isoPrestress;
+		Real sigmaT, epsCrackOnset, relDuctility, G_over_E, tau, expDmgRate, dmgTau, dmgRateExp, plTau, plRateExp, isoPrestress;
 		//! Should new contacts be cohesive? They will before this iter#, they will not be afterwards. If 0, they will never be. If negative, they will always be created as cohesive.
 		long cohesiveThresholdIter;
 		//! Create contacts that don't receive any damage (CpmPhys::neverDamage=true); defaults to false
@@ -218,7 +212,6 @@
 			neverDamage=false;
 			cohesiveThresholdIter=-1;
 			dmgTau=-1; dmgRateExp=0; plTau=-1; plRateExp=-1;
-			omegaThreshold=0.999;
 			isoPrestress=0;
 		}
 
@@ -234,7 +227,6 @@
 			(dmgRateExp)
 			(plTau)
 			(plRateExp)
-			(omegaThreshold)
 			(isoPrestress)
 		);
 
@@ -258,14 +250,17 @@
 		int yieldSurfType;
 		//! scaling in the logarithmic yield surface (should be &lt;1 for realistic results; &gt;=0 for meaningful results)
 		static Real yieldLogSpeed;
+		//! horizontal scaling of the ellipse (shifts on the +x axis as interactions with +y are given)
 		static Real yieldEllipseShift;
+		//! damage after which the contact disappears (&lt;1), since omega reaches 1 only for strain &#8594;+&#8734;
+		static Real omegaThreshold;
 		//! HACK: limit strain on some contacts by moving body #2 in the contact; only if refR1&lt;0 (facet); deactivated if &gt; 0
 		static Real minStrain_moveBody2;
 		Law2_Dem3DofGeom_CpmPhys_Cpm(): logStrain(false), yieldSurfType(0) { /*timingDeltas=shared_ptr&lt;TimingDeltas&gt;(new TimingDeltas);*/ }
 		void go(shared_ptr&lt;InteractionGeometry&gt;&amp; _geom, shared_ptr&lt;InteractionPhysics&gt;&amp; _phys, Interaction* I, MetaBody* rootBody);
 	FUNCTOR2D(Dem3DofGeom,CpmPhys);
 	REGISTER_CLASS_AND_BASE(Law2_Dem3DofGeom_CpmPhys_Cpm,ConstitutiveLaw);
-	REGISTER_ATTRIBUTES(ConstitutiveLaw,(logStrain)(yieldSurfType)(yieldLogSpeed)(yieldEllipseShift)(minStrain_moveBody2));
+	REGISTER_ATTRIBUTES(ConstitutiveLaw,(logStrain)(yieldSurfType)(yieldLogSpeed)(yieldEllipseShift)(minStrain_moveBody2)(omegaThreshold));
 	DECLARE_LOGGER;
 };
 REGISTER_SERIALIZABLE(Law2_Dem3DofGeom_CpmPhys_Cpm);

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_FacetSphere.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -48,7 +48,7 @@
 			Vector3r normal=facet-&gt;nf;
 			Real planeDist=normal.Dot(cogLine);
 			if(planeDist&lt;0){normal*=-1; planeDist*=-1; }
-			if(planeDist&gt;sphereRadius &amp;&amp; !c-&gt;isReal) { /* LOG_TRACE(&quot;Sphere too far (&quot;&lt;&lt;planeDist&lt;&lt;&quot;) from plane&quot;); */ return false;  }
+			if(planeDist&gt;sphereRadius &amp;&amp; !c-&gt;isReal()) { /* LOG_TRACE(&quot;Sphere too far (&quot;&lt;&lt;planeDist&lt;&lt;&quot;) from plane&quot;); */ return false;  }
 			Vector3r planarPt=cogLine-planeDist*normal; // project sphere center to the facet plane
 			Real normDotPt[3];
 			Vector3r contactPt(Vector3r::ZERO);
@@ -70,7 +70,7 @@
 			}
 			normal=cogLine-contactPt; // called normal, but it is no longer the facet's normal (for compat)
 			//TRVAR3(normal,contactPt,sphereRadius);
-			if(!c-&gt;isReal &amp;&amp; normal.SquaredLength()&gt;sphereRadius*sphereRadius) { /* LOG_TRACE(&quot;Sphere too far from closest point&quot;); */ return false; } // fast test before sqrt
+			if(!c-&gt;isReal() &amp;&amp; normal.SquaredLength()&gt;sphereRadius*sphereRadius) { /* LOG_TRACE(&quot;Sphere too far from closest point&quot;); */ return false; } // fast test before sqrt
 			Real penetrationDepth=sphereRadius-normal.Normalize();
 	#else
 		/* This code was mostly copied from InteractingFacet2InteractinSphere4SpheresContactGeometry */
@@ -79,7 +79,7 @@
 			Vector3r normal=facet-&gt;nf;
 			Real L=normal.Dot(contactLine); // height/depth of sphere's center from facet's plane
 			if(L&lt;0){normal*=-1; L*=-1;}
-			if(L&gt;sphereRadius &amp;&amp; !c-&gt;isReal) return false; // sphere too far away from the plane
+			if(L&gt;sphereRadius &amp;&amp; !c-&gt;isReal()) return false; // sphere too far away from the plane
 
 			Vector3r contactPt=contactLine-L*normal; // projection of sphere's center to facet's plane (preliminary contact point)
 			const Vector3r* edgeNormals=facet-&gt;ne; // array[3] of edge normals (in facet plane)
@@ -130,7 +130,7 @@
 		// end facet-local coordinates
 	#endif
 
-	if(penetrationDepth&lt;0 &amp;&amp; !c-&gt;isReal) return false;
+	if(penetrationDepth&lt;0 &amp;&amp; !c-&gt;isReal()) return false;
 
 	shared_ptr&lt;Dem3DofGeom_FacetSphere&gt; fs;
 	Vector3r normalGlob=se31.orientation*normal;
@@ -149,16 +149,6 @@
 	fs-&gt;se31=se31; fs-&gt;se32=se32;
 	fs-&gt;normal=normalGlob;
 	fs-&gt;contactPoint=se32.position+(-normalGlob)*(sphereRadius-penetrationDepth);
-	if(c-&gt;isNew){
-		//TRVAR2(planeDist,planarPt);
-		//TRVAR3(normDotPt[0],normDotPt[1],normDotPt[2]);
-		//TRVAR2(w,contactPt);
-		TRVAR1(penetrationDepth);
-		TRVAR3(fs-&gt;refLength,fs-&gt;cp1pt,fs-&gt;localFacetNormal);
-		TRVAR3(fs-&gt;effR2,fs-&gt;cp2rel,fs-&gt;normal);
-		TRVAR2(fs-&gt;se31.orientation,fs-&gt;se32.orientation);
-		TRVAR2(fs-&gt;contPtInTgPlane1(),fs-&gt;contPtInTgPlane2());
-	}
 	return true;
 }
 

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/Dem3DofGeom_SphereSphere.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -152,7 +152,7 @@
 	InteractingSphere *s1=static_cast&lt;InteractingSphere*&gt;(cm1.get()), *s2=static_cast&lt;InteractingSphere*&gt;(cm2.get());
 	Vector3r normal=se32.position-se31.position;
 	Real penetrationDepthSq=pow(distanceFactor*(s1-&gt;radius+s2-&gt;radius),2)-normal.SquaredLength();
-	if (penetrationDepthSq&lt;0 &amp;&amp; !c-&gt;isReal) return false;
+	if (penetrationDepthSq&lt;0 &amp;&amp; !c-&gt;isReal()) return false;
 
 	Real dist=normal.Normalize(); /* Normalize() works in-place and returns length before normalization; from here, normal is unit vector */
 	shared_ptr&lt;Dem3DofGeom_SphereSphere&gt; ss;

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -84,7 +84,7 @@
         
         for(  ; ii!=iiEnd ; ++ii ) 
         {
-                if ((*ii)-&gt;isReal )
+                if ((*ii)-&gt;isReal() )
                 {
                         const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
                          

Modified: trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -113,7 +113,7 @@
         
         for(  ; ii!=iiEnd ; ++ii ) 
         {
-                if ((*ii)-&gt;isReal)
+                if ((*ii)-&gt;isReal())
                 {	
                 	const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
                 

Modified: trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -119,7 +119,7 @@
         
         for(  ; ii!=iiEnd ; ++ii ) 
         {
-                if ((*ii)-&gt;isReal)
+                if ((*ii)-&gt;isReal())
                 {	
                 	const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
                 

Modified: trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/ThreeDTriaxialEngine.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -238,7 +238,7 @@
 	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end(); 
 	for(  ; ii!=iiEnd ; ++ii ) {
-		if (!(*ii)-&gt;isReal) continue;
+		if (!(*ii)-&gt;isReal()) continue;
 		const shared_ptr&lt;BodyMacroParameters&gt;&amp; sdec1 = YADE_PTR_CAST&lt;BodyMacroParameters&gt;((*bodies)[(body_id_t) ((*ii)-&gt;getId1())]-&gt;physicalParameters);
 		const shared_ptr&lt;BodyMacroParameters&gt;&amp; sdec2 = YADE_PTR_CAST&lt;BodyMacroParameters&gt;((*bodies)[(body_id_t) ((*ii)-&gt;getId2())]-&gt;physicalParameters);		
 		//FIXME - why dynamic_cast fails here?

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -36,6 +36,7 @@
 	previousState=currentState;
 	UnbalancedForce = 1;
 	Key = &quot;&quot;;
+	noFiles=false;
 	Phase1End = &quot;Compacted&quot;;
 	FinalIterationPhase1 = 0;
 	Iteration = 0;
@@ -89,6 +90,7 @@
 	REGISTER_ATTRIBUTE(previousSigmaIso);
 	REGISTER_ATTRIBUTE(sigmaLateralConfinement);
 	REGISTER_ATTRIBUTE(Key);
+	REGISTER_ATTRIBUTE(noFiles);
 	REGISTER_ATTRIBUTE(frictionAngleDegree);
 	REGISTER_ATTRIBUTE(epsilonMax);
 	REGISTER_ATTRIBUTE(uniaxialEpsilonCurr);
@@ -112,8 +114,8 @@
 		height0 = height; depth0 = depth; width0 = width;
 		//compressionActivated = true;
 		wall_bottom_activated=false; wall_top_activated=false;
-		if(currentState==STATE_ISO_UNLOADING){ LOG_INFO(&quot;Speres -&gt; /tmp/unloaded.spheres&quot;); Shop::saveSpheresToFile(&quot;/tmp/unloaded.spheres&quot;); }
-		if(!firstRun) saveSimulation=true; // saving snapshot .xml will actually be done in ::applyCondition
+		if(currentState==STATE_ISO_UNLOADING &amp;&amp; !noFiles){ LOG_INFO(&quot;Speres -&gt; /tmp/unloaded.spheres&quot;); Shop::saveSpheresToFile(&quot;/tmp/unloaded.spheres&quot;); }
+		if(!firstRun &amp;&amp; !noFiles) saveSimulation=true; // saving snapshot .xml will actually be done in ::applyCondition
 		Phase1End = &quot;Unloaded&quot;;
 	}
 	else if(currentState==STATE_ISO_COMPACTION &amp;&amp; nextState==STATE_ISO_UNLOADING){
@@ -122,17 +124,17 @@
 		previousSigmaIso=sigma_iso;
 		internalCompaction=false; // unloading will not change grain sizes
 		if (frictionAngleDegree&gt;0) setContactProperties(body, frictionAngleDegree);
-		if(!firstRun) saveSimulation=true;
+		if(!firstRun &amp;&amp; !noFiles) saveSimulation=true;
 		Phase1End = &quot;Compacted&quot;;
 	}	
 	else if ((currentState==STATE_ISO_COMPACTION || currentState==STATE_ISO_UNLOADING) &amp;&amp; nextState==STATE_LIMBO) {
 	//urrentState==STATE_DIE_COMPACTION
 		internalCompaction = false;
 		height0 = height; depth0 = depth; width0 = width;
-		saveSimulation=true; // saving snapshot .xml will actually be done in ::applyCondition
+		if(!noFiles) saveSimulation=true; // saving snapshot .xml will actually be done in ::applyCondition
 		// stop simulation here, since nothing will happen from now on
 		Phase1End = (currentState==STATE_ISO_COMPACTION ? &quot;compacted&quot; : &quot;unloaded&quot;);
-		Shop::saveSpheresToFile(&quot;/tmp/limbo.spheres&quot;);
+		if(!noFiles) Shop::saveSpheresToFile(&quot;/tmp/limbo.spheres&quot;);
 	}
 	else if( nextState==STATE_FIXED_POROSITY_COMPACTION){		
 		internalCompaction = false;
@@ -239,16 +241,19 @@
 
 	if ( saveSimulation )
 	{
-		string fileName = &quot;./&quot;+ Key + &quot;_&quot; + Phase1End + &quot;_&quot; +
-						  lexical_cast&lt;string&gt; ( Omega::instance().getCurrentIteration() ) + &quot;_&quot; +
-						  lexical_cast&lt;string&gt; ( currentState ) + &quot;.xml&quot;;
-		LOG_INFO ( &quot;saving snapshot: &quot;&lt;&lt;fileName );
-		Omega::instance().saveSimulation ( fileName );
-		fileName=&quot;./&quot;+ Key + &quot;_&quot;+Phase1End+&quot;_&quot;+lexical_cast&lt;string&gt; ( Omega::instance().getCurrentIteration() ) + &quot;_&quot; +
-				 lexical_cast&lt;string&gt; ( currentState ) +&quot;.spheres&quot;;
-		LOG_INFO ( &quot;saving spheres: &quot;&lt;&lt;fileName );
-		Shop::saveSpheresToFile ( fileName );
+		if(!noFiles){
+			string fileName = &quot;./&quot;+ Key + &quot;_&quot; + Phase1End + &quot;_&quot; +
+							  lexical_cast&lt;string&gt; ( Omega::instance().getCurrentIteration() ) + &quot;_&quot; +
+							  lexical_cast&lt;string&gt; ( currentState ) + &quot;.xml&quot;;
+			LOG_INFO ( &quot;saving snapshot: &quot;&lt;&lt;fileName );
+			Omega::instance().saveSimulation ( fileName );
+			fileName=&quot;./&quot;+ Key + &quot;_&quot;+Phase1End+&quot;_&quot;+lexical_cast&lt;string&gt; ( Omega::instance().getCurrentIteration() ) + &quot;_&quot; +
+					 lexical_cast&lt;string&gt; ( currentState ) +&quot;.spheres&quot;;
+			LOG_INFO ( &quot;saving spheres: &quot;&lt;&lt;fileName );
+			Shop::saveSpheresToFile ( fileName );
+		}
 		saveSimulation = false;
+
 	}
 	
 	if ( Omega::instance().getCurrentIteration() % testEquilibriumInterval == 0 )
@@ -333,7 +338,7 @@
 	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end(); 
 	for(  ; ii!=iiEnd ; ++ii ) {
-		if (!(*ii)-&gt;isReal) continue;
+		if (!(*ii)-&gt;isReal()) continue;
 		const shared_ptr&lt;BodyMacroParameters&gt;&amp; sdec1 = YADE_PTR_CAST&lt;BodyMacroParameters&gt;((*bodies)[(body_id_t) ((*ii)-&gt;getId1())]-&gt;physicalParameters);
 		const shared_ptr&lt;BodyMacroParameters&gt;&amp; sdec2 = YADE_PTR_CAST&lt;BodyMacroParameters&gt;((*bodies)[(body_id_t) ((*ii)-&gt;getId2())]-&gt;physicalParameters);		
 		//FIXME - why dynamic_cast fails here?

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -102,6 +102,8 @@
 		int FinalIterationPhase1, Iteration, testEquilibriumInterval;
 		
 		std::string Key;//A code that is appended to file names to help distinguish between different simulations
+		//! If true, no files will be generated (.xml, .spheres)
+		bool noFiles;
 		// //! Is uniaxial compression currently activated?
 		// bool compressionActivated;
 		//! Auto-switch from isotropic compaction or unloading state (if sigmaLateralConfinement&lt;sigmaIsoCompaction)

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -202,7 +202,7 @@
 
  for ( ; ii!=iiEnd ; ++ii )
  {
-	 if ( ( *ii )-&gt;isReal )
+	 if ( ( *ii )-&gt;isReal() )
 	 {
 		 const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
 

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -154,7 +154,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			
@@ -382,7 +382,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for ( ; ii!=iiEnd ; ++ii )
 	{
-		if ( ( *ii )-&gt;isReal )
+		if ( ( *ii )-&gt;isReal() )
 		{
 			SpheresContactGeometry* contact = static_cast&lt;SpheresContactGeometry*&gt; ( ( *ii )-&gt;interactionGeometry.get() );
 			//      if ((*(ncb-&gt;bodies))[(*ii)-&gt;getId1()]-&gt;isDynamic)
@@ -412,7 +412,7 @@
 	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii ) {
-		if ((*ii)-&gt;isReal) {
+		if ((*ii)-&gt;isReal()) {
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			Real f = (static_cast&lt;ElasticContactInteraction*&gt; ((contact-&gt;interactionPhysics.get()))-&gt;normalForce+static_cast&lt;ElasticContactInteraction*&gt;(contact-&gt;interactionPhysics.get())-&gt;shearForce).SquaredLength();
 			if (f!=0)

Modified: trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/BasicViscoelasticRelationships.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -28,7 +28,7 @@
 					, const shared_ptr&lt;PhysicalParameters&gt;&amp; b2 // SimpleViscoelasticBodyParameters
 					, const shared_ptr&lt;Interaction&gt;&amp; interaction)
 {
-    if( !interaction-&gt;isNew ) return;
+    if(interaction-&gt;interactionPhysics) return;
 
     SimpleViscoelasticBodyParameters* sdec1 = static_cast&lt;SimpleViscoelasticBodyParameters*&gt;(b1.get());
     SimpleViscoelasticBodyParameters* sdec2 = static_cast&lt;SimpleViscoelasticBodyParameters*&gt;(b2.get());

Modified: trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/CL1Relationships.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -62,7 +62,7 @@
 	
 	if(interactionGeometry) // so it is SpheresContactGeometry  - NON PERMANENT LINK
 	{
-		if(interaction-&gt;isNew)
+		if(!interaction-&gt;interactionPhysics)
 		{
 //std::cerr &lt;&lt; &quot; isNew, id1: &quot; &lt;&lt; interaction-&gt;getId1() &lt;&lt; &quot; id2: &quot; &lt;&lt; interaction-&gt;getId2()  &lt;&lt; &quot;\n&quot;;
 			interaction-&gt;interactionPhysics = shared_ptr&lt;ContactLaw1Interaction&gt;(new ContactLaw1Interaction());

Modified: trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -64,7 +64,7 @@
 	
 	if(interactionGeometry) // so it is SpheresContactGeometry  - NON PERMANENT LINK
 	{
-		if(interaction-&gt;isNew)
+		if(!interaction-&gt;interactionPhysics)
 		{
 //std::cerr &lt;&lt; &quot; isNew, id1: &quot; &lt;&lt; interaction-&gt;getId1() &lt;&lt; &quot; id2: &quot; &lt;&lt; interaction-&gt;getId2()  &lt;&lt; &quot;\n&quot;;
 			interaction-&gt;interactionPhysics = shared_ptr&lt;CohesiveFrictionalContactInteraction&gt;(new CohesiveFrictionalContactInteraction());

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometry.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometry.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -85,11 +85,12 @@
 		pt2 = se32.position-normal*s-&gt;radius;
 
 		shared_ptr&lt;SpheresContactGeometry&gt; scm;
-		if (c-&gt;isNew) scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+		bool isNew=!c-&gt;interactionGeometry;
+		if (isNew) scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
 		else scm = YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
 
 		#ifdef SCG_SHEAR
-			if(c-&gt;isNew) { /* same as below */ scm-&gt;prevNormal=pt1-pt2; scm-&gt;prevNormal.Normalize(); }
+			if(isNew) { /* same as below */ scm-&gt;prevNormal=pt1-pt2; scm-&gt;prevNormal.Normalize(); }
 			else {scm-&gt;prevNormal=scm-&gt;normal;}
 		#endif
 			
@@ -132,10 +133,11 @@
 		pt2=se32.position+cOnBox_sphere*s-&gt;radius;
 		
 		shared_ptr&lt;SpheresContactGeometry&gt; scm;
-		if (c-&gt;isNew) scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+		bool isNew=!c-&gt;interactionGeometry;
+		if (isNew) scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
 		else scm = YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);	
 		#ifdef SCG_SHEAR
-			if(c-&gt;isNew) { /* same as below */ scm-&gt;prevNormal=-cOnBox_sphere; }
+			if(isNew) { /* same as below */ scm-&gt;prevNormal=-cOnBox_sphere; }
 			else {scm-&gt;prevNormal=scm-&gt;normal;}
 		#endif
 		scm-&gt;contactPoint = 0.5*(pt1+pt2);
@@ -159,7 +161,6 @@
 						const Se3r&amp; se32,
 						const shared_ptr&lt;Interaction&gt;&amp; c)
 {
-	assert(c-&gt;isNew);
 	c-&gt;swapOrder();
 	return go(cm2,cm1,se32,se31,c);
 }

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -86,7 +86,7 @@
 
 		// FIXME : remove those uncommented lines
 		shared_ptr&lt;SpheresContactGeometry&gt; scm;
-		if (c-&gt;isNew)
+		if (!c-&gt;interactionGeometry)
 			scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
 		else
 			scm = dynamic_pointer_cast&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
@@ -136,7 +136,7 @@
 	shared_ptr&lt;SpheresContactGeometry&gt; scm;
 	//cerr &lt;&lt; &quot;scm = &quot; &lt;&lt; scm &lt;&lt; &quot; | c = &quot; &lt;&lt; c &lt;&lt; endl;
 	
-	if (c-&gt;isNew)
+	if (!c-&gt;interactionGeometry)
 	{	//cerr &lt;&lt; &quot;c-&gt;isNew&quot;;
 		scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
 	}

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingFacet2InteractingSphere4SpheresContactGeometry.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -49,25 +49,8 @@
 	Real L = normal.Dot(cl);
 	if (L&lt;0) {normal=-normal; L=-L; }
 
-#if 0
-	int contactFace=0; // temp to save what will be maybe needed for new contact
-	//assert((c-&gt;interactionGeometry&amp;&amp;c-&gt;isReal)||(!c-&gt;interactionGeometry&amp;&amp;!c-&gt;isReal));
-	if(c-&gt;interactionGeometry){ // contact already exists, use old data here
-		contactFace=YADE_CAST&lt;SpheresContactGeometry*&gt;(c-&gt;interactionGeometry.get())-&gt;facetContactFace;
-		// determinate contact on negative side: reverse quantities
-		if(contactFace&lt;0){normal=-normal; L=-L;}
-		// indeterminate contact on negative side: set to -1; if edge, will be reset to 0 below
-		else if (contactFace==0 &amp;&amp; L&lt;0) { normal=-normal; L=-L; contactFace=-1; }
-		// indeterminate and is on the positive side: set to 1; if edge, will be reset to 0 below
-		else if(contactFace==0 &amp;&amp; L&gt;0) {contactFace=1;}
-	} else {
-		if (L&lt;0) { normal=-normal; L=-L; contactFace=-1;} // new contact on the negative face, reverse and save that information so that since now this contact is always reversed
-		else contactFace=1;
-	}
-#endif
-
 	Real sphereRadius = static_cast&lt;InteractingSphere*&gt;(cm2.get())-&gt;radius;
-	if (L&gt;sphereRadius &amp;&amp; !c-&gt;isReal)  return false; // no contact, but only if there was no previous contact; ortherwise, the constitutive law is responsible for setting Interaction::isReal=false
+	if (L&gt;sphereRadius &amp;&amp; !c-&gt;isReal())  return false; // no contact, but only if there was no previous contact; ortherwise, the constitutive law is responsible for setting Interaction::isReal=false
 
 	Vector3r cp = cl - L*normal;
 	const Vector3r* ne = facet-&gt;ne;
@@ -116,7 +99,7 @@
 	// END everything in facet-local coordinates
 	//
 
-	if (penetrationDepth&gt;0 || c-&gt;isReal)
+	if (penetrationDepth&gt;0 || c-&gt;isReal())
 	{
 		shared_ptr&lt;SpheresContactGeometry&gt; scm;
 		if (c-&gt;interactionGeometry)
@@ -146,7 +129,6 @@
 								const Se3r&amp; se32,
 								const shared_ptr&lt;Interaction&gt;&amp; c)
 {
-	assert(c-&gt;isNew);
 	c-&gt;swapOrder();
 	//LOG_WARN(&quot;Swapped interaction order for &quot;&lt;&lt;c-&gt;getId2()&lt;&lt;&quot;&amp;&quot;&lt;&lt;c-&gt;getId1());
 	return go(cm2,cm1,se32,se31,c);

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingBox4InteractionOfMyTetrahedron.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingBox4InteractionOfMyTetrahedron.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingBox4InteractionOfMyTetrahedron.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -74,7 +74,7 @@
 
 	shared_ptr&lt;InteractionOfMyTetrahedron&gt; imt;
 	// depending whether it's a new interaction: create new one, or use the existing one.
-	if (c-&gt;isNew)
+	if (c-&gt;interactionGeometry)
 		imt = shared_ptr&lt;InteractionOfMyTetrahedron&gt;(new InteractionOfMyTetrahedron());
 	else
 		imt = YADE_PTR_CAST&lt;InteractionOfMyTetrahedron&gt;(c-&gt;interactionGeometry);	

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingMyTetrahedron4InteractionOfMyTetrahedron.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingMyTetrahedron4InteractionOfMyTetrahedron.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingMyTetrahedron2InteractingMyTetrahedron4InteractionOfMyTetrahedron.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -36,7 +36,7 @@
 	
 	shared_ptr&lt;InteractionOfMyTetrahedron&gt; imt;
 	// depending whether it's a new interaction: create new one, or use the existing one.
-	if (c-&gt;isNew)
+	if (c-&gt;interactionGeometry)
 		imt = shared_ptr&lt;InteractionOfMyTetrahedron&gt;(new InteractionOfMyTetrahedron());
 	else
 		imt = YADE_PTR_CAST&lt;InteractionOfMyTetrahedron&gt;(c-&gt;interactionGeometry);	

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2BssSweptSphereLineSegment4SpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2BssSweptSphereLineSegment4SpheresContactGeometry.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2BssSweptSphereLineSegment4SpheresContactGeometry.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -39,7 +39,7 @@
                 if (overlap &lt;= 0.0)
                 {
                         shared_ptr&lt;SpheresContactGeometry&gt; scm;
-                        if (c-&gt;isNew) scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+                        if (c-&gt;interactionGeometry) scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
                         else scm = YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
         
                         scm-&gt;contactPoint = se32.position + proj + (ssls-&gt;radius+0.5*overlap)*ccn;

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometry.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -25,13 +25,14 @@
 	InteractingSphere *s1=static_cast&lt;InteractingSphere*&gt;(cm1.get()), *s2=static_cast&lt;InteractingSphere*&gt;(cm2.get());
 	Vector3r normal=se32.position-se31.position;
 	Real penetrationDepthSq=pow(interactionDetectionFactor*(s1-&gt;radius+s2-&gt;radius),2) - normal.SquaredLength();
-	if (penetrationDepthSq&gt;0 || c-&gt;isReal){
+	if (penetrationDepthSq&gt;0 || c-&gt;isReal()){
 		shared_ptr&lt;SpheresContactGeometry&gt; scm;
+		bool isNew=c-&gt;interactionGeometry;
 		if(c-&gt;interactionGeometry) scm=YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
 		else { scm=shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry()); c-&gt;interactionGeometry=scm; }
 
 		#ifdef SCG_SHEAR
-			if(c-&gt;isNew) scm-&gt;prevNormal=normal; 
+			if(isNew) scm-&gt;prevNormal=normal; 
 			else scm-&gt;prevNormal=scm-&gt;normal;
 		#endif
 

Modified: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationships.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -67,7 +67,7 @@
 		contactPhysics-&gt;ks = contactPhysics-&gt;initialKs;
 		contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
 */
-		if( interaction-&gt;isNew)
+		if(!interaction-&gt;interactionPhysics)
 		{
 			interaction-&gt;interactionPhysics = shared_ptr&lt;ElasticContactInteraction&gt;(new ElasticContactInteraction());
 			ElasticContactInteraction* contactPhysics = YADE_CAST&lt;ElasticContactInteraction*&gt;(interaction-&gt;interactionPhysics.get());

Modified: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -68,7 +68,7 @@
 		contactPhysics-&gt;ks = contactPhysics-&gt;initialKs;
 		contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
 */
-		if( interaction-&gt;isNew)
+		if(!interaction-&gt;interactionPhysics)
 		{
 			interaction-&gt;interactionPhysics = shared_ptr&lt;CapillaryParameters&gt;(new CapillaryParameters());
 			CapillaryParameters* contactPhysics = static_cast&lt;CapillaryParameters*&gt;(interaction-&gt;interactionPhysics.get());

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationships.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -25,7 +25,7 @@
 	
 	//if(interactionGeometry)
 	{
-		if( interaction-&gt;isNew)
+		if(!interaction-&gt;interactionPhysics)
 		{
 			const shared_ptr&lt;BodyMacroParameters&gt;&amp; sdec1 = YADE_PTR_CAST&lt;BodyMacroParameters&gt;(b1);
 			const shared_ptr&lt;BodyMacroParameters&gt;&amp; sdec2 = YADE_PTR_CAST&lt;BodyMacroParameters&gt;(b2);

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleElasticRelationshipsWater.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -40,7 +40,7 @@
 	if(interactionGeometry) // so it is SpheresContactGeometry  - NON PERMANENT LINK
 	{
 //cerr &lt;&lt; &quot;interactionGeometry&quot; &lt;&lt; endl;
-		if( interaction-&gt;isNew)
+		if(!interaction-&gt;interactionPhysics)
 		{
 //cerr &lt;&lt; &quot;interaction-&gt;isNew&quot; &lt;&lt; endl;
 			const shared_ptr&lt;BodyMacroParameters&gt;&amp; sdec1 = YADE_PTR_CAST&lt;BodyMacroParameters&gt;(b1);

Modified: trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/SimpleViscoelasticRelationships.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -28,7 +28,7 @@
 					, const shared_ptr&lt;PhysicalParameters&gt;&amp; b2 // SimpleViscoelasticBodyParameters
 					, const shared_ptr&lt;Interaction&gt;&amp; interaction)
 {
-    if( !interaction-&gt;isNew ) return;
+    if(interaction-&gt;interactionPhysics) return;
 
     SimpleViscoelasticBodyParameters* sdec1 = static_cast&lt;SimpleViscoelasticBodyParameters*&gt;(b1.get());
     SimpleViscoelasticBodyParameters* sdec2 = static_cast&lt;SimpleViscoelasticBodyParameters*&gt;(b2.get());

Modified: trunk/pkg/dem/Engine/EngineUnit/ef2_Spheres_Viscoelastic_SimpleViscoelasticContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/ef2_Spheres_Viscoelastic_SimpleViscoelasticContactLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/EngineUnit/ef2_Spheres_Viscoelastic_SimpleViscoelasticContactLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -26,8 +26,9 @@
 	RigidBodyParameters* de2 = YADE_CAST&lt;RigidBodyParameters*&gt;((*bodies)[id2]-&gt;physicalParameters.get());
 
 	Vector3r&amp; shearForce 			= phys-&gt;shearForce;
-	if (I-&gt;isNew) shearForce=Vector3r(0,0,0);
 
+	if (I-&gt;isFresh(rootBody)) shearForce=Vector3r(0,0,0);
+
 	Real dt = Omega::instance().getTimeStep();
 
 	Vector3r axis = phys-&gt;prevNormal.Cross(geom-&gt;normal);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -118,7 +118,7 @@
 
         for(  ; ii!=iiEnd ; ++ii ) {
 
-                if ((*ii)-&gt;isReal) {//FIXME : test to be removed when using DistantPersistentSAPCollider?
+                if ((*ii)-&gt;isReal()) {//FIXME : test to be removed when using DistantPersistentSAPCollider?
 
                         const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
                         unsigned int id1 = interaction-&gt;getId1();
@@ -268,7 +268,7 @@
 
         for(ii= ncb-&gt;transientInteractions-&gt;begin(); ii!=iiEnd ; ++ii ) 
 	{	//cerr &lt;&lt; &quot;interaction &quot; &lt;&lt; ii &lt;&lt; endl;
-                if ((*ii)-&gt;isReal) 
+                if ((*ii)-&gt;isReal()) 
 		{
                         CapillaryParameters* currentContactPhysics	=	static_cast&lt;CapillaryParameters*&gt;((*ii)-&gt;interactionPhysics.get());
                         if (currentContactPhysics-&gt;meniscus) 
@@ -294,7 +294,7 @@
 				//cerr &lt;&lt; &quot;id1/id2 &quot; &lt;&lt; (*ii)-&gt;getId1() &lt;&lt; &quot;/&quot; &lt;&lt; (*ii)-&gt;getId2() &lt;&lt; &quot; Fcap= &quot; &lt;&lt; currentContactPhysics-&gt;Fcap &lt;&lt; endl;
 
                         }
-                }
+					 }
         }
 
 
@@ -317,7 +317,7 @@
 	//Reset fusion numbers
 	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
         InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
-        for( ; ii!=iiEnd ; ++ii ) if ((*ii)-&gt;isReal) static_cast&lt;CapillaryParameters*&gt;((*ii)-&gt;interactionPhysics.get())-&gt;fusionNumber=0;
+        for( ; ii!=iiEnd ; ++ii ) if ((*ii)-&gt;isReal()) static_cast&lt;CapillaryParameters*&gt;((*ii)-&gt;interactionPhysics.get())-&gt;fusionNumber=0;
 	
 	
 	list&lt; shared_ptr&lt;Interaction&gt; &gt;::iterator firstMeniscus, lastMeniscus, currentMeniscus;
@@ -655,7 +655,7 @@
         InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
         InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
         for(  ; ii!=iiEnd ; ++ii ) {
-                if ((*ii)-&gt;isReal) {
+                if ((*ii)-&gt;isReal()) {
                 	if (static_cast&lt;CapillaryParameters*&gt;((*ii)-&gt;interactionPhysics.get())-&gt;meniscus) insert(*ii);
                 }
         }

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -90,7 +90,7 @@
     for (  ; ii!=iiEnd ; ++ii )
     {
         //if ((*ii)-&gt;interactionGeometry &amp;&amp; (*ii)-&gt;interactionPhysics)
-        if ((*ii)-&gt;isReal)
+        if ((*ii)-&gt;isReal())
         {
             if (detectBrokenBodies 
 		    /* FIXME - this had no effect. InteractingBox has its isBroken=false too.
@@ -119,8 +119,7 @@
 
             Vector3r&amp; shearForce 			= currentContactPhysics-&gt;shearForce;
 
-            if (contact-&gt;isNew)
-                shearForce			= Vector3r::ZERO;
+				if (contact-&gt;isFresh(ncb)) shearForce			= Vector3r::ZERO;
 
             Real un 				= currentContactGeometry-&gt;penetrationDepth;
             Real Fn				= currentContactPhysics-&gt;kn*un;
@@ -136,8 +135,9 @@
                 //if (currentContactPhysics-&gt;cohesionBroken) {
                 //cerr &lt;&lt; &quot;broken&quot; &lt;&lt; endl;
 
-                contact-&gt;isReal= false;
-                currentContactPhysics-&gt;cohesionBroken = true;
+                ncb-&gt;interactions-&gt;requestErase(contact-&gt;getId1(),contact-&gt;getId2());
+                // contact-&gt;interactionPhysics was reset now; currentContactPhysics still hold the object, but is not associated with the interaction anymore
+					 currentContactPhysics-&gt;cohesionBroken = true;
                 currentContactPhysics-&gt;normalForce = Vector3r::ZERO;
                 currentContactPhysics-&gt;shearForce = Vector3r::ZERO;
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ContactLaw1.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -51,13 +51,13 @@
     for (  ; ii!=iiEnd ; ++ii )
     {
         //if ((*ii)-&gt;interactionGeometry &amp;&amp; (*ii)-&gt;interactionPhysics)
-	if ((*ii)-&gt;isReal)
+	if ((*ii)-&gt;isReal())
 		{
 		nbreInteracTot++;
 		const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 		int id1 = contact-&gt;getId1();
 		int id2 = contact-&gt;getId2();
-// 		cout &lt;&lt; &quot;contact entre &quot; &lt;&lt; id1 &lt;&lt; &quot; et &quot; &lt;&lt; id2 &lt;&lt; &quot; reel ? &quot; &lt;&lt; contact-&gt;isReal &lt;&lt; endl;
+// 		cout &lt;&lt; &quot;contact entre &quot; &lt;&lt; id1 &lt;&lt; &quot; et &quot; &lt;&lt; id2 &lt;&lt; &quot; reel ? &quot; &lt;&lt; contact-&gt;isReal() &lt;&lt; endl;
 		if ( !( (*bodies)[id1]-&gt;getGroupMask() &amp; (*bodies)[id2]-&gt;getGroupMask() &amp; sdecGroupMask)  )
 			continue; // skip other groups,
 
@@ -68,7 +68,7 @@
 
 		Vector3r&amp; shearForce 			= currentContactPhysics-&gt;shearForce;
 
-		if (contact-&gt;isNew)
+		if (contact-&gt;isFresh(ncb))
 			{
 			shearForce			= Vector3r::ZERO;
 			currentContactPhysics-&gt;previousun=0.0;
@@ -114,12 +114,13 @@
                 //currentContactPhysics-&gt;SetBreakingState();
 
 
-                contact-&gt;isReal= false;
+					 ncb-&gt;interactions-&gt;requestErase(contact-&gt;getId1(),contact-&gt;getId2());
+					 // probably not useful anymore
                 currentContactPhysics-&gt;normalForce = Vector3r::ZERO;
                 currentContactPhysics-&gt;shearForce = Vector3r::ZERO;
 
                 //return;
-                //    } else
+                //    else
                 //    currentContactPhysics-&gt;normalForce	= -currentContactPhysics-&gt;normalAdhesion*currentContactGeometry-&gt;normal;
             	}
             else

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -49,7 +49,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;persistentInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt; contact2 = *ii;
 	

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -50,7 +50,7 @@
 		functor-&gt;useShear=useShear;
 	#endif
 	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; I, *rootBody-&gt;interactions){
-		if(!I-&gt;isReal) continue;
+		if(!I-&gt;isReal()) continue;
 		#ifdef YADE_DEBUG
 			// these checks would be redundant in the functor (ConstitutiveLawDispatcher does that already)
 			if(!dynamic_cast&lt;SpheresContactGeometry*&gt;(I-&gt;interactionGeometry.get()) || !dynamic_cast&lt;ElasticContactInteraction*&gt;(I-&gt;interactionPhysics.get())) continue;	
@@ -77,7 +77,7 @@
 
 			Vector3r&amp; shearForce 			= currentContactPhysics-&gt;shearForce;
 	
-			if (contact-&gt;isNew) shearForce=Vector3r(0,0,0);
+			if (contact-&gt;isFresh(ncb)) shearForce=Vector3r(0,0,0);
 					
 			Real un=currentContactGeometry-&gt;penetrationDepth;
 			TRVAR3(currentContactGeometry-&gt;penetrationDepth,de1-&gt;se3.position,de2-&gt;se3.position);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ForceSnapshot.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -85,7 +85,7 @@
 
 	for( ;ii!=iiEnd;++ii)
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			body_id_t id1 = contact-&gt;getId1();

Modified: trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -189,7 +189,7 @@
 	memset(stiffnesses[0], 0,sizeof(Vector3r)*size);
 	memset(Rstiffnesses[0],0,sizeof(Vector3r)*size);
 	FOREACH(const shared_ptr&lt;Interaction&gt;&amp; contact, *rb-&gt;interactions){
-		if(!contact-&gt;isReal) continue;
+		if(!contact-&gt;isReal()) continue;
 
 		SpheresContactGeometry* geom=YADE_CAST&lt;SpheresContactGeometry*&gt;(contact-&gt;interactionGeometry.get()); assert(geom);
 		NormalShearInteraction* phys=YADE_CAST&lt;NormalShearInteraction*&gt;(contact-&gt;interactionPhysics.get()); assert(phys);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MicroMacroAnalyser.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -156,7 +156,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for ( ; ii!=iiEnd ; ++ii )
 	{
-		if ( ( *ii )-&gt;isReal )
+		if ( ( *ii )-&gt;isReal() )
 		{
 			TriaxialState::Contact *c = new TriaxialState::Contact;
 			TS.contacts.push_back ( c );

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -35,7 +35,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)	// isReal means that InteractingMyTetrahedron2InteractingMyTetrahedron4InteractionOfMyTetrahedron returned true
+		if ((*ii)-&gt;isReal())	// isReal means that InteractingMyTetrahedron2InteractingMyTetrahedron4InteractionOfMyTetrahedron returned true
 					//                or InteractingMyTetrahedron2InteractingBox4InteractionOfMyTetrahedron           returned true
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
@@ -76,7 +76,6 @@
 
 					}
 				}
-
 		}
 	}
 }

Modified: trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/SimpleViscoelasticSpheresInteractionRecorder.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -53,7 +53,7 @@
     for(  ; ii!=iiEnd ; ++ii )
     {
 	const shared_ptr&lt;Interaction&gt;&amp; i = *ii;
-	if ( !i-&gt;isReal ) continue;
+	if ( !i-&gt;isReal() ) continue;
 	if ( i-&gt;interactionGeometry-&gt;getClassIndex() != interactionSphere-&gt;getClassIndex() ) continue;
 	if ( i-&gt;interactionPhysics-&gt;getClassIndex() != viscoelasticInteraction-&gt;getClassIndex() ) continue;
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ViscousForceDamping.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -51,7 +51,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			int id1 = contact-&gt;getId1();
@@ -67,7 +67,7 @@
 			
 			Vector3r&amp; shearForce 			= currentContactPhysics-&gt;shearForce;
 	
-			if ( contact-&gt;isNew)
+			if ( contact-&gt;isFresh(ncb))
 				shearForce			= Vector3r(0,0,0);
 					
 			Real un 				= currentContactGeometry-&gt;penetrationDepth;

Modified: trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/Engine/StandAloneEngine/VolumicContactLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -209,7 +209,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for(  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			int id1 = contact-&gt;getId1();
@@ -230,7 +230,7 @@
 
 
 
-		if (contact-&gt;isNew) // Si on a une nouvelle interpenetration detect&#233;e, on initialise 
+		if (contact-&gt;isFresh(ncb)) // Si on a une nouvelle interpenetration detect&#233;e, on initialise 
 			{
 			shearForce			= Vector3r(0,0,0);
 			currentContactPhysics-&gt;previousun=0.0;
@@ -478,6 +478,7 @@
 			ncb-&gt;bex.addTorque(id2, c2x.Cross(f));
 			
 			currentContactPhysics-&gt;prevNormal = currentContactGeometry-&gt;normal;
+
 		}
 	}
 

Modified: trunk/pkg/dem/PreProcessor/HydraulicTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/HydraulicTest.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/PreProcessor/HydraulicTest.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -23,7 +23,6 @@
 #include&lt;yade/pkg-common/AABB.hpp&gt;
 #include&lt;yade/pkg-common/Sphere.hpp&gt;
 #include&lt;yade/core/MetaBody.hpp&gt;
-#include&lt;yade/pkg-common/DistantPersistentSAPCollider.hpp&gt;
 #include&lt;yade/lib-serialization/IOFormatManager.hpp&gt;
 #include&lt;yade/core/Interaction.hpp&gt;
 #include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;

Modified: trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/PreProcessor/SDECLinkedSpheres.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -192,9 +192,6 @@
 
 				link-&gt;interactionGeometry 		= geometry;
 				link-&gt;interactionPhysics 		= physics;
-				link-&gt;isReal 				= true;
-				link-&gt;isNew 				= false;
-				
 				rootBody-&gt;persistentInteractions-&gt;insert(link);
 			}
 		}

Modified: trunk/pkg/dem/PreProcessor/ThreePointBending.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/ThreePointBending.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/PreProcessor/ThreePointBending.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -200,9 +200,6 @@
 
 				link-&gt;interactionGeometry 		= geometry;
 				link-&gt;interactionPhysics 		= physics;
-				link-&gt;isReal 				= true;
-				link-&gt;isNew 				= false;
-				
 				rootBody-&gt;persistentInteractions-&gt;insert(link);
 			}
 		}

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -34,6 +34,7 @@
 #include&lt;yade/pkg-common/Sphere.hpp&gt;
 #include&lt;yade/core/MetaBody.hpp&gt;
 #include&lt;yade/pkg-common/PersistentSAPCollider.hpp&gt;
+#include&lt;yade/pkg-common/InsertionSortCollider.hpp&gt;
 #include&lt;yade/lib-serialization/IOFormatManager.hpp&gt;
 #include&lt;yade/core/Interaction.hpp&gt;
 #include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
@@ -159,7 +160,8 @@
 	isotropicCompaction=false;
 	fixedPorosity = 1;
 	
-	parallel=false;
+	fast=false;
+	noFiles=false;
 
 	
 	
@@ -230,7 +232,8 @@
 	REGISTER_ATTRIBUTE(isotropicCompaction);
 	REGISTER_ATTRIBUTE(fixedPorosity);
 	REGISTER_ATTRIBUTE(fixedBoxDims);
-	REGISTER_ATTRIBUTE(parallel);
+	REGISTER_ATTRIBUTE(fast);
+	REGISTER_ATTRIBUTE(noFiles);
 }
 
 
@@ -267,8 +270,7 @@
 
 	if(importFilename==&quot;&quot;){
 		Vector3r dimensions=upperCorner-lowerCorner; Real volume=dimensions.X()*dimensions.Y()*dimensions.Z();
-		Real really_radiusMean;
-		if(radiusMean&lt;=0) really_radiusMean=pow(volume*(1-porosity)/(Mathr::PI*(4/3.)*numberOfGrains),1/3.);
+		if(radiusMean&lt;=0) radiusMean=pow(volume*(1-porosity)/(Mathr::PI*(4/3.)*numberOfGrains),1/3.);
 		else {
 			bool fixedDims[3];
 			fixedDims[0]=fixedBoxDims.find('x')!=string::npos; fixedDims[1]=fixedBoxDims.find('y')!=string::npos; fixedDims[2]=fixedBoxDims.find('z')!=string::npos;
@@ -278,9 +280,8 @@
 			LOG_INFO(&quot;Mean radius value of &quot;&lt;&lt;radiusMean&lt;&lt;&quot; requested, scaling &quot;&lt;&lt;nScaled&lt;&lt;&quot; dimensions by &quot;&lt;&lt;boxScaleFactor);
 			dimensions[0]*=fixedDims[0]?1.:boxScaleFactor; dimensions[1]*=fixedDims[1]?1.:boxScaleFactor; dimensions[2]*=fixedDims[2]?1.:boxScaleFactor;
 			upperCorner=lowerCorner+dimensions;
-			really_radiusMean=radiusMean;
 		}
-		message+=GenerateCloud(sphere_list, lowerCorner, upperCorner, numberOfGrains, radiusStdDev, really_radiusMean, porosity);
+		message+=GenerateCloud(sphere_list, lowerCorner, upperCorner, numberOfGrains, radiusStdDev, radiusMean, porosity);
 	}
 	else {
 		if(radiusMean&gt;0) LOG_WARN(&quot;radiusMean ignored, since importFilename specified.&quot;);
@@ -573,13 +574,14 @@
 	triaxialcompressionEngine-&gt;maxMultiplier = maxMultiplier;
 	triaxialcompressionEngine-&gt;finalMaxMultiplier = finalMaxMultiplier;
 	triaxialcompressionEngine-&gt;Key = Key;
+	triaxialcompressionEngine-&gt;noFiles=noFiles;
 	triaxialcompressionEngine-&gt;frictionAngleDegree = sphereFrictionDeg;
 	triaxialcompressionEngine-&gt;fixedPorosity = fixedPorosity;
 	triaxialcompressionEngine-&gt;isotropicCompaction = isotropicCompaction;
 	
 	
 	// recording global stress
-	if(recordIntervalIter&gt;0){
+	if(recordIntervalIter&gt;0 &amp;&amp; !noFiles){
 		triaxialStateRecorder = shared_ptr&lt;TriaxialStateRecorder&gt;(new TriaxialStateRecorder);
 		triaxialStateRecorder-&gt; outputFile 		= WallStressRecordFile + Key;
 		triaxialStateRecorder-&gt; interval 		= recordIntervalIter;
@@ -604,8 +606,9 @@
 	rootBody-&gt;engines.clear();
 	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PhysicalActionContainerReseter));
 	rootBody-&gt;engines.push_back(boundingVolumeDispatcher);
-	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PersistentSAPCollider));
-	if(parallel){
+	if(!fast) rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PersistentSAPCollider));
+	else rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new InsertionSortCollider));
+	if(fast){
 		shared_ptr&lt;InteractionDispatchers&gt; ids(new InteractionDispatchers);
 			ids-&gt;geomDispatcher=interactionGeometryDispatcher;
 			ids-&gt;physDispatcher=interactionPhysicsDispatcher;
@@ -626,7 +629,7 @@
 	//rootBody-&gt;engines.push_back(stiffnessMatrixTimeStepper);
 	rootBody-&gt;engines.push_back(globalStiffnessTimeStepper);
 	rootBody-&gt;engines.push_back(triaxialcompressionEngine);
-	if(recordIntervalIter&gt;0) rootBody-&gt;engines.push_back(triaxialStateRecorder);
+	if(recordIntervalIter&gt;0 &amp;&amp; !noFiles) rootBody-&gt;engines.push_back(triaxialStateRecorder);
 	//rootBody-&gt;engines.push_back(gravityCondition);
 	
 	shared_ptr&lt;NewtonsDampedLaw&gt; newton(new NewtonsDampedLaw);
@@ -714,7 +717,7 @@
 					&quot; tries while generating sphere number &quot; +
 					lexical_cast&lt;string&gt;(i+1) + &quot;/&quot; + lexical_cast&lt;string&gt;(number) + &quot;.&quot;;
 	}
-	return &quot;Generated a sample with &quot; + lexical_cast&lt;string&gt;(number) + &quot;spheres inside box of dimensions: (&quot; 
+	return &quot;Generated a sample with &quot; + lexical_cast&lt;string&gt;(number) + &quot; spheres inside box of dimensions: (&quot; 
 			+ lexical_cast&lt;string&gt;(dimensions[0]) + &quot;,&quot; 
 			+ lexical_cast&lt;string&gt;(dimensions[1]) + &quot;,&quot; 
 			+ lexical_cast&lt;string&gt;(dimensions[2]) + &quot;).&quot;;

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.hpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.hpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -104,10 +104,13 @@
 				,saveAnimationSnapshots
 				,biaxial2dTest
 				//!flag to choose an isotropic compaction until a fixed porosity choosing a same translation speed for the six walls
-				,isotropicCompaction;
+				,isotropicCompaction
+				//! do not create any files during run (.xml, .spheres, wall stress records)
+				,noFiles
+				;
 
-				//! Generate parallel simulation
-				bool parallel;
+				//! Generate faster simulation: use InsertionSortCollider and InteractionDispatchers
+				bool fast;
 
 		int		 recordIntervalIter
 				,timeStepUpdateInterval

Modified: trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -96,8 +96,8 @@
 		const shared_ptr&lt;Body&gt;&amp; b2,
 		bool wireFrame)
 {
-	if(!i-&gt;isReal) return;
-	isReal=i-&gt;isReal;
+	if(!i-&gt;isReal()) return;
+	isReal=i-&gt;isReal();
 
 	CohesiveFrictionalContactInteraction*    ph = static_cast&lt;CohesiveFrictionalContactInteraction*&gt;(ih.get());
 	SpheresContactGeometry*    sc = static_cast&lt;SpheresContactGeometry*&gt;(i-&gt;interactionGeometry.get());

Modified: trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -44,7 +44,7 @@
 		const shared_ptr&lt;Body&gt;&amp; b2,
 		bool wireFrame)
 {
-//	if(!i-&gt;isReal) return;
+//	if(!i-&gt;isReal()) return;
 
 	ElasticContactInteraction*    ph = static_cast&lt;ElasticContactInteraction*&gt;(ih.get());
 	SpheresContactGeometry*    sc = static_cast&lt;SpheresContactGeometry*&gt;(i-&gt;interactionGeometry.get());
@@ -76,13 +76,13 @@
 	glEnd();
 
 // draw normal
-	drawArrow(cp, cp+normal*size*0.9 ,Vector3r(0,i-&gt;isReal?1:0.4,0));
+	drawArrow(cp, cp+normal*size*0.9 ,Vector3r(0,i-&gt;isReal()?1:0.4,0));
 // draw prevNormal
-//	drawArrow(middle, middle+ph-&gt;prevNormal*size*0.9 ,Vector3r(i-&gt;isReal?1:0.4,0,0));
+//	drawArrow(middle, middle+ph-&gt;prevNormal*size*0.9 ,Vector3r(i-&gt;isReal()?1:0.4,0,0));
 // draw shearForce
 	maxLength = std::max(maxLength,ph-&gt;shearForce.Length());
 	if(wireFrame) maxLength = 0.0000001;
-	drawArrow(cp, cp+ph-&gt;shearForce*size*10.0/maxLength ,Vector3r(0,0,i-&gt;isReal?1:0.4));
+	drawArrow(cp, cp+ph-&gt;shearForce*size*10.0/maxLength ,Vector3r(0,0,i-&gt;isReal()?1:0.4));
 
 // write A,B
 //	drawFlatText(pos1d,std::string(&quot;  A &quot;) + boost::lexical_cast&lt;std::string&gt;(b1-&gt;getId()));

Modified: trunk/pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry/GLDrawSDECLinkGeometry.cpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry/GLDrawSDECLinkGeometry.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/RenderingEngine/GLDrawSDECLinkGeometry/GLDrawSDECLinkGeometry.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -59,7 +59,7 @@
 		glRotatef(angle*Mathr::RAD_TO_DEG,axis[0],axis[1],axis[2]);
 		
 	// FIXME - we need a way to give parameters from outside, again.... so curerntly this scale is hardcoded here
-		if( (!ip-&gt;isNew) &amp;&amp; /*ip-&gt;isReal &amp;&amp;*/ ip-&gt;interactionPhysics)
+		if(ip-&gt;interactionPhysics)
 		{
 			Real force = el-&gt;normalForce.Length()/600;
 			forceMax = std::max(force,forceMax);

Modified: trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -62,7 +62,7 @@
 			// BUG: would crash with anything else than ElasticContactInteraction; use GLDrawInteractionPhysics for such things
 			/// ElasticContactInteraction* el = static_cast&lt;ElasticContactInteraction*&gt;(ip-&gt;interactionPhysics.get());
 			// FIXME - we need a way to give parameters from outside, again.... so curerntly this scale is hardcoded here
-			if( (!ip-&gt;isNew) &amp;&amp; ip-&gt;isReal &amp;&amp; ip-&gt;interactionPhysics){
+			if( (!ip-&gt;isNew) &amp;&amp; ip-&gt;isReal() &amp;&amp; ip-&gt;interactionPhysics){
 				Real force = el-&gt;normalForce.Length()/600;
 				forceMax = std::max(force,forceMax);
 				Real scale = midMax*(force/forceMax)*0.3;

Modified: trunk/pkg/dem/SConscript
===================================================================
--- trunk/pkg/dem/SConscript	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/dem/SConscript	2009-05-29 14:35:22 UTC (rev 1786)
@@ -702,6 +702,7 @@
 			'Sphere',
 			'AABB',
 			'PersistentSAPCollider',
+			'InsertionSortCollider',
 			'MetaInteractingGeometry2AABB',
 			'TriaxialStressController',
 			'TriaxialCompressionEngine',

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -106,8 +106,6 @@
 			
 			nonLocal-&gt;gaussValue 			= std::exp( - std::pow( dist / len , 2) ) / ( len * sqPi );
 			
-			interaction-&gt;isReal			= true;
-			interaction-&gt;isNew 			= false;
 			interaction-&gt;interactionPhysics 	= nonLocal;
 			nonl-&gt;insert(interaction);
 			*/

Modified: trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -1108,8 +1108,6 @@
 		if( dir2.Dot(beam2-&gt;otherDirection) &lt; 0.999999 )
 			angularSpring-&gt;initialOffPlaneAngle2   *= -1.0;//, angularSpring-&gt;offPlaneSwap2 = true;
 	
-		interaction-&gt;isReal			= true;
-		interaction-&gt;isNew 			= false;
 		interaction-&gt;interactionPhysics 	= angularSpring;
 		ints-&gt;insert(interaction);
 	}

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleCTData.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -462,8 +462,6 @@
 		if( dir2.Dot(beam2-&gt;otherDirection) &lt; 0.999999 )
 			angularSpring-&gt;initialOffPlaneAngle2   *= -1.0;//, angularSpring-&gt;offPlaneSwap2 = true;
 	
-		interaction-&gt;isReal			= true;
-		interaction-&gt;isNew 			= false;
 		interaction-&gt;interactionPhysics 	= angularSpring;
 		ints-&gt;insert(interaction);
 	}

Modified: trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/lattice/PreProcessor/LatticeExampleSimple.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -414,8 +414,6 @@
 		if( dir2.Dot(beam2-&gt;otherDirection) &lt; 0.999999 )
 			angularSpring-&gt;initialOffPlaneAngle2   *= -1.0;//, angularSpring-&gt;offPlaneSwap2 = true;
 	
-		interaction-&gt;isReal			= true;
-		interaction-&gt;isNew 			= false;
 		interaction-&gt;interactionPhysics 	= angularSpring;
 		ints-&gt;insert(interaction);
 	}

Modified: trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp
===================================================================
--- trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -39,7 +39,7 @@
 	for(  ; ii!=iiEnd ; ++ii )
 	{	
 		shared_ptr&lt;Interaction&gt; spring = *ii;
-		if (spring-&gt;isReal)
+		if (spring-&gt;isReal())
 		{
 			int id1 = spring-&gt;getId1();
 			int id2 = spring-&gt;getId2();

Modified: trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp
===================================================================
--- trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/mass-spring/PreProcessor/HangingCloth.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -415,9 +415,6 @@
 	
 					link-&gt;interactionGeometry 		= geometry;
 					link-&gt;interactionPhysics 		= physics;
-					link-&gt;isReal 				= true;
-					link-&gt;isNew 				= false;
-					
 					rootBody-&gt;persistentInteractions-&gt;insert(link);
 					++linksNum;
 				}
@@ -453,9 +450,6 @@
 
 //	spring-&gt;interactionGeometry = geometry;
 	spring-&gt;interactionPhysics = physics;
-	spring-&gt;isReal = true;
-	spring-&gt;isNew = false;
-
 	return spring;
 }
 

Modified: trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp
===================================================================
--- trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/realtime-rigidbody/Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -44,7 +44,7 @@
 	for( ; ii!=iiEnd; ++ii )
 	{
 		shared_ptr&lt;Interaction&gt; contact = *ii;
-		if (contact-&gt;isReal)
+		if (contact-&gt;isReal())
 		{
 			int id1 = contact-&gt;getId1();
 			int id2 = contact-&gt;getId2();

Modified: trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/snow/Engine/Ef2_BssSnowGrain_BssSnowGrain_makeSpheresContactGeometry.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -29,7 +29,7 @@
 	BssSnowGrain* s1=dynamic_cast&lt;BssSnowGrain*&gt;(cm1.get()), *s2=dynamic_cast&lt;BssSnowGrain*&gt;(cm2.get());
 	Vector3r normal=se32.position-se31.position;
 	Real penetrationDepthSq=pow((s1-&gt;radius+s2-&gt;radius),2) - normal.SquaredLength();
-	if (penetrationDepthSq&gt;0 || c-&gt;isReal || assist)
+	if (penetrationDepthSq&gt;0 || c-&gt;isReal() || assist)
 	{
 		shared_ptr&lt;SpheresContactGeometry&gt; scm;
 		if(c-&gt;interactionGeometry) scm=dynamic_pointer_cast&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);

Modified: trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp
===================================================================
--- trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/snow/Engine/ElawSnowLayersDeformation.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -41,7 +41,7 @@
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
 	for (  ; ii!=iiEnd ; ++ii )
 	{
-		if ((*ii)-&gt;isReal)
+		if ((*ii)-&gt;isReal())
 		{
 			const shared_ptr&lt;Interaction&gt;&amp; contact = *ii;
 			int id1 = contact-&gt;getId1();
@@ -175,7 +175,6 @@
 			//		}
 			//	}
 			}
-
 		}
 	}
 }

Modified: trunk/pkg/snow/RenderingEngine/Ef1_IstSnowLayersContact_glDraw.cpp
===================================================================
--- trunk/pkg/snow/RenderingEngine/Ef1_IstSnowLayersContact_glDraw.cpp	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/pkg/snow/RenderingEngine/Ef1_IstSnowLayersContact_glDraw.cpp	2009-05-29 14:35:22 UTC (rev 1786)
@@ -99,7 +99,7 @@
 		const shared_ptr&lt;Body&gt;&amp; b2,
 		bool wireFrame)
 {
-	if(!ip-&gt;isReal)
+	if(!ip-&gt;isReal())
 		return;
 
 	IstSnowLayersContact* sc = static_cast&lt;IstSnowLayersContact*&gt;(ig.get());

Modified: trunk/scripts/test/regular-sphere-pack.py
===================================================================
--- trunk/scripts/test/regular-sphere-pack.py	2009-05-29 12:14:18 UTC (rev 1785)
+++ trunk/scripts/test/regular-sphere-pack.py	2009-05-29 14:35:22 UTC (rev 1786)
@@ -1,3 +1,3 @@
 O.bodies.append(utils.regularSphereOrthoPack([0,0,0],extents=[2,2,2],radius=.1,gap=.1,color=(1,0,1)))
-O.bodies.append(utils.regularSphereOrthoPack([0,0,4],extents=2,radius=.1,gap=.1,color=(0,1,0)))
+O.bodies.append(utils.regularSphereOrthoPack([0,0,4],extents=2,radius=.1,gap=.1,color=(0,1,0),velocity=[0,10,0]))
 


_______________________________________________
Mailing list: <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
Post to     : <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">yade-dev at lists.launchpad.net</A>
Unsubscribe : <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
More help   : <A HREF="https://help.launchpad.net/ListHelp">https://help.launchpad.net/ListHelp</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000997.html">[deprecated list] [Yade-dev] [svn] r1785 - trunk/pkg/snow/Engine
</A></li>
	<LI>Next message: <A HREF="001006.html">[deprecated list] [Yade-dev] [svn] r1787 - in trunk: core	examples/concrete/pack	gui/py	lib/computational-geometry	pkg/common/Engine/MetaEngine	pkg/dem pkg/dem/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1005">[ date ]</a>
              <a href="thread.html#1005">[ thread ]</a>
              <a href="subject.html#1005">[ subject ]</a>
              <a href="author.html#1005">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-dev">More information about the yade-dev
mailing list</a><br>
</body></html>
