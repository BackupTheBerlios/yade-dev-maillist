<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [deprecated list] [Yade-dev] [svn] r1696 - trunk/extra/SpherePadder
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-dev/2009/index.html" >
   <LINK REL="made" HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1696%20-%20trunk/extra/SpherePadder&In-Reply-To=%3C200902261247.n1QClcPQ004802%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000770.html">
   <LINK REL="Next"  HREF="000772.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[deprecated list] [Yade-dev] [svn] r1696 - trunk/extra/SpherePadder</H1>
    <B>richefeu at BerliOS</B> 
    <A HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1696%20-%20trunk/extra/SpherePadder&In-Reply-To=%3C200902261247.n1QClcPQ004802%40sheep.berlios.de%3E"
       TITLE="[deprecated list] [Yade-dev] [svn] r1696 - trunk/extra/SpherePadder">richefeu at mail.berlios.de
       </A><BR>
    <I>Thu Feb 26 13:47:38 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000770.html">[deprecated list] [Yade-dev] [svn] r1695 - trunk/extra/SpherePadder
</A></li>
        <LI>Next message: <A HREF="000772.html">[deprecated list] [Yade-dev] [svn] r1697 - trunk/extra/SpherePadder
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#771">[ date ]</a>
              <a href="thread.html#771">[ thread ]</a>
              <a href="subject.html#771">[ subject ]</a>
              <a href="author.html#771">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: richefeu
Date: 2009-02-26 13:47:38 +0100 (Thu, 26 Feb 2009)
New Revision: 1696

Modified:
   trunk/extra/SpherePadder/SpherePadder.cpp
   trunk/extra/SpherePadder/SpherePadder.hpp
   trunk/extra/SpherePadder/TetraMesh.cpp
   trunk/extra/SpherePadder/main.cpp
Log:
Begin devel. of densification process



Modified: trunk/extra/SpherePadder/SpherePadder.cpp
===================================================================
--- trunk/extra/SpherePadder/SpherePadder.cpp	2009-02-26 08:35:54 UTC (rev 1695)
+++ trunk/extra/SpherePadder/SpherePadder.cpp	2009-02-26 12:47:38 UTC (rev 1696)
@@ -52,8 +52,8 @@
    trace_functions = true;
    meshIsPlugged = false;   
    probeIsDefined = false;          
-   ratio = 5.0; rmoy = 0.0;
-   virtual_radius_factor = 5.0;
+   ratio = 2.0; rmoy = 0.0;
+   virtual_radius_factor = 10.0;
    
 /* FIXME
    pour le moment, l'utilisateur ne peut entre qu'un ratio.
@@ -171,9 +171,8 @@
   place_at_tetra_vertexes ();
   //save_granulo(&quot;tetra_vertexes_granulo.dat&quot;);
   //detect_overlap();
-  //place_virtual_spheres(); // TODO deplacer dans une fonction 'densify' par exemple
+  //place_virtual_spheres();
   
-
   time_t stop_time = clock();
   
   cerr &lt;&lt; &quot;Total number of spheres    = &quot; &lt;&lt; sphere.size() &lt;&lt; endl;
@@ -187,6 +186,37 @@
   cerr &lt;&lt; &quot;Time used = &quot; &lt;&lt; time_used &lt;&lt; &quot; s&quot; &lt;&lt; endl;      
 }
 
+void SpherePadder::densify()
+{
+  //BEGIN_FUNCTION (&quot;Densify&quot;);
+
+  //place_virtual_spheres();
+  for (unsigned int i = 0 ; i &lt; sphere.size() ; i++)
+  {
+	triangulation.insert_node(sphere[i].x, sphere[i].y, sphere[i].z, i, false);
+  }
+
+  tetra_porosity P;
+  if (!tetra_porosities.empty()) tetra_porosities.clear();
+  // if triangulation is empty ...
+  triangulation.init_current_tetrahedron();
+  do
+  {
+	triangulation.current_tetrahedron_get_nodes(P.id1,P.id2,P.id3,P.id4);
+	P.volume = triangulation.current_tetrahedron_get_volume();
+	P.void_volume = P.volume - solid_volume_of_tetrahedron(sphere[P.id1], sphere[P.id2], sphere[P.id3], sphere[P.id4]);
+	tetra_porosities.push_back(P);
+  } while (triangulation.next_tetrahedron());
+  qsort(&amp;(tetra_porosities[0]),tetra_porosities.size(),sizeof(tetra_porosity),compare_tetra_porosity);
+
+  for (unsigned int i = 0 ; i &lt; tetra_porosities.size() ; i++)
+  {
+	cout &lt;&lt; tetra_porosities[i].volume  &lt;&lt; &quot;\t&quot; &lt;&lt; tetra_porosities[i].void_volume &lt;&lt; endl;
+  }
+
+  //END_FUNCTION;
+}
+
 void SpherePadder::tetra_pad() // EN TRAVAUX !!!!!!!!!!!!!!!!!!!!!!!!!
 {
   place_at_nodes();
@@ -277,16 +307,17 @@
 
     // tmp (bricolage)
     if (i &lt; mesh-&gt;node.size())
+	{
       for (unsigned int s = 0 ; s &lt; mesh-&gt;segment.size() ; ++s)
-    {
-      if (mesh-&gt;segment[s].nodeId[0] == i)
-      {
-	  if (mesh-&gt;segment[s].nodeId[1] &lt; mesh-&gt;node.size())
-        fmgpost &lt;&lt; &quot;    &lt;SPSPx antac=\&quot;&quot; &lt;&lt; mesh-&gt;segment[s].nodeId[1] + 1 &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl;
-      }
-    }
+	  {
+		if (mesh-&gt;segment[s].nodeId[0] == i)
+		{
+		if (mesh-&gt;segment[s].nodeId[1] &lt; mesh-&gt;node.size())
+		  fmgpost &lt;&lt; &quot;    &lt;SPSPx antac=\&quot;&quot; &lt;&lt; mesh-&gt;segment[s].nodeId[1] + 1 &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl;
+		}
+	  }
+	}
 
-
     fmgpost &lt;&lt; &quot;   &lt;/body&gt;&quot; &lt;&lt; endl;
   }
 
@@ -970,13 +1001,11 @@
   k = sphere_virtual_radius;
   sphereId = sphere.size();
   
-  
   for (unsigned int f = 0 ; f &lt; mesh-&gt;face.size() ; ++f)
   {
-  
-    if ( mesh-&gt;face[f].belongBoundary == true ) 
-    {
-           
+
+    if (mesh-&gt;face[f].belongBoundary)
+    {  
       current_tetra_id = mesh-&gt;face[f].tetraOwner[0];
       current_tetra = mesh-&gt;tetraedre[current_tetra_id];
     
@@ -1139,7 +1168,7 @@
       S.tetraOwner = current_tetra_id;
       sphere.push_back(S);     
       partition.add(sphereId++,S.x,S.y,S.z);
-    
+
       ///////////////////////////////////////////// 
     }
 
@@ -1415,7 +1444,7 @@
   
 }
 
-
+// point : x,y,z,R
 double SpherePadder::spherical_triangle (double point1[],double point2[],double point3[],double point4[])
 {
 
@@ -1423,7 +1452,6 @@
   if (rayon == 0.0) return 0.0;
   
   double vect12[3], vect13[3], vect14[3];
-  const double pi = 3.14159265;
 
   vect12[0] = point2[0] - point1[0];
   vect12[1] = point2[1] - point1[1];
@@ -1441,6 +1469,10 @@
   double norme13 = sqrt( (vect13[0]*vect13[0]) + (vect13[1]*vect13[1]) + (vect13[2]*vect13[2]) ); 
   double norme14 = sqrt( (vect14[0]*vect14[0]) + (vect14[1]*vect14[1]) + (vect14[2]*vect14[2]) ); 
 
+//   if (norme12 == 0.0) cout &lt;&lt; &quot;sin(A) == 0.0&quot; &lt;&lt; endl;
+//   if (norme13 == 0.0) cout &lt;&lt; &quot;sin(B) == 0.0&quot; &lt;&lt; endl;
+//   if (norme14 == 0.0) cout &lt;&lt; &quot;sin(C) == 0.0&quot; &lt;&lt; endl;
+  
   double A = acos( (vect12[0]*vect13[0] + vect12[1]*vect13[1] + vect12[2]*vect13[2]) / (norme13 * norme12));
   double B = acos( (vect12[0]*vect14[0] + vect12[1]*vect14[1] + vect12[2]*vect14[2]) / (norme14 * norme12));
   double C = acos( (vect14[0]*vect13[0] + vect14[1]*vect13[1] + vect14[2]*vect13[2]) / (norme13 * norme14));
@@ -1449,14 +1481,16 @@
   double b = acos( (cos(B) - cos(C) * cos(A)) / (sin(C) * sin(A)) );
   double c = acos( (cos(C) - cos(A) * cos(B)) / (sin(A) * sin(B)) );
 
+//   if (sin(A) == 0.0) cout &lt;&lt; &quot;sin(A) == 0.0&quot; &lt;&lt; endl;
+//   if (sin(B) == 0.0) cout &lt;&lt; &quot;sin(B) == 0.0&quot; &lt;&lt; endl;
+//   if (sin(C) == 0.0) cout &lt;&lt; &quot;sin(C) == 0.0&quot; &lt;&lt; endl;
+  
+  double aire_triangle_spherique = rayon * rayon * (a + b + c - M_PI);
 
-  double aire_triangle_spherique = rayon * rayon * (a + b + c - pi);
+  double aire_sphere = 4.0 * M_PI * rayon * rayon;
 
-  double aire_sphere = 4 * pi * rayon * rayon;
+  return ( (4.0 * 0.3333333 * M_PI * rayon * rayon * rayon) * (aire_triangle_spherique / aire_sphere) ) ;
 
-  // attention division par zero !!!!
-  return ( (4 * 0.3333333 * pi * rayon * rayon * rayon) * (aire_triangle_spherique / aire_sphere) ) ;
-
 }
 
 

Modified: trunk/extra/SpherePadder/SpherePadder.hpp
===================================================================
--- trunk/extra/SpherePadder/SpherePadder.hpp	2009-02-26 08:35:54 UTC (rev 1695)
+++ trunk/extra/SpherePadder/SpherePadder.hpp	2009-02-26 12:47:38 UTC (rev 1696)
@@ -123,6 +123,7 @@
     // High level pading functions
     void pad_5 ();
     void tetra_pad();
+	void densify();
 
     // void insert_sphere(double x, double y, double z, double R);
     // void densify ();     

Modified: trunk/extra/SpherePadder/TetraMesh.cpp
===================================================================
--- trunk/extra/SpherePadder/TetraMesh.cpp	2009-02-26 08:35:54 UTC (rev 1695)
+++ trunk/extra/SpherePadder/TetraMesh.cpp	2009-02-26 12:47:38 UTC (rev 1696)
@@ -1,322 +1,325 @@
 /*************************************************************************
-*  Copyright (C) 2009 by Jean Francois Jerier                            *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">jerier at geo.hmg.inpg.fr</A>                                                *
-*  Copyright (C) 2009 by Vincent Richefeu                                *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">vincent.richefeu at hmg.inpg.fr</A>                                          *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
+ *  Copyright (C) 2009 by Jean Francois Jerier                            *
+ *  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">jerier at geo.hmg.inpg.fr</A>                                                *
+ *  Copyright (C) 2009 by Vincent Richefeu                                *
+ *  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">vincent.richefeu at hmg.inpg.fr</A>                                          *
+ *                                                                        *
+ *  This program is free software; it is licensed under the terms of the  *
+ *  GNU General Public License v2 or later. See file LICENSE for details. *
+ *************************************************************************/
 
 #include &quot;TetraMesh.hpp&quot;
 
 TetraMesh::TetraMesh ()
 {
-  isOrganized = false;
+    isOrganized = false;
 }
 
+
 void TetraMesh::read_gmsh (const char* name)
 {
-  ifstream meshFile(name);
-  if(!meshFile)
-  {
-    cerr &lt;&lt; &quot;TetraMesh::read_gmsh, cannot open file &quot; &lt;&lt; name &lt;&lt; endl;
-    return;
-  }
-
-  string token;
-  char not_read[150];
-  meshFile &gt;&gt; token;
-
-  while(meshFile)
-  {
-    if (token == &quot;$Nodes&quot;)
+    ifstream meshFile(name);
+    if(!meshFile)
     {
-      unsigned int nbnodes;
-      unsigned int num_node;
-      Node N;
-
-      meshFile &gt;&gt; nbnodes;
-      for (unsigned int n = 0 ; n &lt; nbnodes ; ++n)
-      {
-        meshFile &gt;&gt; num_node &gt;&gt; N.x &gt;&gt; N.y &gt;&gt; N.z;
-cout &lt;&lt; num_node &lt;&lt; &quot; &quot; &lt;&lt; N.x &lt;&lt; &quot;&quot; &lt;&lt; N.y &lt;&lt; &quot; &quot; &lt;&lt; N.z &lt;&lt; endl;
-        node.push_back(N);
-      }
+        cerr &lt;&lt; &quot;TetraMesh::read_gmsh, cannot open file &quot; &lt;&lt; name &lt;&lt; endl;
+        return;
     }
 
-    if (token == &quot;$Elements&quot;)
-    {
-      unsigned int nbElements;
-      unsigned int num_element, element_type, nbTags ;
-      Tetraedre T;
-      unsigned int t = 0;
+    string token;
+    char not_read[150];
+    meshFile &gt;&gt; token;
 
-      meshFile &gt;&gt; nbElements;
-      for (unsigned int e = 0 ; e &lt; nbElements ; ++e)
-      {
-        meshFile &gt;&gt; num_element &gt;&gt; element_type;
-        if (element_type != 4)  // 4-node tetrahedron
+    while(meshFile)
+    {
+        if (token == &quot;$Nodes&quot;)
         {
-          meshFile.getline(not_read,150);
-          continue;
+            unsigned int nbnodes;
+            unsigned int num_node;
+            Node N;
+
+            meshFile &gt;&gt; nbnodes;
+            for (unsigned int n = 0 ; n &lt; nbnodes ; ++n)
+            {
+                meshFile &gt;&gt; num_node &gt;&gt; N.x &gt;&gt; N.y &gt;&gt; N.z;
+                // cout &lt;&lt; num_node &lt;&lt; &quot; &quot; &lt;&lt; N.x &lt;&lt; &quot;&quot; &lt;&lt; N.y &lt;&lt; &quot; &quot; &lt;&lt; N.z &lt;&lt; endl;
+                node.push_back(N);
+            }
         }
 
+        if (token == &quot;$Elements&quot;)
+        {
+            unsigned int nbElements;
+            unsigned int num_element, element_type, nbTags ;
+            Tetraedre T;
+            unsigned int t = 0;
 
-        meshFile &gt;&gt; nbTags;
-        // the third tag is the number of a mesh partition to which the element belongs
-        unsigned int tag;
-        for (unsigned int tg = 0 ; tg &lt; nbTags ; ++(tg))
-        { meshFile &gt;&gt; tag; }
+            meshFile &gt;&gt; nbElements;
+            for (unsigned int e = 0 ; e &lt; nbElements ; ++e)
+            {
+                meshFile &gt;&gt; num_element &gt;&gt; element_type;
+                                 // 4-node tetrahedron
+                if (element_type != 4)
+                {
+                    meshFile.getline(not_read,150);
+                    continue;
+                }
 
-        meshFile &gt;&gt; T.nodeId[0] &gt;&gt; T.nodeId[1] &gt;&gt; T.nodeId[2] &gt;&gt; T.nodeId[3];
+                meshFile &gt;&gt; nbTags;
+                // the third tag is the number of a mesh partition to which the element belongs
+                unsigned int tag;
+                for (unsigned int tg = 0 ; tg &lt; nbTags ; ++(tg))
+                    { meshFile &gt;&gt; tag; }
 
-        // numbers begin at 0 instead of 1
-        // (0 in C/C++ corresponds to 1 in the file)
-        T.nodeId[0] -= 1;
-        T.nodeId[1] -= 1;
-        T.nodeId[2] -= 1;
-        T.nodeId[3] -= 1;
+                    meshFile &gt;&gt; T.nodeId[0] &gt;&gt; T.nodeId[1] &gt;&gt; T.nodeId[2] &gt;&gt; T.nodeId[3];
 
-        node[T.nodeId[0]].tetraOwner.push_back(t);
-        node[T.nodeId[1]].tetraOwner.push_back(t);
-        node[T.nodeId[2]].tetraOwner.push_back(t);
-        node[T.nodeId[3]].tetraOwner.push_back(t);
+                // numbers begin at 0 instead of 1
+                // (0 in C/C++ corresponds to 1 in the file)
+                T.nodeId[0] -= 1;
+                T.nodeId[1] -= 1;
+                T.nodeId[2] -= 1;
+                T.nodeId[3] -= 1;
 
-        tetraedre.push_back(T);
-        ++t;
-      }
-    }
+                node[T.nodeId[0]].tetraOwner.push_back(t);
+                node[T.nodeId[1]].tetraOwner.push_back(t);
+                node[T.nodeId[2]].tetraOwner.push_back(t);
+                node[T.nodeId[3]].tetraOwner.push_back(t);
 
-    if (token == &quot;$EndElements&quot;) break;
+                tetraedre.push_back(T);
+                ++t;
+            }
+        }
 
-    meshFile &gt;&gt; token;
-  }
+        if (token == &quot;$EndElements&quot;) break;
 
-  organize ();
+        meshFile &gt;&gt; token;
+    }
+
+    organize ();
 }
 
+
 void TetraMesh::read (const char* name)
 {
-	ifstream meshFile(name);
-	if(!meshFile)
-	{
-		cerr &lt;&lt; &quot;TetraMesh::read_data, cannot open file &quot; &lt;&lt; name &lt;&lt; endl;
-		return;
-	}
+    ifstream meshFile(name);
+    if(!meshFile)
+    {
+        cerr &lt;&lt; &quot;TetraMesh::read_data, cannot open file &quot; &lt;&lt; name &lt;&lt; endl;
+        return;
+    }
 
-	string token;
-	meshFile &gt;&gt; token;
-        bool with_numbers = false;
-        unsigned int number;
+    string token;
+    meshFile &gt;&gt; token;
+    bool with_numbers = false;
+    unsigned int number;
 
-	while(meshFile)
-	{
-                if (token == &quot;WITH_NUMBERS&quot;) with_numbers = true;
-		if (token == &quot;NODES&quot;)
-		{
-			unsigned int nbnodes;
-			Node N;
+    while(meshFile)
+    {
+        if (token == &quot;WITH_NUMBERS&quot;) with_numbers = true;
+        if (token == &quot;NODES&quot;)
+        {
+            unsigned int nbnodes;
+            Node N;
 
-			meshFile &gt;&gt; nbnodes;
-			for (unsigned int n = 0 ; n &lt; nbnodes ; ++n)
-			{
-                          if (with_numbers) meshFile &gt;&gt; number;
-				meshFile &gt;&gt; N.x &gt;&gt; N.y &gt;&gt; N.z;
+            meshFile &gt;&gt; nbnodes;
+            for (unsigned int n = 0 ; n &lt; nbnodes ; ++n)
+            {
+                if (with_numbers) meshFile &gt;&gt; number;
+                meshFile &gt;&gt; N.x &gt;&gt; N.y &gt;&gt; N.z;
 
-				//cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; N.x &lt;&lt; &quot; &quot; &lt;&lt; N.y &lt;&lt; &quot; &quot; &lt;&lt; N.z &lt;&lt; endl;
-				node.push_back(N);
-			}
-		}
+                //cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; N.x &lt;&lt; &quot; &quot; &lt;&lt; N.y &lt;&lt; &quot; &quot; &lt;&lt; N.z &lt;&lt; endl;
+                node.push_back(N);
+            }
+        }
 
-		if (token == &quot;TETRA&quot;)
-		{
-			unsigned int nbTetra;
-unsigned int nbignored = 0;
-			Tetraedre T;
+        if (token == &quot;TETRA&quot;)
+        {
+            unsigned int nbTetra;
+            unsigned int nbignored = 0;
+            Tetraedre T;
 
-			meshFile &gt;&gt; nbTetra;
-			for (unsigned int t = 0 ; t &lt; nbTetra ; ++t)
-			{
-                          if (with_numbers) meshFile &gt;&gt; number;
-				meshFile &gt;&gt; T.nodeId[0] &gt;&gt; T.nodeId[1] &gt;&gt; T.nodeId[2] &gt;&gt; T.nodeId[3];
+            meshFile &gt;&gt; nbTetra;
+            for (unsigned int t = 0 ; t &lt; nbTetra ; ++t)
+            {
+                if (with_numbers) meshFile &gt;&gt; number;
+                meshFile &gt;&gt; T.nodeId[0] &gt;&gt; T.nodeId[1] &gt;&gt; T.nodeId[2] &gt;&gt; T.nodeId[3];
 
-				//cout &lt;&lt; t &lt;&lt; &quot; | &quot; &lt;&lt; T.nodeId[0] &lt;&lt; &quot; &quot; &lt;&lt;  T.nodeId[1] &lt;&lt; &quot; &quot; &lt;&lt; T.nodeId[2] &lt;&lt; &quot; &quot; &lt;&lt; T.nodeId[3] &lt;&lt; endl;
+                //cout &lt;&lt; t &lt;&lt; &quot; | &quot; &lt;&lt; T.nodeId[0] &lt;&lt; &quot; &quot; &lt;&lt;  T.nodeId[1] &lt;&lt; &quot; &quot; &lt;&lt; T.nodeId[2] &lt;&lt; &quot; &quot; &lt;&lt; T.nodeId[3] &lt;&lt; endl;
 
-				// numbers begin at 0 instead of 1
-				// (0 in C/C++ corresponds to 1 in the file)
-				T.nodeId[0] -= 1;
-				T.nodeId[1] -= 1;
-				T.nodeId[2] -= 1;
-				T.nodeId[3] -= 1;
+                // numbers begin at 0 instead of 1
+                // (0 in C/C++ corresponds to 1 in the file)
+                T.nodeId[0] -= 1;
+                T.nodeId[1] -= 1;
+                T.nodeId[2] -= 1;
+                T.nodeId[3] -= 1;
 
-				if (T.nodeId[0] &gt;= node.size() || T.nodeId[1] &gt;= node.size() || T.nodeId[2] &gt;= node.size() || T.nodeId[3] &gt;= node.size())
-				{
-				nbignored++;
-				//cerr &lt;&lt; &quot;(1) error in mesh file, tetrahedron ignored! nbignored = &quot; &lt;&lt; nbignored &lt;&lt; endl;
-				continue;
-				}
-				if (T.nodeId[0] &lt; 0 || T.nodeId[1] &lt; 0 || T.nodeId[2] &lt; 0 || T.nodeId[3] &lt; 0)
-				{
-				nbignored++;
-				//cerr &lt;&lt; &quot;(2) error in mesh file, tetrahedron ignored! nbignored = &quot; &lt;&lt; nbignored &lt;&lt; endl;
-				continue;
-				}
-				//cout &lt;&lt; &quot;num = &quot; &lt;&lt; (t-nbignored) &lt;&lt; endl;
+                if (T.nodeId[0] &gt;= node.size() || T.nodeId[1] &gt;= node.size() || T.nodeId[2] &gt;= node.size() || T.nodeId[3] &gt;= node.size())
+                {
+                    nbignored++;
+                    //cerr &lt;&lt; &quot;(1) error in mesh file, tetrahedron ignored! nbignored = &quot; &lt;&lt; nbignored &lt;&lt; endl;
+                    continue;
+                }
+                if (T.nodeId[0] &lt; 0 || T.nodeId[1] &lt; 0 || T.nodeId[2] &lt; 0 || T.nodeId[3] &lt; 0)
+                {
+                    nbignored++;
+                    //cerr &lt;&lt; &quot;(2) error in mesh file, tetrahedron ignored! nbignored = &quot; &lt;&lt; nbignored &lt;&lt; endl;
+                    continue;
+                }
+                //cout &lt;&lt; &quot;num = &quot; &lt;&lt; (t-nbignored) &lt;&lt; endl;
 
-				node[T.nodeId[0]].tetraOwner.push_back(t-nbignored);
-				node[T.nodeId[1]].tetraOwner.push_back(t-nbignored);
-				node[T.nodeId[2]].tetraOwner.push_back(t-nbignored);
-				node[T.nodeId[3]].tetraOwner.push_back(t-nbignored);
+                node[T.nodeId[0]].tetraOwner.push_back(t-nbignored);
+                node[T.nodeId[1]].tetraOwner.push_back(t-nbignored);
+                node[T.nodeId[2]].tetraOwner.push_back(t-nbignored);
+                node[T.nodeId[3]].tetraOwner.push_back(t-nbignored);
 
-				tetraedre.push_back(T);
+                tetraedre.push_back(T);
 
-			}
-		}
+            }
+        }
 
-		if (token == &quot;EOF&quot;) break;
+        if (token == &quot;EOF&quot;) break;
 
-		meshFile &gt;&gt; token;
-	}
+        meshFile &gt;&gt; token;
+    }
 
-	organize ();
+    organize ();
 }
 
+
 void TetraMesh::write_surface_MGP (const char* name)
 {
-  ofstream fmgpost(name);
+    ofstream fmgpost(name);
 
-  fmgpost &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&quot; &lt;&lt; endl
-          &lt;&lt; &quot; &lt;mgpost mode=\&quot;3D\&quot;&gt;&quot; &lt;&lt; endl
-          &lt;&lt; &quot;  &lt;state id=\&quot;&quot; &lt;&lt; 1
-          &lt;&lt; &quot;\&quot; time=\&quot;&quot; &lt;&lt; 0.0 &lt;&lt; &quot;\&quot;&gt;&quot; &lt;&lt; endl;
+    fmgpost &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&quot; &lt;&lt; endl
+        &lt;&lt; &quot; &lt;mgpost mode=\&quot;3D\&quot;&gt;&quot; &lt;&lt; endl
+        &lt;&lt; &quot;  &lt;state id=\&quot;&quot; &lt;&lt; 1
+        &lt;&lt; &quot;\&quot; time=\&quot;&quot; &lt;&lt; 0.0 &lt;&lt; &quot;\&quot;&gt;&quot; &lt;&lt; endl;
 
-  double xm,ym,zm;
-  unsigned int id1,id2,id3;
-  unsigned int idPolyhedron = 1;
-  double div3 = 0.3333333333333333;
-  for (unsigned int i = 0 ; i &lt; face.size() ; ++i)
-  {
-	if(!(face[i].belongBoundary)) continue;
-	id1 = face[i].nodeId[0];
-	id2 = face[i].nodeId[1];
-	id3 = face[i].nodeId[2];
-	xm = div3 * (node[id1].x + node[id2].x + node[id3].x);
-	ym = div3 * (node[id1].y + node[id2].y + node[id3].y);
-	zm = div3 * (node[id1].z + node[id2].z + node[id3].z);
+    double xm,ym,zm;
+    unsigned int id1,id2,id3;
+    unsigned int idPolyhedron = 1;
+    double div3 = 0.3333333333333333;
+    for (unsigned int i = 0 ; i &lt; face.size() ; ++i)
+    {
+        if(!(face[i].belongBoundary)) continue;
+        id1 = face[i].nodeId[0];
+        id2 = face[i].nodeId[1];
+        id3 = face[i].nodeId[2];
+        xm = div3 * (node[id1].x + node[id2].x + node[id3].x);
+        ym = div3 * (node[id1].y + node[id2].y + node[id3].y);
+        zm = div3 * (node[id1].z + node[id2].z + node[id3].z);
 
-    fmgpost &lt;&lt; &quot;   &lt;body&gt;&quot; &lt;&lt; endl;
-    fmgpost &lt;&lt; &quot;    &lt;POLYE id=\&quot;&quot; &lt;&lt; idPolyhedron++ &lt;&lt; &quot;\&quot; r=\&quot;&quot; &lt;&lt; min_segment_length &lt;&lt; &quot;\&quot;&gt;&quot; &lt;&lt; endl
+        fmgpost &lt;&lt; &quot;   &lt;body&gt;&quot; &lt;&lt; endl;
+        fmgpost &lt;&lt; &quot;    &lt;POLYE id=\&quot;&quot; &lt;&lt; idPolyhedron++ &lt;&lt; &quot;\&quot; r=\&quot;&quot; &lt;&lt; min_segment_length &lt;&lt; &quot;\&quot;&gt;&quot; &lt;&lt; endl
             &lt;&lt; &quot;     &lt;position x=\&quot;&quot; &lt;&lt; xm + xtrans &lt;&lt; &quot;\&quot; y=\&quot;&quot; &lt;&lt; ym + ytrans &lt;&lt; &quot;\&quot; z=\&quot;&quot; &lt;&lt; zm + ztrans &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl
             &lt;&lt; &quot;     &lt;node x=\&quot;&quot; &lt;&lt; node[id1].x - xm &lt;&lt; &quot;\&quot; y=\&quot;&quot; &lt;&lt; node[id1].y - ym &lt;&lt; &quot;\&quot; z=\&quot;&quot; &lt;&lt; node[id1].z - zm &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl
             &lt;&lt; &quot;     &lt;node x=\&quot;&quot; &lt;&lt; node[id2].x - xm &lt;&lt; &quot;\&quot; y=\&quot;&quot; &lt;&lt; node[id2].y - ym &lt;&lt; &quot;\&quot; z=\&quot;&quot; &lt;&lt; node[id2].z - zm &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl
             &lt;&lt; &quot;     &lt;node x=\&quot;&quot; &lt;&lt; node[id3].x - xm &lt;&lt; &quot;\&quot; y=\&quot;&quot; &lt;&lt; node[id3].y - ym &lt;&lt; &quot;\&quot; z=\&quot;&quot; &lt;&lt; node[id3].z - zm &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl;
 
-     if (face[i].normal_swap)
-       fmgpost &lt;&lt; &quot;     &lt;face n1=\&quot;&quot; &lt;&lt; 0 &lt;&lt; &quot;\&quot; n2=\&quot;&quot; &lt;&lt; 2 &lt;&lt; &quot;\&quot; n3=\&quot;&quot; &lt;&lt; 1 &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl;
-     else
-       fmgpost &lt;&lt; &quot;     &lt;face n1=\&quot;&quot; &lt;&lt; 0 &lt;&lt; &quot;\&quot; n2=\&quot;&quot; &lt;&lt; 1 &lt;&lt; &quot;\&quot; n3=\&quot;&quot; &lt;&lt; 2 &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl;
+        if (face[i].normal_swap)
+            fmgpost &lt;&lt; &quot;     &lt;face n1=\&quot;&quot; &lt;&lt; 0 &lt;&lt; &quot;\&quot; n2=\&quot;&quot; &lt;&lt; 2 &lt;&lt; &quot;\&quot; n3=\&quot;&quot; &lt;&lt; 1 &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl;
+        else
+            fmgpost &lt;&lt; &quot;     &lt;face n1=\&quot;&quot; &lt;&lt; 0 &lt;&lt; &quot;\&quot; n2=\&quot;&quot; &lt;&lt; 1 &lt;&lt; &quot;\&quot; n3=\&quot;&quot; &lt;&lt; 2 &lt;&lt; &quot;\&quot;/&gt;&quot; &lt;&lt; endl;
 
-    fmgpost &lt;&lt; &quot;    &lt;/POLYE&gt;&quot; &lt;&lt; endl &lt;&lt; flush;
+        fmgpost &lt;&lt; &quot;    &lt;/POLYE&gt;&quot; &lt;&lt; endl &lt;&lt; flush;
 
-    fmgpost &lt;&lt; &quot;   &lt;/body&gt;&quot; &lt;&lt; endl;
-  }
-  
-  fmgpost &lt;&lt; &quot;  &lt;/state&gt;&quot; &lt;&lt; endl
-          &lt;&lt; &quot; &lt;/mgpost&gt;&quot; &lt;&lt; endl;
+        fmgpost &lt;&lt; &quot;   &lt;/body&gt;&quot; &lt;&lt; endl;
+    }
+
+    fmgpost &lt;&lt; &quot;  &lt;/state&gt;&quot; &lt;&lt; endl
+        &lt;&lt; &quot; &lt;/mgpost&gt;&quot; &lt;&lt; endl;
 }
 
 
-
 int compareInt (const void * a, const void * b)
 {
-	return ( *(int*)a &gt; *(int*)b ) ? 1 :-1;
+    return ( *(int*)a &gt; *(int*)b ) ? 1 :-1;
 }
 
+
 void TetraMesh::organize ()
 {
-	// Translate all nodes in such a manner that all coordinates are &gt; 0
-	xtrans = node[0].x;
-	ytrans = node[0].y;
-	ztrans = node[0].z;
-	for (unsigned int i = 1 ; i &lt; node.size() ; ++i)
-	{
-		xtrans = (xtrans &lt; node[i].x) ? xtrans : node[i].x;
-		ytrans = (ytrans &lt; node[i].y) ? ytrans : node[i].y;
-		ztrans = (ztrans &lt; node[i].z) ? ztrans : node[i].z;
-	}
-	xtrans = (xtrans &lt; 0.0) ? -xtrans : 0.0;
-	ytrans = (ytrans &lt; 0.0) ? -ytrans : 0.0;
-	ztrans = (ztrans &lt; 0.0) ? -ztrans : 0.0;
-	for (unsigned int i = 0 ; i &lt; node.size() ; ++i)
-	{
-		node[i].x += xtrans;
-		node[i].y += ytrans;
-		node[i].z += ztrans;
-	}
+    // Translate all nodes in such a manner that all coordinates are &gt; 0
+    xtrans = node[0].x;
+    ytrans = node[0].y;
+    ztrans = node[0].z;
+    for (unsigned int i = 1 ; i &lt; node.size() ; ++i)
+    {
+        xtrans = (xtrans &lt; node[i].x) ? xtrans : node[i].x;
+        ytrans = (ytrans &lt; node[i].y) ? ytrans : node[i].y;
+        ztrans = (ztrans &lt; node[i].z) ? ztrans : node[i].z;
+    }
+    xtrans = (xtrans &lt; 0.0) ? -xtrans : 0.0;
+    ytrans = (ytrans &lt; 0.0) ? -ytrans : 0.0;
+    ztrans = (ztrans &lt; 0.0) ? -ztrans : 0.0;
+    for (unsigned int i = 0 ; i &lt; node.size() ; ++i)
+    {
+        node[i].x += xtrans;
+        node[i].y += ytrans;
+        node[i].z += ztrans;
+    }
 
-	// Organize tetraedre nodes in ascending order
-	for (unsigned int i = 0 ; i &lt; tetraedre.size() ; ++i)
-	{
-		qsort (&amp;(tetraedre[i].nodeId[0]), 4, sizeof(int), compareInt);
-	}
+    // Organize tetraedre nodes in ascending order
+    for (unsigned int i = 0 ; i &lt; tetraedre.size() ; ++i)
+    {
+        qsort (&amp;(tetraedre[i].nodeId[0]), 4, sizeof(int), compareInt);
+    }
 
-	// Face creation
-	vector &lt;Face&gt; tmpFace; // This will contain all faces more than one time (with duplications)
-	Face F;
-	F.tetraOwner.push_back(0);
-	F.belongBoundary = true;
+    // Face creation
+    vector &lt;Face&gt; tmpFace;       // This will contain all faces more than one time (with duplications)
+    Face F;
+    F.tetraOwner.push_back(0);
+    F.belongBoundary = true;
     F.normal_swap    = false;
-	for (unsigned int i = 0 ; i &lt; tetraedre.size() ; ++i)
-	{
-		F.tetraOwner[0] = i;
+    for (unsigned int i = 0 ; i &lt; tetraedre.size() ; ++i)
+    {
+        F.tetraOwner[0] = i;
 
-		// Notice that nodes are still organized in ascending order
-		F.nodeId[0] = tetraedre[i].nodeId[0];
-		F.nodeId[1] = tetraedre[i].nodeId[1];
-		F.nodeId[2] = tetraedre[i].nodeId[2];
-		tmpFace.push_back(F);
+        // Notice that nodes are still organized in ascending order
+        F.nodeId[0] = tetraedre[i].nodeId[0];
+        F.nodeId[1] = tetraedre[i].nodeId[1];
+        F.nodeId[2] = tetraedre[i].nodeId[2];
+        tmpFace.push_back(F);
 
-		F.nodeId[0] = tetraedre[i].nodeId[1];
-		F.nodeId[1] = tetraedre[i].nodeId[2];
-		F.nodeId[2] = tetraedre[i].nodeId[3];
-		tmpFace.push_back(F);
+        F.nodeId[0] = tetraedre[i].nodeId[1];
+        F.nodeId[1] = tetraedre[i].nodeId[2];
+        F.nodeId[2] = tetraedre[i].nodeId[3];
+        tmpFace.push_back(F);
 
-		F.nodeId[0] = tetraedre[i].nodeId[0];
-		F.nodeId[1] = tetraedre[i].nodeId[2];
-		F.nodeId[2] = tetraedre[i].nodeId[3];
-		tmpFace.push_back(F);
+        F.nodeId[0] = tetraedre[i].nodeId[0];
+        F.nodeId[1] = tetraedre[i].nodeId[2];
+        F.nodeId[2] = tetraedre[i].nodeId[3];
+        tmpFace.push_back(F);
 
-		F.nodeId[0] = tetraedre[i].nodeId[0];
-		F.nodeId[1] = tetraedre[i].nodeId[1];
-		F.nodeId[2] = tetraedre[i].nodeId[3];
-		tmpFace.push_back(F);
-	}
+        F.nodeId[0] = tetraedre[i].nodeId[0];
+        F.nodeId[1] = tetraedre[i].nodeId[1];
+        F.nodeId[2] = tetraedre[i].nodeId[3];
+        tmpFace.push_back(F);
+    }
 
-	face.push_back(tmpFace[0]);
-	bool duplicated;
-	for (unsigned int i = 1 ; i &lt; tmpFace.size() ; ++i)
-	{
-		duplicated = false;
-		for (unsigned int n = 0 ; n &lt; face.size() ; ++n)
-		{
-			if (   tmpFace[i].nodeId[0] == face[n].nodeId[0]
-			    &amp;&amp; tmpFace[i].nodeId[1] == face[n].nodeId[1]
-			    &amp;&amp; tmpFace[i].nodeId[2] == face[n].nodeId[2])
-			{
-				duplicated = true;
-				face[n].tetraOwner.push_back(tmpFace[i].tetraOwner[0]);
-				face[n].belongBoundary = false;
-				break;
-			}
-		}
+    face.push_back(tmpFace[0]);
+    bool duplicated;
+    for (unsigned int i = 1 ; i &lt; tmpFace.size() ; ++i)
+    {
+        duplicated = false;
+        for (unsigned int n = 0 ; n &lt; face.size() ; ++n)
+        {
+            if (   tmpFace[i].nodeId[0] == face[n].nodeId[0]
+                &amp;&amp; tmpFace[i].nodeId[1] == face[n].nodeId[1]
+                &amp;&amp; tmpFace[i].nodeId[2] == face[n].nodeId[2])
+            {
+                duplicated = true;
+                face[n].tetraOwner.push_back(tmpFace[i].tetraOwner[0]);
+                face[n].belongBoundary = false;
+                break;
+            }
+        }
 
-		if (!duplicated)
-		{
-			face.push_back(tmpFace[i]);
-		}
-	}
-	tmpFace.clear(); // It should be usefull to free memory before the end of the function
+        if (!duplicated)
+        {
+            face.push_back(tmpFace[i]);
+        }
+    }
+    tmpFace.clear();             // It should be usefull to free memory before the end of the function
 
     // Definition of unit vectors normal to the boundary faces
     unsigned int n1,n2,n3,n4;
@@ -326,186 +329,181 @@
     double scal_product;
     for (unsigned int f = 0 ; f &lt; face.size() ; ++f)
     {
-      if (!(face[f].belongBoundary)) continue;
+        if (!(face[f].belongBoundary)) continue;
 
-      current_tetra = tetraedre[ face[f].tetraOwner[0] ];
+        current_tetra = tetraedre[ face[f].tetraOwner[0] ];
 
-      n1 = current_tetra.nodeId[0];
-      n2 = current_tetra.nodeId[1];
-      n3 = current_tetra.nodeId[2];
-      n4 = current_tetra.nodeId[3];
+        n1 = current_tetra.nodeId[0];
+        n2 = current_tetra.nodeId[1];
+        n3 = current_tetra.nodeId[2];
+        n4 = current_tetra.nodeId[3];
 
-      s1 = face[f].nodeId[0];
-      s2 = face[f].nodeId[1];
-      s3 = face[f].nodeId[2];
+        s1 = face[f].nodeId[0];
+        s2 = face[f].nodeId[1];
+        s3 = face[f].nodeId[2];
 
-      if      ((n1 != s1) &amp;&amp; (n1 != s2) &amp;&amp; (n1 != s3)) {s4 = n1;}
-      else if ((n2 != s1) &amp;&amp; (n2 != s2) &amp;&amp; (n2 != s3)) {s4 = n2;}
-      else if ((n3 != s1) &amp;&amp; (n3 != s2) &amp;&amp; (n3 != s3)) {s4 = n3;}
-      else                                             {s4 = n4;}
+        if      ((n1 != s1) &amp;&amp; (n1 != s2) &amp;&amp; (n1 != s3)) {s4 = n1;}
+        else if ((n2 != s1) &amp;&amp; (n2 != s2) &amp;&amp; (n2 != s3)) {s4 = n2;}
+        else if ((n3 != s1) &amp;&amp; (n3 != s2) &amp;&amp; (n3 != s3)) {s4 = n3;}
+        else                                             {s4 = n4;}
 
-	  v12[0] = node[s2].x - node[s1].x;
-	  v12[1] = node[s2].y - node[s1].y;
-	  v12[2] = node[s2].z - node[s1].z;
+        v12[0] = node[s2].x - node[s1].x;
+        v12[1] = node[s2].y - node[s1].y;
+        v12[2] = node[s2].z - node[s1].z;
 
-	  v13[0] = node[s3].x - node[s1].x;
-	  v13[1] = node[s3].y - node[s1].y;
-	  v13[2] = node[s3].z - node[s1].z;
+        v13[0] = node[s3].x - node[s1].x;
+        v13[1] = node[s3].y - node[s1].y;
+        v13[2] = node[s3].z - node[s1].z;
 
-	  v14[0] = node[s4].x - node[s1].x;
-	  v14[1] = node[s4].y - node[s1].y;
-	  v14[2] = node[s4].z - node[s1].z;
+        v14[0] = node[s4].x - node[s1].x;
+        v14[1] = node[s4].y - node[s1].y;
+        v14[2] = node[s4].z - node[s1].z;
 
-	  vect_product[0] = v12[1]*v13[2] - v12[2]*v13[1];
-	  vect_product[1] = v12[2]*v13[0] - v12[0]*v13[2];
-	  vect_product[2] = v12[0]*v13[1] - v12[1]*v13[0];
+        vect_product[0] = v12[1]*v13[2] - v12[2]*v13[1];
+        vect_product[1] = v12[2]*v13[0] - v12[0]*v13[2];
+        vect_product[2] = v12[0]*v13[1] - v12[1]*v13[0];
 
-	  scal_product = v14[0]*vect_product[0] + v14[1]*vect_product[1] + v14[2]*vect_product[2];
+        scal_product = v14[0]*vect_product[0] + v14[1]*vect_product[1] + v14[2]*vect_product[2];
 
-	  if (scal_product &gt; 0.0) face[f].normal_swap = true;
+        if (scal_product &gt; 0.0) face[f].normal_swap = true;
     }
 
-
     // Define for each node the faces it belong to
-	for (unsigned int f = 0 ; f &lt; face.size() ; ++f)
-	{
-		node[face[f].nodeId[0]].faceOwner.push_back(f);
-		node[face[f].nodeId[1]].faceOwner.push_back(f);
-		node[face[f].nodeId[2]].faceOwner.push_back(f);
-	}
+    for (unsigned int f = 0 ; f &lt; face.size() ; ++f)
+    {
+        node[face[f].nodeId[0]].faceOwner.push_back(f);
+        node[face[f].nodeId[1]].faceOwner.push_back(f);
+        node[face[f].nodeId[2]].faceOwner.push_back(f);
+    }
 
-	// Segment creation
-	vector &lt;Segment&gt; tmpSegment;
-	Segment S;
-	S.faceOwner.push_back(0);
+    // Segment creation
+    vector &lt;Segment&gt; tmpSegment;
+    Segment S;
+    S.faceOwner.push_back(0);
 
-	for (unsigned int i = 0 ; i &lt; face.size() ; ++i)
-	{
-		S.faceOwner[0] = i;
-		S.nodeId[0] = face[i].nodeId[0];
-		S.nodeId[1] = face[i].nodeId[1];
-		tmpSegment.push_back(S);
+    for (unsigned int i = 0 ; i &lt; face.size() ; ++i)
+    {
+        S.faceOwner[0] = i;
+        S.nodeId[0] = face[i].nodeId[0];
+        S.nodeId[1] = face[i].nodeId[1];
+        tmpSegment.push_back(S);
 
-		S.nodeId[0] = face[i].nodeId[1];
-		S.nodeId[1] = face[i].nodeId[2];
-		tmpSegment.push_back(S);
+        S.nodeId[0] = face[i].nodeId[1];
+        S.nodeId[1] = face[i].nodeId[2];
+        tmpSegment.push_back(S);
 
-		S.nodeId[0] = face[i].nodeId[0];
-		S.nodeId[1] = face[i].nodeId[2];
-		tmpSegment.push_back(S);
-	}
+        S.nodeId[0] = face[i].nodeId[0];
+        S.nodeId[1] = face[i].nodeId[2];
+        tmpSegment.push_back(S);
+    }
 
-	segment.push_back(tmpSegment[0]);
-	for (unsigned int i = 1 ; i &lt; tmpSegment.size() ; ++i)
-	{
-		duplicated = false;
-		for (unsigned int n = 0 ; n &lt; segment.size() ; ++n)
-		{
-			if (   tmpSegment[i].nodeId[0] == segment[n].nodeId[0]
-			    &amp;&amp; tmpSegment[i].nodeId[1] == segment[n].nodeId[1])
-			{
-				duplicated = true;
-				segment[n].faceOwner.push_back(tmpSegment[i].faceOwner[0]);
-				break;
-			}
+    segment.push_back(tmpSegment[0]);
+    for (unsigned int i = 1 ; i &lt; tmpSegment.size() ; ++i)
+    {
+        duplicated = false;
+        for (unsigned int n = 0 ; n &lt; segment.size() ; ++n)
+        {
+            if (   tmpSegment[i].nodeId[0] == segment[n].nodeId[0]
+                &amp;&amp; tmpSegment[i].nodeId[1] == segment[n].nodeId[1])
+            {
+                duplicated = true;
+                segment[n].faceOwner.push_back(tmpSegment[i].faceOwner[0]);
+                break;
+            }
 
-		}
+        }
 
-		if (!duplicated)
-		{
-			segment.push_back(tmpSegment[i]);
-		}
-	}
+        if (!duplicated)
+        {
+            segment.push_back(tmpSegment[i]);
+        }
+    }
 
-	for (unsigned int s = 0 ; s &lt; segment.size() ; ++s)
-	{
-		node[segment[s].nodeId[0]].segmentOwner.push_back(s);
-		node[segment[s].nodeId[1]].segmentOwner.push_back(s);
-	}
+    for (unsigned int s = 0 ; s &lt; segment.size() ; ++s)
+    {
+        node[segment[s].nodeId[0]].segmentOwner.push_back(s);
+        node[segment[s].nodeId[1]].segmentOwner.push_back(s);
+    }
 
-	// Compute length of segments
-	double lx,ly,lz;
-	unsigned int id1,id2;
+    // Compute length of segments
+    double lx,ly,lz;
+    unsigned int id1,id2;
 
-        // length_min = length(0)
-        id1 = segment[0].nodeId[0];
-        id2 = segment[0].nodeId[1];
+    // length_min = length(0)
+    id1 = segment[0].nodeId[0];
+    id2 = segment[0].nodeId[1];
+    lx  = node[id2].x - node[id1].x;
+    ly  = node[id2].y - node[id1].y;
+    lz  = node[id2].z - node[id1].z;
+    min_segment_length = sqrt(lx*lx + ly*ly + lz*lz);
+
+    mean_segment_length = 0.0;
+    max_segment_length = 0.0;
+
+    for (unsigned int s = 0 ; s &lt; segment.size() ; ++s)
+    {
+        id1 = segment[s].nodeId[0];
+        id2 = segment[s].nodeId[1];
+
         lx  = node[id2].x - node[id1].x;
         ly  = node[id2].y - node[id1].y;
         lz  = node[id2].z - node[id1].z;
-        min_segment_length = sqrt(lx*lx + ly*ly + lz*lz);
 
+        segment[s].length = sqrt(lx*lx + ly*ly + lz*lz);
 
-	mean_segment_length = 0.0;
-	max_segment_length = 0.0;
+        mean_segment_length += segment[s].length;
+        min_segment_length = (segment[s].length &lt; min_segment_length) ? segment[s].length : min_segment_length;
+        max_segment_length = (segment[s].length &gt; max_segment_length) ? segment[s].length : max_segment_length;
+    }
+    mean_segment_length /= (double)(segment.size());
 
-	for (unsigned int s = 0 ; s &lt; segment.size() ; ++s)
-	{
-		id1 = segment[s].nodeId[0];
-		id2 = segment[s].nodeId[1];
+    cerr &lt;&lt; &quot;mean_segment_length = &quot; &lt;&lt; mean_segment_length &lt;&lt; endl;
+    cerr &lt;&lt; &quot;min_segment_length = &quot; &lt;&lt; min_segment_length &lt;&lt; endl;
+    cerr &lt;&lt; &quot;max_segment_length = &quot; &lt;&lt; max_segment_length &lt;&lt; endl;
 
-		lx  = node[id2].x - node[id1].x;
-	    ly  = node[id2].y - node[id1].y;
-	    lz  = node[id2].z - node[id1].z;
-
-		segment[s].length = sqrt(lx*lx + ly*ly + lz*lz);
-
-		mean_segment_length += segment[s].length;
-		min_segment_length = (segment[s].length &lt; min_segment_length) ? segment[s].length : min_segment_length;
-		max_segment_length = (segment[s].length &gt; max_segment_length) ? segment[s].length : max_segment_length;
-	}
-	mean_segment_length /= (double)(segment.size());
-
-        cerr &lt;&lt; &quot;mean_segment_length = &quot; &lt;&lt; mean_segment_length &lt;&lt; endl;
-        cerr &lt;&lt; &quot;min_segment_length = &quot; &lt;&lt; min_segment_length &lt;&lt; endl;
-        cerr &lt;&lt; &quot;max_segment_length = &quot; &lt;&lt; max_segment_length &lt;&lt; endl;
-
-	// Define tetraedre neighbors
-        bool stop = false;
-	for (unsigned int t1 = 0 ; t1 &lt; tetraedre.size() ; ++t1)
-	{
-          tetraedre[t1].tetraNeighbor.push_back(t1);
-		for (unsigned int t2 = 0 ; t2 &lt; tetraedre.size() ; ++t2)
-		{
-                  /*
-			if (   (tetraedre[t1].nodeId[0] &gt; tetraedre[t2].nodeId[3])
-				|| (tetraedre[t1].nodeId[3] &lt; tetraedre[t2].nodeId[0]) ) continue;
-                        */
-
-                        // FIXME mettre du while... (?)
-                        stop = false;
-			for (unsigned int i = 0 ; i &lt; 4 ; i++)
-                        {
-			        for (unsigned int j = 0 ; j &lt; 4 ; j++)
-				{
-				    if (tetraedre[t1].nodeId[i] == tetraedre[t2].nodeId[j])
-				    {
-				      if (t1 != t2) tetraedre[t1].tetraNeighbor.push_back(t2);
-				      //if (t1 != t2) tetraedre[t2].tetraNeighbor.push_back(t1);
-                                      stop = true;
-				      break;
-				    }
-				}
-                                if (stop) break;
-                        }
-		}
-	}
-
-/*
-        for (unsigned int t1 = 0 ; t1 &lt; tetraedre.size() ; ++t1)
+    // Define tetraedre neighbors
+    bool stop = false;
+    for (unsigned int t1 = 0 ; t1 &lt; tetraedre.size() ; ++t1)
+    {
+        tetraedre[t1].tetraNeighbor.push_back(t1);
+        for (unsigned int t2 = 0 ; t2 &lt; tetraedre.size() ; ++t2)
         {
-          cerr &lt;&lt; &quot;Tetra &quot; &lt;&lt; t1 &lt;&lt; &quot; a &quot; &lt;&lt;  tetraedre[t1].tetraNeighbor.size() &lt;&lt; &quot; voisins&quot; &lt;&lt; endl;
-          for (unsigned int i = 0 ; i &lt; tetraedre[t1].tetraNeighbor.size() ; i++)
-          {
-            cerr &lt;&lt;  tetraedre[t1].tetraNeighbor[i] &lt;&lt; ' ';
-          }
-          cerr &lt;&lt; endl;
+            /*
+            if (   (tetraedre[t1].nodeId[0] &gt; tetraedre[t2].nodeId[3])
+            || (tetraedre[t1].nodeId[3] &lt; tetraedre[t2].nodeId[0]) ) continue;
+                  */
+
+            // FIXME mettre du while... (?)
+            stop = false;
+            for (unsigned int i = 0 ; i &lt; 4 ; i++)
+            {
+                for (unsigned int j = 0 ; j &lt; 4 ; j++)
+                {
+                    if (tetraedre[t1].nodeId[i] == tetraedre[t2].nodeId[j])
+                    {
+                        if (t1 != t2) tetraedre[t1].tetraNeighbor.push_back(t2);
+                        //if (t1 != t2) tetraedre[t2].tetraNeighbor.push_back(t1);
+                        stop = true;
+                        break;
+                    }
+                }
+                if (stop) break;
+            }
         }
-        exit(0);
-*/
+    }
 
-        isOrganized = true;
-}
+    /*
+            for (unsigned int t1 = 0 ; t1 &lt; tetraedre.size() ; ++t1)
+            {
+              cerr &lt;&lt; &quot;Tetra &quot; &lt;&lt; t1 &lt;&lt; &quot; a &quot; &lt;&lt;  tetraedre[t1].tetraNeighbor.size() &lt;&lt; &quot; voisins&quot; &lt;&lt; endl;
+              for (unsigned int i = 0 ; i &lt; tetraedre[t1].tetraNeighbor.size() ; i++)
+              {
+                cerr &lt;&lt;  tetraedre[t1].tetraNeighbor[i] &lt;&lt; ' ';
+              }
+              cerr &lt;&lt; endl;
+            }
+            exit(0);
+    */
 
-
-
+    isOrganized = true;
+}

Modified: trunk/extra/SpherePadder/main.cpp
===================================================================
--- trunk/extra/SpherePadder/main.cpp	2009-02-26 08:35:54 UTC (rev 1695)
+++ trunk/extra/SpherePadder/main.cpp	2009-02-26 12:47:38 UTC (rev 1696)
@@ -24,16 +24,16 @@
   
  
   TetraMesh * mesh = new TetraMesh();
-  //mesh-&gt;read_gmsh(&quot;meshes/test2.msh&quot;);
-  mesh-&gt;read(&quot;meshes/tomo.tetra&quot;);
-  //mesh-&gt;write_surface_MGP (&quot;tomo.mgp&quot;);
+  //mesh-&gt;read_gmsh(&quot;meshes/cube1194.msh&quot;);
+  mesh-&gt;read(&quot;meshes/test.tetra&quot;);
+  //mesh-&gt;write_surface_MGP (&quot;cube.mgp&quot;);
 
   SpherePadder * padder = new SpherePadder();
   padder-&gt;plugTetraMesh(mesh);
   //padder-&gt;add_spherical_probe(0.7);
         
   padder-&gt;pad_5();
-  //padder-&gt;tetra_pad();
+  padder-&gt;densify();
   
   padder-&gt;save_mgpost(&quot;mgp.out.001&quot;);
   // padder-&gt;save_Rxyz(&quot;spheres.Rxyz&quot;);


_______________________________________________
Mailing list: <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
Post to     : <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">yade-dev at lists.launchpad.net</A>
Unsubscribe : <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
More help   : <A HREF="https://help.launchpad.net/ListHelp">https://help.launchpad.net/ListHelp</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000770.html">[deprecated list] [Yade-dev] [svn] r1695 - trunk/extra/SpherePadder
</A></li>
	<LI>Next message: <A HREF="000772.html">[deprecated list] [Yade-dev] [svn] r1697 - trunk/extra/SpherePadder
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#771">[ date ]</a>
              <a href="thread.html#771">[ thread ]</a>
              <a href="subject.html#771">[ subject ]</a>
              <a href="author.html#771">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-dev">More information about the yade-dev
mailing list</a><br>
</body></html>
