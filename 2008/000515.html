<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [deprecated list] [Yade-dev] [svn] r1576 - trunk/extra/triangulation
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-dev/2008/index.html" >
   <LINK REL="made" HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1576%20-%20trunk/extra/triangulation&In-Reply-To=%3C200811201448.mAKEmH8T022245%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000509.html">
   <LINK REL="Next"  HREF="000520.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[deprecated list] [Yade-dev] [svn] r1576 - trunk/extra/triangulation</H1>
    <B>chareyre at BerliOS</B> 
    <A HREF="mailto:yade-dev%40lists.berlios.de?Subject=Re%3A%20%5Bdeprecated%20list%5D%20%5BYade-dev%5D%20%5Bsvn%5D%20r1576%20-%20trunk/extra/triangulation&In-Reply-To=%3C200811201448.mAKEmH8T022245%40sheep.berlios.de%3E"
       TITLE="[deprecated list] [Yade-dev] [svn] r1576 - trunk/extra/triangulation">chareyre at mail.berlios.de
       </A><BR>
    <I>Thu Nov 20 15:48:17 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000509.html">[deprecated list] [Yade-dev] [svn] r1575 -	trunk/pkg/dem/Engine/DeusExMachina
</A></li>
        <LI>Next message: <A HREF="000520.html">[deprecated list] [Yade-dev] inherited PhysicalParameters	for	InteractionPhysicsEngineUnit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#515">[ date ]</a>
              <a href="thread.html#515">[ thread ]</a>
              <a href="subject.html#515">[ subject ]</a>
              <a href="author.html#515">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chareyre
Date: 2008-11-20 15:48:17 +0100 (Thu, 20 Nov 2008)
New Revision: 1576

Added:
   trunk/extra/triangulation/KinematicLocalisationAnalyser.cpp
   trunk/extra/triangulation/KinematicLocalisationAnalyser.hpp
Log:
A class with algorithm for analysing contacts-forces-displacements 
statistics. Using the triangulation lib.




Added: trunk/extra/triangulation/KinematicLocalisationAnalyser.cpp
===================================================================
--- trunk/extra/triangulation/KinematicLocalisationAnalyser.cpp	2008-11-17 17:11:31 UTC (rev 1575)
+++ trunk/extra/triangulation/KinematicLocalisationAnalyser.cpp	2008-11-20 14:48:17 UTC (rev 1576)
@@ -0,0 +1,1039 @@
+/*************************************************************************
+*  Copyright (C) 2006 by Bruno Chareyre                                *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">bruno.chareyre at hmg.inpg.fr</A>                                            *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+//This class computes statistics of micro-variables assuming axi-symetry
+
+
+
+#include &quot;Tesselation.h&quot;
+#include &quot;KinematicLocalisationAnalyser.hpp&quot;
+#include &quot;TriaxialState.h&quot;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;sstream&gt;
+//#include &lt;utility&gt;
+
+int n_debug = 0;
+//cerr &lt;&lt; &quot;n_debug=&quot; &lt;&lt; n_debug++ &lt;&lt; endl;   /// DEBUG LINE  ///
+ 
+ 
+//Usefull fonction to convert int to string (define it elsewhere) 
+std::string _itoa(int i) {
+ std::ostringstream buffer;
+ buffer &lt;&lt; i;
+ return buffer.str();
+} 
+
+KinematicLocalisationAnalyser::KinematicLocalisationAnalyser()
+{
+	sphere_discretisation = SPHERE_DISCRETISATION;
+	linear_discretisation = LINEAR_DISCRETISATION;
+	consecutive = true;
+	TS1=new TriaxialState;
+	TS0=new TriaxialState;
+}
+
+
+KinematicLocalisationAnalyser::~KinematicLocalisationAnalyser()
+{
+	delete (TS1);
+	delete (TS0);
+}
+
+KinematicLocalisationAnalyser::KinematicLocalisationAnalyser(const char*
+state_file1)
+{
+	sphere_discretisation = SPHERE_DISCRETISATION;
+	linear_discretisation = LINEAR_DISCRETISATION;
+	consecutive = true;
+	TS1 = new(TriaxialState);
+	TS0 = NULL;
+	TS1-&gt;from_file(state_file1);
+}
+
+KinematicLocalisationAnalyser::KinematicLocalisationAnalyser(const char*
+state_file1, const char* state_file0, bool consecutive_files)
+{
+	consecutive = consecutive_files;
+	sphere_discretisation = SPHERE_DISCRETISATION;
+	linear_discretisation = LINEAR_DISCRETISATION;
+	TS1 = new(TriaxialState);
+	TS0 = new(TriaxialState);
+	TS1-&gt;from_file(state_file1);
+	TS0-&gt;from_file(state_file0);
+
+	Delta_epsilon(3,3) = TS1-&gt;eps3 - TS0-&gt;eps3;
+	Delta_epsilon(1,1) = TS1-&gt;eps1 - TS0-&gt;eps1;
+	Delta_epsilon(2,2) = TS1-&gt;eps2 - TS0-&gt;eps2;
+}
+
+
+
+void KinematicLocalisationAnalyser::SetBaseFileName (string name)
+{
+	base_file_name = name;
+}
+
+
+bool KinematicLocalisationAnalyser::SetFileNumbers ( int n0, int n1 )
+{
+	//TriaxialState* TS3;
+	//string file_name;
+	bool bf0 = false;
+	bool bf1 = false;
+// char buffer [50];
+	if ( file_number_0 != n0 )
+	{
+		if ( file_number_1 != n0 )
+		{
+			//file_name = base_file_name + n0;
+			bf0 = TS0-&gt;from_file ( ( base_file_name +_itoa ( file_number_0 ) ).c_str() );
+		}
+		else
+		{
+			delete ( TS0 );
+			TS0 = TS1;
+			bf0=true;
+			TS1 = new ( TriaxialState );
+			//file_name = base_file_name + string(n1);
+			bf1 = TS1-&gt;from_file ( ( base_file_name + _itoa ( file_number_1 ) ).c_str() );
+		}
+	}
+	else if ( n1 != file_number_1 )
+	{
+		//file_name = base_file_name + string(n1);
+		bf0 = true;
+		bf1 = TS1-&gt;from_file ( ( base_file_name + _itoa ( file_number_1 ) ).c_str() );
+	}
+
+	file_number_1 = n1;
+	file_number_0 = n0;
+	consecutive = ( ( n1-n0 ) ==1 );
+	Delta_epsilon ( 3,3 ) = TS1-&gt;eps3 - TS0-&gt;eps3;
+	Delta_epsilon ( 1,1 ) = TS1-&gt;eps1 - TS0-&gt;eps1;
+	Delta_epsilon ( 2,2 ) = TS1-&gt;eps2 - TS0-&gt;eps2;
+	return ( bf0 &amp;&amp; bf1 );
+}
+
+
+void KinematicLocalisationAnalyser::SetConsecutive ( bool t )
+{
+	consecutive = t;
+}
+
+void KinematicLocalisationAnalyser::SetNO_ZERO_ID (bool t)
+{
+	TS0-&gt;NO_ZERO_ID = t;
+	TS1-&gt;NO_ZERO_ID = t;
+}
+
+
+void KinematicLocalisationAnalyser::SwitchStates (void ) 
+{
+	TriaxialState* TStemp = TS0;
+	TS0 = TS1;
+	TS1 = TStemp;
+}
+
+vector&lt;Edge_iterator&gt;&amp; KinematicLocalisationAnalyser::Oriented_Filtered_edges (Real Nymin, Real Nymax, vector&lt;Edge_iterator&gt;&amp; filteredList)
+{
+	RTriangulation&amp; T = TS1-&gt;tesselation().Triangulation();
+	filteredList.clear();
+	Edge_iterator ed_end = T.edges_end();
+	for (Edge_iterator ed_it = T.edges_begin(); ed_it != ed_end; ++ed_it)
+	{
+		if (!T.is_infinite(*ed_it)
+				   &amp;&amp; TS1-&gt;inside ( T.segment ( *ed_it ).source() )
+				   &amp;&amp; TS1-&gt;inside ( T.segment ( *ed_it ).target() ) )
+		{
+			Segment s = T.segment(*ed_it);
+			Vecteur v = s.to_vector();
+			Real ny = abs( v.y()/sqrt(s.squared_length()));		
+	
+			if (Nymin &lt; ny &amp;&amp; ny &lt;= Nymax) filteredList.push_back(ed_it);
+		}
+	}
+	return filteredList;
+}
+
+
+bool KinematicLocalisationAnalyser::ToFile (const char* output_file_name)
+{
+	ofstream output_file (output_file_name);
+	if (!output_file.is_open())	{
+		cerr &lt;&lt; &quot;Error opening files&quot;;
+		return false;	}
+		
+	output_file &lt;&lt; &quot;sym_grad_u_total_g (wrong averaged strain):&quot;&lt;&lt; endl &lt;&lt; Tenseur_sym3 ( grad_u_total_g ) &lt;&lt; endl;
+	output_file &lt;&lt; &quot;Total volume = &quot; &lt;&lt; v_total &lt;&lt; &quot;, grad_u = &quot; &lt;&lt; endl &lt;&lt; grad_u_total &lt;&lt; endl &lt;&lt; &quot;sym_grad_u (true average strain): &quot; &lt;&lt; endl &lt;&lt; Tenseur_sym3 ( grad_u_total ) &lt;&lt; endl;
+	output_file &lt;&lt; &quot;Macro strain = &quot; &lt;&lt; Delta_epsilon &lt;&lt; endl;
+
+	ContactDistributionToFile(output_file);
+	AllNeighborDistributionToFile(output_file);
+	
+	TS1-&gt;filter_distance = 2.0;
+	ContactDistributionToFile(output_file);
+	AllNeighborDistributionToFile(output_file);
+
+	TS1-&gt;filter_distance = 4.0;
+	ContactDistributionToFile(output_file);
+	AllNeighborDistributionToFile(output_file);
+
+	output_file &lt;&lt; &quot;Contact_fabric : &quot;;
+	output_file &lt;&lt; (Tenseur_sym3) Contact_fabric(*TS1);// &lt;&lt; endl;
+	output_file &lt;&lt; &quot;Contact_anisotropy : &quot; &lt;&lt; Contact_anisotropy(*TS1) &lt;&lt; endl &lt;&lt; endl;
+	output_file &lt;&lt; &quot;Neighbor_fabric : &quot; &lt;&lt; Neighbor_fabric(*TS1) &lt;&lt; endl;	
+	output_file &lt;&lt; &quot;Neighbor_anisotropy : &quot; &lt;&lt; Neighbor_anisotropy(*TS1) &lt;&lt; endl &lt;&lt; endl;
+		
+	RTriangulation&amp; T = TS1-&gt;tesselation().Triangulation();
+	Edge_iterator ed_end = T.edges_end();
+	vector&lt;Edge_iterator&gt; edges;
+	for (Edge_iterator ed_it = T.edges_begin(); ed_it != ed_end; ++ed_it)
+	{
+		if (!T.is_infinite(*ed_it))
+		{
+			Segment s = T.segment(*ed_it);
+			Vecteur v = s.to_vector();
+			Real xx = abs( v.z()/sqrt(s.squared_length()));		
+	
+			if (xx&gt;0.95) edges.push_back(ed_it);
+		}
+	}
+	NormalDisplacementDistributionToFile(edges, output_file);
+
+	edges.clear();
+	for (Edge_iterator ed_it = T.edges_begin(); ed_it != ed_end; ++ed_it)
+	{
+		if (!T.is_infinite(*ed_it))
+		{
+			Segment s = T.segment(*ed_it);
+			Vecteur v = s.to_vector();
+			Real xx = abs( v.z()/sqrt(s.squared_length()));		
+	
+			if (xx&lt;0.05) edges.push_back(ed_it);
+		}
+	}
+	NormalDisplacementDistributionToFile(edges, output_file);
+
+	edges.clear();
+	for (Edge_iterator ed_it = T.edges_begin(); ed_it != ed_end; ++ed_it)
+	{
+		if (!T.is_infinite(*ed_it))
+		{
+			Segment s = T.segment(*ed_it);
+			Vecteur v = s.to_vector();
+			Real xx = abs( v.z()/sqrt(s.squared_length()));		
+	
+			if (xx&gt;0.65 &amp;&amp; xx&lt;0.75) edges.push_back(ed_it);
+		}
+	}
+	NormalDisplacementDistributionToFile(edges, output_file);
+
+
+	output_file.close();
+	return true;
+}
+
+long KinematicLocalisationAnalyser::Filtered_contacts (TriaxialState&amp; state)
+{
+	long nc1 =0;
+	TriaxialState::ContactIterator cend = state.contacts_end();
+	for (TriaxialState::ContactIterator cit = state.contacts_begin(); cit!=cend; ++cit)
+	{
+		if (state.inside((*cit)-&gt;grain1-&gt;sphere.point()) &amp;&amp; state.inside((*cit)-&gt;grain2-&gt;sphere.point()))
+			nc1 += 2;
+		else if (state.inside((*cit)-&gt;grain1-&gt;sphere.point()) || state.inside((*cit)-&gt;grain2-&gt;sphere.point()))	
+			++nc1;			
+	}
+	return nc1;
+}
+
+long KinematicLocalisationAnalyser::Filtered_neighbors ( TriaxialState&amp; state )
+{
+	long nv1=0;
+	RTriangulation&amp; T = state.tesselation().Triangulation();
+	Edge_iterator ed_end = T.edges_end();
+	for ( Edge_iterator ed_it = T.edges_begin(); ed_it != ed_end; ++ed_it )
+	{
+		if ( !T.is_infinite ( *ed_it ) )
+		{
+			Segment s ( T.segment ( *ed_it ) );
+			if ( state.inside ( s.source() ) &amp;&amp;
+					state.inside ( s.target() ) ) nv1 += 2;
+			else if ( state.inside ( s.source() ) ||
+					  state.inside ( s.target() ) )  ++nv1;
+		}
+	}
+	return nv1;
+}
+
+long KinematicLocalisationAnalyser::Filtered_grains (TriaxialState&amp; state)
+{
+	long ng1 =0;
+	TriaxialState::GrainIterator gend = state.grains_end();
+	for (TriaxialState::GrainIterator git = state.grains_begin(); git!=gend;
+++git) {
+		if (state.inside(git-&gt;sphere.point())) ++ng1;}
+	return ng1;
+}
+
+Real KinematicLocalisationAnalyser::Filtered_volume (TriaxialState&amp; state)
+{
+	return 0;
+}
+
+Real KinematicLocalisationAnalyser::Contact_coordination (TriaxialState&amp; state)
+{
+	return Filtered_contacts(state) / Filtered_grains(state);
+}
+
+Real KinematicLocalisationAnalyser::Neighbor_coordination (TriaxialState&amp; state)
+{
+	return Filtered_neighbors(state) / Filtered_grains(state);
+}
+
+
+Tenseur_sym3 KinematicLocalisationAnalyser::Neighbor_fabric ( TriaxialState&amp;
+		state )
+{
+	RTriangulation&amp; T = state.tesselation().Triangulation();
+	Edge_iterator ed_end = T.edges_end();
+	Tenseur_sym3 Tens;
+	Vecteur v;
+	Segment s;
+	for ( Edge_iterator ed_it = T.edges_begin(); ed_it != ed_end; ++ed_it )
+	{
+		if ( !T.is_infinite ( *ed_it ) )
+		{
+			s = T.segment ( *ed_it );
+			if ( state.inside ( s.source() ) &amp;&amp;
+					state.inside ( s.target() ) )
+			{
+				v =
+					T.segment ( *ed_it ).to_vector() * ( 1/sqrt ( T.segment ( *ed_it ).squared_length() ) );
+				for ( int i=1; i&lt;4; i++ ) for ( int j=3; j&gt;=i; j-- )
+						Tens ( i,j ) += 2*v[i-1]*v[j-1];
+			}
+			else if ( state.inside ( s.source() ) ||
+					  state.inside ( s.target() ) )
+			{
+				v =
+					T.segment ( *ed_it ).to_vector() * ( 1/sqrt ( T.segment ( *ed_it ).squared_length() ) );
+				for ( int i=1; i&lt;4; i++ ) for ( int j=3; j&gt;=i; j-- )
+						Tens ( i,j ) += v[i-1]*v[j-1];
+			}
+		}
+	}
+	Tens /= Filtered_neighbors ( state );
+	return Tens;
+}
+
+Tenseur_sym3 KinematicLocalisationAnalyser::Contact_fabric ( TriaxialState&amp;
+		state )
+{
+	Tenseur_sym3 Tens;
+	Vecteur v;
+	TriaxialState::ContactIterator cend = state.contacts_end();
+
+	for ( TriaxialState::ContactIterator cit = state.contacts_begin();
+			cit!=cend; ++cit )
+	{
+		if ( state.inside ( ( *cit )-&gt;grain1-&gt;sphere.point() ) &amp;&amp;
+				state.inside ( ( *cit )-&gt;grain2-&gt;sphere.point() ) )
+		{
+			v = ( *cit )-&gt;normal;
+			for ( int i=1; i&lt;4; i++ ) for ( int j=3; j&gt;=i; j-- )
+					Tens ( i,j ) += 2*v[i-1]*v[j-1];
+		}
+		else if ( state.inside ( ( *cit )-&gt;grain1-&gt;sphere.point() ) ||
+				  state.inside ( ( *cit )-&gt;grain2-&gt;sphere.point() ) )
+		{
+			v = ( *cit )-&gt;normal;
+			for ( int i=1; i&lt;4; i++ ) for ( int j=3; j&gt;=i; j-- )
+					Tens ( i,j ) += v[i-1]*v[j-1];
+		}
+	}
+	Tens /= Filtered_contacts ( state );
+	return Tens;
+}
+
+
+
+
+
+Real KinematicLocalisationAnalyser::Contact_anisotropy (TriaxialState&amp; state)
+{
+	Tenseur_sym3 tens (Contact_fabric(state));
+	return tens.Deviatoric().Norme()/tens.Trace();
+}
+
+
+Real KinematicLocalisationAnalyser::Neighbor_anisotropy (TriaxialState&amp; state)
+{
+	Tenseur_sym3 tens (Neighbor_fabric(state));
+	return tens.Deviatoric().Norme()/tens.Trace();
+}
+
+vector&lt;pair&lt;Real,Real&gt; &gt;&amp; KinematicLocalisationAnalyser::
+NormalDisplacementDistribution ( vector&lt;Edge_iterator&gt;&amp; edges, vector&lt;pair&lt;Real,Real&gt; &gt; &amp;row )
+{
+	cerr &lt;&lt; &quot;n_debug=&quot; &lt;&lt; n_debug++ &lt;&lt; endl;   /// DEBUG LINE  ///
+	row.clear();
+	row.resize ( linear_discretisation+1 );
+	vector&lt;Real&gt; Un_values;
+	Un_values.resize ( edges.size() );
+	Real UNmin ( 100000 ), UNmax ( -100000 );
+	Vecteur branch, U;
+	Real Un;
+	Vertex_handle Vh1, Vh2;
+	vector&lt;Edge_iterator&gt;::iterator ed_end = edges.end();
+	long val_count = 0;
+
+	cerr &lt;&lt; &quot;n_debug=&quot; &lt;&lt; n_debug++ &lt;&lt; endl;   /// DEBUG LINE  ///
+	for ( vector&lt;Edge_iterator&gt;::iterator ed_it = edges.begin();
+			ed_it!=ed_end; ++ed_it )
+	{
+		Vh1= ( *ed_it )-&gt;first-&gt;vertex ( ( *ed_it )-&gt;second );
+		Vh2= ( *ed_it )-&gt;first-&gt;vertex ( ( *ed_it )-&gt;third );
+		branch = Vh1-&gt;point()- Vh2-&gt;point();
+		NORMALIZE ( branch );
+		if ( consecutive )
+			U = TS1-&gt;grain ( Vh1-&gt;info().id() ).translation -
+				TS1-&gt;grain ( Vh2-&gt;info().id() ).translation;
+		else
+		{
+			U = ( TS1-&gt;grain ( Vh1-&gt;info().id() ).sphere.point() -
+				  TS0-&gt;grain ( Vh1-&gt;info().id() ).sphere.point() )
+				- ( TS1-&gt;grain ( Vh2-&gt;info().id() ).sphere.point() -
+					TS0-&gt;grain ( Vh2-&gt;info().id() ).sphere.point() );
+		}
+		//Un = (U - (Delta_epsilon*branch))*branch; //Diff&#65533;rence par rapport &#65533; Un moyen
+		Un = U*branch;
+		
+		UNmin = min ( UNmin,Un );
+		UNmax = max ( UNmax,Un );
+		Un_values[val_count++] = Un;
+		//cerr &lt;&lt; &quot;Un=&quot; &lt;&lt; Un &lt;&lt; &quot; U=&quot; &lt;&lt; U &lt;&lt; &quot; branch=&quot; &lt;&lt; branch &lt;&lt; 	endl;
+	}
+	cerr &lt;&lt; &quot;n_debug=&quot; &lt;&lt; n_debug++ &lt;&lt; endl;   /// DEBUG LINE  ///
+
+	Real DUN = ( UNmax-UNmin ) /linear_discretisation;
+	for ( int i = 0; i &lt;= linear_discretisation; ++i )
+	{
+		row[i].first = UNmin+ ( i+0.5 ) *DUN;
+		row[i].second = 0;
+	}
+	cerr &lt;&lt; &quot;n_debug=&quot; &lt;&lt; n_debug++ &lt;&lt; endl;   /// DEBUG LINE  ///
+
+	val_count = val_count-1;
+	cerr &lt;&lt; &quot;nval=&quot; &lt;&lt; val_count &lt;&lt; &quot; reserved=&quot; &lt;&lt; edges.size() &lt;&lt; endl;
+	for ( ; val_count&gt;=0; --val_count )
+	{
+		//cerr &lt;&lt; &quot;n_debug0=&quot; &lt;&lt; n_debug &lt;&lt; endl;   /// DEBUG LINE  ///
+		row[ ( int ) ( ( Un_values[val_count]-UNmin ) /DUN ) ].second += 1;
+	}
+	cerr &lt;&lt; &quot;DUN=&quot; &lt;&lt; DUN &lt;&lt; &quot; UNmin=&quot; &lt;&lt; UNmin &lt;&lt; &quot; UNmax=&quot; &lt;&lt; UNmax &lt;&lt; endl;
+	return row;
+	//cerr &lt;&lt; &quot;n_debug=&quot; &lt;&lt; n_debug++ &lt;&lt; endl;   /// DEBUG LINE  ///
+}
+
+
+ofstream&amp; KinematicLocalisationAnalyser::
+NormalDisplacementDistributionToFile ( vector&lt;Edge_iterator&gt;&amp; edges, ofstream&amp; output_file )
+{
+	vector&lt; pair&lt;Real, Real&gt; &gt; row;
+	NormalDisplacementDistribution ( edges, row );
+	vector&lt; pair&lt;Real, Real&gt; &gt;::iterator r_end = row.end();
+
+	//output part :
+	output_file &lt;&lt; &quot;#Normal displacement distribution&quot; &lt;&lt; endl &lt;&lt; &quot;eps3=&quot; &lt;&lt; Delta_epsilon ( 3,3 )
+	&lt;&lt; &quot; eps2=&quot; &lt;&lt; Delta_epsilon ( 2,2 ) &lt;&lt; &quot; eps1=&quot; &lt;&lt; Delta_epsilon ( 1,1 ) &lt;&lt; &quot; number of neigbors: &quot;&lt;&lt; edges.size()
+	&lt;&lt; endl &lt;&lt; &quot;Un_min=&quot; &lt;&lt; 1.5*row[0].first - 0.5*row[1].first &lt;&lt; &quot; Un_max=&quot;
+	&lt;&lt; row[row.size()-1].first &lt;&lt; endl;
+	cout &lt;&lt; &quot;#Normal displacement distribution&quot; &lt;&lt; endl &lt;&lt; &quot;eps3=&quot; &lt;&lt; Delta_epsilon ( 3,3 )
+	&lt;&lt; &quot; eps2=&quot; &lt;&lt; Delta_epsilon ( 2,2 ) &lt;&lt; &quot; eps1=&quot; &lt;&lt; Delta_epsilon ( 1,1 ) &lt;&lt; &quot; number of neigbors: &quot;&lt;&lt; edges.size()
+	&lt;&lt; endl &lt;&lt; &quot;Un_min=&quot; &lt;&lt; 1.5*row[0].first - 0.5*row[1].first &lt;&lt; &quot; Un_max=&quot;
+	&lt;&lt; row[row.size()-1].first &lt;&lt; endl;
+	for ( vector&lt; pair&lt;Real, Real&gt; &gt;::iterator r_it = row.begin(); r_it != r_end; ++r_it )
+	{
+		output_file &lt;&lt; r_it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; r_it-&gt;second &lt;&lt; endl;
+		cout &lt;&lt; r_it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; r_it-&gt;second &lt;&lt; endl;
+	}
+	output_file &lt;&lt; endl;
+	return output_file;
+
+}
+
+
+//vector&lt;pair&lt;Real,Real&gt; &gt;  KinematicLocalisationAnalyser::
+//NormalDisplacementDistribution(TriaxialState&amp; state, TriaxialState&amp; state0)
+//{
+// vector&lt;pair&lt;Real,Real&gt; &gt; table;
+// table.resize(linear_discretisation);
+//
+//
+// return table;
+//}
+
+
+
+ofstream&amp; KinematicLocalisationAnalyser::
+ContactDistributionToFile ( ofstream&amp; output_file )
+{
+	//cerr &lt;&lt; &quot;ContactDistributionToFile&quot; &lt;&lt; endl;
+	vector&lt; pair&lt;Real, Real&gt; &gt; row;
+	row.resize ( sphere_discretisation+1 );
+	Real DZ = 1.0/sphere_discretisation;//interval in term of cos(teta)
+	long nc1=0;
+	long nc2=0;
+	long ng1=0;
+	long ng2=0;
+	//cerr &lt;&lt; &quot;ContactDistributionToFile05&quot; &lt;&lt; endl;
+	TriaxialState::ContactIterator cend = ( *TS1 ).contacts_end();
+	TriaxialState::GrainIterator gend = ( *TS1 ).grains_end();
+
+	for ( int i = 0; i &lt;= sphere_discretisation; ++i )
+	{
+		row[i].first = ( i+0.5 ) *DZ;
+		row[i].second = 0;
+	}
+
+	for ( TriaxialState::GrainIterator git = ( *TS1 ).grains_begin(); git!=gend; ++git )
+	{
+		if ( ( *TS1 ).inside ( git-&gt;sphere.point() ) ) ++ng1;
+		else ++ng2;
+	}
+
+	for ( TriaxialState::ContactIterator cit = ( *TS1 ).contacts_begin(); cit!=cend; ++cit )
+	{
+		if ( ( *TS1 ).inside ( ( *cit )-&gt;grain1-&gt;sphere.point() ) &amp;&amp; ( *TS1 ).inside ( ( *cit )-&gt;grain2-&gt;sphere.point() ) )
+		{
+			row[ ( int ) ( abs ( ( *cit )-&gt;normal.z() ) /DZ ) ].second += 2;
+			nc1 += 2;
+		}
+		else
+		{
+			if ( ( *TS1 ).inside ( ( *cit )-&gt;grain1-&gt;sphere.point() ) || ( *TS1 ).inside ( ( *cit )-&gt;grain2-&gt;sphere.point() ) )
+			{
+				row[ ( int ) ( abs ( ( *cit )-&gt;normal.z() ) /DZ ) ].second += 1;
+				++nc1;
+			}
+			//cerr &lt;&lt; &quot;(*cit)-&gt;normal.z(),DZ : &quot; &lt;&lt; (*cit)-&gt;normal.z() &lt;&lt; &quot; &quot; &lt;&lt; DZ &lt;&lt; endl;}
+			else ++nc2;
+		}
+	}
+	//normalisation :
+	Real normalize = 1.0/ ( ng1*4*DZ*3.141592653 );
+	for ( int i = 0; i &lt;= sphere_discretisation; ++i ) row[i].second *= normalize;
+
+	//output part :
+	output_file &lt;&lt; &quot;#Contacts distribution&quot; &lt;&lt; endl &lt;&lt; &quot;(filter dist. = &quot; &lt;&lt; ( *TS1 ).filter_distance
+	&lt;&lt; &quot;, &quot;&lt;&lt; nc1 &lt;&lt; &quot; contacts, &quot; &lt;&lt; nc2 &lt;&lt; &quot; excluded contacts, for &quot;&lt;&lt; ng1
+	&lt;&lt;&quot;/&quot;&lt;&lt; ( ng1+ng2 ) &lt;&lt; &quot; grains)&quot; &lt;&lt; endl;
+	output_file &lt;&lt; &quot;max_nz number_of_contacts&quot; &lt;&lt; endl;
+	cerr &lt;&lt; &quot;#Contacts distribution (filter dist. = &quot; &lt;&lt; ( *TS1 ).filter_distance
+	&lt;&lt; &quot;, &quot;&lt;&lt; nc1 &lt;&lt; &quot; contacts, &quot; &lt;&lt; nc2 &lt;&lt; &quot; excluded contacts, for &quot;&lt;&lt; ng1
+	&lt;&lt;&quot;/&quot;&lt;&lt; ( ng1+ng2 ) &lt;&lt; &quot; grains)&quot; &lt;&lt; endl;
+	cerr &lt;&lt; &quot;mean_nz number_of_contacts&quot; &lt;&lt; endl;
+	for ( int i = 0; i &lt;= sphere_discretisation; ++i )
+	{
+		output_file &lt;&lt; row[i].first &lt;&lt; &quot; &quot; &lt;&lt; row[i].second &lt;&lt; endl;
+		cerr &lt;&lt; row[i].first &lt;&lt; &quot; &quot; &lt;&lt; row[i].second &lt;&lt; endl;
+	}
+
+	output_file &lt;&lt; endl;
+	return output_file;
+}
+
+
+
+ofstream&amp; KinematicLocalisationAnalyser::
+AllNeighborDistributionToFile ( ofstream&amp; output_file )
+{
+	vector&lt; pair&lt;Real, Real&gt; &gt; row;
+	row.resize ( sphere_discretisation );
+	Real DZ = 1.0/sphere_discretisation;
+	long nv1=0;
+	long nv2=0;
+	long nv3=0;
+	long ng1=0;
+	long ng2=0;
+
+	for ( int i = 0; i &lt; sphere_discretisation; ++i )
+	{
+		row[i].first = ( i+0.5 ) *DZ;
+		row[i].second = 0;
+	}
+
+	TriaxialState::GrainIterator gend = ( *TS1 ).grains_end();
+	for ( TriaxialState::GrainIterator git = ( *TS1 ).grains_begin(); git!=gend; ++git )
+	{
+		if ( ( *TS1 ).inside ( git-&gt;sphere.point() ) ) ++ng1;
+		else ++ng2;
+	}
+
+	RTriangulation&amp; T = ( *TS1 ).tesselation().Triangulation();
+	Segment s;
+	Vecteur v;
+	for ( Edge_iterator ed_it = T.edges_begin(); ed_it != T.edges_end(); ed_it++ )
+	{
+		if ( !T.is_infinite ( *ed_it ) )
+		{
+			s = T.segment ( *ed_it );
+			if ( ( *TS1 ).inside ( s.source() ) &amp;&amp; ( *TS1 ).inside ( s.target() ) )
+			{
+				v = s.to_vector();
+				row[ ( int ) ( abs ( v.z() /sqrt ( s.squared_length() ) ) /DZ ) ].second += 2;
+				nv1 += 2;
+			}
+			else
+			{
+				if ( ( *TS1 ).inside ( s.source() ) || ( *TS1 ).inside ( s.target() ) )
+				{
+					v = s.to_vector();
+					row[ ( int ) ( abs ( v.z() /sqrt ( s.squared_length() ) ) /DZ ) ].second += 1;
+					++nv1;
+				}
+				else ++nv2;
+			}
+		}
+		else ++nv3;
+	}
+
+	Real normalize = 1.0/ ( ng1*4*DZ*3.141592653 );
+	for ( int i = 0; i &lt; sphere_discretisation; ++i ) row[i].second *= normalize;
+
+	output_file &lt;&lt; &quot;#Neighbors distribution&quot; &lt;&lt; endl &lt;&lt; &quot;(filter dist. = &quot; &lt;&lt; ( *TS1 ).filter_distance
+	&lt;&lt; &quot;, &quot;&lt;&lt; nv1 &lt;&lt; &quot; neighbors + &quot; &lt;&lt; nv2 &lt;&lt; &quot; excluded + &quot;
+	&lt;&lt; nv3 &lt;&lt; &quot; infinite, for &quot;&lt;&lt; ng1 &lt;&lt;&quot;/&quot;&lt;&lt; ( ng1+ng2 ) &lt;&lt; &quot; grains)&quot; &lt;&lt; endl;
+	output_file &lt;&lt; &quot;max_nz number_of_neighbors&quot; &lt;&lt; endl;
+	cerr &lt;&lt; &quot;#Neighbors distribution&quot; &lt;&lt; endl &lt;&lt; &quot;(filter dist. = &quot; &lt;&lt; ( *TS1 ).filter_distance
+	&lt;&lt; &quot;, &quot;&lt;&lt; nv1 &lt;&lt; &quot; neighbors + &quot; &lt;&lt; nv2 &lt;&lt; &quot; excluded + &quot;
+	&lt;&lt; nv3 &lt;&lt; &quot; infinite, for &quot;&lt;&lt; ng1 &lt;&lt;&quot;/&quot;&lt;&lt; ( ng1+ng2 ) &lt;&lt; &quot; grains)&quot; &lt;&lt; endl;
+	cerr &lt;&lt; &quot;mean_nz number_of_neighbors&quot; &lt;&lt; endl;
+	for ( int i = 0; i &lt; sphere_discretisation; ++i )
+	{
+		output_file &lt;&lt; row[i].first &lt;&lt; &quot; &quot; &lt;&lt; row[i].second &lt;&lt; endl;
+		cerr &lt;&lt; row[i].first &lt;&lt; &quot; &quot; &lt;&lt; row[i].second &lt;&lt; endl;
+	}
+
+	output_file &lt;&lt; endl;
+	return output_file;
+}
+
+void KinematicLocalisationAnalyser::
+SetForceIncrements ( void ) //WARNING : This function will modify the contact lists : add virtual (lost)) contacts in state 1 and modify old_force and force in state 0, execute this function after all other force analysis functions if you want to avoid problems
+{
+	if ( true ) cerr &lt;&lt; &quot;SetForceIncrements&quot;&lt;&lt; endl;
+//  vector&lt; pair&lt;Real, Real&gt; &gt; row;
+//  row.resize ( sphere_discretisation );
+//  Real DZ = 1.0/sphere_discretisation;
+	long Nc0 = TS0-&gt;contacts.size();
+	long Nc1 = TS1-&gt;contacts.size();
+
+//  long nv1=0;
+//  long nv2=0;
+//  long nv3=0;
+//  long ng1=0;
+//  long ng2=0;
+	n_persistent = 0; n_new = 0; n_lost = 0;
+	long lost_in_state0 = 0;
+
+	for ( int i = 0; i &lt; Nc0; ++i ) {
+		TS0-&gt;contacts[i]-&gt;visited = false;
+		if (TS0-&gt;contacts[i]-&gt;status == TriaxialState::Contact::LOST) ++lost_in_state0;}
+	for ( int i = 0; i &lt; Nc1; ++i ) TS1-&gt;contacts[i]-&gt;visited = false;
+	cerr &lt;&lt; &quot;Nc1 &quot;&lt;&lt;Nc1&lt;&lt;&quot;, Nc0 &quot;&lt;&lt;Nc0&lt;&lt;&quot; (&quot;&lt;&lt;Nc0-lost_in_state0&lt;&lt;&quot; real)&quot;&lt;&lt;endl;
+	for ( int i = 0; i &lt; Nc0; ++i )
+	{
+	//	cerr &lt;&lt; 1;
+		if ( TS0-&gt;contacts[i]-&gt;status != TriaxialState::Contact::LOST )
+		{
+	//		cerr &lt;&lt; 2;
+			for ( int j = 0; j &lt; Nc1; ++j )
+			{
+				
+				if ( TS0-&gt;contacts[i]-&gt;grain1-&gt;id == TS1-&gt;contacts[j]-&gt;grain1-&gt;id &amp;&amp; TS0-&gt;contacts[i]-&gt;grain2-&gt;id == TS1-&gt;contacts[j]-&gt;grain2-&gt;id) // This is a PERSISTENT contact (i.e. it is present in state 0 and 1)
+				{
+					//TS0-&gt;contacts[i]-&gt;visited = true;
+					TS1-&gt;contacts[j]-&gt;visited = true;
+					//TS0-&gt;contacts[i]-&gt;status = TriaxialState::Contact::PERSISTENT;
+					TS1-&gt;contacts[j]-&gt;status = TriaxialState::Contact::PERSISTENT;
+					TS1-&gt;contacts[j]-&gt;old_fn = TS0-&gt;contacts[i]-&gt;fn;
+					TS1-&gt;contacts[j]-&gt;old_fs = TS0-&gt;contacts[i]-&gt;fs;
+					++n_persistent;
+					break;
+				}
+				else if ( j+1==Nc1 ) //This contact was not found in state 1, add it as a LOST contact
+				{
+	//				cerr &lt;&lt; 3 &lt;&lt; endl;
+					TriaxialState::Contact* c = new TriaxialState::Contact;
+					c-&gt;visited = true;
+					c-&gt;status = TriaxialState::Contact::LOST;
+					c-&gt;grain1 = TS0-&gt;contacts[i]-&gt;grain1;
+					c-&gt;grain2 = TS0-&gt;contacts[i]-&gt;grain2;
+					c-&gt;position = TS0-&gt;contacts[i]-&gt;position;
+					c-&gt;normal = TS0-&gt;contacts[i]-&gt;normal;
+					c-&gt;old_fn = TS0-&gt;contacts[i]-&gt;fn;
+					c-&gt;fn = 0;
+					c-&gt;old_fs = TS0-&gt;contacts[i]-&gt;fs;
+					c-&gt;frictional_work = TS0-&gt;contacts[i]-&gt;frictional_work;
+					c-&gt;fs = CGAL::NULL_VECTOR;
+					TS1-&gt;contacts.push_back ( c );
+					++Nc1;
+					++n_lost;
+					break;
+				}
+			}
+		}
+	}
+	//cerr &lt;&lt; 4;
+	for ( int j = 0; j &lt; Nc1; ++j ) //This contact was not visited, it is a NEW one
+	{
+		//cerr &lt;&lt; 5;
+		if ( !TS1-&gt;contacts[j]-&gt;visited /*&amp;&amp; TS1-&gt;contacts[j]-&gt;status != TriaxialState::Contact::LOST*/)
+		{
+			cerr &lt;&lt; 6;
+			TS1-&gt;contacts[j]-&gt;status = TriaxialState::Contact::NEW;
+			TS1-&gt;contacts[j]-&gt;old_fn = 0;
+			TS1-&gt;contacts[j]-&gt;old_fs = CGAL::NULL_VECTOR;
+			++n_new;
+		}
+	}
+	//cerr &lt;&lt; 7;
+	if ( true ) cerr &lt;&lt; &quot;Contact Status : &quot;&lt;&lt; n_persistent &lt;&lt; &quot; persistent, &quot;&lt;&lt; n_new &lt;&lt; &quot; new, &quot;&lt;&lt; n_lost &lt;&lt; &quot; lost&quot;&lt;&lt; endl;
+	/*
+	RGrid1D table;
+
+	for ( Edge_iterator ed_it = T.edges_begin(); ed_it != T.edges_end(); ed_it++ )
+	{
+	 if ( !T.is_infinite ( *ed_it ) )
+	 {
+	  s = T.segment ( *ed_it );
+	  if ( ( *TS1 ).inside ( s.source() ) &amp;&amp; ( *TS1 ).inside ( s.target() ) )
+	  {
+	   v = s.to_vector();
+	   row[ ( int ) ( abs ( v.z() /sqrt ( s.squared_length() ) ) /DZ ) ].second += 2;
+	   nv1 += 2;
+	  }
+	  else
+	  {
+	   if ( ( *TS1 ).inside ( s.source() ) || ( *TS1 ).inside ( s.target() ) )
+	   {
+	    v = s.to_vector();
+	    row[ ( int ) ( abs ( v.z() /sqrt ( s.squared_length() ) ) /DZ ) ].second += 1;
+	    ++nv1;
+	   }
+	   else ++nv2;
+	  }
+	 }
+	 else ++nv3;
+	}
+
+	Real normalize = 1.0/ ( ng1*4*DZ*3.141592653 );
+	for ( int i = 0; i &lt; sphere_discretisation; ++i ) row[i].second *= normalize;
+
+	output_file &lt;&lt; &quot;#Neighbors distribution&quot; &lt;&lt; endl &lt;&lt; &quot;(filter dist. = &quot; &lt;&lt; ( *TS1 ).filter_distance
+	  &lt;&lt; &quot;, &quot;&lt;&lt; nv1 &lt;&lt; &quot; neighbors + &quot; &lt;&lt; nv2 &lt;&lt; &quot; excluded + &quot;
+	  &lt;&lt; nv3 &lt;&lt; &quot; infinite, for &quot;&lt;&lt; ng1 &lt;&lt;&quot;/&quot;&lt;&lt; ( ng1+ng2 ) &lt;&lt; &quot; grains)&quot; &lt;&lt; endl;
+	output_file &lt;&lt; &quot;max_nz number_of_neighbors&quot; &lt;&lt; endl;
+	cerr &lt;&lt; &quot;#Neighbors distribution&quot; &lt;&lt; endl &lt;&lt; &quot;(filter dist. = &quot; &lt;&lt; ( *TS1 ).filter_distance
+	  &lt;&lt; &quot;, &quot;&lt;&lt; nv1 &lt;&lt; &quot; neighbors + &quot; &lt;&lt; nv2 &lt;&lt; &quot; excluded + &quot;
+	  &lt;&lt; nv3 &lt;&lt; &quot; infinite, for &quot;&lt;&lt; ng1 &lt;&lt;&quot;/&quot;&lt;&lt; ( ng1+ng2 ) &lt;&lt; &quot; grains)&quot; &lt;&lt; endl;
+	cerr &lt;&lt; &quot;mean_nz number_of_neighbors&quot; &lt;&lt; endl;
+	for ( int i = 0; i &lt; sphere_discretisation; ++i )
+	{
+	 output_file &lt;&lt; row[i].first &lt;&lt; &quot; &quot; &lt;&lt; row[i].second &lt;&lt; endl;
+	 cerr &lt;&lt; row[i].first &lt;&lt; &quot; &quot; &lt;&lt; row[i].second &lt;&lt; endl;
+	}
+
+	output_file &lt;&lt; endl;
+	return output_file;*/
+}
+
+
+
+void KinematicLocalisationAnalyser::SetDisplacementIncrements ( void )
+{
+	TriaxialState::GrainIterator gend = TS1-&gt;grains_end();
+	for (TriaxialState::GrainIterator git = TS1-&gt;grains_begin(); git!=gend; ++git) 
+		if (git-&gt;id &gt;= 0) git-&gt;translation =  TS1-&gt;grain ( git-&gt;id ).sphere.point() - TS0-&gt;grain ( git-&gt;id ).sphere.point();
+	consecutive = true;
+			
+	
+}
+
+
+
+ofstream&amp; KinematicLocalisationAnalyser::
+StrictNeighborDistributionToFile (ofstream&amp; output_file)
+{
+	return output_file;
+}
+
+
+
+
+
+
+
+// Tenseur3 KinematicLocalisationAnalyser::Grad_u (Point &amp;p1, Point &amp;p2, Point &amp;p3)
+// {
+// 	Tenseur3 T;
+// 	Vecteur V = (Deplacement(p1)+Deplacement(p2)+Deplacement(p3))/3.00;
+// 	Grad_u(p1, p2, p3, V, T);
+// 	return T;
+// 	//Vecteur V = (Deplacement(p1)+Deplacement(p2)+Deplacement(p3))/3;
+// }
+
+//Vecteur KinematicLocalisationAnalyser::Deplacement (Point &amp;p) {return (p-CGAL::ORIGIN)/100;}
+
+Vecteur KinematicLocalisationAnalyser::Deplacement ( Finite_cells_iterator cell, int facet ) // D&#65533;p. moyen sur une facette
+{
+	Vecteur v ( 0.f, 0.f, 0.f );
+	int id;// ident. de la particule
+	for ( int i=0; i&lt;4; i++ )
+	{
+		//  char msg [256];
+		if ( i!=facet )
+		{
+			id = cell-&gt;vertex ( i )-&gt;info().id();
+			if ( consecutive )
+				v = v + TS1-&gt;grain ( id ).translation;
+			else  v = v + ( TS1-&gt;grain ( id ).sphere.point() - TS0-&gt;grain ( id ).sphere.point() );
+
+			//for tests with affine displacement field
+			//if ((TS1-&gt;grain(id).sphere.point().y()+TS1-&gt;grain(id).sphere.point().z())&gt;0.035)//a discontinuity
+			//v = v + Vecteur(0, 0.01*TS1-&gt;grain(id).sphere.point().x(), 0);
+		}
+	}
+	v = v*0.333333333333333333333333;
+	return v;
+}
+
+
+
+void KinematicLocalisationAnalyser::Grad_u ( Finite_cells_iterator cell, int facet, Vecteur &amp;V, Tenseur3&amp; T )
+{
+	Vecteur S = cross_product ( ( cell-&gt;vertex ( l_vertices[facet][1] )-&gt;point() )
+					- ( cell-&gt;vertex ( l_vertices[facet][0] )-&gt;point() ),
+					( cell-&gt;vertex ( l_vertices[facet][2] )-&gt;point() ) -
+					( cell-&gt;vertex ( l_vertices[facet][1] )-&gt;point() ) ) /2.f;
+	Somme ( T, V, S );
+}
+
+
+// void KinematicLocalisationAnalyser::Grad_u (Point &amp;p1, Point &amp;p2, Point &amp;p3, Vecteur &amp;V, Tenseur3&amp; T) // rotation 1-&gt;2-&gt;3 orient&#65533;e vers l'ext&#65533;rieur
+// {		
+// 	Vecteur S = 0.5*cross_product(p2-p1, p3-p2);
+//     	Somme (T, V, S);
+// }
+
+void KinematicLocalisationAnalyser::Grad_u (Finite_cells_iterator cell,
+Tenseur3&amp; T, bool vol_divide)// Calcule le gradient de d&#65533;p. 
+{
+	/*char msg [256];
+	sprintf(msg, &quot;Exec Grad_u (Finite_cells_iterator cell, Tenseur3&amp; T, bool
+vol_divide)&quot;);
+	Udata::out(msg);
+	sprintf(msg, &quot;***  Hv = \n %f %f %f \n %f %f %f \n %f %f %f \n&quot;,  
+	T(1,1), T(1,2), T(1,3), T(2,1), T(2,2), T(2,3),
+	T(3,1), T(3,2), T(3,3));
+	Udata::out(msg);*/
+	T.reset();
+	Vecteur v;
+	for (int facet=0; facet&lt;4; facet++)
+	{
+		v = Deplacement(cell, facet);
+		Grad_u (cell, facet, v, T);
+	}
+	if (vol_divide) T/= Tesselation::Volume(cell);
+}
+
+
+
+
+
+
+// Calcul du tenseur d'orientation des voisins
+// Tenseur_sym3 Orientation_voisins (Tesselation &amp;Tes)
+// {
+// 	RTriangulation&amp; T = Tes.Triangulation();
+// 	Tenseur3 Tens;
+// 	Vecteur v;
+// 	long Nv = 0; //nombre de voisins
+// 	for (Edge_iterator ed_it = T.edges_begin(); ed_it != T.edges_end(); ed_it++)
+// 	{	
+// 		if (!T.is_infinite(*ed_it))
+// 		{
+// 			Nv++;
+// 			v = T.segment(*ed_it).to_vector()/sqrt(T.segment(*ed_it).squared_length());
+// 			for (int i=1; i&lt;4; i++) for (int j=3; j&gt;=i; j--)Tens(i,j) += v[i-1]*v[j-1];
+// 		}
+// 	} 
+// 	Tens /= Nv;
+// 	return Tens;
+// }
+
+
+
+
+
+
+//
+//;------------------------------------------------
+//;orient_n_Y
+//;calcul de la distribution des orientations de contact
+//;(angle entre n et l'axe y)
+//;param&#65533;tres d'entr&#65533;e : N_classes (nombre de classes), e_filtre (&#65533;paisseur de la bordure supprim&#65533;e)
+//;sortie : table 20
+//
+//def orient_n_Z
+//
+//X_min = w_x(waddg) + e_filtre
+//X_max = l + w_x(waddd) - e_filtre
+//Y_min = w_y(waddfa) + e_filtre
+//Y_max = l + w_y(waddfo) - e_filtre
+//Z_min = w_z(waddb) + e_filtre
+//Z_max = h + w_z(waddh) - e_filtre
+//DZ_classes = 1./(N_classes*1.)
+//
+//command
+//table 20 erase
+//table 21 erase
+//endcommand
+//loop temp (0, N_classes)
+//	xtable (20, temp+1) = temp * DZ_classes
+//endloop
+//
+//cp=contact_head
+//N_filtre1 = 0
+//n_cont = 0
+//loop while cp#null
+//	if c_nforce(cp) # 0
+//	n_cont = n_cont +1
+//	if filtre1 = 1
+//	N_filtre1 = N_filtre1 +1
+//		classe = int(abs(c_zun(cp))/DZ_classes) + 1
+//		ytable (20, classe) = ytable (20, classe) +1
+//	endif
+//	endif
+//cp=c_next(cp)
+//endloop
+//
+//command
+//print N_filtre1 n_cont
+//set logfile orient.txt
+//set log on ov
+//pr table 20
+//set log off
+//set logfile res.dat
+//endcommand
+//;Normalisation :
+//
+//end
+
+void KinematicLocalisationAnalyser::ComputeParticlesDeformation ( void )
+{
+	//cerr &lt;&lt; &quot;compute particle deformation&quot; &lt;&lt; endl;
+	Tesselation&amp; Tes = TS1-&gt;tesselation();
+	RTriangulation&amp; Tri = Tes.Triangulation();
+	Tenseur3 grad_u;
+	Real v;
+	v_total = 0;
+	v_solid_total = 0;
+	grad_u_total = NULL_TENSEUR3;
+	v_total_g = 0;
+	grad_u_total_g = NULL_TENSEUR3;
+	Delta_epsilon ( 3,3 ) = TS1-&gt;eps3 - TS0-&gt;eps3;
+	Delta_epsilon ( 1,1 ) = TS1-&gt;eps1 - TS0-&gt;eps1;
+	Delta_epsilon ( 2,2 ) = TS1-&gt;eps2 - TS0-&gt;eps2;
+
+	//Compute Voronoi tesselation (i.e. voronoi center of each cell)
+	if ( !Tes.Computed() ) Tes.Compute();
+	//cerr &lt;&lt; &quot;ParticleDeformation.size() = &quot; &lt;&lt; ParticleDeformation.size() &lt;&lt; endl;
+	if ( ParticleDeformation.size() != ( Tes.Max_id() + 1 ) )
+	{
+		//cerr &lt;&lt; &quot;resize to &quot; &lt;&lt; Tes.Max_id() + 1 &lt;&lt; endl;
+		ParticleDeformation.clear();
+		ParticleDeformation.resize ( Tes.Max_id() + 1 );
+	}
+	//cerr &lt;&lt; &quot;ENDOF ParticleDeformation.size() = &quot; &lt;&lt; ParticleDeformation.size() &lt;&lt; endl;
+	//reset volumes and tensors of each particle
+	for ( RTriangulation::Finite_vertices_iterator  V_it =
+				Tri.finite_vertices_begin (); V_it !=  Tri.finite_vertices_end (); V_it++ )
+	{
+		//cerr &lt;&lt; V_it-&gt;info().id() &lt;&lt; endl;
+		V_it-&gt;info().v() =0;//WARNING : this will erase previous values if some have been computed
+		ParticleDeformation[V_it-&gt;info().id() ]=NULL_TENSEUR3;
+	}
+	//cerr &lt;&lt; &quot;RTriangulation::Finite_vertices_iterator  V_it  = &quot; &lt;&lt; ParticleDeformation.size() &lt;&lt; endl;
+
+	Finite_cells_iterator cell = Tri.finite_cells_begin();
+	Finite_cells_iterator cell0 = Tri.finite_cells_end();
+
+
+	//Compute grad_u and volumes of all cells in the triangulation, and assign them to each of the vertices ( volume*grad_u is added here rather than grad_u, the weighted average is computed later )
+	//cerr &lt;&lt; &quot;for ( ; cell != cell0; cell++ )&quot; &lt;&lt; endl;
+	for ( ; cell != cell0; cell++ ) // calcule la norme du d&#65533;viateur dans chaque cellule
+	{
+		//cerr &lt;&lt; &quot;ij=&quot; &lt;&lt;ij++&lt;&lt;endl;
+		//cerr &lt;&lt; &quot;ij2=&quot; &lt;&lt;ij2++&lt;&lt;endl;
+		//if (!cell-&gt;info()-&gt;isFictious) //FIXME
+		Grad_u ( cell, grad_u, false );// false : don't divide by volume, here grad_u = volume of cell * average grad_u in cell
+		//cerr &lt;&lt; &quot;grad_u=&quot; &lt;&lt; grad_u &lt;&lt; endl;
+		v = Tri.tetrahedron ( cell ).volume();
+		grad_u_total += grad_u;
+		v_total += v;
+		for ( unsigned int index=0; index&lt;4; index++ )
+		{
+			cell-&gt;vertex ( index )-&gt;info().v() += v;//WARNING2 : this will affect values which differ from the volumes of voronoi cells
+			//cerr &lt;&lt; &quot;ParticleDeformation[cell-&gt;vertex (&quot; &lt;&lt; cell-&gt;vertex ( index )-&gt;info().id() &lt;&lt; &quot;)&quot;&lt;&lt; endl;
+			ParticleDeformation[cell-&gt;vertex ( index )-&gt;info().id() ] += grad_u;
+		}
+	}
+
+	//Delete volume and grad_u for particles on the border FIXME : replace that using isFictious flags?
+	Tesselation::Vector_Vertex border_vertices;
+	Tes.Voisins ( Tri.infinite_vertex (), border_vertices );
+	unsigned int l = border_vertices.size();
+	//cerr &lt;&lt; &quot;l=&quot; &lt;&lt; l &lt;&lt; endl;
+	
+	//cerr &lt;&lt; &quot;for ( ; cell != cell0; cell++ )&quot; &lt;&lt; endl;
+	for ( unsigned int i=0; i&lt;l; ++i )
+	{
+		//cerr &lt;&lt; &quot;border &quot; &lt;&lt; i &lt;&lt; endl;
+		border_vertices[i]-&gt;info().v() =0;
+
+		ParticleDeformation[border_vertices[i]-&gt;info().id() ]=NULL_TENSEUR3;
+	}
+
+	//Divide sum(v*grad_u) by sum(v) to get the average grad_u on each particle
+	for ( RTriangulation::Finite_vertices_iterator  V_it = Tri.finite_vertices_begin (); V_it !=  Tri.finite_vertices_end (); V_it++ )
+	{
+		v_total_g += V_it-&gt;info().v();
+		v_solid_total += 4.188790*pow(V_it-&gt;point().weight(),1.5);//4.18... = 4/3*PI; and here, weight is rad&#178;
+		grad_u_total_g += ParticleDeformation[V_it-&gt;info().id() ];
+		if ( V_it-&gt;info().v() ) ParticleDeformation[V_it-&gt;info().id() ]/=V_it-&gt;info().v();
+	}
+	grad_u_total_g /= v_total_g;
+	cerr &lt;&lt; &quot;sym_grad_u_total_g (wrong averaged strain):&quot;&lt;&lt; endl &lt;&lt; Tenseur_sym3 ( grad_u_total_g ) &lt;&lt; endl;
+
+	if ( v_total ) grad_u_total /= v_total;
+	cerr &lt;&lt; &quot;Total volume = &quot; &lt;&lt; v_total &lt;&lt; &quot;, grad_u = &quot; &lt;&lt; endl &lt;&lt; grad_u_total &lt;&lt; endl &lt;&lt; &quot;sym_grad_u (true average strain): &quot; &lt;&lt; endl &lt;&lt; Tenseur_sym3 ( grad_u_total ) &lt;&lt; endl;
+	cerr &lt;&lt; &quot;Macro strain = &quot; &lt;&lt; Delta_epsilon &lt;&lt; endl;
+	
+}
+
+Real KinematicLocalisationAnalyser::ComputeMacroPorosity (void)
+{
+	return (1-v_solid_total/(TS1-&gt;haut*TS1-&gt;larg*TS1-&gt;prof));
+}
+
+
+


Property changes on: trunk/extra/triangulation/KinematicLocalisationAnalyser.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/extra/triangulation/KinematicLocalisationAnalyser.hpp
===================================================================
--- trunk/extra/triangulation/KinematicLocalisationAnalyser.hpp	2008-11-17 17:11:31 UTC (rev 1575)
+++ trunk/extra/triangulation/KinematicLocalisationAnalyser.hpp	2008-11-20 14:48:17 UTC (rev 1576)
@@ -0,0 +1,125 @@
+/*************************************************************************
+*  Copyright (C) 2006 by Bruno Chareyre                                *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">bruno.chareyre at hmg.inpg.fr</A>                                            *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+/**
<A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">+ at author</A> Bruno Chareyre
+*/
+//This class computes statistics of micro-variables assuming axi-symetry
+
+
+#ifndef KINEMATICLOCALISATIONANALYSER_H
+#define KINEMATICLOCALISATIONANALYSER_H
+
+#include &quot;TriaxialState.h&quot;
+#include &quot;Tenseur3.h&quot;
+//class TriaxialState;
+
+
+#define SPHERE_DISCRETISATION 20; //number of &quot;teta&quot; intervals on the unit sphere
+#define LINEAR_DISCRETISATION 200; //number of intervals on segments like [UNmin,UNmax]
+
+
+// l_vertices : d&#65533;finition de l'ordre de parcours des sommets
+// pour la facette k, les indices des 3 sommets sont dans la colonne k
+const int l_vertices [4][3] = { {1, 2, 3}, {0, 3, 2}, {3, 0, 1}, {2, 1, 0} };
+
+
+
+
+
+
+
+class KinematicLocalisationAnalyser
+{
+
+
+
+	public:
+
+		typedef vector&lt; pair&lt;Real,Real&gt; &gt; RGrid1D;
+		typedef vector&lt;vector &lt;Real&gt; &gt;  RGrid2D;
+		typedef vector&lt;vector&lt;vector&lt;Real&gt; &gt; &gt; RGrid3D;
+
+
+		KinematicLocalisationAnalyser();
+		KinematicLocalisationAnalyser ( const char* state_file1 );
+		KinematicLocalisationAnalyser ( const char* state_file1, const char* state_file0, bool consecutive_files = true );
+		KinematicLocalisationAnalyser ( const char* base_name, int file_number0, int file_number1 );
+
+		~KinematicLocalisationAnalyser();
+
+		void SetBaseFileName ( string name );
+		bool SetFileNumbers ( int n0, int n1 );
+		void SetConsecutive (bool);
+		void SetNO_ZERO_ID (bool);
+		void SwitchStates ( void );
+
+		bool ToFile ( const char* output_file_name );
+		ofstream&amp; ContactDistributionToFile ( ofstream&amp; output_file );
+		ofstream&amp; AllNeighborDistributionToFile ( ofstream&amp; output_file );
+		ofstream&amp; StrictNeighborDistributionToFile ( ofstream&amp; output_file );
+		ofstream&amp; NormalDisplacementDistributionToFile ( vector&lt;Edge_iterator&gt;&amp; edges, ofstream&amp; output_file );
+
+		long Filtered_contacts ( TriaxialState&amp; state );
+		long Filtered_neighbors ( TriaxialState&amp; state );
+		long Filtered_grains ( TriaxialState&amp; state );
+		Real Filtered_volume ( TriaxialState&amp; state );
+		Real Contact_coordination ( TriaxialState&amp; state );
+		Real Neighbor_coordination ( TriaxialState&amp; state );
+		Tenseur_sym3 Neighbor_fabric ( TriaxialState&amp; state );
+		Tenseur_sym3 Contact_fabric ( TriaxialState&amp; state );
+		Real Contact_anisotropy ( TriaxialState&amp; state );
+		Real Neighbor_anisotropy ( TriaxialState&amp; state );
+		
+		void SetForceIncrements (void);
+		void SetDisplacementIncrements (void);
+
+		///Add surface*displacement to T
+		void Grad_u ( Finite_cells_iterator cell, int facet, Vecteur &amp;V, Tenseur3&amp; T );
+		///Compute grad_u in cell (by default, T= average grad_u in cell, if !vol_divide, T=grad_u*volume
+		void Grad_u ( Finite_cells_iterator cell, Tenseur3&amp; T, bool vol_divide=true );
+		///Compute grad_u for all particles, by summing grad_u of all adjaent cells
+		void ComputeParticlesDeformation (void);
+		///Compute porisity from cumulated spheres volumes and positions of boxes
+		Real ComputeMacroPorosity (void );
+
+
+		Vecteur Deplacement ( Cell_handle cell );  //donne le d&#65533;placement d'un sommet de voronoi
+		Vecteur Deplacement ( Finite_cells_iterator cell, int facet ); //mean displacement on a facet
+
+		// Calcul du tenseur d'orientation des voisins
+		//Tenseur_sym3 Orientation_voisins (Tesselation&amp; Tes);
+
+		vector&lt;pair&lt;Real,Real&gt; &gt;&amp; NormalDisplacementDistribution ( vector&lt;Edge_iterator&gt;&amp; edges, vector&lt;pair&lt;Real,Real&gt; &gt;&amp; row );
+		//vector&lt;pair&lt;Real,Real&gt; &gt; NormalDisplacementDistribution(TriaxialState&amp; state, TriaxialState&amp; state0);
+
+		//member data
+		int sphere_discretisation;
+		int linear_discretisation;
+		Tenseur_sym3 Delta_epsilon;
+		Tenseur3 grad_u_total;
+		vector&lt;Tenseur3&gt; ParticleDeformation;		
+		Tenseur3 grad_u_total_g;//grad_u averaged on extended grain cells
+		TriaxialState *TS1, *TS0;
+	private:
+
+		int file_number_1, file_number_0;
+		//Characteristic size of particles
+		string base_file_name;   //Base name of state-files, complete name is (base_name+state_number).
+		bool consecutive; //Are the two triax states consecutive? if &quot;false&quot; displacements are re-computed
+		//from the two source files; if &quot;true&quot; one file is enough.
+		Real v_solid_total;//solid volume in the box
+		Real v_total;//volume of the box
+		Real v_total_g;//summed volumes of extended grain cells
+		long n_persistent, n_new, n_lost;
+
+
+
+};
+
+#endif


Property changes on: trunk/extra/triangulation/KinematicLocalisationAnalyser.hpp
___________________________________________________________________
Name: svn:executable
   + *


_______________________________________________
Mailing list: <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
Post to     : <A HREF="https://lists.berlios.de/mailman/listinfo/yade-dev">yade-dev at lists.launchpad.net</A>
Unsubscribe : <A HREF="https://launchpad.net/~yade-dev">https://launchpad.net/~yade-dev</A>
More help   : <A HREF="https://help.launchpad.net/ListHelp">https://help.launchpad.net/ListHelp</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000509.html">[deprecated list] [Yade-dev] [svn] r1575 -	trunk/pkg/dem/Engine/DeusExMachina
</A></li>
	<LI>Next message: <A HREF="000520.html">[deprecated list] [Yade-dev] inherited PhysicalParameters	for	InteractionPhysicsEngineUnit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#515">[ date ]</a>
              <a href="thread.html#515">[ thread ]</a>
              <a href="subject.html#515">[ subject ]</a>
              <a href="author.html#515">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-dev">More information about the yade-dev
mailing list</a><br>
</body></html>
